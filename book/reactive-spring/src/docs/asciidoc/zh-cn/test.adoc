= 测试

我喜欢测试，你也应该喜欢测试

== 我并不担心，因为我热爱测试

我花了一段时间才真正进入 TDD。 我们在 Pivotal Labs 做 TDD。 Pivotal Labs 是一家尖端咨询公司。 Pivotal Labs 已经存在了几十年。
这是一个随着时间的推移与敏捷联系在一起的咨询业务； 它的创始人 Rob Mee 在 big-A 和 little-a "敏捷" 社区中是传奇人物，从最早的时候起就是该方法的主要推动者之一。
Pivotal Labs，通过 Pivotal，不会做很多广告，我们会拒绝很多我们收到的请求。 原因很简单：我们不需要业务。 人们来找我们，如果我们要从事新的工作，那么我们所做的工作必须对组织具有变革性。
我们没有兴趣帮助组织构建，比方说，会议室调度系统，如果这样的应用程序不会帮助业务。 我们在世界各地都设有办事处 - 纽约、东京、旧金山、伦敦、新加坡、柏林、波士顿、亚特兰大、多伦多和无数其他地点。
在任何时候，我们在世界各地的 Pivotal Labs 办公室几乎总是客满。

我们不是人员扩充。 人们参与 Pivotal Labs 不仅是为了帮助他们编写一些软件，而且是为了教他们如何编写软件。 当人们来和我们一起工作时，他们会在上午 9 点之前到达，
与当地办公室的其他人一起吃早餐。 如果他们想和我们一起吃免费早餐，他们会在早上 9 点到达。 到 9 点 07 分，我们全办公室的晨会开始了。
通常不超过五分钟。 然后，从事不同客户项目的每个独立团队开始各自的站立会议。 这些是真正的站会 - 非常快！ 到上午 9 点 15 分或 9 点 20 分，我们就要开始比赛了。
在 Pivotal Labs，人们被聚集到支持不同项目的团队中。 我们有来自客户的现场代表。 我们有现场项目的工程。

每天人们从待办事项列表中提取工作并开始处理，他们结对工作。 通常，它是我们亲切地称呼自己的一个“枢轴”和来自客户的一名成员配对在一起。 配对可能每天都在变化。
也许今天我想和 Jacques 一起学习 Go 编程语言的特性，明天我想和 Natalie 一起学习更多关于 Android 的知识，而后天我想和 Alex 一起学习更多关于 Android 的知识。
大厅。 我们都将独特的技能带到特定的工作中，并且通过这种不断的配对，我们有机会分享这些技能。 吸收和扩散它们。 当然，客户也最了解业务领域。
因此，我们经常将一位 Pivot 和一位客户团队成员配对。 它有助于传播技能； 这意味着团队中没有任何一个成员是不可替代的。 这是一个重要的动力。 我们要促进可持续发展。
我们希望每个人都掌握并拥有代码。

Pivots，在这种情况下是一个集体名词，指的是在 Pivotal Labs 位置工作的每个人，通常进行“红绿重构”，其中一对编写失败的测试（测试为红色），然后另一对编写失败的测试 使失败的测试通过的代码。
我们一直这样做，直到工作完成！ 或者直到午餐，以先到者为准。 整个办公室的午餐时间固定。 当你结对编程时，你最不想要的就是人们在午餐约会上闲逛，这比平时要花更长的时间。
因此，您一直工作到午餐，吃午饭，然后回到椅子上进行结对编程，直到工作完成或一天结束，以先到者为准。 一天结束于 18:00 / 6pm。 不是下午 6:01。 不是下午 5:59。
下午 6:00。 在那之后，办公室就是一座鬼城。 这里的目标是促进可持续发展。 Pivotal Labs 不提供公司笔记本电脑。 人们来上班并登录机器。
任何机器！ 我们要求人们在门口检查他们的意见。 我们根本不在乎您糟糕的 Active Directory 配置和 Eclipse 键绑定以及您如此锁定以至于无用的企业 Windows 安装。
在 Pivotal Labs，每个人都使用具有相同配置的同一台机器：macOS、IntelliJ IDEA 等。我们有针对 git 等东西的自定义工具，因此我们可以在同一台机器上使用两对的名称对提交进行签名。
一天结束后，我们希望人们回家，直到第二天才开始工作。 再次，可持续发展！

当我们第一次介绍 Spring Boot 时，我花了很多时间去不同的 Pivotal Labs 办公室，试图帮助他们升级 Spring Boot，当然，我们走到了一起，但令我惊讶的是我学到了很多东西。
我离开了真正富有成效的体验！ 我爱它。 我了解到（嗯，至少，我开始学习..）大师们如何使用支持非大师的人的过程来编写软件。 该过程非常有用，因为它提供了许多质量检查。
它提供了一个框架，通过优化机会来确保质量，从而将质量构建到系统中。

在 Pivotal 形成时，Pivotal Labs 开发人员不一定使用 Spring。 他们是狂热的 Ruby-on-Rails 开发者。
他们从来没有被授权使用 Spring，因为 Spring 研发团队与 Pivotal Labs 位于同一公司结构中。
不，如果 Spring Boot 成功了，那是因为它对他们有用。 那是因为他们真的觉得他们可以放心地向我们的客户推荐它。

我承认我对整件事有一些偏见。 Pivotal Labs 的员工通常年轻且无忧无虑。 他们很开心！ 这些不是我所熟悉的疲惫不堪、轮廓分明的企业开发人员。
不，先生！ 他们不可能胜任管理“真正的”企业软件的任务！ 他们对 WebSphere 了解多少？ 他们对 Axway Integrator 了解多少？ 他们对 SOAP 了解多少？

结果……什么都没有！ 谢天谢地！ 他们的工作过去是，而且一直是，提供支持业务需求的优质软件，而不是实施某些 CIO 与供应商打高尔夫球时商定的垃圾工具。
他们通过采用不断检查质量的流程来交付质量。 如果你这样做足够多，那么从刚从大学毕业的业余爱好者那里获得精通级别的代码就足够容易了，而且速度也很快。
最后一个事实对我来说非常有趣。 我误解了事情。 我错误地认为我们 Spring 团队中的企业类型必须提升 Pivotal Labs 的人员水平，但事实上他们最终教会了我们很多东西！
事实证明，如果你带一个业余开发人员（当然，在 Pivotal Labs 没有人是业余的）并将他们投入森林，只配备 Spring Boot 和一个由快速反馈和测试支持和指导的过程......他们做得很好 ！
事实上，我认为我更喜欢他们基于 Spring Boot 的代码，而不是我一生中共事过的许多“企业架构师”的代码！

从这个正在进行的讨论中脱颖而出的一件事是，至少与 Ruby on Rails 社区相比，Java 社区的测试工具并没有那么复杂。
呀。 承认这一点很痛！ 我的意思是，我们先于其他人拥有该死的 JUnit！ 其他人的 X-Unit 都是 JUnit-like！ 我们怎么落后了？
我认为很大一部分原因是我们在 Java 社区中从未真正认真地接受 TDD。 我们从未真正认真地努力让每个人都能使用 Java 进行编程。
当然，不像 Rails 社区那样。 Java 很复杂是一个特性，而不是一个错误。 Spring Boot 改变了这里的东西。
Spring Boot 为人们提供了一种自以为是的全栈方法来构建可扩展且包含测试的软件。 实际上，从 Spring Initializr 生成的每个项目都包含了支持测试的依赖项。
没有选择退出。 它包含测试驱动开发！ 那么，什么是测试驱动开发呢？

== 测试驱动开发

当然，我们步履维艰：我们实践持续集成 (CI) 和持续交付 (CD)。 我们进行试驾开发。 我们使用云计算。 所有这些都转化为更好、更快的结果，因此很难写出像这一章那样专注于测试，
似乎将所有其他精彩实践排除在外。 我们将专注于测试，我们甚至将尝试进行测试驱动开发（TDD）。

简单来说，TDD 就是首先编写测试的行为。 在编写一行生产代码之前，您需要编写测试生产代码的测试。 如果您没有编写生产代码，这很难做到。 因为没有可编译的类型。
因此，您最终不得不编写最少的代码以使编译器满意，然后返回充实测试。 但是你不想写太多的测试。 毕竟，您只是想在生产代码中证明一件事。
所以，你最终会陷入这个最初看起来非常令人沮丧的紧密循环中。 Bob Martin 描述了 TDD 的三个规则如下：

* 不允许编写任何生产代码，除非它是为了让失败的单元测试通过。
* 不允许编写超过足以失败的单元测试； 编译失败就是失败。
* 除了足以通过一个失败的单元测试之外，您不得编写任何更多的产品代码。

使用像 Java 这样的静态类型语言，你最终会陷入一个连续的循环中，编写测试，然后编写代码使测试编译通过，然后返回测试代码等等。 起初这似乎.. 约束。 一旦你掌握了它，
你就会喜欢上它。 TDD 有一些深远的好处。 一个执行 TDD 的团队最多只有几个 cmd / ctrl + Z 距离绿色的、有生产价值的代码。
执行 TDD 的团队在实现功能的同时完成测试。 成功实现功能的内啡肽冲击同时到达团队成员，否则将对代码进行测试。
它不再感觉像是一件苦差事，就像必须照顾的文档一样，但感觉不像是一个次要的优先事项。 敏捷宣言说“重视工作代码而不是综合文档”。
使用 TDD，您可以获得工作代码并证明该代码同时工作。 如果您使用 JavaDocs 和 TDD 之类的东西，那么您也可以在交付工作测试的同时获得非常好的文档！
有关 Spring REST 文档的更多信息，您可以查看 O'Reilly 的 Cloud Native Java。

所以，很明显，我是 TDD 的忠实粉丝，但很难在一本书中展示它的执行情况！ 所以，这就是我要做的。 我们会先介绍测试代码，需要时再看满足测试的生产代码。
我（大部分）不会介绍测试的碎片。 书里做TDD真的很繁琐！

== 由内而外或由外而内


我想这取决于团队和他们的风格，以及个人的风格，但是你必须决定是否要先为最内部的组件编写测试，然后再到 API 层和 UI ，边走边测试，或者如果你想做相反的事情，从 UI 开始，然后向内工作。
这种由内而外的方法有时被称为“芝加哥式”。

据我所知，这是方法上的差异。 假设您正在构建一个复杂的系统。 在由内而外的方法中，您将从个体实体开始，并开始充实它们在更高层的行为。
最终，在更高的层次上，你会开始组装单独的部分。 现在，有些人可能会说这个组件，这个集成，是风险所在，在你进入支持集成的小的甚至可能是无意义的实体之前，
应该首先关注这个定义。 我认为，如果你从内到外开始，并行化工作会更容易； 人们可以选择他们想要处理的应用程序的一部分，工作流会在集成层汇聚。

我喜欢由内而外：我将开始充实业务实体并朝着界面努力。 如果您只是构建 API（HTTP API 或 RPC API），那么该 API 就是“接口”。
通过这种方式，我将有潜在风险的集成推迟到稍后，并希望 - 在微服务世界中 - 集成仍然相当小并且由同一团队中的人们控制。
也就是说，如果全部由同一个人或足够小的团队中的一组人完成，“集成”就不会那么可怕。

微服务都是关于实现自治和降低协调成本的，但这并不意味着你消除了协调！ 只是减少它。 您的里程可能会有所不同，我在这里告诉您，我对此并没有很强的看法；
我只想提供有关我将如何处理本章的背景：由内而外。

我们将构建两个东西：一个生产者 API 和一个消费者 API 。

== Customer 对象永远是对的（对吗？）

我们将需要实例化和管理 Customer 类型的对象以映射到域模型。 让我们首先确保我们有一个有效的对象，可以成功地保存我们期望在那里的数据。
此时我们对这个对象是否是映射到数据库中数据的有效实体不感兴趣。 我们只想断言有关对象状态的一些基本内容，并在此处查看 Spring 支持我们的方式。