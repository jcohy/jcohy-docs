= 测试

我喜欢测试，你也应该喜欢测试

== 我并不担心，因为我热爱测试

我花了一段时间才真正进入 TDD。 我们在 Pivotal Labs 做 TDD。 Pivotal Labs 是一家尖端咨询公司。 Pivotal Labs 已经存在了几十年。
这是一个随着时间的推移与敏捷联系在一起的咨询业务； 它的创始人 Rob Mee 在 big-A 和 little-a "敏捷" 社区中是传奇人物，从最早的时候起就是该方法的主要推动者之一。
Pivotal Labs，通过 Pivotal，不会做很多广告，我们会拒绝很多我们收到的请求。 原因很简单：我们不需要业务。 人们来找我们，如果我们要从事新的工作，那么我们所做的工作必须对组织具有变革性。
我们没有兴趣帮助组织构建，比方说，会议室调度系统，如果这样的应用程序不会帮助业务。 我们在世界各地都设有办事处 - 纽约、东京、旧金山、伦敦、新加坡、柏林、波士顿、亚特兰大、多伦多和无数其他地点。
在任何时候，我们在世界各地的 Pivotal Labs 办公室几乎总是客满。

我们不是人员扩充。 人们参与 Pivotal Labs 不仅是为了帮助他们编写一些软件，而且是为了教他们如何编写软件。 当人们来和我们一起工作时，他们会在上午 9 点之前到达，
与当地办公室的其他人一起吃早餐。 如果他们想和我们一起吃免费早餐，他们会在早上 9 点到达。 到 9 点 07 分，我们全办公室的晨会开始了。
通常不超过五分钟。 然后，从事不同客户项目的每个独立团队开始各自的站立会议。 这些是真正的站会 - 非常快！ 到上午 9 点 15 分或 9 点 20 分，我们就要开始比赛了。
在 Pivotal Labs，人们被聚集到支持不同项目的团队中。 我们有来自客户的现场代表。 我们有现场项目的工程。

每天人们从待办事项列表中提取工作并开始处理，他们结对工作。 通常，它是我们亲切地称呼自己的一个“枢轴”和来自客户的一名成员配对在一起。 配对可能每天都在变化。
也许今天我想和 Jacques 一起学习 Go 编程语言的特性，明天我想和 Natalie 一起学习更多关于 Android 的知识，而后天我想和 Alex 一起学习更多关于 Android 的知识。
大厅。 我们都将独特的技能带到特定的工作中，并且通过这种不断的配对，我们有机会分享这些技能。 吸收和扩散它们。 当然，客户也最了解业务领域。
因此，我们经常将一位 Pivot 和一位客户团队成员配对。 它有助于传播技能； 这意味着团队中没有任何一个成员是不可替代的。 这是一个重要的动力。 我们要促进可持续发展。
我们希望每个人都掌握并拥有代码。

Pivots，在这种情况下是一个集体名词，指的是在 Pivotal Labs 位置工作的每个人，通常进行“红绿重构”，其中一对编写失败的测试（测试为红色），然后另一对编写失败的测试 使失败的测试通过的代码。
我们一直这样做，直到工作完成！ 或者直到午餐，以先到者为准。 整个办公室的午餐时间固定。 当你结对编程时，你最不想要的就是人们在午餐约会上闲逛，这比平时要花更长的时间。
因此，您一直工作到午餐，吃午饭，然后回到椅子上进行结对编程，直到工作完成或一天结束，以先到者为准。 一天结束于 18:00 / 6pm。 不是下午 6:01。 不是下午 5:59。
下午 6:00。 在那之后，办公室就是一座鬼城。 这里的目标是促进可持续发展。 Pivotal Labs 不提供公司笔记本电脑。 人们来上班并登录机器。
任何机器！ 我们要求人们在门口检查他们的意见。 我们根本不在乎您糟糕的 Active Directory 配置和 Eclipse 键绑定以及您如此锁定以至于无用的企业 Windows 安装。
在 Pivotal Labs，每个人都使用具有相同配置的同一台机器：macOS、IntelliJ IDEA 等。我们有针对 git 等东西的自定义工具，因此我们可以在同一台机器上使用两对的名称对提交进行签名。
一天结束后，我们希望人们回家，直到第二天才开始工作。 再次，可持续发展！

当我们第一次介绍 Spring Boot 时，我花了很多时间去不同的 Pivotal Labs 办公室，试图帮助他们升级 Spring Boot，当然，我们走到了一起，但令我惊讶的是我学到了很多东西。
我离开了真正富有成效的体验！ 我爱它。 我了解到（嗯，至少，我开始学习..）大师们如何使用支持非大师的人的过程来编写软件。 该过程非常有用，因为它提供了许多质量检查。
它提供了一个框架，通过优化机会来确保质量，从而将质量构建到系统中。

在 Pivotal 形成时，Pivotal Labs 开发人员不一定使用 Spring。 他们是狂热的 Ruby-on-Rails 开发者。
他们从来没有被授权使用 Spring，因为 Spring 研发团队与 Pivotal Labs 位于同一公司结构中。
不，如果 Spring Boot 成功了，那是因为它对他们有用。 那是因为他们真的觉得他们可以放心地向我们的客户推荐它。

我承认我对整件事有一些偏见。 Pivotal Labs 的员工通常年轻且无忧无虑。 他们很开心！ 这些不是我所熟悉的疲惫不堪、轮廓分明的企业开发人员。
不，先生！ 他们不可能胜任管理“真正的”企业软件的任务！ 他们对 WebSphere 了解多少？ 他们对 Axway Integrator 了解多少？ 他们对 SOAP 了解多少？

结果……什么都没有！ 谢天谢地！ 他们的工作过去是，而且一直是，提供支持业务需求的优质软件，而不是实施某些 CIO 与供应商打高尔夫球时商定的垃圾工具。
他们通过采用不断检查质量的流程来交付质量。 如果你这样做足够多，那么从刚从大学毕业的业余爱好者那里获得精通级别的代码就足够容易了，而且速度也很快。
最后一个事实对我来说非常有趣。 我误解了事情。 我错误地认为我们 Spring 团队中的企业类型必须提升 Pivotal Labs 的人员水平，但事实上他们最终教会了我们很多东西！
事实证明，如果你带一个业余开发人员（当然，在 Pivotal Labs 没有人是业余的）并将他们投入森林，只配备 Spring Boot 和一个由快速反馈和测试支持和指导的过程......他们做得很好 ！
事实上，我认为我更喜欢他们基于 Spring Boot 的代码，而不是我一生中共事过的许多“企业架构师”的代码！

从这个正在进行的讨论中脱颖而出的一件事是，至少与 Ruby on Rails 社区相比，Java 社区的测试工具并没有那么复杂。
呀。 承认这一点很痛！ 我的意思是，我们先于其他人拥有该死的 JUnit！ 其他人的 X-Unit 都是 JUnit-like！ 我们怎么落后了？
我认为很大一部分原因是我们在 Java 社区中从未真正认真地接受 TDD。 我们从未真正认真地努力让每个人都能使用 Java 进行编程。
当然，不像 Rails 社区那样。 Java 很复杂是一个特性，而不是一个错误。 Spring Boot 改变了这里的东西。
Spring Boot 为人们提供了一种自以为是的全栈方法来构建可扩展且包含测试的软件。 实际上，从 Spring Initializr 生成的每个项目都包含了支持测试的依赖项。
没有选择退出。 它包含测试驱动开发！ 那么，什么是测试驱动开发呢？

== 测试驱动开发

当然，我们步履维艰：我们实践持续集成 (CI) 和持续交付 (CD)。 我们进行试驾开发。 我们使用云计算。 所有这些都转化为更好、更快的结果，因此很难写出像这一章那样专注于测试，
似乎将所有其他精彩实践排除在外。 我们将专注于测试，我们甚至将尝试进行测试驱动开发（TDD）。

简单来说，TDD 就是首先编写测试的行为。 在编写一行生产代码之前，您需要编写测试生产代码的测试。 如果您没有编写生产代码，这很难做到。 因为没有可编译的类型。
因此，您最终不得不编写最少的代码以使编译器满意，然后返回充实测试。 但是你不想写太多的测试。 毕竟，您只是想在生产代码中证明一件事。
所以，你最终会陷入这个最初看起来非常令人沮丧的紧密循环中。 Bob Martin 描述了 TDD 的三个规则如下：

* 不允许编写任何生产代码，除非它是为了让失败的单元测试通过。
* 不允许编写超过足以失败的单元测试； 编译失败就是失败。
* 除了足以通过一个失败的单元测试之外，您不得编写任何更多的产品代码。

使用像 Java 这样的静态类型语言，你最终会陷入一个连续的循环中，编写测试，然后编写代码使测试编译通过，然后返回测试代码等等。 起初这似乎.. 约束。 一旦你掌握了它，
你就会喜欢上它。 TDD 有一些深远的好处。 一个执行 TDD 的团队最多只有几个 cmd / ctrl + Z 距离绿色的、有生产价值的代码。
执行 TDD 的团队在实现功能的同时完成测试。 成功实现功能的内啡肽冲击同时到达团队成员，否则将对代码进行测试。
它不再感觉像是一件苦差事，就像必须照顾的文档一样，但感觉不像是一个次要的优先事项。 敏捷宣言说“重视工作代码而不是综合文档”。
使用 TDD，您可以获得工作代码并证明该代码同时工作。 如果您使用 JavaDocs 和 TDD 之类的东西，那么您也可以在交付工作测试的同时获得非常好的文档！
有关 Spring REST 文档的更多信息，您可以查看 O'Reilly 的 Cloud Native Java。

所以，很明显，我是 TDD 的忠实粉丝，但很难在一本书中展示它的执行情况！ 所以，这就是我要做的。 我们会先介绍测试代码，需要时再看满足测试的生产代码。
我（大部分）不会介绍测试的碎片。 书里做TDD真的很繁琐！

== 由内而外或由外而内


我想这取决于团队和他们的风格，以及个人的风格，但是你必须决定是否要先为最内部的组件编写测试，然后再到 API 层和 UI ，边走边测试，或者如果你想做相反的事情，从 UI 开始，然后向内工作。
这种由内而外的方法有时被称为“芝加哥式”。

据我所知，这是方法上的差异。 假设您正在构建一个复杂的系统。 在由内而外的方法中，您将从个体实体开始，并开始充实它们在更高层的行为。
最终，在更高的层次上，你会开始组装单独的部分。 现在，有些人可能会说这个组件，这个集成，是风险所在，在你进入支持集成的小的甚至可能是无意义的实体之前，
应该首先关注这个定义。 我认为，如果你从内到外开始，并行化工作会更容易； 人们可以选择他们想要处理的应用程序的一部分，工作流会在集成层汇聚。

我喜欢由内而外：我将开始充实业务实体并朝着界面努力。 如果您只是构建 API（HTTP API 或 RPC API），那么该 API 就是“接口”。
通过这种方式，我将有潜在风险的集成推迟到稍后，并希望 - 在微服务世界中 - 集成仍然相当小并且由同一团队中的人们控制。
也就是说，如果全部由同一个人或足够小的团队中的一组人完成，“集成”就不会那么可怕。

微服务都是关于实现自治和降低协调成本的，但这并不意味着你消除了协调！ 只是减少它。 您的里程可能会有所不同，我在这里告诉您，我对此并没有很强的看法；
我只想提供有关我将如何处理本章的背景：由内而外。

我们将构建两个东西：一个生产者 API 和一个消费者 API 。

== Customer 对象永远是对的（对吗？）

我们将需要实例化和管理 Customer 类型的对象以映射到域模型。 让我们首先确保我们有一个有效的对象，可以成功地保存我们期望在那里的数据。
此时我们对这个对象是否是映射到数据库中数据的有效实体不感兴趣。 我们只想断言有关对象状态的一些基本内容，并在此处查看 Spring 支持我们的方式。

[source,java]
----

public class CustomerTest {
    @Test
    public void create() {
        Customer customer = new Customer("123", "foo"); // <1>
        Assert.assertEquals(customer.getId(), "123"); // <2>
        Assert.assertThat(customer.getId(), Matchers.is("123")); // <3>
        Assertions.assertThat(customer.getName()).isEqualToIgnoringWhitespace("foo"); // <4>
    }
}

----
====
<1> 创建 `Customer` ，并为它分配一个 id 和一个名称
<2> 使用普通的 JUnit 4 的 Assert 方法来确认我们存储在 id 属性中的值 123 是我们通过属性访问器访问它时返回的值。 换句话说：我们可以将数据放入并再次取出吗？ 我们正在使用 JUnit 4，但这并不重要。
Assert 类在 JUnit 中已经存在了几十年。
<3> 如果您最终进行了更复杂的测试，那么一切最终都会归结为 `Assert.assertTrue( boolean )` 调用，其中测试的配方被编码在某个可重用的地方——也许是一种返回布尔值的方法？
一段时间后这可能会变得乏味，因为测试的原因——为什么这个测试失败了——随着时间的流逝而消失了。 我们必须记住以有意义的方式命名我们用于测试的任何方法，
然后为 `assertTrue(String, boolean)` 重载编写相关消息。 我们所要展示的只是布尔值。 我们可以做得更好。
JUnit 的 assertThat 变体支持将条件与错误报告相结合的 `Matcher` 对象。 `Hamcrest` 是一个附带 Spring Boot 默认测试支持的第三方库，它为我们提供了许多有用的 Matchers。
在这里，我们断言两个操作数的相等性。
<4> 最后是 AssertJ。 AssertJ 是另一个支持 Spring Boot 附带的测试的第三方库。 它提供了方便的类型安全测试，这些测试从给定的类型流畅地进行。
在这里，我们很友好地为 `Assertions.assertThat(String)` 的参数提供了一个 `isEqualToIgnoringWhitespace(String)` 方法。
====

不错？ 这个测试应该很容易满足！ 让我们看看这种东西的生产代码是什么样的。

[source,java]
----
// <1>
@Data
@AllArgsConstructor
@NoArgsConstructor
class Customer {
    // <2>
    private String id;
    private String name;
}
----
====
<1> 这些注解来自 Lombok，这是一个编译时注解处理器，它会为我们自动生成 getter、setter、构造函数等。 这只是为我们节省了大量与在此对象中存储和检索数据相关的代码。
不过，您需要一个适用于 IntelliJ 或 Eclipse 的插件。
<2> 我可以使用 Spring Data MongoDB 的 `@Document` 注解来注解这个类，并使用 Spring Data Commons 的 `@Id` 注解来注解这个字段，但是 Spring Data 非常聪明！ 它会为我们解决的。 这在任何意义上都是 "POJO"。
====

== 未测试的存储库

我对这一部分有两种看法。我们是否应该看看仅测试 Spring Data MongoDB 持久化该实体的能力这一事实是什么？ 我们并没有真正利用对象映射器 Spring Data MongoDB 为我们提供的生命周期。
实际上，除了构造一个对象之外，我们什么也没做。 介绍 `ReactiveMongoTemplate` 可能是一个有趣的借口，但我们将在下一节中看到的步骤同样适用于我们使用 `ReactiveMongoTemplate` 所做的任何事情，
此外 - 我们已经看过它以及更多内容 除了我们在另一章中对响应数据的讨论。 让我们转而测试响应性存储库。

“等一下！”，我听到你惊呼，"我为什么要测试 Spring Data 存储库？我认为重点是它们能正常工作吗？" 你是对的！ 我不会太担心测试存储库本身。
该存储库中隐含的标准 CRUD 支持方法（如 `findById` 和 `save`）工作正常并且已经过数百万次测试。 他们像宣传的那样工作。
不，相反，我们会将测试限制在我们可能在存储库中定义的任何自定义查询。 通过约定表达自定义查询是微不足道的——只是根据记录的约定在存储库接口上声明的方法的名称 - 或者在声明的查找器方法上显式地使用 `@Query` 注解。
这些依赖于对象结构的查询有时可能会与对象的结构不同步，因此手动测试这些查询至关重要。

===  The Spring Test Framework

这里的目标是测试与将文档持久化到 MongoDB 数据库有关的业务逻辑是否按照我们希望和配置的方式工作。 因此，除了仅实例化对象实例 `Customer` 之外，我们还需要至少实例化所有 Spring Data MongoDB 机制。

听起来像是嗡嗡声。 我不想花一天时间尝试重新创建设置 Spring Data MongoDB 的方法并尝试正确连接！ Spring Boot 已经知道如何做到这一点。 我们可以在我们的测试中手动新建一个 Spring `ApplicationContext`，但这并不优雅。
此外，我希望能够将相关依赖项注入我的测试类，而不是从生成的 ApplicationContext 中按类型请求它。

JUnit 有一个集成机制，即 `@RunWith` 注解，它告诉它遵循特定的类以让它管理测试类的生命周期。 这样，除了实例化我们的单元测试本身和执行实际的测试方法之外，Spring 可以做任何事情。
结果是一个真正流线型的集成，让我们考虑我们要测试的代码，更不用说 Spring 本身了。 如果我们只在与我们的生产 Spring Boot 应用程序相同的包中的测试类上使用 `@RunWith(SpringRunner.class)` 和 `@SpringBootTest` 注解，
那么整个 Spring 应用程序将在测试运行时自动启动，任何字段 - 在类中用 `@Autowired` 声明的依赖关系得到满足。

[NOTE]
====
是的。 我知道。 瞎了！ 现场注入？ 我也不喜欢它。 现在是时候提一下这是 JUnit 4 的限制，该限制已在 Sam Brannen 领导的 JUnit 5 中解除。
领导 Spring Test Framework 集成的就是 Sam Brannen。 现在也是提及我们正在使用 JUnit 4 的好时机，因为它目前是 Spring Boot 中的默认设置，
但 JUnit 5 可以与 Spring Boot 完美配合，并且它的使用有据可查。
====

=== Test Slices

Spring Data 存储库通常存在于 Spring Boot 应用程序中，而 Spring Boot 应用程序又可能与 Web 服务器、Web 框架、Spring Boot Actuator 等一起存在。
我们最不想做的就是启动所有这些部分来测试持久性逻辑和我们的 Spring Data MongoDB 代码。

Spring Boot 提供了将 Spring Boot 应用程序上下文划分为逻辑层的测试切片。 Spring Boot 中有很多切片，但它们大多具有相同的基本结构：它们作为注解提供，
您可以将其添加到测试上下文代码中。 然后他们转身禁用大部分（如果不是全部）Spring Boot 的自动配置，然后有选择地重新引入与您正在测试的逻辑层相关的自动配置。
他们有时会定义组件过滤器，告诉 Spring Boot 在这个新的应用程序上下文中引入哪些 bean。 因此，如果您要测试 Spring Data MongoDB 代码，
这样的过滤器将只包含与 Spring Data MongoDB 相关的组件，而忽略例如任何 Servlet 或 Spring WebFlux 代码。 测试片使我们很容易将被测事物与不变量隔离开来。


=== Flapdoodle

并不总是存在可靠的嵌入式数据库选项，我们可以使用它来代替需要部署的数据库。 如果是这样，那么您绝对应该利用该选项。
我们可以使用 Flapdoodle，一个 Spring Boot 已经集成的第三方项目。 您需要做的就是将它添加到类路径中，Spring 的测试支持将连接一切。
将以下依赖项添加到应用程序的 `pom.xml` 中：

* de.flapdoodle.embed:de.flapdoodle.embed.mongo。

确保给它一个测试范围。 这样，即使您没有安装 MongoDB，您的测试

依赖于 MongoDB 的代码将起作用。

让我们看一个简单的测试示例，该测试将一些数据写入数据库，然后再次将其拉回。

Data in, data out...

[source,java]
----
@Testcontainers
@DataMongoTest // <1>
public class CustomerRepositoryTest {

    @Container
    static MongoDBContainer mongoDBContainer = new MongoDBContainer("mongo:5.0.3");

    @DynamicPropertySource
    static void setProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.data.mongodb.uri",mongoDBContainer::getReplicaSetUrl);
    }

    // <2>
    @Autowired
    private CustomerRepository repository;

    // <3>
    @Test
    public void findByName() {
        var commonName = "Jane";
        var one = new Customer("1",commonName);
        var two = new Customer("2","John");
        var three = new Customer("3",commonName);

        var setupPublisher = this.repository
                .deleteAll()
                .thenMany(this.repository.saveAll(Flux.just(one,two,three)))
                .thenMany(this.repository.findByName(commonName));

        var customerPredicate = (Predicate<Customer>) customer -> commonName.equalsIgnoreCase(customer.name()); // <4>

        // <5>
        StepVerifier
                .create(setupPublisher)
                .expectNextMatches(customerPredicate)
                .expectNextMatches(customerPredicate)
                .verifyComplete();
    }
}
----
====
<1> `@DataMongoTest` 是与 Spring Data 和 MongoDB 一起工作的相关测试夹片。
<2> 我们可以自动装配 Spring bean； 在这里我们注入 `CustomerRepository`（我们稍后会看一下它的实现）
<3> 定期测试方法。 现在，考虑一下我们正在使用响应式数据管道，其中测试的设置逻辑是异步发生的。 拆卸逻辑也可能是异步的。
因此，我发现虽然我可以将逻辑本身分解成一个单独的方法，但我想将生成的 `Publisher<T>` 插入到被测代码中，就像我在本次测试中所做的那样。
出于这个原因，我的响应式测试代码中没有很多 `@Before-` 或 `@After-` 注解的方法。
<4> 这是一个常规的 Java 8 `Predicate<T>`，我们将与所有响应测试的中心部分 `StepVerifier` 一起使用。
<5> `StepVerifier` 需要一些发布者的定义来观察，然后让我们断言关于我们期望发布者可能发出的东西的某些事情。 在此测试中，我们断言我们希望 `Publisher<Customer>` 发出两条记录，两条记录的名称都与 `commonName` 匹配。
一旦我们调用 `verifyComplete`，`StepVerifier` 就会耗尽 `Publisher`。
====

这个测试类的基本安排应该很熟悉：我们建立一些先决条件并确保它们得到满足。 然后，我们做我们不确定并试图测试的事情。 然后，确认我们所做的事情按照我们预期的方式进行。
不过，我们不必配置所有的 Spring Data MongoDB 机制。 我们不必从 Spring `ApplicationContext` 中找出那些改变的东西。
我们不必弄清楚如何等待 reative 发布者发出感兴趣的项目然后断言关于它们的事情。

此测试确认我们的存储库、`CustomerRepository` 和自定义查找器方法 `findByName(String name)` 按预期工作。 这是存储库的实现。

数据输入，数据输出...

[source,java]
----
public interface CustomerRepository extends ReactiveMongoRepository<Customer,String> {

    // <1>
    Flux<Customer> findByName(String name);
}
----
====
<1> 如果愿意，我们可以在这里使用自定义 BSON 查询，使用 `@Query` 注解。 无论哪种方式，我们都受益于有效的测试。
====

== 在网络上，没有人知道你是一个响应流

但无论如何，我们确实需要能够对其进行测试！ 我们有一个工作数据访问层。 我们已经确认我们可以将数据往返 MongoDB，所以现在我们面临一个存在的问题，
我相信你们在大学里都在努力解决这个问题：如果我（响应性地）将数据写入数据库但没有 有一个 API 来访问它，事实上我们真的写了吗？ 答案最好由哲学家决定。
我要采取的策略是，我们需要构建一个成功支持（具有 HTTP 状态代码 200/OK）的 API，将数据检索为 `application/json` 以响应 HTTP GET。 无论如何，
这就是我所期待的！ 让我们通过响应式 `WebTestClient` 支持来确认。

在此测试中，我们有兴趣证明 Web 层按设计工作。 我们有兴趣确认从 Spring WebFlux Web 运行时返回的有效负载看起来和感觉上与我们期望的一样。
我们对证明 MongoDB 的工作不感兴趣。 我们已经做到了！ 在此测试中，我们将使用 `@WebFluxTest` 测试切片将 Web 层与其他所有内容隔离开来。
我们已经建立了 Spring 测试切片，可以选择性地包含 Spring bean 以供在应用程序中使用，从而允许测试仅加载与我们关心的事物相关的机制。
`@WebFluxTest` 切片不会包含任何与持久性相关的内容。 这是好事也是坏事。 这意味着我们的代码是有重点的，
但这也意味着我们依赖于 `CustomerRepository` 的功能性响应处理程序注定会失败，除非我们可以给它一个有效的存储库引用。

这里需要的是一个模拟； 我们想用空的东西换出部分对象图。 它代表一个真正的 `CustomerRepository`。 这是对的一半。
我们的存储库不仅仅需要返回 `null` 和 `0` 和 `false`。 它不仅仅是一个物体的空壳。 当被询问时，它需要返回一个被动的 `Publisher<Customer>` 。
所以，实际上，我们需要一个存根——一个经过预编程以返回特定形状的结果以适应我们的测试的对象。 我们将使用@MockBean 来实现这一点。
最终，`@MockBean` 使用 `Mockito` 模拟模拟引用，并允许我们将它们的响应预编程为存根。 `Mockito` 是另一个优秀的第三方库，
它已经发布在 Spring Boot 应用程序的测试类路径中。

测试时间：

对客户 HTTP GET 端点的测试

我们的测试实际上比实现本身复杂一点！ 让我们看看吧。 所有这些都在 `CustomerWebConfiguration` 中定义。

对客户 HTTP GET 端点的测试

[source,java]
----
@WebFluxTest // <1>
@Import(CustomerWebConfiguration.class) // <2>
public class CustomerWebTest {

    @Autowired
    private WebTestClient client; //<3>

    @MockBean
    private CustomerRepository repository; // <4>

    @Test
    public void getAll() {

        // <5>
        Mockito.when(this.repository.findAll()).thenReturn(Flux.just(new Customer("1","A"),new Customer("2","B")));

        // <6>
        this.client.get()
                .uri("/customers")
                .accept(MediaType.APPLICATION_JSON)
                .exchange()
                .expectStatus().isOk()
                .expectHeader().contentType(MediaType.APPLICATION_JSON)
                .expectBody()
                .jsonPath("$.[0].id").isEqualTo("1")
                .jsonPath("$.[0].name").isEqualTo("A")
                .jsonPath("$.[1].id").isEqualTo("2")
                .jsonPath("$.[1].name").isEqualTo("B");
    }
}
----
====
<1> `@WebFluxTest` 切片使您可以将 Web 层机制与 Spring 应用程序上下文中的其他所有内容隔离开来
<2> `CustomerWebConfiguration` 声明 `RouterFunction<ServerResponse>` 实例。
<3> Spring 测试框架定义了响应式 WebTestClient，它类似于来自以 Servlet 为中心的 Spring MVC 世界的 MockMvc 模拟客户端的响应式模拟
<4> `@MockBean` 告诉 Spring 将 bean 注册表中的任何 bean 替换为与注解字段类型相同的 Mockito 模拟 bean，或者如果不存在这样的 bean，则将 Mockito 模拟 bean 添加到 bean 注册表。
<5> 在这里，我们通过预编程 `CustomerRepository#findAll` 调用将我们的模拟对象变成存根。 现在，当被测代码注入 `CustomerRepository` 并调用 `findAll` 方法时，
它将始终获得此处定义的 `Publisher<Customer>` 以及静态的已知先验结果。 我们可以很容易地将这一行放在一个用 `@Before` 注解的方法中。
<6> 这是困难重重的地方：测试确认有一个 HTTP GET 可访问端点生成 `application/json` 并以 HTTP 状态 200 响应。我们还使用 JSON 路径表达式稍微检查返回的有效负载以确认 在生成的 JSON 中有两个条目，其值与我们预编程存根以返回的值一致。
====

`@WebFluxTest` 代码自动配置 `WebTestClient`、Spring WebFlux 本身、缓存支持，并且仅包括 WebFlux 层 Spring beans，如 `@Controller`、`@ControllerAdvice`、`@JsonComponent`、`Converter/GenericConverter` 和 `WebFluxConfigurer` beans。
我们必须使用 `@Import` 和 `@MockBean` 之类的东西来为被测代码引入协作对象。

很可能您需要所有 Spring 应用程序上下文来进行测试。 也许你正在尝试做更多的集成测试。 在这种情况下，您应该更喜欢通用的 `@SpringBootTest` 和 `@AutoconfigureWebTestClient`。

很简单，是吗？ 到目前为止运行所有测试，我想你会同意 - 事情正在好转！ 我们已经设法测试了数据访问层和 Web 层。 我们的测试运行很快。 我们还能要求什么？ 我想我们已经准备好建立一个客户了！

== The Customer is Always Right!

客户端是一组可分配的类型，可以让另一个应用程序与我们的 API 对话。 作为一个组织，您可能同意构建和维护一个“幸运的”客户端库，或者您可以让每个团队构建自己的客户端库。 无论哪种方式，结果都是一样的。 有一些代码旨在支持使用必须与 API 分开维护的 API。 正是在这里，我们冒着漂移的风险——客户端代码与服务代码变得不一致。

我们面临着一个古老的问题。 我们如何测试客户端代码以确认它针对服务 API 可靠地工作？

我们面临紧张局势。 我们希望确保客户端可以使用该服务，但我们还需要能够测试客户端而不必运行整个系统以确保合规性。 我们希望在使用我们的客户端时速度更快，但我们也希望保持一致性。 我们希望保证我们的客户端将使用它所针对的 API。

我一直认为用“现在请部署这个大规模分布式系统来测试你的 API”这样的话来欢迎新人加入新工作是特别粗鲁的。 在其他语言中感觉很冒犯，而不仅仅是英语！ 这样的声明告诉我，贡献者的速度是不被重视的。 它告诉我，在定义系统中组件的接缝时并不关心。

想象一下。 你转向微服务，表面上是为了获得速度和自主权，你被告知要做的第一件事是在你的本地机器上重现整个工作系统。 在任何类型的重要系统中，这可能意味着数十个或数百个服务及其数据库、消息队列、缓存等。 这对任何人来说都不是一个可持续的要求，尤其是对那些从事完全不相关的事情的人来说，比如支持 iPhone 应用程序的边缘服务。

让我们来解决这个问题。 我们将在一个新模块 consumer 中完成这项工作。 新项目将在类路径上具有以下依赖项。

* org.springframework.boot:spring-boot-starter-webflux
* org.projectlombok:lombok，`optional` 设置为 true
* org.springframework.boot:spring-boot-starter-test, scope 为 test
* io.projectreactor:reactor-test，scope 为 test
* org.springframework.cloud:spring-cloud-starter-contract-stub-runner， scope 为 test

如果您使用 Spring Initializr 生成此项目，您将自动获得一个具有 Spring Cloud 物料清单 (BOM) 依赖项的 `pom.xml`。 如果没有，请确保添加它。

在这一点上，我们应该同意部署整个系统并不是真正的解决方案。 我们可以使用 Wiremock 来模拟系统。 Wiremock 是 Spring Cloud Contract 很好支持的第三方 API。 使用 Wiremock 模拟 HTTP 服务很容易。 在这种情况下，当我们说“mock”时，我们的意思是它将建立一个 HTTP 服务器并以我们提供的任何预编程响应进行响应。 Wiremock 非常适合模拟合作伙伴希望缓慢发展的 API。 一些不错的候选者是 Facebook API 或云供应商的面向公众的 API。

让我们看一个使用 Wiremock 的简单测试。

[source,java]
----
@Import(CustomerApplication.class)
@SpringBootTest(webEnvironment =  SpringBootTest.WebEnvironment.RANDOM_PORT) // <1>
@AutoConfigureWireMock(port = 0)  // <2>
public class WiremockCustomerClientTest {

    // <3>
    @Autowired
    private CustomerClient client;

    @Autowired
    private Environment environment;

    @BeforeEach
    public void setupWireMock() {
        var wiremockServerPort = this.environment.getProperty("wiremock.server.port",Integer.class);

        var base = String.format("%s:%s","localhost",wiremockServerPort);
        this.client.setBase(base);

        var json = """
                {
                    {"id":"1","name":"Jane"},
                    {"id":"2","name":"John"}
                }
                """;

        // <4>
        WireMock.stubFor(
                WireMock.get("/customers")
                        .willReturn(WireMock.aResponse()
                                .withHeader(CONTENT_TYPE,APPLICATION_JSON_VALUE)
                                .withBody(json)));
    }

    @Test
    public void getAllCustomers() {
        var customers = this.client.getAllCustomer();
        StepVerifier.create(customers)
                .expectNext(new Customer("1","Jane"))
                .expectNext(new Customer("2","John"))
                .verifyComplete();
    }
}
----
====
<1> 这是标准的 Spring Boot 测试，将在随机 HTTP 端口上运行。
<2> `@AutoConfigureWireMock` 注解安装基本的 WireMock 机制并规定它应该在哪个端口上运行。 在我们自定义之前，WireMock HTTP 服务器不会返回任何特别的东西。
<3> 此测试将运行我们稍后介绍的 CustomerClient。
<4> 这是橡胶与路面的交汇处。 我们使用 Java WireMock API 来定义我们期望我们的模拟 HTTP 服务在给定对 `/customers` 的 HTTP GET 请求时如何响应。
这有点像我们如何自定义 Mockito 模拟，将其变成一个存根，以自定义响应。
====

该测试执行一个 `CustomerClient`，它是其他团队可以依赖的类型化 Java 客户端。 预计我们将在此 `CustomerClient` 中执行任何网络通信。

[source,java]
----
@Component
public class CustomerClient {

    private static final Logger log = LoggerFactory.getLogger(CustomerClient.class);

    public CustomerClient(WebClient client) {
        this.client = client;
    }

    private final WebClient client;

    private String base = "localhost:8080";

    public void setBase(String base) {
        this.base = base;

    }

    public Flux<Customer> getAllCustomer() {
        return  this.client // <1>
                .get() // <2>
                .uri("http://" + this.base + "/customers") // <3>
                .retrieve() // <4>
                .bodyToFlux(Customer.class); // <5>
    }
}
----
====
<1> WebClient 是响应式 HTTP 客户端，类似于 RestTemplate，就像 R2DBC 的 DatabaseClient 是响应式 SQL 数据库客户端，类似于 JdbcTemplate。 我们需要在某处生成这种类型的 bean。
<2> 它支持所有常见 HTTP 动词的便捷方法。 在这里，我们发出 HTTP GET。
<3> 我们向我们的 URL 发出请求...
<4> 并告诉响应式 WebClient 发出请求...
<5> ...并将 JSON 结果转换为 Flux<Customer>
====

`CustomerClient` 假定上下文中某处存在 WebClient bean。 制造这个 bean 的实例并不难—— `WebClient.builder().build()` 可以工作——但是 `WebClient` 实例很重要，
并且可能在许多 bean 之间共享资源。 我们可能希望集中配置压缩、客户端负载平衡、身份验证等。 例如，Spring Cloud 可以使用 Ribbon 配置客户端负载平衡。
因此，虽然 Spring Boot 不会自动构建 WebClient，但它会自动构建一个 `WebClient.Builder` 类型的对象，其他配置可以向该对象提供过滤器和错误处理程序。
我们可以注入该构建器，可以选择进一步自定义 WebClient，然后构建生成的实例。

[source,java]
----
@Configuration
public class CustomerClientConfiguration {

    @Bean
    WebClient myWebClient(WebClient.Builder builder) {
        return builder.build();
    }
}
----

运行该测试，一切都应该按计划进行。 我们的消费者测试是绿色的。 我们的生产者测试是绿色的。 他们都是绿色的！ 东西是如此绿色，以至于它们是金色的！ 我们可以发货，吃一顿长午餐，然后休息一天，因为我们已经完成了，对吧？ 没那么快闪闪发光！ 我们已经手动放弃了重要代码的一部分：Customer 类。

这个消费者是一个独立于生产者的代码库。 我们不会在两个项目中共享该类的定义。 首先，我们不能保证它们会使用相同的语言甚至部署在相同的平台上。

切线：为什么有人会使用除 Spring 和 JVM 之外的任何东西来发布面向服务的软件？ 我以同样谨慎的态度看待这种可能性，就像 CERN 的科学家在首次宣布希格斯玻色子的想法时看待希格斯玻色子粒子的可能性一样：这显然是可能的，但他们不能确定！ 对于您谦虚的作者来说，人们会使用 Spring 似乎是合乎逻辑的，但有时人们希望看到世界燃烧并使用 PHP ...

无论如何，这是一个值得娱乐的假设。 当然，在这种特殊情况下，您和我碰巧知道生产者和消费者都是用 Java 和 Spring 实现的。 但这可能并不总是（喘气！）是真的。 即使这是真的，我们也不应该在生产者和消费者之间共享类型定义，因为他们的目的不同。 生产者中 Customer 的定义是一个类，旨在支持在 MongoDB 中持久化文档。 它非常小，但它可能涉及更多。 它可以支持验证、审计和数据生命周期方法，所有这些方法都应该只存在于生产者中。 消费者只需要一个简单的数据传输对象 (DTO) 来支持将数据传送到服务或从服务传送数据。 因此，两种类型有两种用途。 如果消费者中的实现与生产者中的实现有实质性不同，会发生什么情况？ 假设生产者改进了记录类型并决定重构。 如果在 2.0 版本中，name 字段被拆分为两个字段 familyName 和 givenName 会怎么样？ HTTP REST API 现在会反映这个新数据，但客户端不会！ 但是生产者和消费者仍然会构建，我们的测试将是绿色的，因为他们只测试自己，对其他方无动于衷。

多么阴险！ 看来我们又回到了原点。 我们想确定双方是否同意。 我们可以编写详尽的集成测试来部署生产者和消费者，然后运行端到端测试。 这将使晚上更容易入睡，但我们会失去敏捷性。 我们已经转向微服务，表面上是为了敏捷； 当然，我们可以做得更好，而不是仅仅为了确信系统中的两个参与者是正确的而不得不重新部署整个集群？ 另外：这种确定的情况确实比我们可以使用 Mockito 的单体要复杂得多！

必须有更好的方法！

== Customer 并不总是对的

因此，如果您要模拟一个相当稳定的 API，或者在紧要关头，如果您要模拟一个您无法控制的第三方 API（无论是否快速移动），Wiremock 都是一种绝佳的方法。
在这个特定的例子中，我们有能力改变生产者和消费者。 可能我们可以通过与其他团队合作来实现改变，或者我们可以直接实现改变。

让我们使用消费者驱动的契约测试 (CDCT) 和 Spring Cloud Contract 来设计一个测试，该测试将确认我们的响应式 HTTP API 的结构并生成一个我们可以测试客户端的工件。
Spring Cloud Contract 支持许多不同的工作流程，本章并不打算解决所有问题。 我们想要了解的是如何使用 Spring Cloud Contract 测试基于 Spring WebFlux 的响应式端点。

CDCT 背后的想法很简单：我们定义契约（不是模式！）用于在测试时断言网络服务接口的某些事情。 如果断言有效，我们就可以使用合同来建立一个符合合同断言的模拟网络服务，
客户端可以合理地进行调用并期望得到有效响应。 当我说网络服务时，我指的是 HTTP API，或者由 Spring Integration 或 Apache Camel 等支持的消息传递 API。

通常，我为生产者定义一个合同文件，为 Spring Cloud Contract 配置 Maven 插件（在生产者中），在基类中定义任何设置逻辑，
然后重新编写客户端测试以替代 Wiremock 用于 Spring Cloud 合同 Stubrunner。

将 Spring Cloud Contract Contract 验证器依赖项添加到生产者的 Maven 构建中：

* org.springframework.cloud:spring-cloud-starter-contract-verifier, scope 为 test

这部分是最简单的，至少对我来说是这样。 这只是代码！ 您使用类型安全的 Groovy、Java 或基于 Kotlin 的 DSL 为 API 编写合约。
合同通常位于生产者模块或生产者和消费者都可以更改的相互共享的合同模块中的 `src/main/resources/contracts` 中。
在 CDCT 中，假设客户将定义并贡献合约定义供生产者构建。 毕竟，您为什么要构建一个没有客户想要的 API？ 你应该为你想要捕获的每一件小事，
为每一个可能跨版本的变化定义一个契约。 当您想要捕获跨 API 版本的潜在破坏性更改时，契约特别有效。 合同可帮助您确保依赖旧 API 的旧客户端的兼容性，
直到您可以将它们迁移到新版本。 让我们看一下捕获 HTTP 端点 `/customers` 行为的合约。

[source,groovy]
----
import org.springframework.cloud.contract.spec.Contract

Contract.make {

    // <1>
    request {
        method "GET"
        url "/customers"
    }

    // <2>
    response {

        // <3>
        body(
                """
                            [
                            {"id":"1","name":"Jane"},
                            {"id":"2","name":"John"}
                            ]
                            """
        )
        status(200)
        headers {
            contentType(applicationJson())
        }
    }
}
----
====
<1> 定义我们期望对此端点的请求看起来像什么
<2> 假设响应式 HTTP 端点中的代码已运行并假设我们稍后插入的任何设置逻辑已运行，断言我们期望返回的内容。
====

很简单，对吧？ 如果您使用具有 Groovy 支持的 IntelliJ IDEA，当您更改此契约定义时，您将获得自动完成功能。
如果您为 Gradle 或 Maven 配置了正确的插件，该合约将在测试期间执行。

=== 配置 Spring Cloud Contract Maven 插件

在法律体系中，合同的有效性取决于管辖它的确认和执行系统。 在这种情况下，那个调控器——确保结果完整性的东西——是一个构建时插件。
我们正在使用 Maven，因此我们将配置插件的 Maven 版本。

Spring Cloud Contract Maven插件配置

[source,xml]
----
<plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>${spring-cloud-contract-maven-plugin.version}</version>
    <extensions>true</extensions>
    <configuration>
        <!--  --> // <1>
        <baseClassForTests>
        rsb.testing.producer.BaseClass
        </baseClassForTests>
         <!--  --> // <2>
        <testMode>WEBTESTCLIENT</testMode>
        <!--                    <testMode>EXPLICIT</testMode>-->
    </configuration>
</plugin>
----
====
<1> 该插件会将我们的合同定义（我们稍后将探讨）转换为测试用例。 一个实际的、诚实至善的 JUnit 类，将与我们所有其他测试一起编译和运行。 这个声明性契约将产生一个测试，该测试会检查我们的响应式 HTTP 端点的结构，几乎与我们之前在 rsb.testing.producer.CustomerWebTest 中所做的相同。 这个新的测试类将要求我们设置测试工作所需的任何机器，就像我们在 CustomerWebTest 中必须做的那样。 我们将把设置逻辑放在一个基类中。
<2> 我们的 HTTP API 由响应式 Spring WebFlux 端点提供支持，而不是基于非响应式 HTTP Servlet 的应用程序。 此配置开关有助于 Spring Cloud Contract Maven 插件了解这一事实。
====

插件版本随版本而变化。 下面是 Maven 属性，它定义了我们在本书中使用的代码的版本。

Spring Cloud Contract Maven插件版本

[source,xml]
----
<spring-cloud-contract-maven-plugin.version>2022.0.0</spring-cloud-contract-maven-plugin.version>
----

Maven 插件会将我们的合同文件转换为单元测试，该单元测试本身将扩展提供的基类。 基类必须设置 Spring Cloud Contract 测试机制并提供测试工作所需的任何模拟协作者，就像我们在 CustomerWebTest 中提供模拟调用者一样。

=== Defining the Base Class

我们可以通过多种方式为转译的 Spring Cloud Contract 测试提供基类。 我们可以使用基于契约名称、基于包名称等的约定来做到这一点。
在这里，我选择了一个非常简单的策略：我将把所有转译的测试映射到一个基类。 这显然不会扩展，但它是开始的好方法。

[source,java]
----
// <1>
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,properties = "server.port=0")
public class BaseClass {

    private static final Logger log = LoggerFactory.getLogger(BaseClass.class);

    // <2>
    @LocalServerPort
    private int port;

    // <3>
    @MockBean
    private CustomerRepository customerRepository;

    @Autowired
    private RouterFunction<?> routerFunction;

    @BeforeEach
    public void before() {
        log.info("the embedded test web server is available on port" + this.port);

        // <4>
        Mockito.when(this.customerRepository.findAll())
                .thenReturn(Flux.just(new Customer("1","Jane"),new Customer("2","John")));

        // <5>
        RestAssuredWebTestClient.standaloneSetup(this.routerFunction);
    }

    // <6>
    @Configuration
    @Import(ProducerApplication.class)
    public static class TestConfiguration {}
}
----
====
<1> 我们指示 Spring Boot 测试机器在随机端口上启动被测 Web 应用程序
<2> 在我们的测试中，我们需要知道应用程序最终在哪个端口安顿下来。 使用 `@LocalServerPort` 注解在此处注入。
<3> 使用 `@MockBean` 来模拟 `CustomerRepository` 协作对象...
<4> ...我们将以正常方式配置其预编程存根行为
<5> Spring Cloud Contract 反过来使用名为 RestAssured 的第三方项目。 我们在这里将 RestAssured 机器指向我们正在运行的 Web 应用程序
<6> Spring 测试框架需要了解如何构造 Spring 应用程序上下文以发现被测 bean。 在此处导入根 Spring Boot 配置类。
====

安装 Spring Cloud Contract 生产者存根...

[source,text]
----
...
[INFO]
[INFO] --- maven-install-plugin:2.5.2:install (default-install) @ producer ---
[INFO] Installing /Users/joshlong/reactive-spring-
book/code/testing/producer/target/producer-0.0.1-SNAPSHOT.jar to
/Users/joshlong/.m2/repository/rsb/producer/0.0.1-SNAPSHOT/producer-0.0.1-SNAPSHOT.jar
[INFO] Installing /Users/joshlong/reactive-spring-book/code/testing/producer/pom.xml to
/Users/joshlong/.m2/repository/rsb/producer/0.0.1-SNAPSHOT/producer-0.0.1-SNAPSHOT.pom
[INFO] Installing /Users/joshlong/reactive-spring-
book/code/testing/producer/target/producer-0.0.1-SNAPSHOT-stubs.jar to
/Users/joshlong/.m2/repository/rsb/producer/0.0.1-SNAPSHOT/producer-0.0.1-SNAPSHOT-
stubs.jar
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 13.564 s
...
----

扫描输出，您会看到常见的嫌疑人：它自然地安装了 pom.xml 和 producer-0.0.1-SNAPSHOT.jar。 但还有一件有趣的事情：它是已安装的存根！
这些存根传达 API 使用者建立此 API 的模拟版本所需的信息。 消费者可以通过多种方式发现这些存根：通过本地 Maven `~/.m2/repository` (LOCAL)，作为（测试）CLASSPATH 上的工件，
或通过组织中托管的共享工件存储库 (REMOTE)。

让我们回顾一下预期和理想的工作流程。 您将对制作人和合同进行更改。 您将在本地运行构建。 如果一切都是绿色的，您将提交更改，
然后执行 git push。 CI 环境将运行与您在本地运行的测试相同的测试。 它将运行更详尽的集成测试。 如果一切都是绿色的，CI 环境会将代码推送到 CD 管道中，
这将（有人希望）生成一个已部署到生产环境的构建，其中新 API 中的代码现在代表所有客户端必须与之集成的代码 是他们在转向生产时可能会遇到的问题。
同时，您的 CI 构建将执行 mvn 部署，将二进制文件和存根提升到您组织的工件存储库。

[NOTE]
====
当我们完成这个示例时，我们理所当然地认为您已经设置了 CD 管道。 如果你还没有，那就去做吧！
您还可以参考 O'Reilly 的 Cloud Native Java 以了解有关该主题的更多信息。
====

出于我们的目的，对于此示例，我们的“工件存储库”只是 `~/.m2/repository`。 让我们重新审视我们的消费者代码，并根据 Spring Cloud Contract 对其进行修改。

=== 在客户端测试中使用 Spring Cloud Contract Stubrunner

这部分很简单！ 这是我最喜欢的部分，甚至。 我们要删除代码！ 这是一个新测试，它与我们之前的测试几乎相同，只是我们删除了与 Wiremock 相关的所有内容，
并将其替换为一个简单的注解 `@AutoConfigureStubRunner`。


[source,java]
----
@DirtiesContext
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK,classes = ConsumerApplication.class)
@AutoConfigureStubRunner(
        ids = StubRunnerCustomerClientTest.PRODUCER_ARTIFACT_ID,// <1>
        stubsMode = StubRunnerProperties.StubsMode.LOCAL // <2>
)
public class StubRunnerCustomerClientTest {

    private static final Logger log = LoggerFactory.getLogger(StubRunnerCustomerClientTest.class);

    final static String PRODUCER_ARTIFACT_ID = "rsb:producer";

    @Autowired
    private CustomerClient client;

    @StubRunnerPort(StubRunnerCustomerClientTest.PRODUCER_ARTIFACT_ID)
    private int portOfProducerService; // <3>

    @Test
    public void getAllCustomers() {
        var base = "localhost:" + this.portOfProducerService;

        this.client.setBase(base);
        log.info("setBase( " + base + ")");

        Flux<Customer> customers = this.client.getAllCustomer();

        StepVerifier.create(customers)
                .expectNext(new Customer("1","Jane"))
                .expectNext(new Customer("2","John"))
                .verifyComplete();
    }
}
----
====
<1> `@AutoConfigureStubRunner` 注解在运行时加载存根的工件并将其转换为模拟 HTTP API，其响应是我们在合约定义中预先编程的。
它实际上使用与 Ivy Maven 兼容的依赖项解析器来加载存根。 我们在 ids 属性中提供坐标。 如果您曾经使用过 Ivy（恐怖！）或 Gradle，
那么您应该熟悉这种坐标语法：它是 `groupId:artifactId:version`。 + 表示使用最新版本，这是我们想要的，因为根据定义，在持续交付环境中，
存根的最新版本也对应于生产中的版本。 最后一个参数 `8080` 告诉存根运行器在端口 8080 上运行我们的模拟 HTTP 服务器，就像使用 Wiremock 一样。
<2> `StubsMode.LOCAL` 向 stubrunner 发出信号，表明我们希望通过查看本地 `~/.m2/repository` 文件夹来解析存根，而不是在运行应用程序的 CLASSPATH 上的组织工件存储库中。
<3> 存根运行器将为我们启动端点。 我们可以找到使用 `@StubRunnerPort` 注解并向其提供生产者工件坐标的位置——与我们为 `@AutoConfigureStubRunner` 本身指定的坐标相同。
====

除了配置 `@AutoConfigureStubRunner`，我们还删除了 Wiremock 代码，只留下我们想要测试的本质：给 `/customers` HTTP 端点的请求，
确认我们知道包含 Jane 和 John 的结果确实包含这些记录 . `Stubrunner` 在我们的测试生命周期内启动和停止模拟 HTTP 端点。
与部署完整的生产集群相比，运行该模拟 HTTP 服务要轻得多，成本也低得多。

如果消费者中的 Customer DTO 包含不一致的字段名称，那么您的测试现在将失败，因为客户端中返回的模拟数据反映了生产者生成的 JSON 的形状。 问题解决了！

=== 奖励：使用 Spring Cloud Contract Stubrunner Boot .jar

好吧——这对任何使用 Spring 的人来说都很好。 Spring Cloud Contract 帮助使用 Spring 的生产者和消费者背后的人们准时回家。 但是假设的非 Spring 和非 JVM 开发人员呢？
那些构建 iPhone 应用程序、Android 应用程序和 HTML5、基于浏览器的应用程序的人呢？ 他们当然也有家庭！ 想想孩子们！

我们可以使用必须下载的 Spring Cloud Contract Stub Runner Boot .jar，并使用它运行模拟 HTTP API，就像 `@AutoconfigureStubRunner` 注解对我们的测试所做的那样。
您可以从 Maven Central 或任何其他常用站点下载 `.jar`。

使用 Spring Cloud Contract Stub Runner Boot `.jar`

[source,shell]
----
$ wget -O stub-runner.jar
'https://search.maven.org/remotecontent?filepath=org/springframework/cloud/spring-cloud-
contract-stub-runner-boot/{srb-version}/spring-cloud-contract-stub-runner-boot-{srb-
version}.jar'
$ java -jar spring-cloud-contract-stub-runner-boot-{srb-version}.jar \
    --stubrunner.ids=rsb:producer:+:8080 \ // <1>
    --stubrunner.stubsMode=LOCAL --server.port=0
----
====
<1> 我们指定与使用 `@AutoconfigureStubRunner` 注解时相同的坐标
====

另一种方法是通过从 Spring Initializr 构建新的 Spring Boot 项目，添加 Cloud Bootstrap，然后单击“生成”以获取新的 Spring Boot `.jar`，
以老式方式构建您自己的 Stub Runner Boot Server .jar。 打开它并将 `org.springframework.cloud:spring-cloud-starter-contract-stub-runner` 添加到 Maven 构建中。
然后，这最后一步很重要，确保用 `org.springframework.cloud.contract.stubrunner.server.EnableStubRunnerServer` 注解主类。 最后，编译并享受吧！

一旦进程启动，它就会启动并运行，您可以在 `http://localhost:8080/customers` 调用您的模拟 HTTP API。 在那里，您会看到 Jane 和 John 的记录，
正如我们在合同中指定的那样。 因此，现在，与其告诉某人部署 Kubernetes 集群只是为了测试他们的 HTML 5 应用程序，
不如给他们一份 Stub Runner Boot .jar 的副本以及组织工件存储库中存根的坐标。

== 结论

测试是您自信前进的方式。 想象一下，随着时间的推移，你对昨天、前天等所做的工作越来越不确定？ 你会很紧张，很快就会后悔！ 测试是解毒剂。
这就是您与自己相处并自信面对同龄人的方式。 响应式编程颠覆了一些关于代码中行为可观察性的假设，但 Reactor 和在其之上的 Spring 提供了提供帮助的工具。
在本章中，我们已经了解了如何从服务到系统自信地发展基于 Spring 的响应式应用程序。







