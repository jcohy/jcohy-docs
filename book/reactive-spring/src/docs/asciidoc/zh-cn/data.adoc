= 数据访问

如果把您的应用程序比做是身体，那么数据库就是他的大脑。 数据也是应用程序的命脉。今天，您的应用程序花费大量时间处理数据，如何高效地处理数据至关重要。

在本章中，我们将研究如何以原生响应式使用数据。响应式数据访问驱动程序和客户端使用异步 IO 并支持背压。 他们应该能够独立于线程扩展读写。

Spring Data 可以在这里帮助我们。Spring Data 是一个综合项目，由许多支持 NoSQL 和 RDBMS 连接的模块组成，用于一些不同的数据存储和数据访问客户端。
在某些情况下，对于某些 `RDBMSes`、`Cassandra`、`MongoDB`、`Couchbase` 和 `Redis`，Spring Data 支持传统的阻塞和响应式非阻塞。 这些响应式替代方案是使用异步或响应式驱动程序从头开始构建的。
正是出于这个原因，我们还不一定有一些非响应性 Spring Data 模块的响应式替代方案。 例如，已经讨论了 Spring Data `Neo4j` 响应式模块。

我们将在本章中研究一些响应式选项。 响应式模块不是传统和阻塞选项的直接替代品，因此本章固有的现实是您可能需要重构现有的数据访问代码以支持响应式。 这也是一项非常重要的工作！

== 为什么需要响应式？

那么，你为什么要这样做？ 为什么在处理数据时需要响应式。 在考虑响应式编程时，数据是主要动机。 响应式编程支持更高效地使用线程，并允许系统中的节点同时处理更多 IO 工作。
响应式编程为您提供了更简洁的 API 来处理数据流。 它使您可以更自然地加入、拆分、过滤和以其他方式转换数据流。 响应式编程在 API 中支持显示错误处理和背压，为消费者提供一致的表面级 API，通过该 API 处理导致系统不稳定的极端情况。

最后一点至关重要。 请记住，所有系统都存在这种不稳定性，但我们往往无法在我们的阻塞代码中解决它。我们简化的抽象让我们对机器和网络的现实视而不见。 这里的观察力是我们是优秀的开发人员，但很容易看不到这些问题。
响应式编程使我们能够以一种一致的、易于理解的方式来面对这些问题。

如今，以数据为中心的应用程序已成为必需品。 组织正在通过网络将越来越多的数据从一项服务移动到另一项服务，并且它们正在以越来越快的速度生成更多数据。 传感器数据、移动网络、社交网络活动、大数据和分析、点击流跟踪、机器学习、人工智能，
当然还有存储冗余数据的成本不断下降，这些都促进了我们应用程序和组织中产生的数据的增长。 响应式编程让我们尽可能高效地管理尽可能多的数据。

底线：响应式编程可能会提供一种更优雅的数据处理方式，并且它可能会提供一种方式来处理具有相同资源（连接、线程和硬件）的更多用户。

响应式编程要求您重新思考使用数据存储的方式。它不是直接替代品，因此我们处理数据的方式的一些基本内容需要修改。

== 事务呢？

数据库事务是独立和分散执行的逻辑工作单元。在许多数据库中，数据库事务是符合 ACID 的。 它们支持原子性、一致性、隔离性和持久性。事务允许客户端开始一个工作单元，将多个分散的记录写入该工作单元内的数据库，然后选择提交这些写入（原子地）或将它们全部回滚，回写。
独立连接到数据库的客户端将在写入之前看到数据库的状态（没有可观察到的变化），或者它会看到对数据库的所有写入。 当我们说写入是原子的时，我们的意思是客户端不会看到数据库处于不一致状态。

SQL 数据存储符合 ACID 标准。 它们支持原子地提交或撤销事务。 在使用 SQL 数据存储时，我们用于 SQL 数据访问的任何方法都需要支持事务。

NoSQL 数据存储不支持事务是一种常见的误解。虽然这在历史上有一定道理，但情况正在改善。 例如，Google 的 `Spanner` 以声称支持地理分布式规模的分布式事务而闻名。 `Neo4J` 支持事务。 `MongoDB 4.0` 也引入了事务支持。

对于同步或阻塞 API，Spring 长期以来一直支持 `PlatformTransactionManager` 以进行资源本地事务划分。当 NoSQL 数据存储引入事务支持时，我们会很快为该特定资源提供 `PlatformTransactionManager` 抽象的实现。
除了那些以 JDBC 为中心的数据访问，如 `DataSourceTransactionManager`，Spring Data 支持许多不同的资源本地事务类型。 在许多其他方面，有 Apache Geode (`GemfireTransactionManager`)、Neo4J (`Neo4jTransactionManager`) 和 - 对我们有用的 - MongoDB (`MongoTransactionManager`) 的实现。
Spring 的 `PlatformTransactionManager` 抽象帮助开发人员以无缝方式将事务划分一致地集成到非响应式 Spring 应用程序中。

[source,java]
----
package org.springframework.transaction;

import org.springframework.lang.Nullable;

/**
 * This is the central interface in Spring's imperative transaction infrastructure.
 * Applications can use this directly, but it is not primarily meant as an API:
 * Typically, applications will work with either TransactionTemplate or
 * declarative transaction demarcation through AOP.
 *
 * <p>For implementors, it is recommended to derive from the provided
 * {@link org.springframework.transaction.support.AbstractPlatformTransactionManager}
 * class, which pre-implements the defined propagation behavior and takes care
 * of transaction synchronization handling. Subclasses have to implement
 * template methods for specific states of the underlying transaction,
 * for example: begin, suspend, resume, commit.
 *
 * <p>The default implementations of this strategy interface are
 * {@link org.springframework.transaction.jta.JtaTransactionManager} and
 * {@link org.springframework.jdbc.datasource.DataSourceTransactionManager},
 * which can serve as an implementation guide for other transaction strategies.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @since 16.05.2003
 * @see org.springframework.transaction.support.TransactionTemplate
 * @see org.springframework.transaction.interceptor.TransactionInterceptor
 * @see org.springframework.transaction.ReactiveTransactionManager
 */
public interface PlatformTransactionManager extends TransactionManager {

	/**
	 * Return a currently active transaction or create a new one, according to
	 * the specified propagation behavior.
	 * <p>Note that parameters like isolation level or timeout will only be applied
	 * to new transactions, and thus be ignored when participating in active ones.
	 * <p>Furthermore, not all transaction definition settings will be supported
	 * by every transaction manager: A proper transaction manager implementation
	 * should throw an exception when unsupported settings are encountered.
	 * <p>An exception to the above rule is the read-only flag, which should be
	 * ignored if no explicit read-only mode is supported. Essentially, the
	 * read-only flag is just a hint for potential optimization.
	 * @param definition the TransactionDefinition instance (can be {@code null} for defaults),
	 * describing propagation behavior, isolation level, timeout etc.
	 * @return transaction status object representing the new or current transaction
	 * @throws TransactionException in case of lookup, creation, or system errors
	 * @throws IllegalTransactionStateException if the given transaction definition
	 * cannot be executed (for example, if a currently active transaction is in
	 * conflict with the specified propagation behavior)
	 * @see TransactionDefinition#getPropagationBehavior
	 * @see TransactionDefinition#getIsolationLevel
	 * @see TransactionDefinition#getTimeout
	 * @see TransactionDefinition#isReadOnly
	 */
	TransactionStatus getTransaction(@Nullable TransactionDefinition definition)
			throws TransactionException;

	/**
	 * Commit the given transaction, with regard to its status. If the transaction
	 * has been marked rollback-only programmatically, perform a rollback.
	 * <p>If the transaction wasn't a new one, omit the commit for proper
	 * participation in the surrounding transaction. If a previous transaction
	 * has been suspended to be able to create a new one, resume the previous
	 * transaction after committing the new one.
	 * <p>Note that when the commit call completes, no matter if normally or
	 * throwing an exception, the transaction must be fully completed and
	 * cleaned up. No rollback call should be expected in such a case.
	 * <p>If this method throws an exception other than a TransactionException,
	 * then some before-commit error caused the commit attempt to fail. For
	 * example, an O/R Mapping tool might have tried to flush changes to the
	 * database right before commit, with the resulting DataAccessException
	 * causing the transaction to fail. The original exception will be
	 * propagated to the caller of this commit method in such a case.
	 * @param status object returned by the {@code getTransaction} method
	 * @throws UnexpectedRollbackException in case of an unexpected rollback
	 * that the transaction coordinator initiated
	 * @throws HeuristicCompletionException in case of a transaction failure
	 * caused by a heuristic decision on the side of the transaction coordinator
	 * @throws TransactionSystemException in case of commit or system errors
	 * (typically caused by fundamental resource failures)
	 * @throws IllegalTransactionStateException if the given transaction
	 * is already completed (that is, committed or rolled back)
	 * @see TransactionStatus#setRollbackOnly
	 */
	void commit(TransactionStatus status) throws TransactionException;

	/**
	 * Perform a rollback of the given transaction.
	 * <p>If the transaction wasn't a new one, just set it rollback-only for proper
	 * participation in the surrounding transaction. If a previous transaction
	 * has been suspended to be able to create a new one, resume the previous
	 * transaction after rolling back the new one.
	 * <p><b>Do not call rollback on a transaction if commit threw an exception.</b>
	 * The transaction will already have been completed and cleaned up when commit
	 * returns, even in case of a commit exception. Consequently, a rollback call
	 * after commit failure will lead to an IllegalTransactionStateException.
	 * @param status object returned by the {@code getTransaction} method
	 * @throws TransactionSystemException in case of rollback or system errors
	 * (typically caused by fundamental resource failures)
	 * @throws IllegalTransactionStateException if the given transaction
	 * is already completed (that is, committed or rolled back)
	 */
	void rollback(TransactionStatus status) throws TransactionException;

}
----

事务的生命周期短而直接：事务开始，当工作完成后事务提交，或回滚（通常是因为发生了一些异常）。 有 `try/catch` 块和异常，以及涉及的一些错误处理。 您需要实例化事务本身，然后对其进行管理。
这一切都是令人困惑的东西，让大多数人渴望更简单、没有花里胡哨的客户端编程世界，他们只是逃到那里，然后发现自己以 UI 绑定框架的形式管理着无限复杂的状态机。 但是，我跑题了。
您可以使用 Spring 的 `TransactionTemplate` 简化管理事务的工作。 `TransactionTemplate` 实例为您管理状态机，让您专注于事务中要完成的工作单元，将您的工作单元块封装在事务中。 如果封闭块中没有异常，则 Spring 提交事务。 否则，Spring 回滚事务。
最好的是命令式事务管理！ 当您需要在给定方法的范围内管理各个工作单元时，Spring 的支持非常出色。

将 `@EnableTransactionManagement` 添加到 `@Configuration-annotated` 类以启用声明式事务管理。 您可以使用 `@Transactional` 注解单个方法或整个类。
Spring 自动将您的方法调用包含在一个事务中。 如果该方法无异常地完成，Spring 将提交事务，并且方法调用主体中的所有工作都将随之进行。 如果有任何异常，Spring 将回滚事务。

Spring 的 `PlatformTransactionManager` 使用 `ThreadLocal` 将当前事务的状态绑定到当前线程，因此事务中完成的任何工作都需要在该线程上进行。
这种每个线程事务的方法不适合响应式数据访问，在响应式这种情况下，执行可以而且经常会跨线程。

Spring Framework 5.2 引入了一个新的层次结构，以 `ReactiveTransactionManager` 类型为基础，以支持事务。

[source,java]
----
/*
 * Copyright 2002-2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.transaction;

import reactor.core.publisher.Mono;

import org.springframework.lang.Nullable;

/**
 * This is the central interface in Spring's reactive transaction infrastructure.
 * Applications can use this directly, but it is not primarily meant as an API:
 * Typically, applications will work with either transactional operators or
 * declarative transaction demarcation through AOP.
 *
 * @author Mark Paluch
 * @author Juergen Hoeller
 * @since 5.2
 * @see org.springframework.transaction.reactive.TransactionalOperator
 * @see org.springframework.transaction.interceptor.TransactionInterceptor
 * @see org.springframework.transaction.PlatformTransactionManager
 */
public interface ReactiveTransactionManager extends TransactionManager {

	/**
	 * Emit a currently active reactive transaction or create a new one, according to
	 * the specified propagation behavior.
	 * <p>Note that parameters like isolation level or timeout will only be applied
	 * to new transactions, and thus be ignored when participating in active ones.
	 * <p>Furthermore, not all transaction definition settings will be supported
	 * by every transaction manager: A proper transaction manager implementation
	 * should throw an exception when unsupported settings are encountered.
	 * <p>An exception to the above rule is the read-only flag, which should be
	 * ignored if no explicit read-only mode is supported. Essentially, the
	 * read-only flag is just a hint for potential optimization.
	 * @param definition the TransactionDefinition instance,
	 * describing propagation behavior, isolation level, timeout etc.
	 * @return transaction status object representing the new or current transaction
	 * @throws TransactionException in case of lookup, creation, or system errors
	 * @throws IllegalTransactionStateException if the given transaction definition
	 * cannot be executed (for example, if a currently active transaction is in
	 * conflict with the specified propagation behavior)
	 * @see TransactionDefinition#getPropagationBehavior
	 * @see TransactionDefinition#getIsolationLevel
	 * @see TransactionDefinition#getTimeout
	 * @see TransactionDefinition#isReadOnly
	 */
	Mono<ReactiveTransaction> getReactiveTransaction(@Nullable TransactionDefinition definition)
			throws TransactionException;

	/**
	 * Commit the given transaction, with regard to its status. If the transaction
	 * has been marked rollback-only programmatically, perform a rollback.
	 * <p>If the transaction wasn't a new one, omit the commit for proper
	 * participation in the surrounding transaction. If a previous transaction
	 * has been suspended to be able to create a new one, resume the previous
	 * transaction after committing the new one.
	 * <p>Note that when the commit call completes, no matter if normally or
	 * throwing an exception, the transaction must be fully completed and
	 * cleaned up. No rollback call should be expected in such a case.
	 * <p>If this method throws an exception other than a TransactionException,
	 * then some before-commit error caused the commit attempt to fail. For
	 * example, an O/R Mapping tool might have tried to flush changes to the
	 * database right before commit, with the resulting DataAccessException
	 * causing the transaction to fail. The original exception will be
	 * propagated to the caller of this commit method in such a case.
	 * @param transaction object returned by the {@code getTransaction} method
	 * @throws UnexpectedRollbackException in case of an unexpected rollback
	 * that the transaction coordinator initiated
	 * @throws HeuristicCompletionException in case of a transaction failure
	 * caused by a heuristic decision on the side of the transaction coordinator
	 * @throws TransactionSystemException in case of commit or system errors
	 * (typically caused by fundamental resource failures)
	 * @throws IllegalTransactionStateException if the given transaction
	 * is already completed (that is, committed or rolled back)
	 * @see ReactiveTransaction#setRollbackOnly
	 */
	Mono<Void> commit(ReactiveTransaction transaction) throws TransactionException;

	/**
	 * Perform a rollback of the given transaction.
	 * <p>If the transaction wasn't a new one, just set it rollback-only for proper
	 * participation in the surrounding transaction. If a previous transaction
	 * has been suspended to be able to create a new one, resume the previous
	 * transaction after rolling back the new one.
	 * <p><b>Do not call rollback on a transaction if commit threw an exception.</b>
	 * The transaction will already have been completed and cleaned up when commit
	 * returns, even in case of a commit exception. Consequently, a rollback call
	 * after commit failure will lead to an IllegalTransactionStateException.
	 * @param transaction object returned by the {@code getTransaction} method
	 * @throws TransactionSystemException in case of rollback or system errors
	 * (typically caused by fundamental resource failures)
	 * @throws IllegalTransactionStateException if the given transaction
	 * is already completed (that is, committed or rolled back)
	 */
	Mono<Void> rollback(ReactiveTransaction transaction) throws TransactionException;

}

----

`ReactiveTransactionManager` 和 Spring 的所有响应式事务管理支持都依赖 Reactor Context 来跨线程传播事务状态。 Spring 提供了 `TransactionalOperator` 来强制管理响应式事务。

Spring 还支持使用 `@Transactional` 注解的声明式事务划分，只要带注解的方法返回 `Publisher<T>`。

我们将在我们介绍的每个数据存储的上下文中返回到事务管理的讨论。

== 响应式 SQL 数据访问

在过去的几年里，我一直在与世界各地的工程师交谈，因为我将一个接一个的组织介绍响应式编程，第一个问题总是：它支持 JDBC 吗？ 有没有一种方法可以响应式地使用 JDBC？
我一直不得不给出的答案是非常诚实的，如果令人失望的话：JDBC 是一个基本同步和阻塞的 API。 如果 Spring 团队要包装它并在 Reactive Streams 类型中调整它，它就不会为任何人服务。
它不会更具可扩展性，而且 API 会更麻烦，因为您必须使用线程来扩展事务。 更不用说，它甚至没有与最初期待 JDBC 的更广泛的工具生态系统集成。 何必呢？

有些人会颓然离开，显然对我帮助他们“啊哈！”感到沮丧。 响应式编程的那一刻才彻底破灭了他们的希望。 响应式编程不是他们的解决方案； 他们绝望了。 还没有。 有点遗憾！
如果做得好，响应式 SQL 客户端可以提供 NoSQL 数据存储所追求的一些东西，即性能和可伸缩性。

所以：就目前而言，JDBC 对于响应式数据访问来说并不是一个很好的选择。 现在，这并不是说您不能响应式地与 SQL 数据存储对话 - 恰恰相反。 你不能用 JDBC 做到这一点。
但是，如果您真的非常想使用 JDBC，您可能会有一些伪响应式的选项。 `Lightbend` 在这方面有一个令人兴奋的项目，叫做 `Slick`。 `Slick` 最终会采用 JDBC 并尝试为您隐藏一些线程。
它的主要目的似乎不是为基于 SQL 的数据访问提供响应式 API，而是支持友好的、以 `Scala` 为中心和类型安全的抽象来处理 SQL 数据存储。
它还为您提供了一种在响应式代码中运行良好的编程模型，并且通过使用调度程序甚至可以对客户端隐藏一些阻塞代码。 您不会获得响应式编程应能带来的横向扩展优势，但至少编程模型是友好的。
这是半步，但可能值得您考虑。

=== 响应式关系数据库连接 (R2DBC)

除了 JDBC 之外，还有一些选择正努力在本地支持异步 IO 甚至响应式编程。

响应式数据库访问的一个选择可能是 Oracle 的 `ADBA` 项目。 Oracle 在 JavaOne 2016 上宣布了 `ADBA`（异步数据库 API）项目。当时它还不能用，但至少人们承认需要一些东西来填补这个空白。
一年后，在 JavaOne 2017 上，Oracle 有一个基于 Java 8 的 `CompletionStage` 之类的原型项目。 `CompletionStage`（和 `CompletableFuture`）支持单个值的异步解析。
它们不支持值流的异步解析，也不支持背压。 他们不是被动的。

Java 9 版本将 Reactive Streams 规范中的核心接口添加到 `java.util.concurrent.Flow` 类型中，作为嵌套类型。 因此，`org.reactivestreams.Publisher` 变为 `java.util.concurrent.Flow.Publisher`，
`org.reactivestreams.Subscriber` 变为 `java.util.concurrent.Flow.Subscriber`，`org.reactivestreams.Processor` 变为 `java.util.concurrent.Flow.Processor`。·
在 2018 年年中，`ADBA` 背后的团队终于认为有必要修改他们的工作以支持 JDK 中的响应式类型。

与此同时，Pivotal 的一个团队开始着手设计名为 R2DBC（Relational Reactive Database Connectivity 的缩写）的响应式 SQL 数据访问 API 的原型。
R2DBC 是一个开源项目，许多人已经为此做出了贡献。 我们在本章中讨论 R2DBC。

在撰写本文时，`ADBA` 和 `R2DBC` 都处于早期阶段，（还）不适合生产。 R2DBC 还包含一个适配器模块，它将 ADBA 模块与 R2DBC 集成在一起，这样，如果 ADBA 变得具有生产价值，那么那些构建在 R2DBC 上的选项就不会短缺。

R2DBC 试图为基于 SQL 的数据存储访问定义一个响应式 SPI。 它不是现有 JDBC 之上的外观，而是意在利用罕见的本地响应 SQL 数据库驱动程序。 强调稀有！ 许多常见数据库都有 SPI 的实现，包括由 Pivotal 工程团队驱动的 `H2`、`Microsoft` `SQL Server` 和 `PostgreSQL`。
还有一个名为 `JAsync` 的第三方项目支持的 MySQL 的 R2DBC 实现。 我知道许多其他大型数据库供应商也在致力于 R2DBC 支持。 在撰写本文时，至少有五家其他数据库供应商正在开发 R2DBC 驱动程序。 （不，据我所知，其中没有一个是 `Oracle`）。

从广义上讲，当我提到 R2DBC 时，我指的是至少三个抽象级别。 低级 SPI 的工作方式或多或少类似于原始 JDBC API。 `DatabaseClient` 或多或少类似于 Spring 的 `JdbcTemplate`。
最后，Spring Data R2DBC 提供了类似 ORM 的体验，将实体声明性映射到记录，并支持内置的声明性存储库对象。

=== 建立连接

让我们构建一个使用 R2DBC 连接到 `PostgreSQL` 的应用程序。
您需要添加相关的 R2DBC 驱动程序和支持  R2DBC 集成的 Spring Boot Starter ，类似于直接使用 `JdbcTemplate`，或支持 Spring Data R2DBC 的集成。

* org.springframework.boot：spring-boot-starter-data-r2dbc
* io.r2dbc：r2dbc-postgresql

`ConnectionFactory` 是 R2BDC SPI 的核心。 它将客户端连接到适当的数据存储。 Spring Boot 的自动配置可以为您完成，或者您可以覆盖默认的自动配置并自己完成。 我宁愿让自动配置来完成繁重的工作；
定义一个属性 `spring.r2dbc.url`，然后开始吧！ 这是我本地机器上的配置：

在我的本地计算机上运行的 `PostgreSQL` 数据库的 R2DBC URL。 您应该根据您的特定环境对其进行自定义。

[source,properties]
----
spring.r2dbc.url=r2dbc:postgresql://orders:orders@localhost:5432/orders
spring.r2dbc.username=orders
spring.r2dbc.password=orders
----

您可能不想将该信息保存在应用程序的属性文件中。 相反，考虑将其保存在外部。 您可以使用 `--` 参数、环境变量、Spring Cloud Config Server、Hashicorp Vault 等。

=== Database Schema

在下面的示例中，我们将假设您有一个配置了用户名 (`orders`) 和密码 (`0rd3rz`) 的数据库 (`orders`)。 如果您已经登录到您的管理员帐户，您可以执行以下语句来创建所需的角色和数据库。

在 `PostgreSQL` 中创建订单角色和数据库的 DDL

[source,sql]
----
CREATE ROLE orders WITH LOGIN PASSWORD '0rd3rz' ;
ALTER ROLE orders CREATEDB ;
CREATE DATABASE orders;
----

接下来，您需要一个表。 在每次运行之前，在我们的测试中从 `src/main/resources/schema.sql` 创建 schema（稍后会详细介绍）。 这是我们 `customer` 表的 DDL。 我们要将一个对象映射到这个表。

[source,sql]
----
drop table customer;
create table customer (
  id    serial  not null primary key,
  email varchar not null
);
----

=== Repository Interface(存储库接口)

让我们构建一个存储库来管理对我们数据的访问。存储库将较高级别的业务逻辑与较低级别的持久性和数据管理事务隔离开来。为了最好地展示各种 R2DBC 抽象的独特应用，我们将实现相同的存储库接口三次。
存储库模式描述了封装访问数据源所需逻辑的类。 它们集中了标准数据访问要求（创建、读取、更新、删除），提供更好的可维护性并将用于访问数据库的基础设施与领域模型层分离。

这是我们将在游览中使用的存储库接口。 它支持各种常见用例，包括查找记录、保存（或更新）记录和删除记录。

[source,java]
----
@NoRepositoryBean
public interface SimpleCustomerRepository {

    Mono<Customer> save(Customer c);

    Flux<Customer> findAll();

    Mono<Customer> update(Customer c);

    Mono<Customer> findById(Integer id);

    Mono<Void> deleteById(Integer id);
}
----

我们将立即介绍各种实现。

=== Customer 实体

存储库操作实体 `Customer` 的实例，该实例映射到我们的表中的数据 `PostgreSQL` 数据库，客户。 这是该实体的定义。

[source,java]
----
public record Customer(@Id Integer id, String email) {
}
----

该实体相对简单。 使用 Spring Data 的 `@Id` 注解映射 id 字段。 我们暂时不需要那个注解，但稍后我们将在引入 Spring Data R2DBC 时使用它。

=== 测试

我们将使用测试来练习各种存储库实现。

让我们首先看一下我们的存储库实现的基础测试。我们将实现多个存储库，因此我们的测试都扩展了我们的 Base 测试并使用 template 模式来交换存储库实现。

[source,java]
----
@Testcontainers
public abstract class BaseCustomerRepositoryTest {

    @DynamicPropertySource
    static void registerProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.sql.init.mode",() -> "always");
        registry.add("spring.r2dbc.url",()  -> "r2dbc:tc:postgresql://rsbhost/rsb?TC_IMAGE_TAG=9.6.8");
    }

    // <1>
    public abstract SimpleCustomerRepository getRepository();

    @Test
    public void delete() {
        var repository = getRepository();

        var data = repository.findAll()
                .flatMap(c -> repository.deleteById(c.id()))
                .thenMany(Flux.just(
                        new Customer(null,"first@email.com"),
                        new Customer(null,"second@email.com"),
                        new Customer(null,"third@email.com")))
                .flatMap(repository::save);

        StepVerifier.create(data)
                .expectNextCount(3)
                .verifyComplete();

        StepVerifier.create(repository.findAll().take(1).flatMap(customer -> repository.deleteById(customer.id())).then())
                        .verifyComplete();

        StepVerifier.create(repository.findAll())
                .expectNextCount(2)
                .verifyComplete();
    }

    @Test
    public void saveAndFindAll() {
        var repository = getRepository();

        var data = Flux.just(
                new Customer(null,"first@email.com"),
                new Customer(null,"second@email.com"),
                new Customer(null,"third@email.com"))
                .flatMap(repository::save);
        StepVerifier.create(data)
                .expectNextCount(2)
                .expectNextMatches(customer -> customer.id() != null && customer.email() != null)
                .verifyComplete();
    }

    @Test
    public void findById() {
        var repository = getRepository();

        var insert = Flux.just(
                        new Customer(null,"first@email.com"),
                        new Customer(null,"second@email.com"),
                        new Customer(null,"third@email.com"))
                .flatMap(repository::save);

        var all = repository.findAll()
                .flatMap(customer -> repository.deleteById(customer.id()))
                .thenMany(insert.thenMany(repository.findAll()));

        StepVerifier.create(all)
                .expectNextCount(3)
                .verifyComplete();

        var recordsById = repository.findAll()
                .flatMap(customer -> Mono.zip(Mono.just(customer),repository.findById(customer.id())))
                .filterWhen(tuple2 ->Mono.just(tuple2.getT1().equals(tuple2.getT2())));

        StepVerifier.create(recordsById)
                .expectNextCount(3)
                .verifyComplete();

    }

    @Test
    public void update() {
        var repository = getRepository();

        var email = "test@email.com";

        StepVerifier
                .create(repository.findAll()
                        .flatMap(customer -> repository.deleteById(customer.id()))
                        .thenMany(repository.save(new Customer(null,email.toUpperCase(Locale.ROOT)))))
                .expectNextMatches(p -> p.id() != null)
                .verifyComplete();

        StepVerifier
                .create(repository.findAll())
                .expectNextCount(3)
                .verifyComplete();

        StepVerifier
                .create(repository.findAll()
                        .map(customer -> new Customer(customer.id(), customer.email().toUpperCase(Locale.ROOT)))
                        .flatMap(repository::update))
                .expectNextMatches(customer -> customer.email().equals(email.toUpperCase(Locale.ROOT)))
                .verifyComplete();
    }
}
----
====
<1> 每个测试都通过模板方法提供对 `SimpleCustomerRepository` 实现的引用。
====

当我们查看 R2DBC 时，我们将根据此 `SimpleCustomerRepository` 接口的实现来介绍每个新的抽象级别。我不会重新访问这些测试中的每一个，因为它们都仅用于扩展现有测试，通过覆盖 `getRepository()` 方法来交换 `SimpleCustomerRepository` 的实现。
大部分实现都在这个核心测试类中。 该测试读取表的数据定义语言 (DDL)，然后使用 `StepVerifier` 练习各种方法。 请务必查看我们关于测试的章节。

现在我们有了测试工具，让我们实现 `SimpleCustomerRepository` 接口。

使用 `ConnectionFactory` 的 base 存储库

在第一个实现中，我们将直接注入一个 `ConnectionFactory` 实例，并使用它向数据源提供新的连接。 在一个重要的示例中，我们将使用一个连接池，因此 Spring Boot 自动配置将我们的 `ConnectionFactory` 包装在一个连接池中，假设我们在某处定义了一个有效的 `ConnectionFactory`。

我们要看的第一个例子是与我们的数据库交互的最低级别的方式。 此实现中的所有 `SimpleCustomerRepository` 接口方法的流程都是相同的：

• 我们将创建一个声明。
• 可选择将参数绑定到语句。
• 可选地指定语句的意图（是添加？删除？）
• 执行语句。

[source,java]
----
package rsb.data.r2dbc.basics;
import io.r2dbc.spi.Row;
import io.r2dbc.spi.RowMetadata;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Repository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import rsb.data.r2dbc.Customer;
import rsb.data.r2dbc.SimpleCustomerRepository;
import java.util.function.BiFunction;

@Repository // <1>
@Log4j2
@RequiredArgsConstructor
class CustomerRepository implements SimpleCustomerRepository {

    // <2>
    private final ConnectionManager connectionManager;

    private final BiFunction<Row, RowMetadata, Customer> mapper = (row,
        rowMetadata) -> new Customer(row.get("id", Integer.class),
                row.get("email", String.class));

    @Override
    public Mono<Customer> update(Customer customer) {
        // <3>
        return connectionManager.inConnection(conn -> Flux
                .from(conn.createStatement("update customer set email = $1 where id = $2")
                .bind("$1", customer.getEmail()) //
                .bind("$2", customer.getId()) //
                .execute()))
                .then(findById(customer.getId()));
    }

    @Override
    public Mono<Customer> findById(Integer id) {
        // <4>
        return connectionManager
                    .inConnection(conn -> Flux.from(conn.createStatement("select * from customer where id = $1")
                    .bind("$1", id)//
                    .execute()))
                    .flatMap(result -> result.map(this.mapper))
                    .single()//
                    .log();
    }

    @Override
    public Mono<Void> deleteById(Integer id) {
            return connectionManager.inConnection(conn -> Flux
                    .from(conn.createStatement("delete from customer where id = $1") //
                    .bind("$1", id) //
                    .execute())) //
                    .then();
    }

    @Override
    public Flux<Customer> findAll() {
         return connectionManager.inConnection(conn -> Flux
                    .from(conn.createStatement("select * from customer ").execute())
                    .flatMap(result -> result.map(mapper)));
    }

    @Override
    public Mono<Customer> save(Customer c) {
            return connectionManager
            .inConnection(
                    conn -> Flux
                            .from(conn
                            .createStatement("INSERT INTO customer(email) VALUES($1)")
                            .bind("$1", c.getEmail()) //
                            .returnGeneratedValues("id").execute())
                    .flatMap(r -> r.map((row, rowMetadata) -> {
                            var id = row.get("id", Integer.class);
                            return new Customer(id, c.getEmail());
            }))) //
            .single() //
            .log();
    }
}
----
====
<1> `@Repository` 是另一个 Spring 构造型注解。 它使用 `@Component` 进行元注解。 它只不过是文档； 它在功能上只是一个 `@Component`。
<2> `ConnectionManager` 是获取（和回收）连接的主要接口。 `ConnectionManager#inConnection` 方法接受在 `Connection` 上起作用的回调。 回调机制也允许连接池高效工作。
<3> 第一个方法 `update` 创建一条语句，将参数与位置参数（以美元符号开头的数字、`$1`、`$2` 等）绑定，然后执行该语句。 大多数对数据库的写入或更新看起来像这样。
<4> 以下方法 `findById` 查询数据库，当结果到达时，它使用 `BiFunction<Row, RowMetadata, Customer>` 映射这些结果。 大多数查询或读取数据库的方法看起来像这样。
====

一旦您发现您可以流利地表达整个交互管道，就会出现响应式 R2DBC 代码。 毫无疑问，与原始 JDBC 代码相比，使用它要干净得多 我非常想包含一个原始的 JDBC 示例，仅供参考！ 但是，我不会，所以接下来靠你了。

`DatabaseClient`

`DatabaseClient` 是 Spring 的 `JdbcTemplate` 的响应式等价物。 它为日常操作提供了便捷的方法，减少了样板代码。 `DatabaseClient` 中的方法通常返回对构建器对象的引用，您可以针对该对象链接方法调用。

让我们看看我们的 `CustomerRepository` 的新实现，这次由 `DatabaseClient` 支持。 自动配置应该为您提供对 `DatabaseClient` 的引用，但如果您愿意，创建自己的也很简单。

[source,java]
----
public class CustomerRepository implements SimpleCustomerRepository {

    private final DatabaseClient databaseClient;

    private Customer map(Map<String, Object> row) {
        return new Customer((Integer) row.get("id"),(String) row.get("email"));
    }
    public CustomerRepository(DatabaseClient databaseClient) {
        this.databaseClient = databaseClient;
    }

    @Override
    public Mono<Customer> save(Customer c) {
        return databaseClient.sql("insert into customer ( email ) values ($1)")
                .bind("$1",c.email())
                .filter((stmt,ef) -> stmt.returnGeneratedValues("id").execute())
                .fetch()
                .first()
                .flatMap(row -> findById((Integer) row.get("id")));
    }

    @Override
    public Flux<Customer> findAll() {
        return databaseClient.sql("select * from customer")
                .fetch()
                .all()
                .as(rows -> rows.map(this::map));
    }

    @Override
    public Mono<Customer> update(Customer c) {
        return databaseClient.sql("update customer set email = $1 where id = $2")
                .bind("$1",c.email())
                .bind("$2",c.id())
                .fetch()
                .first()
                .switchIfEmpty(Mono.empty())
                .then(findById(c.id()));

    }

    @Override
    public Mono<Customer> findById(Integer id) {
        return databaseClient.sql("select * from customer where id = $1")
                .bind("$1",id)
                .fetch()
                .first()
                .map(map -> new Customer((Integer) map.get("id"),(String)map.get("email")));
    }

    @Override
    public Mono<Void> deleteById(Integer id) {
        return databaseClient.sql("delete from customer where id = $1")
                .bind("$1",id)
                .fetch()
                .rowsUpdated()
                .then();
    }
}
----

这个例子比前一个例子明显更简单，而前一个例子本身并没有那么令人难以抗拒。

=== Spring Data R2DBC

到目前为止，我们直接使用了普通的 R2DBC 库。 现在让我们看看 Spring Data R2DBC。 自动配置为我们提供了我们所需的一切，以便我们可以像使用任何其他（响应式）Spring Data 模块一样使用 Spring Data 模块。

[source,java]
----
// <1>
public interface CustomerRepository extends ReactiveCrudRepository<Customer,Integer> {

    // <2>
    @Query("select id, email from customer c where c.email = $1")
    Flux<Customer> findByEmail(String email);
}
----
====
<1> 支持我们的测试所需的一切都在 `ReactiveCrudRepository` 中。
<2> 那么，为什么我们需要 `findByEmail`？ 我们没有！ 我只是想向您展示使用自定义查询中定义自定义查询方法并将这些方法中的参数绑定到查询本身是多么容易。
在这种情况下，电子邮件是创建查询的参数。
====

就是这样！ Spring Data R2DBC 可以映射其他表。我们需要更多实体和更多存储库。 看？ 即使给定 `SimpleCustomerRepository` 和 `R2dbcConfiguration`，就代码行而言，我们仍然领先于第一个基本的 `CustomerRepository`！ 遥遥领先。
这个新版本甚至支持自定义查找方法，提供比以前更多的功能。 几分钟的工作还不错。

复杂性大幅降低的一个重要原因是我们的存储库扩展的基础接口 `ReactiveCrudRepository`。 你会在 Spring Data 中经常看到这个接口。 它的定义如下所示：

[source,java]
----
package org.springframework.data.repository.reactive;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import org.reactivestreams.Publisher;

import org.springframework.dao.OptimisticLockingFailureException;
import org.springframework.data.repository.NoRepositoryBean;
import org.springframework.data.repository.Repository;

@NoRepositoryBean
public interface ReactiveCrudRepository<T, ID> extends Repository<T, ID> {
	<S extends T> Mono<S> save(S entity);
	<S extends T> Flux<S> saveAll(Iterable<S> entities);
	<S extends T> Flux<S> saveAll(Publisher<S> entityStream);
	Mono<T> findById(ID id);
	Mono<T> findById(Publisher<ID> id);
	Mono<Boolean> existsById(ID id);
	Mono<Boolean> existsById(Publisher<ID> id);
	Flux<T> findAll();
	Flux<T> findAllById(Iterable<ID> ids);
	Flux<T> findAllById(Publisher<ID> idStream);
	Mono<Long> count();
	Mono<Void> deleteById(ID id);
	Mono<Void> deleteById(Publisher<ID> id);
	Mono<Void> delete(T entity);
	Mono<Void> deleteAllById(Iterable<? extends ID> ids);
	Mono<Void> deleteAll(Iterable<? extends T> entities);
	Mono<Void> deleteAll(Publisher<? extends T> entityStream);
	Mono<Void> deleteAll();
}

----


该接口定义了许多有用的方法，您可以熟悉一下这些方法。 这些方法支持常见的操作 — 查找、保存、删除和创建。 该接口公开了按 ID 查询记录。

但是，这些方法都不接受 String sql 参数。

在 Spring Data 中，您可以使用自定义查询方法，就像我们在存储库接口中所做的那样，并且通常使用 `@Query` 注解来表达查询。 这些方法非常方便，因为它们删除了所有样板资源初始化和获取逻辑。
他们删除了将记录映射到对象的工作。我们需要做的就是在方法的原型中提供查询和可选参数。

你可能会抗议：“如果你只是想在这里结束，为什么要向我们展示前两种方法呢？” 公平的问题！ 关系数据库管理系统 (RDBMS) 在开发人员的心中占有特殊的位置。 据统计，我们中的大多数人从事任何后端或服务器端工作都是从 RDBMS 开始我们的旅程。
它是最根深蒂固的一种数据库，也是您在职业生涯中最需要熟悉的一种数据库，至少在可预见的未来是这样。社区中存在关于 ORM 在应用程序架构中的作用的争论。也有许多不同的方法可以使用 RDBMS。 您是否正在使用您的分析和数据仓库？ 联机事务处理？ 作为事务存储？ 您是否使用 SQL '99 功能，或者您是否精通 `PostgreSQL` `PL/pgSQL` 或 `Oracle` PL/SQL？
您使用的是 `PostgreSQL` XML 类型还是 `PostGIS` 地理空间索引？ 你在使用存储过程吗？ 典型 RDBMS 的丰富性使得很难规定特定的抽象级别。 首先，我更喜欢在 Spring Data 存储库方面使用这些技术，并且能够在需要时下降到较低的抽象级别。

我们有一个存储库，我们的测试呢？ 精明的读者注意到我们的存储库没有实现 `SimpleCustomerRepository` 接口。 我不想让事情复杂化，所以我将本机 Spring Data 存储库调整为 `SimpleCustomerRepository` 接口，将调用转发到底层 Spring Data 存储库。

[source,java]
----
@Component
public class SpringDataCustomerRepository implements SimpleCustomerRepository {

    private final CustomerRepository repository;

    public SpringDataCustomerRepository(CustomerRepository repository) {
        this.repository = repository;
    }

    @Override
    public Mono<Customer> save(Customer c) {
        return repository.save(c);
    }

    @Override
    public Flux<Customer> findAll() {
        return repository.findAll();
    }

    @Override
    public Mono<Customer> update(Customer c) {
        return repository.save(c);
    }

    @Override
    public Mono<Customer> findById(Integer id) {
        return repository.findById(id);
    }

    @Override
    public Mono<Void> deleteById(Integer id) {
        return repository.deleteById(id);
    }
}
----

响应式 SQL 数据访问为我们打开了以前关闭的大门。 基于 SQL 数据库的现有工作负载的整个星系现在可能成为响应式编程的候选对象。 是一个严峻的选择。

响应式编程可以：

* 使您的应用程序更有效率。
* 使您的应用更具成本效益。
* 成为您继续使用 SQL 数据库所需的前沿技术，相信它会根据您的需要进行扩展。
* 延长某些应用程序的自然寿命。

没有什么是免费的。你必须重构为响应式。如果您正在使用 ORM，或者甚至可能已经在使用 Spring Data，并且您正在使用类似 Spring Data JPA 的东西，那么迁移到 Spring Data R2DBC 可能并不是什么大问题。
如果您使用的是 Spring Data JDBC，那么迁移到 Spring Data R2DBC 将是微不足道的。 如果您使用的是 JOOQ 之类的东西，则可以迁移到 R2DBC 或 Spring Data R2DBC。
JOOQ 的创始人 Lukas Eder 考虑过有一天可能会支持 R2DBC。 如果您使用的是 `JdbcTemplate`，那么这是一个更重要但可行的迁移。 如果您直接使用 JDBC，那么这会很痛苦。
非常非常痛苦。 这也是重构和清理代码的宝贵机会。 无论哪种方式，从原始 JDBC 迁移到 `JdbcTemplate` 或 R2DBC 都可以用明显更少的代码提供更多功能。

== NoSQL 中更高效的响应式数据访问

如果您的现有应用程序有少数技术可以替换成响应式的方案，那么是什么促使您采取行动？ 为什么要从传统的 MongoDB 切换到响应式 MongoDB？ 首先你为什么会接受像 MongoDB 这样的东西？ MongoDB 是一个具有大量特性的全功能数据库。
您选择它可能只是因为它具有无法用其他技术替换的原因。也许您想使用它的可扩展文件系统抽象 GridFS？ 或者，地理空间索引 (GIS) 支持？ 也许您真的想要拥有无模式文档的能力？ 不管是什么原因，您选择 MongoDB 是因为它自然地映射到您需要管理的数据类型。
（干得好！）如果你对你的数据存储感到满意并且你的性能达到标准，那么我不知道是否有令人信服的论据来支持重构为响应式。

当然，所有常见的原因都适用。 响应类型将促进处理数据和错误的统一抽象。 它将在 API 本身中显示网络集成问题。 当然，这些都是成果。 他们值得重构一切吗？ 也许。

您可能会选择 NoSQL 数据存储，因为该技术具有引以为豪的规模和速度特征。 MongoDB 是（众所周知的）“网络规模”。 它扩展大量数据的能力是一项可能单独证明其使用合理性的功能。
事实上，存在许多支持规模化的技术。 一些 NoSQL 选项以不太灵活的数据模型为代价，让您获得更好的性能和更好的规模。 例如，Map/reduce 是一种原始的数据处理方式，但天然支持大量数据。
我对 Apache HBase 和 Apache Cassandra 等列式数据库也有同样的感觉。 对于大多数人来说，使用列式数据存储对数据建模并不是阻力最小的途径。
对于大多数人来说，它并不比 PostgreSQL 或其他一些 RDBMS 更容易。

这些有时不太灵活的数据模型，它会是阻碍我们的原因吗？ 不会。但是，它们提供性能和规模，如果这是促使您做出决定的考虑因素，那么您应该考虑响应式编程。 它会让您从数据库客户端代码中榨取所有最后的效率。

数据越大，响应式编程越有利。 当某些东西可能会独占线程时，反应式编程最有价值。 响应式数据库客户端可能是一个 Web 服务器节点和五个之间的区别！

=== Reactive R2DBC 中的事务

构建存储库很好，但它是有意设置为低级别的。 它处理数据输入和数据输出。 作为服务层的一部分，业务逻辑往往存在于更高级别。 让我们构建一个提供粗粒度操作的服务，支持系统中所有电子邮件的规范化，以及通过电子邮件更新记录。

此服务具有两个操作，可对许多离散记录进行操作。 这些操作应该是原子的 - 我们不希望它们提交任何更改，除非一切都成功。 这是我们引入事务的天然机会。

[source,java]
----
----


第一个操作 `upsert`，委托给 `SimpleCustomerRepository` 的底层实例来查找现有数据库中的所有记录（是的，我意识到我们可能应该使用带有谓词的 SQL 查询），在 Java 代码中过滤以查找其记录 电子邮件与电子邮件参数匹配。
如果找到记录，则会更新它。 如果没有找到记录，则插入一个新记录。

抓住一切机会验证结果至关重要。 此方法通过 `errorIfEmailsAreInvalid` 方法传递结果，直观地说，如果在验证电子邮件中包含 `@` 字符时出现任何错误，该方法将返回错误 - `IllegalArgumentException`。

如果任何验证失败，我们将恢复写入 - 所有这些。 验证逻辑在数据库写入后运行。 写入是一个原子操作：要么所有写入都成功，要么都不成功。 `upsert` 方法使用 `TransactionalOperator#transactional` 方法将响应管道封装在事务中。
如果验证逻辑在响应管道中的任何地方导致错误，则写入将回滚。

cold stream（没有任何订阅者的流）和 hot stream（至少有一个订阅者的流）之间的区别很有用，因为这意味着我们可以定义响应流，然后稍后将其封装在之前的事务中 任何数据都流经流。

`TransactionalOperator` 就像 Spring 的 `TransactionTemplate`。 它非常适合显式、细粒度的事务划分，在给定范围内对不同的流进行操作。

如果您想要从包含在事务中的方法返回值流，您可以使用 `@Transactional` 修饰该方法，这是 `normalizeAllEmails` 所采用的方法。

您可以自己使用这两种方法或其中一种方法：尝试在数据中某处处理无效电子邮件，然后看看会发生什么。 我敢打赌！




