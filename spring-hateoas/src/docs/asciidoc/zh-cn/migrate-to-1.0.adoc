[[migrate-to-1.0]]
= Migrating to Spring HATEOAS 1.0

对于 1.0,我们借此机会重新评估了为 0.x 分支所做的一些设计和封装结构选择.
关于它的反馈令人难以置信,主要版本的颠簸似乎是重构它们的最自然的地方.

[[migrate-to-1.0.changes]]
== 改变

封装结构的最大变化是通过引入超媒体类型注册 API 来实现的,以支持 Spring HATEOAS 中的其他媒体类型. 这导致客户端和服务器API(分别命名的包)以及包 mediatype 中的媒体类型实现的清晰分离.

将代码库升级到新API的最简单方法是使用 <<migrate-to-1.0.script, migration script>>. 在我们开始之前,这些都都已经了解了这些变化.

[[migrate-to-1.0.changes.representation-models]]
=== 表示模型

`ResourceSupport`/`Resource`/`Resources`/`PagedResources` 这些类从被真正恰当地命名过,毕竟,这些类型实际上并不代表资源,而是表示模型.可以通过超媒体信息和提供的内容来丰富它们. 这是新名称映射到旧名称的方式:

* `ResourceSupport` 现在是 `RepresentationModel`
* `Resource` 现在是 `EntityModel`
* `Resources` 现在是 `CollectionModel`
* `PagedResources` 现在是 `PagedModel`

因此, `ResourceAssembler` 已重命名为 `RepresentationModelAssembler` 它的 `toResource(…)` 和 `toResources(…)` 方法被重命名为 `toModel(…)` 和 `toCollectionModel(…)` .
名称的变化也反映在 `TypeReferences` 包含的类中.

* `RepresentationModel.getLinks()` 现在暴露一个 `Links` 实例 (在 `List<Link>` 上) 因为它暴露了其他API,以使用各种策略来连接和合并不同的 `Links` 实例. 同样,它已经变成了自绑定的泛型类型,以允许向实例添加链接的方法返回实例本身.
* `LinkDiscoverer` APIs 已移至 `client` 包下.
* `LinkBuilder` 和 `EntityLinks` APIs 已移至 `server` 包下.
* `ControllerLinkBuilder` 已移到 `server.mvc` 中,不建议使用 `WebMvcLinkBuilder` 替代.
* `RelProvider` 已重命名为 `LinkRelationProvider` 并返回 `LinkRelation` 实例而不是 ``String``s.
* `VndError` 已移至 `mediatype.vnderror` 包下.

[[migrate-to-1.0.script]]
== 迁移脚本

您可以在应用程序根目录放置 https://github.com/spring-projects/spring-hateoas/tree/master/etc[一个脚本],该脚本会将所有导入语句和静态方法引用更新为在源代码仓库中移动的 Spring HATEOAS 类型.
只需下载该文件,然后从您的项目根目录中运行它即可. 默认情况下,它将检查所有Java源文件,并用新的替换旧的Spring HATEOAS类型引用.

.Sample application of the migration script
====
[source]
----
$ ./migrate-to-1.0.sh

Migrating Spring HATEOAS references to 1.0 for files : *.java

Adapting ./src/main/java/…
…

Done!
----
====

请注意,该脚本不一定能够完全修复所有更改,但应涵盖最重要的重构.

现在,验证对您最喜欢的Git客户端中的文件所做的更改,并进行适当的提交. 如果您发现未迁移的方法或类型引用,请打开出票跟踪器中的票证.

[[migration.1-0-M3-to-1-0-RC1]]
== 从 1.0 M3 迁移到 1.0 RC1

- `Link.andAffordance(…)` 的 Affordance 详细信息已移至 `Affordances`. 现在,要手动构建 `Affordance` 实例,请使用 `Affordances.of(link).afford(…)`. 另请注意,`Affordances` 暴露了新的 `AffordanceBuilder` 类型,以使其流式使用. 有关详细信息,请参见 <<server.affordances>>.
- `AffordanceModelFactory.getAffordanceModel(…)` 现在接收 `InputPayloadMetadata` 和 `PayloadMetadata` 实例,而不是 ``ResolvableType``s 实例 ,以允许基于非类型的实现. 自定义媒体类型的实现必须相应地进行调整.
- 如果 HAL Forms 的属性值遵循规范中定义的默认属性,则现在不呈现属性属性. 即 如果先前将 `required` 显式设置为 `false`,则现在我们省略了 `required` 条目. 现在,对于使用 `PATCH` 作为HTTP方法的模板,我们现在也只强制不需要使用它们.