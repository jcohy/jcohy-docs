[[mapping.fundamentals]]
= 对象映射基础

本节介绍了 Spring Data 对象映射,对象创建,字段和属性访问,可变性和不可变性的基础知识.请注意,本节仅适用于不使用基础数据存储 (例如 JPA) 的对象映射的 Spring Data 模块.
另外,请确保参考存储库特定的部分以获取存储库特定的对象映射,例如索引,自定义列或字段名称等.

Spring Data 对象映射的核心职责是创建域对象的实例,并将存储本地数据结构映射到这些实例上.
这意味着我们需要两个基本步骤:

1. 使用暴露的构造函数之一创建实例.
2. 实例填充以实现所有暴露的属性.

[[mapping.object-creation]]
== 创建对象

Spring Data 会自动尝试检测要用于实现该类型对象的持久性实体的构造函数.
解析算法的工作原理如下:

1. 如果有一个用 `@PersistenceCreator` 注解的静态工厂方法，则使用它。
2. 如果只有一个构造函数，则使用它。
3. 如果有多个构造函数，并且只有一个被 `@PersistenceCreator` 注解，则使用它。
4. 如果类型是 Java `Record`，则使用规范构造函数。
5. 如果有一个无参构造函数，则使用它。

值解析假定 构造/工厂 方法参数名称与实体的属性名称匹配,即,解析将像要填充该属性一样执行,包括映射中的所有自定义项 (不同的数据存储列或字段名称等) .
这也需要在类文件中可用的参数名称信息或在构造函数上存在的 `@ConstructorProperties` 注解.

可以通过使用特定于存储的 SpEL 表达式使用 Spring Framework 的 `@Value` 值注解来自定义值解析.
请参阅有关特定存储映射的部分以获取更多详细信息.

[[mapping.object-creation.details]]
.创建内部对象
****

为了避免反射的开销,Spring Data 对象的创建使用默认情况下在运行时生成的工厂类,该工厂类将直接调用 domain 类的构造函数.  即 对于此示例类型:

[source, java]
----
class Person {
  Person(String firstname, String lastname) { … }
}
----

我们将在运行时创建一个在语义上与此工厂等效的工厂类:

[source, java]
----
class PersonObjectInstantiator implements ObjectInstantiator {

  Object newInstance(Object... args) {
    return new Person((String) args[0], (String) args[1]);
  }
}
----

与反射相比,这使我们的性能提高了约 10％.  为了使域类有资格进行此类优化,它需要遵守一组约束:

- 它不能是 private 类
- 它不能是非静态内部类
- 它不能是 CGLib 代理类
- Spring Data 使用的构造函数不能为 private

如果这些条件中的任何一个匹配,Spring Data 将通过反射回退到实体实例化.
****

[[mapping.property-population]]
== 属性 population

创建实体的实例后,Spring Data 会填充该类的所有剩余持久性属性.  除非实体的构造函数已经填充了该实体 (即通过其构造函数参数列表使用) ,否则将首先填充 `identifier` 属性,以允许解析循环对象引用.  之后,在实体实例上设置所有尚未由构造函数填充的非临时属性.  为此,我们使用以下算法:

1. 如果属性是不可变的,但使用 wither 方法 (请参见下文) ,则我们使用 `with…`  方法创建具有新属性值的新实体实例.
2. 如果定义了属性访问权限 (即通过 getter 和 setter 的访问) ,则我们正在调用 setter 方法.
3. 如果属性是可变的,则直接设置该字段.
4. 如果属性是不可变的,那么我们将使用持久化操作使用的构造函数 (请参见 <<mapping.object-creation>>) 来创建实例的副本.
5. 默认情况下,直接设置字段值.

[[mapping.property-population.details]]
.Property population internals
****
与我们在<<mapping.object-creation.details,构造对象的优化>> 类似,我们还使用 Spring Data 运行时生成的访问器类与实体实例进行交互.

[source,java]
----
class Person {

  private final Long id;
  private String firstname;
  private @AccessType(Type.PROPERTY) String lastname;

  Person() {
    this.id = null;
  }

  Person(Long id, String firstname, String lastname) {
    // Field assignments
  }

  Person withId(Long id) {
    return new Person(id, this.firstname, this.lastame);
  }

  void setLastname(String lastname) {
    this.lastname = lastname;
  }
}
----

.生成的属性访问器
====
[source, java]
----
class PersonPropertyAccessor implements PersistentPropertyAccessor {

  private static final MethodHandle firstname;              <2>

  private Person person;                                    <1>

  public void setProperty(PersistentProperty property, Object value) {

    String name = property.getName();

    if ("firstname".equals(name)) {
      firstname.invoke(person, (String) value);             <2>
    } else if ("id".equals(name)) {
      this.person = person.withId((Long) value);            <3>
    } else if ("lastname".equals(name)) {
      this.person.setLastname((String) value);              <4>
    }
  }
}
----
<1> PropertyAccessor 持有底层对象的一个可变实例. 这是为了允许对其他不可变的属性进行更改.
<2> 默认情况下,Spring 数据使用字段访问来读写属性值. 根据  `private` 字段的可见性规则,使用 `MethodHandles` 与字段交互.
<3> 该类暴露了一个  `withId(…)` 方法,该方法用于设置标识符,例如,当一个实例被插入到数据存储并生成了一个标识符时. 调用  `withId(…)` 创建一个新的 `Person` 对象. 所有后续的突变都将在新实例中发生,而不影响先前的实例.
<4> 使用属性访问允许直接调用方法而不使用  `MethodHandles`.
====

与反射相比,这使我们的性能提高了约 25％.  为了使域类有资格进行此类优化,它需要遵守一组约束:

- Types 不得位于默认值或 java 包下.
- 类型及其构造函数必须是 `public` 的
- 内部类的类型必须是静态的.
- 使用的 Java 运行时必须允许在原始 `ClassLoader` 中声明类.  Java 9 和更高版本强加了某些限制.

默认情况下,Spring Data 尝试使用生成的属性访问器,如果检测到限制,则回退到基于反射的属性访问器.
****

让我们看一下以下实体:

.一个简单的实体
====
[source, java]
----
class Person {

  private final @Id Long id;                                                <1>
  private final String firstname, lastname;                                 <2>
  private final LocalDate birthday;
  private final int age;                                                    <3>

  private String comment;                                                   <4>
  private @AccessType(Type.PROPERTY) String remarks;                        <5>

  static Person of(String firstname, String lastname, LocalDate birthday) { <6>

    return new Person(null, firstname, lastname, birthday,
      Period.between(birthday, LocalDate.now()).getYears());
  }

  Person(Long id, String firstname, String lastname, LocalDate birthday, int age) { <6>

    this.id = id;
    this.firstname = firstname;
    this.lastname = lastname;
    this.birthday = birthday;
    this.age = age;
  }

  Person withId(Long id) {                                                  <1>
    return new Person(id, this.firstname, this.lastname, this.birthday, this.age);
  }

  void setRemarks(String remarks) {                                         <5>
    this.remarks = remarks;
  }
}
----
====
<1> 标识符属性是 `final`,但在构造函数中设置为 `null`.  该类暴露用于设置标识符的  `withId(…)` 方法,例如 将实例插入数据存储区并已生成标识符时.  创建新实例后,原始 `Person` 实例保持不变.
通常将相同的模式应用于存储管理的其他属性,但可能需要为持久性操作进行更改 `.wither` 方法是可选的,因为构造函数 (请参见 6) 实际上是一个复制的构造函数,设置该属性将转换为使用新的值创建一个新实例.
<2> `firstname` 和 `lastname` 属性是可能通过 getter 暴露的普通不可变属性.
<3> `age` 属性是一个不变的,但从  `birthday`  属性扩展的属性.  通过显示的设计,数据库值将胜过默认值,因为 Spring Data 使用唯一声明的构造函数.  即使意图是首选计算,此构造函数也必须将 `age` 作为参数 (可能会忽略它) ,这一点很重要,因为否则属性填充步骤将尝试设置 `age` 字段并由于其不可变而失败,并且没有 `with…` 方法存在.
<4> 通过直接设置其字段可以填充 `comment` 属性是可变的.
<5> `remarks` 属性是可变的,可通过直接设置  `comment` 字段或通过调用 setter 方法来填充
<6> 该类暴露用于对象创建的工厂方法和构造函数.  这里的核心思想是使用工厂方法而不是其他构造函数,以避免通过 `@PersistenceCreator` 消除构造函数歧义的需要.  相反,属性的默认设置是在工厂方法中处理的.
如果希望 Spring Data 使用工厂方法进行对象实例化，请使用 `@PersistenceCreator` 注解。

[[mapping.general-recommendations]]
== 一般建议

* _尝试坚持不可变的对象_ -- 不可变的对象很容易创建,因为实现一个对象只需调用其构造函数即可.  同样,这避免了用允许客户端代码操纵对象状态的 setter 方法乱扔您的域对象.  如果需要它们,则最好使它们受到程序包保护,以便只能由有限数量的同一位置类型调用它们.  仅限构造函数的实现比属性填充快 30％.
* _提供一个全参数的构造函数_ -- 即使您不能或不希望将实体建模为不可变的值,仍然可以提供一个将实体的所有属性作为参数 (包括可变属性) 作为参数的构造函数,因为这样做可以 对象映射以跳过属性填充以获得最佳性能.
* _使用工厂方法而不是重载的构造函数来避免  ``@PersistenceCreator``_ -- 为了获得最佳性能,需要使用全参数构造函数,我们通常希望暴露更多特定于应用程序用例的构造函数,从而省略了诸如自动生成的标识符等内容.  使用静态工厂方法暴露 `all-args` 构造函数的这些变体.
* _确保您遵守允许使用生成的实例化器和属性访问器类的约束_ --
* _对于要生成的标识符,仍然将 final 字段与全参数构造函数  `with…` 方法结合使用_ --
* _使用 Lombok 来避免样板代码_ -- 由于持久性操作通常需要构造函数使用所有参数,因此它们的声明成为对字段分配的样板参数的繁琐重复,最好使用 Lombok 的 `@AllArgsConstructor` 来避免.

[[mapping.general-recommendations.override.properties]]
=== 重写属性

Java 允许灵活设计 domain 类，其中子类可以定义一个已在其超类中以相同名称声明的属性。
考虑以下示例:

====
[source,java]
----
public class SuperType {

   private CharSequence field;

   public SuperType(CharSequence field) {
      this.field = field;
   }

   public CharSequence getField() {
      return this.field;
   }

   public void setField(CharSequence field) {
      this.field = field;
   }
}

public class SubType extends SuperType {

   private String field;

   public SubType(String field) {
      super(field);
      this.field = field;
   }

   @Override
   public String getField() {
      return this.field;
   }

   public void setField(String field) {
      this.field = field;

      // optional
      super.setField(field);
   }
}
----
====

这两个类都使用可分配类型定义了一个  `field` 。 `SubType` 但是会影响 `SuperType.field`。
根据类设计，使用构造函数可能是设置 `SuperType.field` 的唯一默认方法。
或者，在 setter 中调用 `super.setField(…)` 可以在 `SuperType` 中设置 `field`。
所有这些机制都会在某种程度上产生冲突，因为属性共享相同的名称但可能代表两个不同的值。
如果类型不可分配，Spring Data 会跳过超类型属性。
也就是说，被覆盖的属性的类型必须可以分配给它的超类型属性类型才能注册为覆盖，否则超类型属性被认为是瞬态的。
我们通常建议使用不同的属性名称。

Spring Data 模块通常支持覆盖不同值的属性。
从编程模型的角度来看，有几点需要考虑：

1. 哪个属性应该被持久化（默认为所有声明的属性）？ 您可以通过使用 `@Transient` 注解这些属性来排除这些属性。
2. 如何在数据存储中表示属性？ 对不同的值使用相同的字段/列名称通常会导致数据损坏，因此您应该使用明确的字段/列名称注解至少一个属性。
3. 不能使用 `@AccessType(PROPERTY)`，因为如果不进一步假设 setter 实现，通常无法设置超属性。

[[mapping.kotlin]]
== Kotlin 支持

Spring Data 修改了 Kotlin 的细节以允许对象创建和变异.

[[mapping.kotlin.creation]]
=== Kotlin 对象创建

支持 Kotlin 类实例化，所有类默认都是不可变的，需要显式的属性声明来定义可变属性。

Spring Data 自动尝试检测用于具体化该类型对象的持久化实体的构造函数。
解析算法的工作原理如下：

1. 如果有一个构造函数被 `@PersistenceCreator` 注解，则使用它。
2. 如果类型是 <<mapping.kotlin,Kotlin data cass>> 则使用主构造函数。
3. 如果有一个用 `@PersistenceCreator` 注解的静态工厂方法，则使用它。
4. 如果只有一个构造函数，则使用它。
5. 如果有多个构造函数，并且恰好有一个被 `@PersistenceCreator` 注解，则使用它。
6. 如果类型是 Java `Record`，则使用规范构造函数。
7. 如果有一个无参构造函数，则使用它。
其他构造函数将被忽略。

考虑以下  `data`  类 `Person`:

====
[source,kotlin]
----
data class Person(val id: String, val name: String)
----
====

上面的类使用显式构造函数编译为典型类.  我们可以通过添加另一个构造函数来定制该类,并使用 `@PersistenceCreator` 对其进行注解以指示构造函数的首选项:

====
[source,kotlin]
----
data class Person(var id: String, val name: String) {

    @PersistenceCreator
    constructor(id: String) : this(id, "unknown")
}
----
====

Kotlin 通过允许在未提供参数的情况下使用默认值来支持参数的可选性.  当 Spring Data 检测到带有参数默认值的构造函数时,如果数据存储区不提供值 (或简单地返回 `null`) ,则它将使这些参数不存在,因此 Kotlin 可以应用参数默认值.  考虑下面的类,该类将参数默认值用作 `name`

====
[source,kotlin]
----
data class Person(var id: String, val name: String = "unknown")
----
====

每次 `name` 参数不是结果的一部分或值为 `null` 时, name` 默认为  `unknown`.

=== Property population of Kotlin data classes

在 Kotlin 中,所有类默认都是不可变的,并且需要显式的属性声明来定义可变属性.  考虑以下 `data` 类 Person:

====
[source,kotlin]
----
data class Person(val id: String, val name: String)
----
====

该类实际上是不可变的.  当 Kotlin 生成 `copy(…)` 方法时,它可以创建新的实例,该方法创建新的对象实例,该对象实例从现有对象复制所有属性值,并将作为参数提供的属性值应用于该方法.

[[mapping.kotlin.override.properties]]
=== Kotlin 重写属性

Kotlin 允许声明 https://kotlinlang.org/docs/inheritance.html#overriding-properties[property overrides] 以更改子类中的属性。

====
[source,kotlin]
----
open class SuperType(open var field: Int)

class SubType(override var field: Int = 1) :
	SuperType(field) {
}
----
====

这样的显示了两个名为 `field` 的属性。 Kotlin 为每个类中的每个属性生成属性访问器（getter 和 setter）。
实际上，代码如下所示：

====
[source,java]
----
public class SuperType {

   private int field;

   public SuperType(int field) {
      this.field = field;
   }

   public int getField() {
      return this.field;
   }

   public void setField(int field) {
      this.field = field;
   }
}

public final class SubType extends SuperType {

   private int field;

   public SubType(int field) {
      super(field);
      this.field = field;
   }

   public int getField() {
      return this.field;
   }

   public void setField(int field) {
      this.field = field;
   }
}
----
====

`SubType` 上的 getter 和 setter 仅设置 `SubType.field` 而不是 `SuperType.field`。
在这样的安排中，使用构造函数是设置 `SuperType.field` 的唯一默认方法。
通过 `this.SuperType.field = ...` 向 `SubType` 添加方法以设置 `SuperType.field` 是可能的，但不符合支持的约定。
属性覆盖在某种程度上会产生冲突，因为属性共享相同的名称但可能代表两个不同的值。
我们通常建议使用不同的属性名称。

Spring Data 模块通常支持覆盖不同值的属性。
从编程模型的角度来看，有几点需要考虑：

1. 哪个属性应该被持久化（默认为所有声明的属性）？ 您可以通过使用 `@Transient` 注解这些属性来排除这些属性。
2. 如何在数据存储中表示属性？ 对不同的值使用相同的字段/列名称通常会导致数据损坏，因此您应该使用明确的字段/列名称注解至少一个属性。
3. 不能使用 `@AccessType(PROPERTY)`，因为如果不进一步假设 setter 实现，通常无法设置超属性。
