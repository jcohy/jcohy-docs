:spring-framework-docs: https://docs.spring.io/spring/docs/{spring-framework-version}/spring-framework-reference
:spring-framework-javadoc: https://docs.spring.io/spring/docs/{spring-framework-version}/javadoc-api

[[repositories]]
= 使用 Spring Data Repositories

Spring Data 存储库抽象层的目标是减少为各种持久性存储实现数据访问所需的样板代码数量.

[IMPORTANT]
====
_Spring 数据存储库文档和你的模块_

本章介绍 Spring Data 存储库的核心概念和接口. 本章中的信息来自 Spring Data Commons 模块. 它使用 Java 持久性 API (JPA) 模块的配置和代码示例. 您应该将 XML 命名空间声明和要扩展的类型调整为您使用的特定模块的等同项. "`<<repositories.namespace-reference,命名空间参考>>`" 涵盖了所有支持存储库 API 的 Spring Data 模块支持的 XML 配置.
"`<<repository-query-keywords,存储库查询关键字>>`" 一般涵盖了存储库抽象支持的查询方法关键字. 有关模块特定功能的详细信息,请参阅本文档的该模块章节.
====

[[repositories.core-concepts]]
== 核心概念
Spring Data 存储库抽象中的中心接口是 `Repository`. 它需要 domain 类以及 domain 的 ID 类型作为类型参数. 该接口主要作为标记接口来捕获要使用的类型,并帮助您发现该接口的子接口.  `CrudRepository` 实现了实体类复杂的 CRUD 功能.

[[repositories.repository]]
.`CrudRepository` 接口
====
[source,java]
----
public interface CrudRepository<T, ID> extends Repository<T, ID> {

  <S extends T> S save(S entity);      <1>

  Optional<T> findById(ID primaryKey); <2>

  Iterable<T> findAll();               <3>

  long count();                        <4>

  void delete(T entity);               <5>

  boolean existsById(ID primaryKey);   <6>

  // … more functionality omitted.
}
----
<1> 保存给定的实体.
<2> 返回由给定 ID 标识的实体.
<3> 返回所有实体.
<4> 返回实体的数量.
<5> 删除给定的实体.
<6> 判断是否存在具有给定ID的实体.
====

NOTE: 我们还提供持久性技术的特定抽象,如 `JpaRepository` 或 `MongoRepository`. 这些接口扩展 `CrudRepository` 并暴露了持久化技术的基本功能,以及通用的持久化技术,例如 `CrudRepository`.

除此之外 `CrudRepository`,还有一个 https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/PagingAndSortingRepository.html[`PagingAndSortingRepository`] 的抽象的接口,来简化对实体的分页操作:

.`PagingAndSortingRepository` 接口
====
[source,java]
----
public interface PagingAndSortingRepository<T, ID> extends CrudRepository<T, ID> {

  Iterable<T> findAll(Sort sort);

  Page<T> findAll(Pageable pageable);
}
----
====

要访问 `User` 第二页,每页 20,您可以执行以下操作:

====
[source,java]
----
PagingAndSortingRepository<User, Long> repository = // … get access to a bean
Page<User> users = repository.findAll(PageRequest.of(1, 20));
----
====

除了查询方法外,count 和 delete 查询的相关扩展都是可用的. 以下列表扩展 count 查询的接口定义:

.扩展 count 查询
====
[source,java]
----
interface UserRepository extends CrudRepository<User, Long> {

  long countByLastname(String lastname);
}
----
====

以下列表扩展 delete 查询的接口定义:

.扩展删除查询
====
[source,java]
----
interface UserRepository extends CrudRepository<User, Long> {

  long deleteByLastname(String lastname);

  List<User> removeByLastname(String lastname);
}
----
====

[[repositories.query-methods]]
== 查询方法

标准 CRUD 功能通常会在底层数据存储上进行查询. 使用 Spring Data,声明这些查询需要四步:

. 声明一个扩展 `Repository` 或其子接口的接口,并输入它应该处理的 domain 类和 `ID` 类型,如以下示例所示:
+
====
[source,java]
----
interface PersonRepository extends Repository<Person, Long> { … }
----
====

. 在接口上声明查询方法.
+
====
[source,java]
----
interface PersonRepository extends Repository<Person, Long> {
  List<Person> findByLastname(String lastname);
}
----
====

. 使用 Spring  <<repositories.create-instances.java-config,JavaConfig>> 或 <<repositories.create-instances,XML 配置>> 为这些接口创建代理实例.

.. 要使用 Java 配置,请创建类似于以下的类:
+
====
[source,java]
----
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@EnableJpaRepositories
class Config { … }
----
====

.. 要使用XML配置,请定义一个类似于以下的 bean:
+
====
[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:jpa="http://www.springframework.org/schema/data/jpa"
   xsi:schemaLocation="http://www.springframework.org/schema/beans
     https://www.springframework.org/schema/beans/spring-beans.xsd
     http://www.springframework.org/schema/data/jpa
     https://www.springframework.org/schema/data/jpa/spring-jpa.xsd">

   <jpa:repositories base-package="com.acme.repositories"/>

</beans>
----
====
+
这个例子中使用了 JPA 命名空间. 如果您想使用其他的存储库,则需要将其更改为相应的命名空间声明. 换句话说,你应该替换 jpa,例如 `mongodb`.
另请注意,JavaConfig 不会显式配置包,因为默认情况下会使用注解类的包. 定制要扫描的软件包,请使用 `basePackage…` 特定于数据存储库的 `@Enable${store}Repositories` 注解的一个属性.
+
. 注入资源库实例并使用它,如以下示例所示:
+
====
[source,java]
----
class SomeClient {

  private final PersonRepository repository;

  SomeClient(PersonRepository repository) {
    this.repository = repository;
  }

  void doSomething() {
    List<Person> persons = repository.findByLastname("Matthews");
  }
}
----
====

以下部分详细解释每一步:

* <<repositories.definition,定义 Repository  接口>>
* <<repositories.query-methods.details,定义查询方法>>
* <<repositories.create-instances,创建存储库实例>>
* <<repositories.custom-implementations,Spring Data Repository  的自定义实现>>

[[repositories.definition]]
== 定义 Repository  接口

首先,定义一个 domain 类特定的 repository 接口. 该接口必须扩展 `Repository` 并且输入 domain 类和 `ID` 类型. 如果您想暴露该 domain 类型的 CRUD 方法,请扩展 `CrudRepository` 而不是 `Repository`.

[[repositories.definition-tuning]]
=== 微调 Repository  定义

通常情况下,您的 Repository  接口扩展了 `Repository`,`CrudRepository` 或 `PagingAndSortingRepository`. 如果您不想扩展 Spring Data 接口,也可以使用 `@RepositoryDefinition` 注解您的 Repository 接口.
扩展 `CrudRepository` 暴露了一套完整的方法来操纵你的实体. 如果您想选择暴露的方法,请复制 `CrudRepository` 中要暴露的方法 到您的实体类 Repository 中.

NOTE: 这样做可以让您在提供的 Spring Data Repositories 功能之上定义自己的抽象.

以下示例显示如何选择性地暴露 CRUD方法 (`findById` 以及 `save` 在这种情况下) :

.选择性地暴露 CRUD 方法
====
[source,java]
----
@NoRepositoryBean
interface MyBaseRepository<T, ID> extends Repository<T, ID> {

  Optional<T> findById(ID id);

  <S extends T> S save(S entity);
}

interface UserRepository extends MyBaseRepository<User, Long> {
  User findByEmailAddress(EmailAddress emailAddress);
}
----
====

在前面的示例中,您为所有 domain Repository 定义了一个通用的基本接口,并暴露了 `findById(…)` 和  `save(…)` 方法. 这些方法被路由到 Spring Data 提供的所选存储的基本存储库实现中 (例如,如果使用 JPA,则实现为 `SimpleJpaRepository`,因为它们与 `CrudRepository` 中的方法签名匹配.
因此,`UserRepository` 现在可以保存用户,通过ID查找单个用户,并触发查询以通过电子邮件地址查找 `Users`.

NOTE: 中间的 repository 接口用 `@NoRepositoryBean` 注解. 确保添加了该注解的 repository 接口不会在  Spring Data 运行时被创建实例.

[[repositories.multiple-modules]]
=== 将 Repositories  与多个 Spring Data 模块一起使用

在您的应用程序中使用唯一的 Spring Data 模块很简单,因为已定义范围中的所有存储库接口均已绑定到该 Spring Data 模块.  有时,应用程序需要使用多个 Spring Data 模块.  在这种情况下,存储库的定义必须区分要使用哪个.
当它在类路径上检测到多个存储库工厂时,Spring Data 进入严格的存储库配置模式.  严格的配置使用 repository  或 domain 类上的详细信息来决定有关存储库定义的 Spring Data 模块:

1. 如果存储库扩展了<<repositories.multiple-modules.types,特定于指定模块的存储库>>,则它是特定 Spring Data 模块的有效候选者.
2. 如果 domain 类使用模块<<repositories.multiple-modules.annotations,特定的注解类型进行注解>>,则它是特定 Spring Data 模块的有效候选者.  Spring Data 模块可以接受第三方注解 (例如 JPA 的 `@Entity`) ,也可以提供自己的注解 (例如 Spring Data MongoDB 的 `@Document` 和 Spring Data Elasticsearch) .

以下示例显示使用特定于模块的接口 (在这种情况下为 JPA) 的存储库:

[[repositories.multiple-modules.types]]
.使用模块特定接口的存储库定义
====
[source,java]
----
interface MyRepository extends JpaRepository<User, Long> { }

@NoRepositoryBean
interface MyBaseRepository<T, ID> extends JpaRepository<T, ID> { … }

interface UserRepository extends MyBaseRepository<User, Long> { … }
----
`MyRepository` 和 `UserRepository` 继承 `JpaRepository` .  它们是 Spring Data JPA 模块的有效候选者.
====

下面的例子展示了一个使用通用接口的存储库:

.使用通用接口的存储库定义
====
[source,java]
----
interface AmbiguousRepository extends Repository<User, Long> { … }

@NoRepositoryBean
interface MyBaseRepository<T, ID> extends CrudRepository<T, ID> { … }

interface AmbiguousUserRepository extends MyBaseRepository<User, Long> { … }
----
`AmbiguousRepository` 和 `AmbiguousUserRepository` 仅在其类型层次结构中扩展 `Repository` 和 `CrudRepository`.  尽管在使用唯一的 Spring Data 模块时没有什么问题,但是多个模块无法区分这些存储库应绑定到哪个特定的 Spring Data.
====

以下示例显示了使用带注解的 domain  类的存储库:

[[repositories.multiple-modules.annotations]]
.使用带有注解的 domain 类的存储库定义
====
[source,java]
----
interface PersonRepository extends Repository<Person, Long> { … }

@Entity
class Person { … }

interface UserRepository extends Repository<User, Long> { … }

@Document
class User { … }
----
`PersonRepository` 引用使用JPA `@Entity` 注解进行注解的 `Person`,因此该存储库显然属于 Spring Data JPA.  `UserRepository` 引用 `User`,该 User 使用 Spring Data MongoDB 的 `@Document` 注解进行注解.
====

以下错误的示例显示了使用带有混和注解的 domain 类的存储库:

.使用带有混合注解的 domain 类的存储库定义
====
[source,java]
----
interface JpaPersonRepository extends Repository<Person, Long> { … }

interface MongoDBPersonRepository extends Repository<Person, Long> { … }

@Entity
@Document
class Person { … }
----
此示例显示了同时使用 JPA 和 Spring Data MongoDB 注解的 domain 类.  它定义了两个存储库,`JpaPersonRepository` 和 `MongoDBPersonRepository`.
====

<<repositories.multiple-modules.types,存储库类型详细信息>> 和<<repositories.multiple-modules.annotations,可区分的 domain 类注解>> 用于配置严格的存储库,以标识特定 Spring Data 模块的存储库候选者.
在同一个 domain 类型上使用多个特定于持久性技术的注解是可能的,并且可以跨多种持久性技术重用 domain 类型.  但是,Spring Data 无法再确定用于绑定存储库的唯一模块.

区分存储库的最后一种方法是确定存储库 `basePackages` 的范围.  `basePackages` 包定义了扫描存储库接口定义的起点,这意味着将存储库定义放在适当的软件包中.  默认情况下,注解驱动的配置使用配置类的包.
 <<repositories.create-instances.spring,基于 XML 的配置中>>中的 `basePackages` 是必需的.

以下示例显示了基础包的注解驱动配置:

.`basePackages` 的注解驱动配置
====
[source,java]
----
@EnableJpaRepositories(basePackages = "com.acme.repositories.jpa")
@EnableMongoRepositories(basePackages = "com.acme.repositories.mongo")
class Configuration { … }
----
====

[[repositories.query-methods.details]]
== 定义查询方法

存储库代理有两种从方法名称扩展特定查询的方式:

* 通过直接从方法名称扩展查询.
* 通过使用手动定义的查询

可用选项取决于实际存储. 但是,必须有一种策略可以决定要创建的实际查询. 下一节将介绍可用的选项.

[[repositories.query-methods.query-lookup-strategies]]
=== 查询策略

以下策略可用于存储库基础结构来解决查询. 使用 XML 配置,您可以通过 `query-lookup-strategy` 属性在命名空间中配置策略. 对于 Java 配置,可以使用 `Enable${store}Repositories` 注解的 `queryLookupStrategy` 属性. 某些数据存储可能不支持某些策略.


- `CREATE` 尝试从查询方法名称构造特定于存储的查询. 通用方法是从方法名称中删除一组给定的前缀,然后解析该方法的其余部分. 您可以在 "`<<repositories.query-methods.query-creation,查询创建>>`" 中阅读有关查询构造的更多信息.

- `USE_DECLARED_QUERY` 尝试查找已声明的查询,如果找不到则抛出异常. 该查询可以通过某处的注解定义,也可以通过其他方式声明. 请查阅特定存储的文档以找到该存储方式的可用选项. 如果在查询时找不到该方法的声明查询,则它将失败.

- `CREATE_IF_NOT_FOUND` (默认) 结合 `CREATE` 和 `USE_DECLARED_QUERY`. 它首先查找一个声明的查询,如果找不到声明的查询,它将创建一个基于名称的自定义方法查询. 这是默认的查找策略,因此,如果未显式配置任何内容,则使用该策略. 它允许通过方法名称快速定义查询,也可以通过根据需要引入已声明的查询来自定义调整这些查询.

[[repositories.query-methods.query-creation]]
=== 查询创建

Spring Data 内置的查询机制对于在存储库实体上构建查询约束很有用. 该机制的前缀  `find…By`, `read…By`, `query…By`, `count…By`, 和 `get…By` 从所述方法和开始解析它的其余部分. `Introduction` 子句可以包含其他表达式,
例如,`Distinct` 以在要创建的查询上设置不同的标志. 但是,第一个 `By` 充当分隔符以指示实际查询的开始. 在此级别上,您可以定义实体属性的条件,并将其与 `And` 和 `Or` 串联 . 下面的示例演示如何创建许多查询:

.从方法名查询创建
====
[source,java]
----
interface PersonRepository extends Repository<Person, Long> {

  List<Person> findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);

  // Enables the distinct flag for the query
  List<Person> findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
  List<Person> findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);

  // Enabling ignoring case for an individual property
  List<Person> findByLastnameIgnoreCase(String lastname);
  // Enabling ignoring case for all suitable properties
  List<Person> findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);

  // Enabling static ORDER BY for a query
  List<Person> findByLastnameOrderByFirstnameAsc(String lastname);
  List<Person> findByLastnameOrderByFirstnameDesc(String lastname);
}
----
====

解析查询方法的名称分为主题和断言.第一部分  (`find…By`, `exists…By`)  定义查询的主题,第二部分形成断言.
Introduction子句 (主题) 可以包含其他表达式. 任何在 `find` (或其他 introducing 关键字) 和 `By` 之间的任何文本都被视为描述性语句,除非使用结果限制关键字之一 (例如,`Distinct` ) 在要创建的查询上设置 distinct 的标记,或者 <<repositories.limit-query-result,`Top`/`First`  以限制查询结果>>.

附录包含 <<appendix.query.method.subject,查询方法主题关键字的完整列表>> 和 <<appendix.query.method.predicate,包括排序和字母大小写修饰符的查询方法断言关键字>>.
但是,第一个 `By` 充当分隔符,以指示实际标准断言的开始. 在此基础上,您可以定义实体属性的条件,并将其与 `And` 和 `Or` 连接起来.

解析该方法的实际结果取决于您为其创建查询的持久性存储. 但是,需要注意一些一般事项:

- 表达式通常是属性遍历,并带有可串联的运算符.  您可以将属性表达式与 `AND` 和 `OR` 结合使用.  您还将获得属性表达式的支持,例如 `between`,`LessThan`,`GreaterThan` 和 `Like`.  支持的运算符可能因数据存储而异,因此请参考参考文档的相应部分.

- 方法解析器支持为单个属性 (例如,`findByLastnameIgnoreCase(…)`) 或支持忽略大小写的类型的所有属性 (通常为 `String` 实例,例如, `findByLastnameAndFirstnameAllIgnoreCase(…)`) 设置 `IgnoreCase` 标志.  是否支持忽略大小写可能因存储而异,因此请参考参考文档中有关存储特定查询方法的相关部分.

- 您可以通过将 `OrderBy` 子句附加到引用属性的查询方法并提供排序方向 (`Asc` 或 `Desc`) 来应用静态排序.  要创建支持动态排序的查询方法,请参见 "`<<repositories.special-parameters,特殊参数处理>>`".

[[repositories.query-methods.query-property-expressions]]
=== 属性表达式

如上例所示,属性表达式只能引用实体的直接属性.  在查询创建时,您需要确保已解析的属性是被管理 domain 类的属性.  但是,您也可以通过遍历嵌套属性来定义约束.  考虑以下方法签名:

====
[source,java]
----
List<Person> findByAddressZipCode(ZipCode zipCode);
----
====

假设一个 `Person` (人) 的 `Address` (地址) 带有 `ZipCode` (邮政编码).  在这种情况下,该方法将创建遍历属性 `x.address.zipCode`.  解析算法首先将整个部分 (`AddressZipCode`) 解释为属性,然后在 domain 类中检查具有该名称的属性 (未大写) .
如果算法成功,它将使用该属性.  如果不是,该算法将按驼峰解析为头和尾,并尝试找到对应的属性,在我们的示例中为 `AddressZip` 和 `Code`.  如果该算法找到了具有该头部的属性,则它将采用该头部,并继续从那里开始构建,以刚才描述的方式将尾部向上拆分.  如果第一个拆分不匹配,则算法会将拆分点移到左侧 (`Address`, `ZipCode`) 并继续.

尽管这在大多数情况下应该可行,但是算法可能会选择错误的属性.  假设 `Person` 类也具有 `addressZip` 属性.  该算法将在第一轮拆分中匹配,选择错误的属性,然后失败 (因为 `addressZip` 的类型可能没有 `code` 属性) .

要解决这种歧义,您可以在方法名称中使用 `_` 手动定义遍历点.  因此,我们的方法名称如下:

====
[source,java]
----
List<Person> findByAddress_ZipCode(ZipCode zipCode);
----
====

因为我们将下划线字符视为保留字符,所以我们强烈建议您遵循以下标准 Java 命名约定 (即,在属性名称中不使用下划线,而使用驼峰大小写) .

[[repositories.special-parameters]]
=== 特殊参数处理

要处理查询中的参数,请定义方法参数,如前面的示例所示.  除此之外,基本架构还可以识别某些特定类型,例如 `Pageable` 和 `Sort`,以将分页和排序动态应用于您的查询.  以下示例演示了这些功能:

.在查询方法中使用 `Pageable`, `Slice`, 和 `Sort`
====
[source,java]
----
Page<User> findByLastname(String lastname, Pageable pageable);

Slice<User> findByLastname(String lastname, Pageable pageable);

List<User> findByLastname(String lastname, Sort sort);

List<User> findByLastname(String lastname, Pageable pageable);
----
====

IMPORTANT: 采用 `Sort` 和 `Pageable` 的 API 期望将非 `null` 值传递到方法中.  如果您不想应用任何排序或分页,请使用 `Sort.unsorted()` 和 `Pageable.unpaged()`.

第一种方法使您可以将 `org.springframework.data.domain.Pageable` 实例传递给查询方法,以将分页动态添加到静态定义的查询中.  页面知道可用元素和页面的总数.  它是通过基础结构触发计数查询来计算总数来实现的.
由于这可能很耗时 (取决于所使用的存储) ,因此您可以返回一个 `Slice`.  切片仅知道下一个切片是否可用,当遍历较大的结果集时这可能就足够了.

排序选项也通过 `Pageable` 实例处理.  如果只需要排序,则将 `org.springframework.data.domain.Sort` 参数添加到您的方法中.  如您所见,返回列表也是可能的.  在这种情况下,将不会创建构建实际的 `Page` 实例所需的其他元数据 (这反过来意味着不会发出本来必要的其他计数查询) .  而是,它将查询限制为仅查找给定范围的实体.

NOTE: 要找出整个查询可获得多少页,您必须触发其他计数查询.  默认情况下,此查询扩展自您实际触发的查询.

[[repositories.paging-and-sorting]]
==== Paging 和 Sorting

可以使用属性名称定义简单的排序表达式.  可以将表达式连接起来,以将多个条件收集到一个表达式中.

.定义排序表达式
====
[source,java]
----
Sort sort = Sort.by("firstname").ascending()
  .and(Sort.by("lastname").descending());
----
====

对于排序表达式的类型安全性更高的方法,请从该类型开始为定义排序表达式,然后使用方法引用来定义要进行排序的属性.

.使用类型安全的 API 定义排序表达式
====
[source,java]
----
TypedSort<Person> person = Sort.sort(Person.class);

TypedSort<Person> sort = person.by(Person::getFirstname).ascending() 
  .and(person.by(Person::getLastname).descending());
----
====

NOTE: `TypedSort.by(…)` 通过 (通常) 使用 CGlib 来使用运行时代理,这在使用 Graal VM Native 等工具时可能会影响本地镜像的编译.

如果您的存储实现支持 Querydsl,则还可以使用生成的元模型类型来定义排序表达式:

.使用 Querydsl API 定义排序表达式
====
[source,java]
----
QSort sort = QSort.by(QPerson.firstname.asc())
  .and(QSort.by(QPerson.lastname.desc()));
----
====

[[repositories.limit-query-result]]
=== 限制查询结果

可以通过使用 `first` 或 `top` 关键字来限制查询方法的结果,这些关键字可以互换使用.  可以在 `top` 或 `first`  附加可选的数值,以指定要返回的最大结果大小.  如果省略数字,则假定结果大小为 `1`.  以下示例显示了如何限制查询大小:

.使用 `first` 和 `top` 限制查询的结果大小
====
[source,java]
----
User findFirstByOrderByLastnameAsc();

User findTopByOrderByAgeDesc();

Page<User> queryFirst10ByLastname(String lastname, Pageable pageable);

Slice<User> findTop3ByLastname(String lastname, Pageable pageable);

List<User> findFirst10ByLastname(String lastname, Sort sort);

List<User> findTop10ByLastname(String lastname, Pageable pageable);
----
====

限制表达式还支持 `Distinct` 关键字.  另外,对于将结果集限制为一个实例的查询,支持使用 `Optional` 关键字将结果包装到其中.

如果将分页或切片应用于限制查询分页 (以及对可用页面数的计算) ,则会在限制结果内应用分页或切片.

NOTE: 通过使用 `Sort` 参数将结果限制与动态排序结合使用,可以让您表达对最小的 "K" 元素和对 "K" 的最大元素的查询方法.

[[repositories.collections-and-iterables]]
=== 存储库方法返回集合或可迭代对象

返回多个结果的查询方法可以使用标准的 Java `Iterable`,`List`,`Set`.  除此之外,我们还支持返回 Spring Data 的 `Streamable`,`Iterable` 的自定义扩展以及  https://www.vavr.io/[Vavr] 提供的集合类型.请参阅附录,了解所有可能的 <<appendix.query.return.types,查询方法返回类型>>.

[[repositories.collections-and-iterables.streamable]]
==== 使用 Streamable 作为查询方法返回类型
`Streamable` 可用作 `Iterable` 或任何集合类型的替代.  它提供了方便的方法来访问非并行流 (缺少 `Iterable`) ,可以直接在元素上进行  `….filter(…)` 和  `….map(…)` 并将 `Streamable` 连接到其他元素:

.使用 Streamable 合并查询方法结果
====
[source,java]
----
interface PersonRepository extends Repository<Person, Long> {
  Streamable<Person> findByFirstnameContaining(String firstname);
  Streamable<Person> findByLastnameContaining(String lastname);
}

Streamable<Person> result = repository.findByFirstnameContaining("av")
  .and(repository.findByLastnameContaining("ea"));
----
====

[[repositories.collections-and-iterables.streamable-wrapper]]
==== 返回自定义 Streamable 包装器类型

为集合提供专用的包装器类型是一种常用的模式,用于在返回多个元素的查询执行结果上提供 API.  通常,这些类型是通过调用存储库方法来返回类似集合的类型并手动创建包装类型的实例来使用的.  如果 Spring Data 满足以下条件,则可以将这些包装器类型用作查询方法返回类型,因此可以避免执行附加步骤:

. 该类型实现 `Streamable`.
. 该类型以  `Streamable` 作为参数暴露构造函数或名为 `of(…)` 或 `valueOf(…)` 的静态工厂方法.

示例用例如下所示:

====
[source,java]
----
class Product {                                         <1>
  MonetaryAmount getPrice() { … }
}

@RequiredArgConstructor(staticName = "of")
class Products implements Streamable<Product> {         <2>

  private Streamable<Product> streamable;

  public MonetaryAmount getTotal() {                    <3>
    return streamable.stream()
      .map(Priced::getPrice)
      .reduce(Money.of(0), MonetaryAmount::add);
  }


  @Override
  public Iterator<Product> iterator() {                 <4>
    return streamable.iterator();
  }
}

interface ProductRepository implements Repository<Product, Long> {
  Products findAllByDescriptionContaining(String text); <5>
}
----
<1> 暴露 API 以访问产品价格的 `Product` 实体.
<2> 可以通过 `Products.of(…)`  (通过 Lombok 注解创建的工厂方法) 构造的 `Streamable<Product>`  的包装器类型.
<3> 包装器类型在 `Streamable<Product>` 上暴露其他用于计算新值的 API.
<4> 实现 `Streamable` 接口并且委托给实际结果.
<5> 该包装器类型 `Products` 可以直接用作查询方法返回类型.  无需返回  `Stremable<Product>`  并在查询之后将其手动包装在存储库客户端中.
====

[[repositories.collections-and-iterables.vavr]]
==== 支持 Vavr 集合

https://www.vavr.io/[Vavr] 是一个包含 Java 中函数式编程概念的库. 它附带一组可作为查询方法返回类型使用的自定义集合类型.

[options=header]
|====
|Vavr 集合类型 |使用 Vavr 实现类型 |验证 Java source 类型
|`io.vavr.collection.Seq`|`io.vavr.collection.List`|`java.util.Iterable`
|`io.vavr.collection.Set`|`io.vavr.collection.LinkedHashSet`|`java.util.Iterable`
|`io.vavr.collection.Map`|`io.vavr.collection.LinkedHashMap`|`java.util.Map`
|====

第一列中的类型 (或其子类型) 可以用作查询方法返回类型,并将根据实际查询结果的 Java 类型 (第三列) 获取第二列中的类型作为实现类型.  或者,可以声明 `Traversable` (等效于 Vavr `Iterable`) ,然后从实际返回值扩展实现类,即 `java.util.List` 将变成 Vavr  `List`/`Seq`,而 `java.util.Set` 变为Vavr `LinkedHashSet`/`Set` 等

[[repositories.nullability]]
=== 存储库方法的空处理

从 Spring Data 2.0 开始,返回单个聚合实例的存储库 CRUD 方法使用 Java 8 的 `Optional` 来指示可能缺少值.  除此之外,Spring Data 支持在查询方法上返回以下包装器类型:

* `com.google.common.base.Optional`
* `scala.Option`
* `io.vavr.control.Option`

另外,查询方法可以选择不使用包装器类型.  然后,通过返回 `null` 指示查询结果不存在.  保证返回集合,集合替代项,包装器和流的存储库方法永远不会返回 `null`,而是会返回相应的空表示形式.
有关详细信息,请参见 "`<<repository-query-return-types,存储库查询返回类型>>`" .

[[repositories.nullability.annotations]]
==== 可空性注解

您可以使用 {spring-framework-docs}/core.html#null-safety[Spring Framework 的可空性注解] 来表达存储库方法的可空性约束.  它们提供了一种工具友好的方法,并在运行时提供了选择加入的 `null` 检查,如下所示:


* {spring-framework-javadoc}/org/springframework/lang/NonNullApi.html[`@NonNullApi`]: 在包级别用于声明参数和返回值的默认行为是不为空值.
* {spring-framework-javadoc}/org/springframework/lang/NonNull.html[`@NonNull`]:用于不为空的参数或返回值 (`@NonNullApi` 适用的参数和返回值不需要) .
* {spring-framework-javadoc}/org/springframework/lang/Nullable.html[`@Nullable`]: 用于可以为空的参数或返回值.

Spring 注解使用 https://jcp.org/en/jsr/detail?id=305[JSR 305] 注解进行元注解.  JSR 305 元注解使工具供应商 (如  https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html[IDEA],
https://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.jdt.doc.user/tasks/task-using_external_null_annotations.htm[Eclipse] 和 https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types[Kotlin] ) 以通用方式提供了空安全支持,而不必对 Spring 注解进行硬编码支持.
要对查询方法的可空性约束进行运行时检查,您需要使用 `package-info.java` 中的 Spring 的 `@NonNullApi` 在包级别激活非可空性,如以下示例所示:

.在 `package-info.java` 中声明不可为空
====
[source,java]
----
@org.springframework.lang.NonNullApi
package com.acme;
----
====

一旦设置了非 `null` 默认值,就可以在运行时验证存储库查询方法的调用是否具有可空性约束.  如果查询执行结果违反了定义的约束,则会引发异常.  当方法将返回 `null` 但被声明为不可为 `null` 时 (在存储库所在的包中定义了注解的默认值) ,就会发生这种情况.  如果要再次选择接受可为空的结果,请在各个方法上有选择地使用 `@Nullable`.
使用本节开头提到的结果包装器类型可以按预期继续工作: 将空结果转换为表示缺少的值.

下面的示例显示了刚才描述的许多技术:

.使用不同的可空性约束
====
[source,java]
----
package com.acme;                                                       <1>

import org.springframework.lang.Nullable;

interface UserRepository extends Repository<User, Long> {

  User getByEmailAddress(EmailAddress emailAddress);                    <2>

  @Nullable
  User findByEmailAddress(@Nullable EmailAddress emailAdress);          <3>

  Optional<User> findOptionalByEmailAddress(EmailAddress emailAddress); <4>
}
----
<1> 存储库位于我们上面定义的非空的包 (或子包) 中.
<2> 当执行的查询未产生结果时,抛出 `EmptyResultDataAccessException`.  当传递给该方法的 `emailAddress` 为 `null` 时,抛出 `IllegalArgumentException`.
<3> 当执行的查询不产生结果时,返回 `null`.  还接受 `null` 作为 `emailAddress` 的值.
<4> 当执行的查询不产生结果时,返回 `Optional.empty()`.  当传递给该方法的 `emailAddress` 为 `null` 时,抛出 `IllegalArgumentException`.
====

[[repositories.nullability.kotlin]]
==== 基于 Kotlin 的存储库中的可空性

Kotlin 定义了语言中包含的 https://kotlinlang.org/docs/reference/null-safety.html[可空性约束] .  Kotlin 代码编译为字节码,字节码不通过方法签名来表达可空性约束,而是通过内置的元数据来表达.  请确保在您的项目中包含 `kotlin-reflect` 的JAR,以对 Kotlin 的可空性约束进行自省.  Spring Data 存储库使用语言机制来定义这些约束以应用相同的运行时检查,如下所示:

.在 Kotlin repository 上使用可空性约束
====
[source, kotlin]
----
interface UserRepository : Repository<User, String> {

  fun findByUsername(username: String): User     <1>

  fun findByFirstname(firstname: String?): User? <2>
}
----
<1> 该方法将参数和结果都定义为不可为空 (Kotlin 默认值) .  Kotlin 编译器拒绝将 `null` 传递给方法的方法调用.  如果查询执行产生空结果,则抛出 `EmptyResultDataAccessException`.
<2> 此方法的 `firstname` 参数接受 `null`,如果查询执行未产生结果,则返回 `null`.
====

[[repositories.query-streaming]]
=== 流查询结果

可以使用 Java 8 `Stream<T>` 作为返回类型来递增地处理查询方法的结果.  并非将查询结果包装在 `Stream` 中,而是使用特定于数据存储的方法来执行流传输,如以下示例所示:

.用 Java 8  `Stream<T>` 流查询的结果
====
[source,java]
----
@Query("select u from User u")
Stream<User> findAllByCustomQueryAndStream();

Stream<User> readAllByFirstnameNotNull();

@Query("select u from User u")
Stream<User> streamAllPaged(Pageable pageable);
----
====
NOTE: `Stream` 可能包装了特定于底层数据存储的资源,因此必须在使用后关闭.  您可以使用 `close()` 方法或使用 Java 7 `try-with-resources` 块来手动关闭 `Stream`,如以下示例所示:

.`Stream<T>` 的结果使用 try-with-resources 块
====
[source,java]
----
try (Stream<User> stream = repository.findAllByCustomQueryAndStream()) {
  stream.forEach(…);
}
----
====
NOTE: 当前,并非所有的 Spring Data 模块都支持 `Stream<T>` 作为返回类型.

[[repositories.query-async]]
=== 异步查询结果

使用  {spring-framework-docs}/integration.html#scheduling[Spring 的异步方法执行功能],可以异步运行存储库查询.  这意味着该方法在调用时立即返回,而实际查询执行发生在已提交给 Spring `TaskExecutor` 的任务中.  异步查询执行与响应式查询执行不同,因此不应混为一谈.  有关响应式支持的更多详细信息,请参阅存储特定的文档.  以下示例显示了许多异步查询:

====
[source,java]
----
@Async
Future<User> findByFirstname(String firstname);               <1>

@Async
CompletableFuture<User> findOneByFirstname(String firstname); <2>

@Async
ListenableFuture<User> findOneByLastname(String lastname);    <3>
----
<1> 使用 `java.util.concurrent.Future` 作为返回类型.
<2> 使用 Java 8 `java.util.concurrent.CompletableFuture` 作为返回类型.
<3> 使用 `org.springframework.util.concurrent.ListenableFuture` 作为返回类型.
====

[[repositories.create-instances]]
== 创建存储库实例
在本部分中,将为已定义的存储库接口创建实例和 Bean 定义.  一种方法是使用支持存储库机制的每个 Spring Data 模块随附的 Spring 命名空间,尽管我们通常建议使用 Java 配置.

[[repositories.create-instances.spring]]
=== XML 配置
每个 Spring Data 模块都包含一个 `repositories` 元素,可用于定义 Spring 为其扫描的基本包,如以下示例所示:

.通过 XML 启用 Spring Data repository
====
[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns:beans="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="http://www.springframework.org/schema/data/jpa"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/jpa
    https://www.springframework.org/schema/data/jpa/spring-jpa.xsd">

  <repositories base-package="com.acme.repositories" />

</beans:beans>
----
====

在前面的示例中,指示 Spring 扫描 `com.acme.repositories` 及其所有子包,以查找扩展 `Repository` 的接口或其子接口之一.  对于找到的每个接口,基础结构都会注册持久性技术特定的 `FactoryBean`,以创建处理查询方法调用的适当代理.
每个 bean 都使用从接口名称扩展的 bean 名称进行注册,因此 `UserRepository` 的接口将注册在 `userRepository` 下.  `base-package` 属性允许使用通配符,以便您可以定义扫描程序包的模式.

[[repositories.using-filters]]
==== 使用过滤器

默认情况下,Spring Data 会自动扫描配置路径下的 `Repository` 子接口的每个接口,并为其创建一个 bean 实例.  但是,您可能希望更精细地控制哪些接口具有为其创建的 Bean 实例.
为此,请在 `<repositories />` 元素内使用 `<include-filter />` 和 `<exclude-filter />` 元素.  语义完全等同于 Spring 的上下文命名空间中的元素.  有关详细信息,请参见这些元素的 {spring-framework-docs}/core.html#beans-scanning-filters[Spring 参考文档] .

例如,要将某些接口从实例中排除为存储库 Bean,可以使用以下配置:

.使用 exclude-filter 元素
====
[source, xml]
----
<repositories base-package="com.acme.repositories">
  <context:exclude-filter type="regex" expression=".*SomeRepository" />
</repositories>
----
====

前面的示例将所有以 `SomeRepository` 结尾的接口都排除在实例化之外.

[[repositories.create-instances.java-config]]
=== Java 配置
还可以在 JavaConfig 类上使用特定于存储的 `@Enable${store}Repositories`  注解来触发存储库基础架构.  有关 Spring 容器的基于 Java 的配置的介绍,请参见 {spring-framework-docs}/core.html#beans-java[Spring 参考文档中的 JavaConfig].

.基于注解的存储卡示例
====
[source,java]
----
@Configuration
@EnableJpaRepositories("com.acme.repositories")
class ApplicationConfiguration {

  @Bean
  EntityManagerFactory entityManagerFactory() {
    // …
  }
}
----
====

NOTE: 前面的示例使用特定于 JPA 的注解,您将根据实际使用的存储模块对其进行更改.  这同样适用于 `EntityManagerFactory` bean 的定义.  请参阅涵盖存储特定配置的部分.

[[repositories.create-instances.standalone]]
=== 独立使用
您还可以在 Spring 容器之外使用存储库基础结构,例如在 CDI 环境中.  您的类路径中仍然需要一些 Spring 库,但是,通常,您也可以通过编程方式来设置存储库.  提供存储库支持的 Spring Data 模块附带了特定于持久性技术的 `RepositoryFactory`,您可以按以下方式使用它:

.repository 工厂的独立使用
====
[source,java]
----
RepositoryFactorySupport factory = … // Instantiate factory here
UserRepository repository = factory.getRepository(UserRepository.class);
----
====

[[repositories.custom-implementations]]
== Spring Data 存储库的自定义实现
本节介绍存储库定制以及片段如何形成复合存储库.

当查询方法需要不同的行为或无法通过查询扩展实现时,则有必要提供自定义实现.  Spring Data 存储库使您可以提供自定义存储库代码,并将其与通用 CRUD 抽象和查询方法功能集成.

[[repositories.single-repository-behavior]]
=== 自定义单个存储库
要使用自定义功能丰富存储库,必须首先定义一个接口和自定义功能的实现,如以下示例所示:

.定制 repository 功能的接口
====
[source,java]
----
interface CustomizedUserRepository {
  void someCustomMethod(User user);
}
----
====

.自定义存储库功能的实现
====
[source,java]
----
class CustomizedUserRepositoryImpl implements CustomizedUserRepository {

  public void someCustomMethod(User user) {
    // Your custom implementation
  }
}
----
====

NOTE: 与这个接口相对应的类名称中最重要的部分是 `Impl` 后缀.

实现本身不依赖于 Spring Data,可以是常规的 Spring bean.  因此,您可以使用标准的依赖注入行为来注入对其他 bean (例如 `JdbcTemplate`) 的引用,参与各个方面,等等.

然后,可以让您的存储库接口扩展此接口,如以下示例所示:

.更改您的存储库接口
====
[source,java]
----
interface UserRepository extends CrudRepository<User, Long>, CustomizedUserRepository {

  // Declare query methods here
}
----
====

用存储库接口扩展此接口,将 CRUD 和自定义功能结合在一起,并使它可用于客户端.

Spring Data 存储库是通过使用构成存储库组成的片段来实现的.  片段是基础存储库,功能方面 (例如 <<core.extensions.querydsl,QueryDsl>>) 以及自定义接口及其实现.  每次向存储库接口添加接口时,都通过添加片段来增强组合.  每个 Spring Data 模块都提供了基础存储库和存储库方面的实现.

以下示例显示了自定义接口及其实现:

.片段及其实现
====
[source,java]
----
interface HumanRepository {
  void someHumanMethod(User user);
}

class HumanRepositoryImpl implements HumanRepository {

  public void someHumanMethod(User user) {
    // Your custom implementation
  }
}

interface ContactRepository {

  void someContactMethod(User user);

  User anotherContactMethod(User user);
}

class ContactRepositoryImpl implements ContactRepository {

  public void someContactMethod(User user) {
    // Your custom implementation
  }

  public User anotherContactMethod(User user) {
    // Your custom implementation
  }
}
----
====

以下示例显示了扩展 `CrudRepository` 的自定义存储库的接口:

.更改您的存储库接口
====
[source,java]
----
interface UserRepository extends CrudRepository<User, Long>, HumanRepository, ContactRepository {

  // Declare query methods here
}
----
====

存储库可能由多个自定义实现组成,这些自定义实现按其声明顺序导入.  自定义实现比基础实现和存储库方面的优先级更高.  通过此顺序,您可以覆盖基础存储库和方面方法,并在两个片段贡献相同方法签名的情况下解决歧义.
存储库片段不限于在单个存储库界面中使用.  多个存储库可以使用片段接口,使您可以跨不同的存储库重用自定义项.

以下示例显示了存储库片段及其实现:

.覆盖 Fragments `save(…)`
====
[source,java]
----
interface CustomizedSave<T> {
  <S extends T> S save(S entity);
}

class CustomizedSaveImpl<T> implements CustomizedSave<T> {

  public <S extends T> S save(S entity) {
    // Your custom implementation
  }
}
----
====

以下示例显示了使用上述存储库片段的存储库:

.定制的存储库接口
====
[source,java]
----
interface UserRepository extends CrudRepository<User, Long>, CustomizedSave<User> {
}

interface PersonRepository extends CrudRepository<Person, Long>, CustomizedSave<Person> {
}
----
====

[[repositories.configuration]]
==== 配置
如果使用命名空间配置,则存储库基础结构会尝试通过扫描发现存储库的包下方的类来自动检测自定义实现片段.  这些类需要遵循将命名空间元素的 `repository-impl-postfix` 属性附加到片段接口名称的命名约定.  此后缀默认为 `Impl`.  以下示例显示了使用默认后缀的存储库和为后缀设置自定义值的存储库:

.配置示例
====
[source, xml]
----
<repositories base-package="com.acme.repository" />

<repositories base-package="com.acme.repository" repository-impl-postfix="MyPostfix" />
----
====

上一示例中的第一个配置尝试查找一个名为 `com.acme.repository.CustomizedUserRepositoryImpl` 的类,以用作自定义存储库实现.  第二个示例尝试查找 `com.acme.repository.CustomizedUserRepositoryMyPostfix`.

[[repositories.single-repository-behaviour.ambiguity]]
===== 解决歧义

如果在不同的包中找到具有匹配类名的多个实现,Spring Data 将使用 Bean 名称来标识要使用的那个.

给定前面显示的 `CustomizedUserRepository` 的以下两个自定义实现,将使用第一个实现.  它的 bean 名称是 `customizedUserRepositoryImpl`,它与片段接口 (`CustomizedUserRepository`) 加上后缀 `Impl` 的名称匹配.

.解决歧义的实现
====
[source,java]
----
package com.acme.impl.one;

class CustomizedUserRepositoryImpl implements CustomizedUserRepository {

  // Your custom implementation
}
----
[source,java]
----
package com.acme.impl.two;

@Component("specialCustomImpl")
class CustomizedUserRepositoryImpl implements CustomizedUserRepository {

  // Your custom implementation
}
----
====

如果使用 `@Component("specialCustom")` 注解 `UserRepository` 接口,则 Bean 名称加 `Impl` 会与 `com.acme.impl.two` 中为存储库实现匹配定义一个,并使用它代替第一个.

[[repositories.manual-wiring]]
===== 手动织入

如果您的自定义实现仅使用基于注解的配置和自动装配,则 <<repositories.single-repository-behaviour.ambiguity,上述>>显示的方法会很好地起作用,因为它被视为其他任何 Spring Bean.
如果实现片段 bean 需要特殊的拼接,则可以声明 bean 并根据上一节中描述的约定对其进行命名.  然后,基础结构通过名称引用手动定义的 bean 定义,而不是自己创建一个.  以下示例显示如何手动连接自定义实现:


.手动织入自定义实现
====
[source, xml]
----
<repositories base-package="com.acme.repository" />

<beans:bean id="userRepositoryImpl" class="…">
  <!-- further configuration -->
</beans:bean>
----
====

[[repositories.customize-base-repository]]
=== 自定义基础存储库

当您要自定义基本存储库行为时,<<repositories.manual-wiring,上一节>>  中描述的方法需要自定义每个存储库接口,以使所有存储库均受到影响.  要改为更改所有存储库的行为,您可以创建一个实现,以扩展特定于持久性技术的存储库基类.
然后,该类充当存储库代理的自定义基类,如以下示例所示:

.定制存储库基类
====
[source,java]
----
class MyRepositoryImpl<T, ID>
  extends SimpleJpaRepository<T, ID> {

  private final EntityManager entityManager;

  MyRepositoryImpl(JpaEntityInformation entityInformation,
                          EntityManager entityManager) {
    super(entityInformation, entityManager);

    // Keep the EntityManager around to used from the newly introduced methods.
    this.entityManager = entityManager;
  }

  @Transactional
  public <S extends T> S save(S entity) {
    // implementation goes here
  }
}
----
====

CAUTION: 该类需要具有特定于存储库的存储库工厂实现使用的父类的构造函数.  如果存储库父类具有多个构造函数,则覆盖一个采用 `EntityInformation` 加上存储特定基础结构对象 (例如 `EntityManager` 或模板类) 的构造函数.

最后一步是使 Spring Data 基础结构了解定制的存储库基类.  在 Java 配置中,可以通过使用 `@Enable${store}Repositories` 注解的 `repositoryBaseClass` 属性来实现,如以下示例所示:

.使用 JavaConfig 配置自定义存储库基类
====
[source,java]
----
@Configuration
@EnableJpaRepositories(repositoryBaseClass = MyRepositoryImpl.class)
class ApplicationConfiguration { … }
----
====

XML 命名空间中有相应的属性,如下例所示:

.使用 XML 配置自定义存储库基类
====
[source, xml]
----
<repositories base-package="com.acme.repository"
     base-class="….MyRepositoryImpl" />
----
====

[[core.domain-events]]
== 从聚合根发布事件

由存储库管理的实体是聚合根.  在领域驱动设计应用程序中,这些聚合根通常发布领域事件.  Spring Data 提供了一个称为 `@DomainEvents` 的注解,您可以在聚合根的方法上使用该注解,可以使发布事件变得简单,如以下示例所示:

.从聚合根暴露领域事件
====
[source,java]
----
class AnAggregateRoot {

    @DomainEvents <1>
    Collection<Object> domainEvents() {
        // … return events you want to get published here
    }

    @AfterDomainEventPublication <2>
    void callbackMethod() {
       // … potentially clean up domain events list
    }
}
----
<1> 使用 `@DomainEvents` 的方法可以返回单个事件实例或事件的集合.  它不能接受任何参数.
<2> 在发布所有事件之后,我们有一个用 `@AfterDomainEventPublication` 注解的方法.  它可以用来潜在地清除要发布的事件列表 (以及其他用途) .
====

每次调用 Spring Data Repository `save(...)`, `saveAll(…)`, `delete(…)` or `deleteAll(…)`  方法之一时,将调用这些方法.

[[core.extensions]]
== Spring Data 扩展

本节记录了一组 Spring Data 扩展,这些扩展可在各种上下文中启用 Spring Data 使用.  当前,大多数集成都针对 Spring MVC.

[[core.extensions.querydsl]]
=== Querydsl 扩展

http://www.querydsl.com/[Querydsl] 是一个框架,可通过其流式的 API 来构造静态类型的类似 SQL 的查询.

几个 Spring Data 模块通过 `QuerydslPredicateExecutor` 与 `Querydsl` 集成,如以下示例所示:

.QuerydslPredicateExecutor 接口
====
[source,java]
----
public interface QuerydslPredicateExecutor<T> {

  Optional<T> findById(Predicate predicate);  <1>

  Iterable<T> findAll(Predicate predicate);   <2>

  long count(Predicate predicate);            <3>

  boolean exists(Predicate predicate);        <4>

  // … more functionality omitted.
}
----
<1> 查找并返回与 `Predicate` 匹配的单个实体.
<2> 查找并返回与 `Predicate` 匹配的所有实体.
<3> 返回与 `Predicate` 匹配的实体数.
<4> 返回与 `Predicate` 匹配的实体是否存在.
====

要使用 Querydsl 支持,请在存储库界面上扩展 `QuerydslPredicateExecutor`,如以下示例所示

.repository 上的 Querydsl 集成
====
[source,java]
----
interface UserRepository extends CrudRepository<User, Long>, QuerydslPredicateExecutor<User> {
}
----
====

前面的示例使您可以使用 Querydsl  `Predicate`  实例编写类型安全查询,如以下示例所示:

[source,java]
----
Predicate predicate = user.firstname.equalsIgnoreCase("dave")
	.and(user.lastname.startsWithIgnoreCase("mathews"));

userRepository.findAll(predicate);
----

[[core.web]]
=== Web 支持

支持存储库编程模型的 Spring Data 模块附带了各种 Web 支持.  与 Web 相关的组件要求 Spring MVC JAR 位于类路径上.  其中一些甚至提供与 https://github.com/SpringSource/spring-hateoas[Spring HATEOAS] 的集成.
通常,通过在 JavaConfig 配置类中使用 `@EnableSpringDataWebSupport` 注解来启用集成支持,如以下示例所示:

.启用 Spring Data web 支持
====
[source,java]
----
@Configuration
@EnableWebMvc
@EnableSpringDataWebSupport
class WebConfiguration {}
----
====

`@EnableSpringDataWebSupport` 注解注册了一些我们稍后将讨论的组件.  它还将在类路径上检测 Spring HATEOAS,并为其注册集成组件 (如果存在) .

另外,如果您使用 XML 配置,则将 `SpringDataWebConfiguration` 或 `HateoasAwareSpringDataWebConfiguration` 注册为 Spring Bean,如以下示例所示 (对于 `SpringDataWebConfiguration`) :

.在 XML中启用 Spring Data web 支持
====
[source, xml]
----
<bean class="org.springframework.data.web.config.SpringDataWebConfiguration" />

<!-- If you use Spring HATEOAS, register this one *instead* of the former -->
<bean class="org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration" />
----
====

[[core.web.basic]]
==== Basic Web 支持

<<core.web,上一节>> 中显示的配置注册了一些基本组件:

- <<core.web.basic.domain-class-converter,DomainClassConverter>> 可让 Spring MVC 从请求参数或路径变量解析存储库管理的 domain 类的实例.
- <<core.web.basic.paging-and-sorting,`HandlerMethodArgumentResolver`>> 实现,可让 Spring MVC 从请求参数中解析 `Pageable` 和 `Sort` 实例.
- <<core.web.basic.jackson-mappers, Jackson Modules>> 序列化或反序列化类似 `Point` 和 `Distance` 的类型, 或者其他特定的类型, 主要由您使用的 Spring Data Module 决定.


[[core.web.basic.domain-class-converter]]
===== 使用 `DomainClassConverter` 类
`DomainClassConverter` 允许您直接在 Spring MVC 控制器方法签名中使用 domain 类型,因此您无需通过存储库手动查找实例,如以下示例所示:

.一个在方法签名中使用 domain 类型的 Spring MVC 控制器
====
[source,java]
----
@Controller
@RequestMapping("/users")
class UserController {

  @RequestMapping("/{id}")
  String showUserForm(@PathVariable("id") User user, Model model) {

    model.addAttribute("user", user);
    return "userForm";
  }
}
----
====

如您所见,该方法直接接收 `User` 实例,不需要进一步的查找.  可以通过让 Spring MVC 首先将路径变量转换为 domain 类的 `id` 类型并最终通过在为该类型注册的存储库实例上调用 `findById(…)` 来访问该实例来解析该实例.

NOTE: 当前,该存储库必须实现 `CrudRepository` 才有资格被发现以进行转换.

[[core.web.basic.paging-and-sorting]]
===== 用于分页和排序的 `HandlerMethodArgumentResolvers`
<<core.web.basic.domain-class-converter,上一节>>中显示的配置代码段还注册了 `PageableHandlerMethodArgumentResolver` 以及 `SortHandlerMethodArgumentResolver` 的实例.  该注册启用了 `Pageable` 和 `Sort` 作为控制器方法参数,如以下示例所示

.使用 Pageable 作为控制器方法参数
====
[source,java]
----
@Controller
@RequestMapping("/users")
class UserController {

  private final UserRepository repository;

  UserController(UserRepository repository) {
    this.repository = repository;
  }

  @RequestMapping
  String showUsers(Model model, Pageable pageable) {

    model.addAttribute("users", repository.findAll(pageable));
    return "users";
  }
}
----
====

前面的方法签名使 Spring MVC 尝试使用以下默认配置从请求参数扩展 `Pageable` 实例:

.请求为 `Pageable` 实例评估后的参数
[options = "autowidth"]
|===
|`page`|您要检索的页面.  0 索引,默认为 0.
|`size`|您要检索的页面大小.  默认为 20
|`sort`|应该以格式属性 `property,property(,ASC\|DESC)` 进行排序的属性.  默认排序方向为升序.  如果要切换排序,请使用多个排序参数. 例如, `?sort=firstname&sort=lastname,asc`.
|===

要自定义此行为,请注册分别实现 `PageableHandlerMethodArgumentResolverCustomizer` 接口或 `SortHandlerMethodArgumentResolverCustomizer` 接口的 bean.  它的 `customize()` 方法被调用,让您更改设置,如以下示例所示:

====
[source,java]
----
@Bean SortHandlerMethodArgumentResolverCustomizer sortCustomizer() {
    return s -> s.setPropertyDelimiter("<-->");
}
----
====

如果设置现有 `MethodArgumentResolver` 的属性不足以满足您的目的,请扩展 `SpringDataWebConfiguration` 或启用 HATEOAS ,重写 `pageableResolver()` 或 `sortResolver()` 方法,然后导入自定义的配置文件,而不使用 `@Enable` 注解.

如果您需要从请求中解析多个 `Pageable` 或 `Sort` 实例 (例如,对于多个表) ,则可以使用 Spring 的 `@Qualifier` 注解将一个实例与另一个实例区分开.  然后,请求参数必须以 `${qualifier}_` 为前缀.  以下示例显示了生成的方法签名:

====
[source,java]
----
String showUsers(Model model,
      @Qualifier("thing1") Pageable first,
      @Qualifier("thing2") Pageable second) { … }
----
====

您必须填充 `thing1_page` 和 `thing2_page`,依此类推.

传递给该方法的默认 `Pageable` 等效于 `PageRequest.of(0, 20)`,但可以使用 `Pageable` 参数上的 `@PageableDefault` 注解注解进行自定义.

[[core.web.pageables]]
==== 超媒体对页面的支持

Spring HATEOAS 附带了一个表示模型类 (`PagedResources`) ,该类允许使用必要的页面元数据以及链接来丰富 `Page` 实例的内容,并使客户端可以轻松浏览页面.  `Page` 到 `PagedResources` 的转换是通过 Spring HATEOAS `ResourceAssembler` 接口 (称为 `PagedResourcesAssembler`) 的实现完成的.  下面的示例演示如何将 `PagedResourcesAssembler` 用作控制器方法参数:

.使用 PagedResourcesAssembler 作为控制器方法参数
====
[source,java]
----
@Controller
class PersonController {

  @Autowired PersonRepository repository;

  @RequestMapping(value = "/persons", method = RequestMethod.GET)
  HttpEntity<PagedResources<Person>> persons(Pageable pageable,
    PagedResourcesAssembler assembler) {

    Page<Person> persons = repository.findAll(pageable);
    return new ResponseEntity<>(assembler.toResources(persons), HttpStatus.OK);
  }
}
----
====

如上例中所示启用配置,可以将 `PagedResourcesAssembler` 用作控制器方法参数.  对其调用  `toResources(…)` 具有以下效果:

- `Page` 的内容成为 `PagedResources` 实例的内容.
- `PagedResources` 对象获取附加的 `PageMetadata` 实例,并使用 `Page` 和基础 `PageRequest` 的信息填充该实例.
- `PagedResources` 可能会附加上一个和下一个链接,具体取决于页面的状态.  链接指向方法映射到的 URI.  添加到该方法的分页参数与 `PageableHandlerMethodArgumentResolver` 的设置匹配,以确保以后可以解析链接.

假设数据库中有 30 个 Person 实例.  现在,您可以触发请求 (`GET http://localhost:8080/persons` ) ,并查看类似于以下内容的输出:

====
[source, javascript]
----
{ "links" : [ { "rel" : "next",
                "href" : "http://localhost:8080/persons?page=1&size=20 }
  ],
  "content" : [
     … // 20 Person instances rendered here
  ],
  "pageMetadata" : {
    "size" : 20,
    "totalElements" : 30,
    "totalPages" : 2,
    "number" : 0
  }
}
----
====

您会看到编译器生成了正确的 URI,并且还选择了默认配置以将参数解析为即将到来的请求的 `Pageable`.  这意味着,如果您更改该配置,则链接将自动遵循更改.  默认情况下,编译器指向调用它的控制器方法,但是可以通过传递自定义链接 (用作构建分页链接的基础) 进行自定义,这会使 `PagedResourcesAssembler.toResource(...)` 方法过载.

[[core.web.basic.jackson-mappers]]
==== Spring Data Jackson Modules

core module 和 存储库特定的模块附带了一组用于类型的 Jackson 模块， 例如 `org.springframework.data.geo.Distance` 和 `org.springframework.data.geo.Point`, 使用 Spring Data domain. +
一旦启用 <<core.web, web support>> 这些模块将被导入， 并且 `com.fasterxml.jackson.databind.ObjectMapper` 可用.

在初始化期间， 像 `SpringDataJacksonConfiguration` 一样， `SpringDataJacksonModules` 会被自动检测， 以便声明的 ``com.fasterxml.jackson.databind.Module`` 可供 Jackson 的 `ObjectMapper` 使用.

Data binding mixins for the following domain types are registered by the common infrastructure.
----
org.springframework.data.geo.Distance
org.springframework.data.geo.Point
org.springframework.data.geo.Box
org.springframework.data.geo.Circle
org.springframework.data.geo.Polygon
----

[NOTE]
====
各个模块可以提供附加的 `SpringDataJacksonModules`. +
请参阅存储库特定部分以获取更多详细信息.
====

[[core.web.binding]]
==== Web 数据绑定支持

通过使用 https://goessner.net/articles/JsonPath/[JSONPath] 表达式 (需要 https://github.com/json-path/JsonPath[Jayway JsonPath] 或 https://www.w3.org/TR/xpath-31/[XPath]表达式 (需要 https://xmlbeam.org/[XmlBeam]) ) ,可以使用 Spring Data 投影 (在 <<projections,Projections>> 中描述) 来绑定传入的请求有效负载,如以下示例所示:

.使用 JSONPath 或 XPath 表达式的 HTTP 有效负载绑定
====
[source,java]
----
@ProjectedPayload
public interface UserPayload {

  @XBRead("//firstname")
  @JsonPath("$..firstname")
  String getFirstname();

  @XBRead("/lastname")
  @JsonPath({ "$.lastname", "$.user.lastname" })
  String getLastname();
}
----
====

前面示例中显示的类型可以用作 Spring MVC 处理程序方法参数,也可以通过在 `RestTemplate` 的方法之一上使用 `ParameterizedTypeReference` 来使用.  前面的方法声明将尝试在给定文档中的任何位置查找名字.   `lastname` XML 查找是在传入文档的顶层执行的.
JSON 首先尝试使用顶层 `lastname` ,但是如果前者不返回值,则还尝试嵌套在用户子文档中的 `lastname` .  这样,无需客户端调用暴露的方法即可轻松缓解源文档结构的更改 (通常是基于类的有效负载绑定的缺点) .

如 <<projections,投影>>中所述,支持嵌套投影.  如果该方法返回复杂的非接口类型,则将使用 Jackson `ObjectMapper` 映射最终值.

对于 Spring MVC,`@EnableSpringDataWebSupport` 处于活动状态并且所需的依赖在类路径上可用后,会自动自动注册必要的转换器.  要与 `RestTemplate` 一起使用,请手动注册 `ProjectingJackson2HttpMessageConverter` (JSON)  或 `XmlBeamHttpMessageConverter`.

有关更多信息,请参见规范的 https://github.com/spring-projects/spring-data-examples[Spring Data Examples repository] 存储库中的 https://github.com/spring-projects/spring-data-examples/tree/master/web/projection[web projection example] .

[[core.web.type-safe]]
==== Querydsl Web 支持

对于那些具有 http://www.querydsl.com/[QueryDSL] 集成的存储,可以从 · 查询字符串中包含的属性扩展查询.

考虑以下查询字符串:

====
[source,text]
----
?firstname=Dave&lastname=Matthews
----
====

给定前面示例中的 `User` 对象,可以使用 `QuerydslPredicateArgumentResolver` 将查询字符串解析为以下值.

====
[source,text]
----
QUser.user.firstname.eq("Dave").and(QUser.user.lastname.eq("Matthews"))
----
====

NOTE: 在类路径上找到 Querydsl 时,将自动启用该功能以及 `@EnableSpringDataWebSupport`.

将 `@QuerydslPredicate` 添加到方法签名中可提供一个现成的 `Predicate`,可以使用 `QuerydslPredicateExecutor` 来运行它.

TIP: 类型信息通常从方法的返回类型中解析.  由于该信息不一定与 domain 类型匹配,因此使用 `QuerydslPredicate` 的 `root` 属性可能是一个好主意.

下面的示例演示如何在方法签名中使用 `@QuerydslPredicate`:

====
[source,java]
----
@Controller
class UserController {

  @Autowired UserRepository repository;

  @RequestMapping(value = "/", method = RequestMethod.GET)
  String index(Model model, @QuerydslPredicate(root = User.class) Predicate predicate,    <1>
          Pageable pageable, @RequestParam MultiValueMap<String, String> parameters) {

    model.addAttribute("users", repository.findAll(predicate, pageable));

    return "index";
  }
}
----
<1> 将查询字符串参数解析为与 `User` `Predicate` 匹配.
====

默认绑定如下:

* 简单属性上的对象如 `eq`.
* 集合上的对象,如 `contains` 的属性.
* 集合上的对象,如 `in` 的属性.

可以通过 `@QuerydslPredicate` 的 `bindings` 属性或通过使用 Java 8 `default methods` 并将 `QuerydslBinderCustomizer` 方法添加到存储库接口来自定义那些绑定.

====
[source,java]
----
interface UserRepository extends CrudRepository<User, String>,
                                 QuerydslPredicateExecutor<User>,                <1>
                                 QuerydslBinderCustomizer<QUser> {               <2>

  @Override
  default void customize(QuerydslBindings bindings, QUser user) {

    bindings.bind(user.username).first((path, value) -> path.contains(value))    <3>
    bindings.bind(String.class)
      .first((StringPath path, String value) -> path.containsIgnoreCase(value)); <4>
    bindings.excluding(user.password);                                           <5>
  }
}
----
<1> `QuerydslPredicateExecutor` 提供对断言的特定查找器方法的访问
<2> 在存储库界面上定义的 `QuerydslBinderCustomizer` 会被自动提取,并提供 `@QuerydslPredicate(bindings=...)`.
<3> 将 `username` 属性的绑定定义为简单的 `contains`  绑定.
<4> 将 `String` 属性的默认绑定定义为不区分大小写的 `contains` 匹配项.
<5> 从  `Predicate` 解析中排除 `password` 属性.
====

[[core.repository-populators]]
=== 存储库填充器
如果您使用 Spring JDBC 模块,则可能熟悉使用 SQL 脚本填充 `DataSource` 的支持.  尽管它不使用 SQL 作为数据定义语言,因为它必须独立于存储,因此可以在存储库级别使用类似的抽象.  因此,填充器支持XML (通过 Spring 的 OXM 抽象) 和 JSON  (通过 Jackson) 来定义用于填充存储库的数据.

假设您有一个包含以下内容的 `data.json` 文件:

.JSON中定义的数据
====
[source, javascript]
----
[ { "_class" : "com.acme.Person",
 "firstname" : "Dave",
  "lastname" : "Matthews" },
  { "_class" : "com.acme.Person",
 "firstname" : "Carter",
  "lastname" : "Beauford" } ]
----
====

您可以使用 Spring Data Commons 中提供的存储库命名空间的 `populator` 元素来填充存储库.  要将前面的数据填充到 `PersonRepository` 中,请声明类似于以下内容的填充器:

.声明一个 Jackson 存储库填充器
====
[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:repository="http://www.springframework.org/schema/data/repository"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/repository
    https://www.springframework.org/schema/data/repository/spring-repository.xsd">

  <repository:jackson2-populator locations="classpath:data.json" />

</beans>
----
====

前面的声明使 `Jackson.ObjectMapper` 读取并反序列化 `data.json` 文件.

通过检查JSON文档的 `_class` 属性来确定将 JSON 对象解组到的类型.  基础结构最终选择适当的存储库来处理反序列化的对象.

要改为使用 XML 定义应使用存储库填充的数据,可以使用 `unmarshaller-populator` 元素.  您可以将其配置为使用 Spring OXM 中可用的 XML marshaller 选项之一.  有关详细信息,请参见 {spring-framework-docs}/data-access.html#oxm[Spring 参考文档].  以下示例显示如何使用 JAXB 解组存储库填充器:

.声明一个解组存储库填充器 (使用 JAXB)
====
[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:repository="http://www.springframework.org/schema/data/repository"
  xmlns:oxm="http://www.springframework.org/schema/oxm"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/repository
    https://www.springframework.org/schema/data/repository/spring-repository.xsd
    http://www.springframework.org/schema/oxm
    https://www.springframework.org/schema/oxm/spring-oxm.xsd">

  <repository:unmarshaller-populator locations="classpath:data.json"
    unmarshaller-ref="unmarshaller" />

  <oxm:jaxb2-marshaller contextPath="com.acme" />

</beans>
----
====