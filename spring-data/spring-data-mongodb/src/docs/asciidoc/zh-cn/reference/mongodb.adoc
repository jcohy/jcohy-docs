[[mongo.core]]
= MongoDB 支持

MongoDB的支持包含广泛的功能：

* Spring 配置支持基于 Java 的 `@Configuration` 类或 XML 命名空间的 Mongo 驱动实例和副本集。
* `MongoTemplate` 辅助类，在执行常见的 Mongo 操作时提高生产力。包括文档和 POJO 之间的集成对象映射。
* 将异常转换为 Spring Data Access Exception 层次结构。
* 功能丰富的对象映射与 Spring 的转换服务集成。
* 基于注解的映射元数据，可扩展到支持其他元数据格式。
* 持久化和映射生命周期事件。
* 基于 Java 的 Query、Criteria 和 Update DSL。
* 自动实现 `Repository` 接口，包括支持自定义查询方法。
* QueryDSL 集成，支持类型安全的查询。
* 对 JPA 实体的跨存储持久性支持，其字段可通过 MongoDB 进行透明的持久化和检索（已废弃—将被移除，没有替换）。
* 地理空间（GeoSpatial）集成。

对于大多数任务，你应该使用 `MongoTemplate` 或 `Repository` 支持，它们都利用了丰富的映射功能。`MongoTemplate` 是访问功能的地方，如递增计数器或临时 CRUD 操作。
`MongoTemplate` 还提供了回调方法，这样你就很容易获得低级别的 API 构件，如 `com.mongodb.client.MongoDatabase`，从而直接与 MongoDB 进行通信。
对各种 API 构件 进行命名的目的是为了复制基础 MongoDB Java 驱动中的那些 API 构件，这样你就可以轻松地将现有知识映射到 Spring API 上。

[[mongodb-getting-started]]
== 入门

建立工作环境的一个简单方法是在 https://spring.io/tools/sts[STS] 中创建一个基于 Spring 的项目。

首先，你需要设置一个正在运行的 MongoDB 服务器。请参考 https://docs.mongodb.org/manual/core/introduction/[MongoDB 快速入门指南] ，了解如何启动 MongoDB 实例。
安装完毕后，启动 MongoDB 通常只需运行以下命令即可。`${MONGO_HOME}/bin/mongod`

在 STS 中创建一个 Spring 项目：

. Go to File → New → Spring Template Project → Simple Spring Utility Project，并在出现提示时按 Yes。然后输入一个项目和一个包的名称，比如 `org.spring.mongodb.example`。
. 在 `pom.xml` 文件的 `dependencies` 元素中加入以下内容。
+
[source,xml,subs="+attributes"]
----
<dependencies>

  <!-- other dependency elements omitted -->

  <dependency>
    <groupId>org.springframework.data</groupId>
    <artifactId>spring-data-mongodb</artifactId>
    <version>{version}</version>
  </dependency>

</dependencies>
----
. 将 `pom.xml` 中 Spring 的版本改为：
+
[source,xml,subs="+attributes"]
----
<spring.framework.version>{springVersion}</spring.framework.version>
----
. 在你的 `pom.xml` 中添加以下 Maven 的 Spring Milestone repository 的位置，使其位于 `<dependencies/>` 元素的同一级别。
+
[source,xml]
----
<repositories>
  <repository>
    <id>spring-milestone</id>
    <name>Spring Maven MILESTONE Repository</name>
    <url>https://repo.spring.io/libs-milestone</url>
  </repository>
</repositories>
----

repository 也可在此  https://repo.spring.io/milestone/org/springframework/data/[浏览] 。

你可能还想把日志级别设置为 `DEBUG`，以查看一些额外的信息。要做到这一点，编辑 `log4j.properties` 文件，使其具有以下内容。

[source]
----
log4j.category.org.springframework.data.mongodb=DEBUG
log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %40.40c:%4L - %m%n
----

然后，你可以创建一个 `Person` 持久化类:

[source,java]
----
package org.spring.mongodb.example;

public class Person {

  private String id;
  private String name;
  private int age;

  public Person(String name, int age) {
    this.name = name;
    this.age = age;
  }

  public String getId() {
    return id;
  }
  public String getName() {
    return name;
  }
  public int getAge() {
    return age;
  }

  @Override
  public String toString() {
    return "Person [id=" + id + ", name=" + name + ", age=" + age + "]";
  }
}
----

你也需要一个 main 应用程序去运行:

[source,java]
----
package org.spring.mongodb.example;

import static org.springframework.data.mongodb.core.query.Criteria.where;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.data.mongodb.core.MongoOperations;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Query;

import com.mongodb.client.MongoClients;

public class MongoApp {

  private static final Log log = LogFactory.getLog(MongoApp.class);

  public static void main(String[] args) throws Exception {

    MongoOperations mongoOps = new MongoTemplate(MongoClients.create(), "database");
    mongoOps.insert(new Person("Joe", 34));

    log.info(mongoOps.findOne(new Query(where("name").is("Joe")), Person.class));

    mongoOps.dropCollection("person");
  }
}
----

当您运行此 main 程序，此示例会有以下输出

[source]
----
10:01:32,062 DEBUG apping.MongoPersistentEntityIndexCreator:  80 - Analyzing class class org.spring.example.Person for index information.
10:01:32,265 DEBUG ramework.data.mongodb.core.MongoTemplate: 631 - insert Document containing fields: [_class, age, name] in collection: Person
10:01:32,765 DEBUG ramework.data.mongodb.core.MongoTemplate:1243 - findOne using query: { "name" : "Joe"} in db.collection: database.Person
10:01:32,953  INFO      org.spring.mongodb.example.MongoApp:  25 - Person [id=4ddbba3c0be56b7e1b210166, name=Joe, age=34]
10:01:32,984 DEBUG ramework.data.mongodb.core.MongoTemplate: 375 - Dropped collection [database.person]
----

即使在这个简单的例子中，也有一些事情需要注意：

* 你可以通过使用标准的 `com.mongodb.client.MongoClient` 对象和要使用的数据库名称，来实例化 Spring Mongo 的中心辅助类 <<mongo-template,`MongoTemplate`>>。
* 该 mapper 针对标准的 POJO 对象工作，不需要任何额外的元数据（尽管你可以选择性地提供这些信息。 见 <<mapping-chapter,here>>）。
* 惯例用于处理 `id` 字段，在数据库中存储时将其转换为 `ObjectId`。
* 映射约定可以使用字段访问。请注意，`Person` 类只有 `getter`。
* 如果构造函数的参数名与存储文档的字段名相匹配，它们将被用来实例化对象。

[[mongo.examples-repo]]
== 示例仓库

有一个 GitHub 仓库，里面有 https://github.com/spring-projects/spring-data-examples[几个例子]，你可以下载并玩一玩，感受一下这个库是如何工作的。

[[mongodb-connectors]]
== 使用 Spring 连接到 MongoDB

在使用 MongoDB 和 Spring 时，首要任务之一是使用 IoC 容器创建一 个 `com.mongodb.client.MongoClient` 对象。有两种主要的方法可以做到这一点，一种是使用基于 Java 的 bean 元数据，另一种是使用基于 XML 的 bean 元数据。这两种方式将在下面的章节中讨论。

NOTE: 对于那些不熟悉如何使用基于 Java 的 Bean 元数据而不是基于 XML 的元数据来配置 Spring 容器的人来说，请参考 https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/new-in-3.0.html#new-java-configuration[这里] 的参考文档中的高级介绍，
以及 https://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/core.html#beans-java-instantiating-container[这里] 的详细文档。

[[mongo.mongo-java-config]]
=== 通过使用基于 Java 的元数据注册 Mongo 实例

下面的例子显示了一个使用基于 Java 的 bean 元数据来注册 `com.mongodb.client.MongoClient` 实例的例子。

.使用基于 Java 的 bean 元数据注册一个 `com.mongodb.client.MongoClient` 对象
====
[source,java]
----
@Configuration
public class AppConfig {

  /*
   * Use the standard Mongo driver API to create a com.mongodb.client.MongoClient instance.
   */
   public @Bean MongoClient mongoClient() {
       return MongoClients.create("mongodb://localhost:27017");
   }
}
----
====

这种方法可以让你使用标准的 `com.mongodb.client.MongoClient` 实例，而容器则使用 Spring 的 `MongoClientFactoryBean`。与直接实例化 `com.mongodb.client.MongoClient` 实例相比，`FactoryBean` 的额外优势在于它还为容器提供了 `ExceptionTranslator` 实现，
该实现可将 MongoDB 异常转换为 Spring 的可移植 `DataAccessException` 层次结构中的异常，用于带有 `@Repository` 注解的数据访问类。这个层次结构和 `@Repository` 的使用在  https://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/data-access.html[Spring 的 DAO 支持功能] 中有所描述。

下面的例子显示了一个基于 Java 的 Bean 元数据的例子，它支持对 `@Repository` 注解的类进行异常转换。

.通过使用 Spring 的 `MongoClientFactoryBean` 注册 `com.mongodb.client.MongoClient` 对象，并启用 Spring 的异常转换支持。
====
[source,java]
----
@Configuration
public class AppConfig {

    /*
     * Factory bean that creates the com.mongodb.client.MongoClient instance
     */
     public @Bean MongoClientFactoryBean mongo() {
          MongoClientFactoryBean mongo = new MongoClientFactoryBean();
          mongo.setHost("localhost");
          return mongo;
     }
}
----
====

要访问由 `MongoClientFactoryBean` 在其他 `@Configuration` 类或你自己的类中创建的 `com.mongodb.client.MongoClient` 对象，请使用一个私有的 `@Autowired MongoClient mongoClient;` 字段。

[[mongo.mongo-xml-config]]
=== 通过使用基于 XML 的元数据注册 Mongo 实例

虽然你可以使用 Spring 传统的 `<beans/>` XML 命名空间来向容器注册 `com.mongodb.client.MongoClient` 的实例，但由于它是通用的，所以 XML 可能相当冗长。XML 命名空间是配置常用对象（如 Mongo 实例）的一个更好的选择。
`mongo` 命名空间可以让你创建一个 Mongo 实例的服务器位置、副本集和选项。

要使用 `Mongo` 命名空间元素，你需要引用 Mongo schema，如下所示。

.XML schema 配置 MongoDB
====
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:mongo="http://www.springframework.org/schema/data/mongo"
          xsi:schemaLocation=
          "
          http://www.springframework.org/schema/data/mongo https://www.springframework.org/schema/data/mongo/spring-mongo.xsd
          http://www.springframework.org/schema/beans
          https://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- Default bean name is 'mongo' -->
    <mongo:mongo-client host="localhost" port="27017"/>

</beans>
----
====

以下示例显示了 `MongoClientSettings` 的更高级配置（请注意，这些不是推荐值）：

.XML schema 使用 `MongoClientSettings` 配置 `com.mongodb.client.MongoClient` 对象
====
[source,xml]
----
<beans>

  <mongo:mongo-client host="localhost" port="27017">
    <mongo:client-settings connection-pool-max-connection-life-time="10"
        connection-pool-min-size="10"
		connection-pool-max-size="20"
		connection-pool-maintenance-frequency="10"
		connection-pool-maintenance-initial-delay="11"
		connection-pool-max-connection-idle-time="30"
		connection-pool-max-wait-time="15" />
  </mongo:mongo-client>

</beans>
----
====

下面的例子显示了一个使用副本集的配置。

.用 XML schema 来配置带有 Replica Sets 的 `com.mongodb.client.MongoClient` 对象
====
[source,xml]
----
<mongo:mongo-client id="replicaSetMongo" replica-set="rs0">
    <mongo:client-settings cluster-hosts="127.0.0.1:27017,localhost:27018" />
</mongo:mongo-client>
----
====

[[mongo.mongo-db-factory]]
=== MongoDatabaseFactory 接口

虽然 `com.mongodb.client.MongoClient` 是 MongoDB 驱动程序 API 的入口，但连接到特定的 `MongoDB` 数据库实例需要额外的信息，例如数据库名称以及可选的用户名和密码。
有了这些信息，你就可以获得 `com.mongodb.client.MongoDatabase` 对象并访问特定 MongoDB 数据库实例的所有功能。
Spring 提供了 `org.springframework.data.mongodb.core.MongoDatabaseFactory` 接口，如下表所示，用于引导与数据库的连接:

[source,java]
----
public interface MongoDatabaseFactory {

  MongoDatabase getDatabase() throws DataAccessException;

  MongoDatabase getDatabase(String dbName) throws DataAccessException;
}
----

下面的章节展示了你如何使用基于 Java 或基于 XML 的元数据的容器来配置 `MongoDatabaseFactory` 接口的实例。反过来，你可以使用 `MongoDatabaseFactory` 实例来配置 `MongoTemplate`。

你可以在标准的 Java 代码中使用它们，而不是使用 IoC 容器来创建 `MongoTemplate` 的实例，如下所示。

[source,java]
----
public class MongoApp {

  private static final Log log = LogFactory.getLog(MongoApp.class);

  public static void main(String[] args) throws Exception {

    MongoOperations mongoOps = new MongoTemplate(new SimpleMongoClientDatabaseFactory(MongoClients.create(), "database"));

    mongoOps.insert(new Person("Joe", 34));

    log.info(mongoOps.findOne(new Query(where("name").is("Joe")), Person.class));

    mongoOps.dropCollection("person");
  }
}
----

黑体字的代码强调了 `SimpleMongoClientDbFactory` 的使用，这也是与 <<mongodb-getting-started,入门部分>> 所示清单的唯一区别。

NOTE: 在选择 `com.mongodb.client.MongoClient` 作为首选入口时，使用 `SimpleMongoClientDbFactory`。

[[mongo.mongo-db-factory-java]]
[[mongo.mongo-db-factory.config]]
=== 注册 `MongoDatabaseFactory`

为了在容器中注册一个 `MongoDatabaseFactory` 实例，你写的代码很像前面代码清单中强调的那样。下面的列表显示了一个简单的例子。

[source,java]
----
@Configuration
public class MongoConfiguration {

  @Bean
  public MongoDatabaseFactory mongoDatabaseFactory() {
    return new SimpleMongoClientDatabaseFactory(MongoClients.create(), "database");
  }
}
----

MongoDB 服务器第 3 代改变了连接到 DB 时的认证模式。因此，一些可用于认证的配置选项不再有效。你应该使用 `MongoClient` 特有的选项，通过 `MongoCredential` 设置证书，以提供认证数据，如下例所示。

====
.Java
[source,java,role="primary"]
----
@Configuration
public class ApplicationContextEventTestsAppConfig extends AbstractMongoClientConfiguration {

  @Override
  public String getDatabaseName() {
    return "database";
  }

  @Override
  protected void configureClientSettings(Builder builder) {

    builder
        .credential(MongoCredential.createCredential("name", "db", "pwd".toCharArray()))
        .applyToClusterSettings(settings  -> {
          settings.hosts(singletonList(new ServerAddress("127.0.0.1", 27017)));
        });
  }
}
----

.XML
[source,xml,role="secondary"]
----
<mongo:db-factory dbname="database" />
----
====


NOTE: 在基于 XML 的配置中使用的用户名和密码凭证，如果包含保留字符，如 `:`, `%`, `@`, or `,` ，必须进行 URL 编码。下面的例子显示了编码的凭证： `m0ng0@dmin:mo_res:bw6},Qsdxx@admin@database` -> `m0ng0%40dmin:mo_res%3Abw6%7D%2CQsdxx%40admin@database`，
更多细节请参见 https://tools.ietf.org/html/rfc3986#section-2.2[section 2.2 of RFC 3986]。

如果你需要在用于创建 `SimpleMongoClientDbFactory` 的 `com.mongodb.client.MongoClient` 实例上配置额外的选项，你可以参考现有的 bean，如以下示例所示。为了显示另一种常见的使用模式，
下面的列表显示了属性占位符的使用，它可以让你对配置和 `MongoTemplate` 的创建进行参数化。

====
.Java
[source,java,role="primary"]
----
@Configuration
@PropertySource("classpath:/com/myapp/mongodb/config/mongo.properties")
public class ApplicationContextEventTestsAppConfig extends AbstractMongoClientConfiguration {

  @Autowired
  Environment env;

  @Override
  public String getDatabaseName() {
    return "database";
  }

  @Override
  protected void configureClientSettings(Builder builder) {

    builder.applyToClusterSettings(settings -> {
    settings.hosts(singletonList(
          new ServerAddress(env.getProperty("mongo.host"), env.getProperty("mongo.port", Integer.class))));
    });

    builder.applyToConnectionPoolSettings(settings -> {

      settings.maxConnectionLifeTime(env.getProperty("mongo.pool-max-life-time", Integer.class), TimeUnit.MILLISECONDS)
          .minSize(env.getProperty("mongo.pool-min-size", Integer.class))
          .maxSize(env.getProperty("mongo.pool-max-size", Integer.class))
          .maintenanceFrequency(10, TimeUnit.MILLISECONDS)
          .maintenanceInitialDelay(11, TimeUnit.MILLISECONDS)
          .maxConnectionIdleTime(30, TimeUnit.SECONDS)
          .maxWaitTime(15, TimeUnit.MILLISECONDS);
    });
  }
}
----

.XML
[source,xml,role="secondary"]
----
<context:property-placeholder location="classpath:/com/myapp/mongodb/config/mongo.properties"/>

<mongo:mongo-client host="${mongo.host}" port="${mongo.port}">
  <mongo:client-settings connection-pool-max-connection-life-time="${mongo.pool-max-life-time}"
    connection-pool-min-size="${mongo.pool-min-size}"
    connection-pool-max-size="${mongo.pool-max-size}"
    connection-pool-maintenance-frequency="10"
    connection-pool-maintenance-initial-delay="11"
    connection-pool-max-connection-idle-time="30"
    connection-pool-max-wait-time="15" />
</mongo:mongo-client>

<mongo:db-factory dbname="database" mongo-ref="mongoClient"/>

<bean id="anotherMongoTemplate" class="org.springframework.data.mongodb.core.MongoTemplate">
  <constructor-arg name="mongoDbFactory" ref="mongoDbFactory"/>
</bean>
----
====

[[mongo-template]]
== 介绍 `MongoTemplate`

`MongoTemplate` 类位于 `org.springframework.data.mongodb.core` 包中，是 Spring 支持 MongoDB 的中心类，为与数据库交互提供了丰富的功能集。该 template 提供了创建、更新、删除和查询 MongoDB 文档的便利操作，
并提供了你的 domain 对象和 MongoDB 文档之间的映射。

NOTE: 一旦配置好，`MongoTemplate` 是线程安全的，可以在多个实例中重复使用。

MongoDB 文档和 domain 类之间的映射是通过委托给 `MongoConverter` 接口的实现完成的。Spring 提供了 `MappingMongoConverter`，但你也可以编写自己的转换器。参见 "`<<mongo.custom-converters>>`" 以了解更多详细信息。

`MongoTemplate` 类实现了 `MongoOperations` 接口。在尽可能多的情况下， `MongoOperations` 上的方法是以 MongoDB 驱动 `Collection` 对象上的方法命名的，以使习惯于驱动 API 的现有 MongoDB 开发者熟悉该 API。例如，你可以找到诸如 `find`、`findAndModify`、`findAndReplace`、`findOne`、`insert`、`remove`、`save`、`update` 和 `updateMulti` 等方法。
设计目标是使其尽可能容易地在使用基本 MongoDB 驱动和 `MongoOperations` 之间过渡。这两个 API 之间的一个主要区别是，`MongoOperations` 可以被传递 domain 对象而不是 `Document` 。另外，`MongoOperations` 对 `Query`、`Criteria` 和 `Update` 操作有 fluent API，而不是通过填充 `Document` 来指定这些操作的参数。

NOTE: 引用 `MongoTemplate` 实例上的操作的首选方式是通过其接口 `MongoOperations`。

`MongoTemplate` 使用的默认转换器实现是 `MappingMongoConverter`。虽然 `MappingMongoConverter` 可以使用额外的元数据来指定对象到文档的映射，但它也可以通过使用一些约定来转换不包含额外元数据的对象，以实现 ID 和 `collection` 名称的映射。这些约定以及映射注解的使用在 "`<<mapping-chapter>>`" 章节中有解释。

`MongoTemplate` 的另一个核心功能是将 MongoDB Java 驱动抛出的异常转换为 Spring 的可移植数据访问异常层次结构。请参阅 "`<<mongo.exception>>`"  以了解更多信息。

`MongoTemplate` 提供了许多方便的方法来帮助你轻松地执行常见的任务。然而，如果你需要直接访问 MongoDB 驱动 API，你可以使用几个 `Execute` 回调方法中的一个。`execute` 回调给你一个对 `com.mongodb.client.MongoCollection` 或 `com.mongodb.client.MongoDatabase` 对象的引用。更多信息请参见 <<mongo.executioncallback,"`Execution Callbacks`">> 部分。

下一节包含一个例子，说明如何在 Spring 容器中使用 `MongoTemplate`。

[[mongo-template.instantiating]]
=== 安装 `MongoTemplate`

你可以使用下面的配置来创建和注册 `MongoTemplate` 的实例，如下例所示。

.注册 `com.mongodb.client.MongoClient` 对象并启用 Spring 的异常转换支持
====
.Java
[source,java,role="primary"]
----
@Configuration
class AppConfig {

  @Bean
  MongoClient mongoClient() {
      return MongoClients.create("mongodb://localhost:27017");
  }

  @Bean
  MongoTemplate mongoTemplate(MongoClient mongoClient) {
      return new MongoTemplate(mongoClient, "geospatial");
  }
}
----

.XML
[source,xml,role="secondary"]
----
<mongo:mongo-client host="localhost" port="27017"/>

<bean id="mongoTemplate" class="org.springframework.data.mongodb.core.MongoTemplate">
  <constructor-arg ref="mongoClient"/>
  <constructor-arg name="databaseName" value="geospatial"/>
</bean>
----
====

`MongoTemplate` 有几个重载的构造函数:

* `MongoTemplate(MongoClient mongo, String databaseName)`:  接受 `MongoClient` 对象和默认的数据库名称来进行操作
* `MongoTemplate(MongoDatabaseFactory mongoDbFactory)`: 接受一个 `MongoDbFactory` 对象，该对象封装了 `MongoClient` 对象、数据库名称以及用户名和密码。
* `MongoTemplate(MongoDatabaseFactory mongoDbFactory, MongoConverter mongoConverter)`: 添加一个用于映射的 `MongoConverter`。

在创建 `MongoTemplate` 时，你可能想设置的其他可选的默认属性是 `WriteResultCheckingPolicy`、`WriteConcern` 和 `ReadPreference` 属性。

NOTE: 引用 `MongoTemplate` 实例上的操作的首选方式是通过其接口 MongoOperations。

[[mongo-template.writeresultchecking]]
=== `WriteResultChecking` 策略

在开发过程中，如果从任何 MongoDB 操作返回的 `com.mongodb.WriteResult` 包含一个错误，那么记录或抛出一个异常是很方便的。在开发过程中，忘记这样做是很常见的，然后最终得到一个看起来运行成功的应用程序，而事实上，数据库并没有按照你的预期进行修改。你可以将 `MongoTemplate` 的 `WriteResultChecking` 属性设置为以下值之一。`EXCEPTION` 或 `NONE`，分别用来抛出一个 `Exception` 或不做任何事情。默认是使用 `NONE` 的 `WriteResultChecking` 值。

[[mongo-template.writeconcern]]
=== `WriteConcern`

如果尚未通过驱动程序在更高层次（如 `com.mongodb.client.MongoClient`）上指定，可以设置 `MongoTemplate` 用于写操作的 `com.mongodb.WriteConcern` 属性。如果没有设置 `WriteConcern` 属性，则默认为 MongoDB 驱动程序的 DB 或 `Collection` 设置中的设置。

[[mongo-template.writeconcernresolver]]
=== `WriteConcernResolver`

对于更高级的情况，即你想在每个操作的基础上设置不同的 `WriteConcern` 值（对于 `remove`, `update`, `insert` 和 `save` 操作），可以在 `MongoTemplate` 上配置一个名为 `WriteConcernResolver` 的策略接口。由于 `MongoTemplate` 用于持久化 POJO， `WriteConcernResolver` 让你创建一个策略，可以将特定的 POJO 类映射到 `WriteConcern` 值。
下面的列表显示了 `WriteConcernResolver` 的接口。

[source,java]
----
public interface WriteConcernResolver {
  WriteConcern resolve(MongoAction action);
}
----

你可以使用 `MongoAction` 参数来决定 `WriteConcern` 值，或者使用 Template 本身的值作为默认值。`MongoAction` 包含被写入的集合名称、POJO 的 `java.lang.Class`、转换后的 `Document`、操作（`REMOVE`、`UPDATE`、`INSERT`、`INSERT_LIST` 或 `SAVE`），以及其他一些上下文信息。下面的例子显示了两组类得到不同的 `WriteConcern` 设置。

[source]
----
private class MyAppWriteConcernResolver implements WriteConcernResolver {

  public WriteConcern resolve(MongoAction action) {
    if (action.getEntityClass().getSimpleName().contains("Audit")) {
      return WriteConcern.NONE;
    } else if (action.getEntityClass().getSimpleName().contains("Metadata")) {
      return WriteConcern.JOURNAL_SAFE;
    }
    return action.getDefaultWriteConcern();
  }
}
----

[[mongo-template.save-update-remove]]
== 保存、更新和删除文档

`MongoTemplate` 让你保存、更新和删除你的 `domain` 对象，并将这些对象映射到存储在 MongoDB 中的文档。

考虑以下类:

[source,java]
----
public class Person {

  private String id;
  private String name;
  private int age;

  public Person(String name, int age) {
    this.name = name;
    this.age = age;
  }

  public String getId() {
    return id;
  }
  public String getName() {
    return name;
  }
  public int getAge() {
    return age;
  }

  @Override
  public String toString() {
    return "Person [id=" + id + ", name=" + name + ", age=" + age + "]";
  }

}
----

给出前面例子中的 `Person` 类，你可以保存、更新和删除该对象，如下例所示。

NOTE: `MongoOperations` 是 `MongoTemplate` 实现的接口。

[source,java]
----
package org.spring.example;

import static org.springframework.data.mongodb.core.query.Criteria.where;
import static org.springframework.data.mongodb.core.query.Update.update;
import static org.springframework.data.mongodb.core.query.Query.query;

import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.data.mongodb.core.MongoOperations;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.SimpleMongoClientDbFactory;

import com.mongodb.client.MongoClients;

public class MongoApp {

  private static final Log log = LogFactory.getLog(MongoApp.class);

  public static void main(String[] args) {

    MongoOperations mongoOps = new MongoTemplate(new SimpleMongoClientDbFactory(MongoClients.create(), "database"));

    Person p = new Person("Joe", 34);

    // Insert is used to initially store the object into the database.
    mongoOps.insert(p);
    log.info("Insert: " + p);

    // Find
    p = mongoOps.findById(p.getId(), Person.class);
    log.info("Found: " + p);

    // Update
    mongoOps.updateFirst(query(where("name").is("Joe")), update("age", 35), Person.class);
    p = mongoOps.findOne(query(where("name").is("Joe")), Person.class);
    log.info("Updated: " + p);

    // Delete
    mongoOps.remove(p);

    // Check that deletion worked
    List<Person> people =  mongoOps.findAll(Person.class);
    log.info("Number of people = : " + people.size());


    mongoOps.dropCollection(Person.class);
  }
}
----

前面的例子会产生以下日志输出（包括来自 `MongoTemplate` 的 `debug` 信息）。

[source]
----
DEBUG apping.MongoPersistentEntityIndexCreator:  80 - Analyzing class class org.spring.example.Person for index information.
DEBUG work.data.mongodb.core.MongoTemplate: 632 - insert Document containing fields: [_class, age, name] in collection: person
INFO               org.spring.example.MongoApp:  30 - Insert: Person [id=4ddc6e784ce5b1eba3ceaf5c, name=Joe, age=34]
DEBUG work.data.mongodb.core.MongoTemplate:1246 - findOne using query: { "_id" : { "$oid" : "4ddc6e784ce5b1eba3ceaf5c"}} in db.collection: database.person
INFO               org.spring.example.MongoApp:  34 - Found: Person [id=4ddc6e784ce5b1eba3ceaf5c, name=Joe, age=34]
DEBUG work.data.mongodb.core.MongoTemplate: 778 - calling update using query: { "name" : "Joe"} and update: { "$set" : { "age" : 35}} in collection: person
DEBUG work.data.mongodb.core.MongoTemplate:1246 - findOne using query: { "name" : "Joe"} in db.collection: database.person
INFO               org.spring.example.MongoApp:  39 - Updated: Person [id=4ddc6e784ce5b1eba3ceaf5c, name=Joe, age=35]
DEBUG work.data.mongodb.core.MongoTemplate: 823 - remove using query: { "id" : "4ddc6e784ce5b1eba3ceaf5c"} in collection: person
INFO               org.spring.example.MongoApp:  46 - Number of people = : 0
DEBUG work.data.mongodb.core.MongoTemplate: 376 - Dropped collection [database.person]
----

`MongoConverter` 通过识别（通过惯例）`Id` 属性名称，在 `String` 和存储在数据库中的 `ObjectId` 之间引起隐性转换。

NOTE: 前面的例子是为了展示 `MongoTemplate` 上保存、更新和删除操作的使用，而不是为了展示复杂的映射功能。

前面的例子中使用的查询语法在 "`<<mongo.query>>`" 一节中有更详细的解释。

[[mongo-template.id-handling]]
=== 在映射层中如何处理 `_id` 字段

MongoDB 要求你为所有的文档设置一个 `_id` 字段。如果你没有提供，驱动程序就会自动分配一个带有生成值的 `ObjectId`。当你使用 `MappingMongoConverter` 时，某些规则规定了如何将 Java 类中的属性映射到这个 `_id` 字段。

. 用 `@Id` (`org.springframework.data.annotation.Id`) 注解的属性或字段映射到 `_id` 字段。
. 一个没有注解但名为 `id` 的属性或字段映射到 `_id` 字段。

下面描述了在使用 `MappingMongoConverter`（`MongoTemplate` 的默认值）时，对映射到 `_id` 文档字段的属性进行了哪些类型转换（如果有的话）。

. 如果可能的话，通过使用 Spring `Converter<String, ObjectId>`，将 Java 类中声明为 `String` 的 `id` 属性或字段转换为 `ObjectId` 并存储。有效的转换规则被委托给 MongoDB Java 驱动。如果它不能被转换为 `ObjectId`，那么该值将作为字符串存储在数据库中。
. 通过使用 Spring `Converter<BigInteger, ObjectId>`， 在 Java 类中声明为 `BigInteger` 的 `id` 属性或字段被转换为 `ObjectId` 并存储。

如果 Java 类中没有前几组规则中指定的字段或属性，驱动程序会生成一个隐含的 `_id` 文档，但不会映射到 Java 类的某个属性或字段。

在查询和更新时，`MongoTemplate` 使用与前面保存文档的规则相对应的转换器（`converter`），以便在查询中使用的字段名和类型能够与你的 domain 类中的内容相匹配。

有些环境需要使用自定义的方法来映射 `Id` 值，例如存储在 MongoDB 中的数据没有经过 Spring Data 映射层。文档可以包含 `_id` 值，可以用 `ObjectId` 或 `String` 表示。
从存储区读回 domain 类型的文档工作得很好。由于隐含的 `ObjectId` 转换，通过其 `id` 查询文档会很麻烦。因此不能以这种方式检索文档。对于这些情况，`@MongoId` 提供了对实际 id 映射尝试的更多控制。

.`@MongoId` 映射
====
[source,java]
----
public class PlainStringId {
  @MongoId String id; <1>
}

public class PlainObjectId {
  @MongoId ObjectId id; <2>
}

public class StringToObjectId {
  @MongoId(FieldType.OBJECT_ID) String id; <3>
}
----
<1> id 被视为 `String`，无需进一步转换。
<2> id 被视为 `ObjectId`。
<3> 如果给定的 `String` 是一个有效的 `ObjectId` 十六进制，`id` 将被视为 `ObjectId`，否则视为 `String`。对应于 `@Id` 的用法。
====

[[mongo-template.type-mapping]]
=== 类型映射

MongoDB 集合（collection）可以包含代表各种类型实例的文档。如果你存储了一个类的层次结构，或者有一个具有 `Object` 类型属性的类，那么这个特性就很有用。在后一种情况下，当检索对象时，必须正确地读入该属性内的值。

为了实现这一点，`MappingMongoConverter` 使用一个 `MongoTypeMapper` 抽象，以 `DefaultMongoTypeMapper` 作为其主要实现。它的默认行为是全路径的 `classname` 存储在文档内的 `_class` 下。
类型提示是为顶级文档以及每个值（如果它是一个复杂类型和声明的属性类型的子类型）编写的。

.类型映射
====
[source,java]
----
class Sample {
  Contact value;
}

abstract class Contact { … }

class Person extends Contact { … }

Sample sample = new Sample();
sample.value = new Person();

mongoTemplate.save(sample);

{
  "value" : { "_class" : "com.acme.Person" },
  "_class" : "com.acme.Sample"
}
----
====

Spring Data MongoDB 将类型信息作为实际 root 类以及嵌套类型的最后一个字段来存储（因为它是复杂的，是 `Contact` 的一个子类型）。因此，如果你现在使用 `mongoTemplate.findAll(Object.class, "sample")`，
你可以发现存储的文档是一个 `Sample` 实例。你还可以发现值属性实际上是一个 `Person`。

==== 自定义类型映射

如果你想避免把整个 Java 类的名字写成类型信息，而是想使用一个 key，你可以在实体类上使用 `@TypeAlias` 注解。如果你需要进一步自定义映射，可以看看 `TypeInformationMapper` 接口。
该接口的实例可以在 `DefaultMongoTypeMapper` 上配置，反过来，可以在 `MappingMongoConverter` 上配置。

.为一个实体定义一个类型别名
====
[source,java]
----
@TypeAlias("pers")
class Person {

}
----
====

请注意，所产生的文档中包含 `pers` 作为 `_class` 字段的值。

[WARNING]
====
类型别名只有在映射上下文知道实际类型的情况下才起作用。所需的实体元数据要么在第一次保存时确定，要么必须通过配置的初始实体集提供。默认情况下，配置类会扫描 base package 以寻找潜在的候选者。

[source,java]
----
@Configuration
class AppConfig extends AbstractMongoClientConfiguration {

  @Override
  protected Set<Class<?>> getInitialEntitySet() {
    return Collections.singleton(Person.class);
  }

  // ...
}
----
====

==== 配置自定义类型映射

下面的例子显示了如何在 `MappingMongoConverter` 中配置一个自定义的 `MongoTypeMapper`。

[source,java]
----
class CustomMongoTypeMapper extends DefaultMongoTypeMapper {
  //implement custom type mapping here
}
----

.配置自定义的 `MongoTypeMapper`
====
.Java
[source,java,role="primary"]
----
@Configuration
class SampleMongoConfiguration extends AbstractMongoClientConfiguration {

  @Override
  protected String getDatabaseName() {
    return "database";
  }

  @Bean
  @Override
  public MappingMongoConverter mappingMongoConverter(MongoDatabaseFactory databaseFactory,
			MongoCustomConversions customConversions, MongoMappingContext mappingContext) {
    MappingMongoConverter mmc = super.mappingMongoConverter();
    mmc.setTypeMapper(customTypeMapper());
    return mmc;
  }

  @Bean
  public MongoTypeMapper customTypeMapper() {
    return new CustomMongoTypeMapper();
  }
}
----

.XML
[source,xml,role="secondary"]
----
<mongo:mapping-converter type-mapper-ref="customMongoTypeMapper"/>

<bean name="customMongoTypeMapper" class="com.acme.CustomMongoTypeMapper"/>
----
====

请注意，前面的例子扩展了 `AbstractMongoClientConfiguration` 类，并覆写了 `MappingMongoConverter` 的 bean 定义，我们在那里配置了我们的自定义 `MongoTypeMapper`。

[[mongo-template.save-insert]]
=== 保存和插入文档的方法

`MongoTemplate` 上有几个方便的方法，用于保存和插入你的对象。为了对转换过程有更精细的控制，你可以用 `MappingMongoConverter` 注册 Spring Converter — 例如 `Converter<Person, Document>` 和 `Converter<Document, Person>`。

NOTE: 插入（insert）和保存（save）操作之间的区别是，如果对象还没有持久化，保存操作会执行插入操作。

使用保存操作的简单情况是保存一个 POJO。在这种情况下，集合名称是由类的名称（非完全限定）决定的。你也可以用一个特定的集合名称来调用保存操作。你可以使用映射元数据来重写存储对象的集合。

当插入或保存时，如果 `Id` 属性没有被设置，假设它的值将由数据库自动生成。因此，为了成功地自动生成一个 `ObjectId`，你的类中的 `Id` 属性或字段的类型必须是一个 `String`，一个 `ObjectId`，或一个 `BigInteger`。

下面的例子显示了如何保存一个文档和检索其内容。

.使用 `MongoTemplate` 插入和检索文档
====
[source,java]
----
import static org.springframework.data.mongodb.core.query.Criteria.where;
import static org.springframework.data.mongodb.core.query.Criteria.query;
…

Person p = new Person("Bob", 33);
mongoTemplate.insert(p);

Person qp = mongoTemplate.findOne(query(where("age").is(33)), Person.class);
----
====

可以进行以下插入和保存操作:

* `void` *save* `(Object objectToSave)`: 将该对象保存到默认的集合中。
* `void` *save* `(Object objectToSave, String collectionName)`: 将该对象保存到指定的集合中。

也有一套类似的插入操作:

* `void` *insert* `(Object objectToSave)`: 将该对象插入到默认集合中.
* `void` *insert* `(Object objectToSave, String collectionName)`: 插入对象到指定的集合。

[[mongo-template.save-insert.collection]]
==== 我的文档被保存在哪个集合中？

有两种方法来管理用于文档的集合名称。默认使用的集合名是将类名改为以小写字母开头。所以一个 `com.test.Person` 类被存储在 `person` 集合中。你可以通过使用 `@Document` 注解提供一个不同的集合名称来自定义它。你也可以通过提供你自己的集合名称作为选定的 `MongoTemplate` 方法调用的最后一个参数来覆盖该集合名称。

[[mongo-template.save-insert.individual]]
==== 插入或保存单个对象

MongoDB 驱动支持在单个操作中插入一个文档集合。`MongoOperations` 接口中的下列方法支持这一功能。

* *insert*: 插入一个对象。如果有一个具有相同 `id` 的现有文档，就会产生一个错误。
* *insertAll*: 接受一个 `Collection` 的集合作为第一个参数。该方法检查每个对象，并根据前面指定的规则将其插入到适当的集合中。
* *save*: 保存对象，覆盖任何可能有相同 `id` 的对象。

[[mongo-template.save-insert.batch]]
==== 批量插入对象

MongoDB 驱动支持在一个操作中插入一个文档集合。`MongoOperations` 接口中的下列方法支持这一功能。

* *insert* methods: 以一个 `Collection` 作为第一个参数。它们在一次批量写入数据库中插入一个对象的列表。

[[mongodb-template-update]]
=== 更新集合中的文档

对于更新，你可以通过使用 `MongoOperation.updateFirst` 来更新找到的第一个文档，或者你可以通过使用 `MongoOperation.updateMulti` 方法来更新所有找到的符合查询的文档。下面的例子显示了对所有 SAVINGS 账户的更新，我们通过使用 `$inc` 操作符在余额中添加一次性的 50 美元奖金。

.通过使用 `MongoTemplate` 更新文档
====
[source,java]
----
import static org.springframework.data.mongodb.core.query.Criteria.where;
import static org.springframework.data.mongodb.core.query.Query;
import static org.springframework.data.mongodb.core.query.Update;

...

WriteResult wr = mongoTemplate.updateMulti(new Query(where("accounts.accountType").is(Account.Type.SAVINGS)),
  new Update().inc("accounts.$.balance", 50.00), Account.class);
----
====

除了前面讨论的 `Query` 之外，我们还通过使用 `Update` 对象来提供更新定义。 `Update` 类拥有与 MongoDB 可用的更新修改器（update modifier）相匹配的方法。

大多数方法都返回 `Update` 对象，为 API 提供一种 fluent 的风格。

[[mongodb-template-update.methods]]
==== 运行更新文档的方法

* *updateFirst*: 用更新后的文档更新第一个符合查询文档 criteria 的文档。
* *updateMulti*: 用更新后的文档更新所有符合查询文档 criteria 的对象。

WARNING: `updateFirst` 不支持排序。请使用 <<mongo-template.find-and-upsert, findAndModify>>  来应用 `Sort`。

[[mongodb-template-update.update]]
==== `Update` 类中的方法

你可以在 `Update` 类中使用一点 "'语法糖'"，因为它的方法是要被串联起来的。另外，你可以通过使用 `public static Update update(String key, Object value)` 和使用静态导入来启动一个新的 `Update` 实例的创建。

`Update` 类包含以下方法:

* `Update` *addToSet* `(String key, Object value)` Update using the `$addToSet` update modifier
* `Update` *currentDate* `(String key)` Update using the `$currentDate` update modifier
* `Update` *currentTimestamp* `(String key)` Update using the `$currentDate` update modifier with `$type` `timestamp`
* `Update` *inc* `(String key, Number inc)` Update using the `$inc` update modifier
* `Update` *max* `(String key, Object max)` Update using the `$max` update modifier
* `Update` *min* `(String key, Object min)` Update using the `$min` update modifier
* `Update` *multiply* `(String key, Number multiplier)` Update using the `$mul` update modifier
* `Update` *pop* `(String key, Update.Position pos)` Update using the `$pop` update modifier
* `Update` *pull* `(String key, Object value)` Update using the `$pull` update modifier
* `Update` *pullAll* `(String key, Object[] values)` Update using the `$pullAll` update modifier
* `Update` *push* `(String key, Object value)` Update using the `$push` update modifier
* `Update` *pushAll* `(String key, Object[] values)` Update using the `$pushAll` update modifier
* `Update` *rename* `(String oldName, String newName)` Update using the `$rename` update modifier
* `Update` *set* `(String key, Object value)` Update using the `$set` update modifier
* `Update` *setOnInsert* `(String key, Object value)` Update using the `$setOnInsert` update modifier
* `Update` *unset* `(String key)` Update using the `$unset` update modifier

一些更新修改器，如 `$push` 和 `$addToSet`，允许嵌套额外的操作符。

[source]
----
// { $push : { "category" : { "$each" : [ "spring" , "data" ] } } }
new Update().push("category").each("spring", "data")

// { $push : { "key" : { "$position" : 0 , "$each" : [ "Arya" , "Arry" , "Weasel" ] } } }
new Update().push("key").atPosition(Position.FIRST).each(Arrays.asList("Arya", "Arry", "Weasel"));

// { $push : { "key" : { "$slice" : 5 , "$each" : [ "Arya" , "Arry" , "Weasel" ] } } }
new Update().push("key").slice(5).each(Arrays.asList("Arya", "Arry", "Weasel"));

// { $addToSet : { "values" : { "$each" : [ "spring" , "data" , "mongodb" ] } } }
new Update().addToSet("values").each("spring", "data", "mongodb");
----

[[mongo-template.upserts]]
=== 在一个集合中 "`Upserting`" 文档

与执行 `updateFirst` 操作相关，你也可以执行 "`upsert`" 操作，如果没有找到与查询相匹配的文档，它将执行插入操作。被插入的文档是查询文档和更新文档的组合。下面的例子显示了如何使用 `upsert` 方法。

[source]
----
template.update(Person.class)
  .matching(query(where("ssn").is(1111).and("firstName").is("Joe").and("Fraizer").is("Update"))
  .apply(update("address", addr))
  .upsert();
----

WARNING: upsert 不支持排序。请使用 <<mongo-template.find-and-upsert, findAndModify>> 来应用 `Sort`。

[[mongo-template.find-and-upsert]]
=== 查找和 Upsert 集合中的文档

`MongoCollection` 上的 `findAndModify(…)` 方法可以更新一个文档，并在一次操作中返回旧的或新更新的文档。`MongoTemplate` 提供了四个 `findAndModify` 重载方法，这些方法采用 `Query` 和 `Update` 类，并从 `Document` 转换为你的 POJO。

[source,java]
----
<T> T findAndModify(Query query, Update update, Class<T> entityClass);

<T> T findAndModify(Query query, Update update, Class<T> entityClass, String collectionName);

<T> T findAndModify(Query query, Update update, FindAndModifyOptions options, Class<T> entityClass);

<T> T findAndModify(Query query, Update update, FindAndModifyOptions options, Class<T> entityClass, String collectionName);
----

下面的例子在容器中插入了几个 `Person` 对象，并执行了 `findAndUpdate` 操作。

[source,java]
----
template.insert(new Person("Tom", 21));
template.insert(new Person("Dick", 22));
template.insert(new Person("Harry", 23));

Query query = new Query(Criteria.where("firstName").is("Harry"));
Update update = new Update().inc("age", 1);

Person oldValue = template.update(Person.class)
  .matching(query)
  .apply(update)
  .findAndModifyValue(); // return's old person object

assertThat(oldValue.getFirstName()).isEqualTo("Harry");
assertThat(oldValue.getAge()).isEqualTo(23);

Person newValue = template.query(Person.class)
  .matching(query)
  .findOneValue();

assertThat(newValue.getAge()).isEqualTo(24);

Person newestValue = template.update(Person.class)
  .matching(query)
  .apply(update)
  .withOptions(FindAndModifyOptions.options().returnNew(true)) // Now return the newly updated document when updating
  .findAndModifyValue();

assertThat(newestValue.getAge()).isEqualTo(25);
----

`FindAndModifyOptions` 方法让你设置 `returnNew`、`upsert` 和 `remove` 的选项。下面是一个从前面的代码片断延伸出来的例子。

[source,java]
----
Person upserted = template.update(Person.class)
  .matching(new Query(Criteria.where("firstName").is("Mary")))
  .apply(update)
  .withOptions(FindAndModifyOptions.options().upsert(true).returnNew(true))
  .findAndModifyValue()

assertThat(upserted.getFirstName()).isEqualTo("Mary");
assertThat(upserted.getAge()).isOne();
----

[[mongo-template.aggregation-update]]
=== 聚合管道（Aggregation Pipeline）更新

`MongoOperations` 和 `ReactiveMongoOperations` 暴露的更新方法也通过 `AggregationUpdate` 接受一个 <<mongo.aggregation, Aggregation Pipeline>>（聚合管道）。
使用 `AggregationUpdate` 可以在更新操作中利用 https://docs.mongodb.com/manual/reference/method/db.collection.update/#update-with-aggregation-pipeline[MongoDB 4.2 聚合] 。
在更新中使用聚合允许通过用单个操作表达多个阶段和多个条件来更新一个或多个字段。

更新可以包括以下几个阶段:

* `AggregationUpdate.set(...).toValue(...)` -> `$set : { ... }`
* `AggregationUpdate.unset(...)` -> `$unset : [ ... ]`
* `AggregationUpdate.replaceWith(...)` -> `$replaceWith : { ... }`

.Update Aggregation
====
[source,java]
----
AggregationUpdate update = Aggregation.newUpdate()
    .set("average").toValue(ArithmeticOperators.valueOf("tests").avg())     <1>
    .set("grade").toValue(ConditionalOperators.switchCases(                 <2>
        when(valueOf("average").greaterThanEqualToValue(90)).then("A"),
        when(valueOf("average").greaterThanEqualToValue(80)).then("B"),
        when(valueOf("average").greaterThanEqualToValue(70)).then("C"),
        when(valueOf("average").greaterThanEqualToValue(60)).then("D"))
        .defaultTo("F")
    );

template.update(Student.class)                                              <3>
    .apply(update)
    .all();                                                                 <4>
----
[source,javascript]
----
db.students.update(                                                         <3>
   { },
   [
     { $set: { average : { $avg: "$tests" } } },                            <1>
     { $set: { grade: { $switch: {                                          <2>
                           branches: [
                               { case: { $gte: [ "$average", 90 ] }, then: "A" },
                               { case: { $gte: [ "$average", 80 ] }, then: "B" },
                               { case: { $gte: [ "$average", 70 ] }, then: "C" },
                               { case: { $gte: [ "$average", 60 ] }, then: "D" }
                           ],
                           default: "F"
     } } } }
   ],
   { multi: true }                                                          <4>
)
----
<1> 第1个 `$set` 阶段根据 `tests` 字段的平均值（average）计算出一个新的字段 `average`。
<2> 第2个 `$set` 阶段根据第一聚合阶段计算的 `average` 字段，计算新的字段 `grade`。
<3> 该管道在 `students` 集合上运行，并使用 `Student` 作为聚合字段的映射。
<4> 将更新应用于集合中所有匹配的文档。
====

[[mongo-template.find-and-replace]]
=== 查找和替换文档

替换整个 `Document` 的最直接的方法是通过其 `id` 使用 `save` 方法。 `findAndReplace` 提供了一个替代方法，允许通过一个简单的查询来确定要替换的文档。

.查找和替换文档
====
[source,java]
----
Optional<User> result = template.update(Person.class)      <1>
    .matching(query(where("firstame").is("Tom")))          <2>
    .replaceWith(new Person("Dick"))
    .withOptions(FindAndReplaceOptions.options().upsert()) <3>
    .as(User.class)                                        <4>
    .findAndReplace();                                     <5>
----
<1> 使用给定的 `domain` 类型的 fluent 更新 API 来映射查询并推导出集合名称，或者直接使用 `MongoOperations#findAndReplace`。
<2> 针对给定的 domain 类型映射的实际匹配查询。通过查询提供 `sort`、`fields` 和 `collation` 设置。
<3> 额外的可选 hook，提供除默认值以外的选项，如 `upsert`。
<4> 用于映射操作结果的可选投影类型。如果没有，则使用初始 domain 类型。
<5> 触发实际处理。使用 `findAndReplaceValue` 来获得可能为 `null` 的结果，而不是一个 `Optional`。
====

IMPORTANT: 请注意，替换的文档本身不能持有一个 `id`，因为现有的 `Document` 的 `id` 会被 store 本身带入替换的文档中。另外请记住，`findAndReplace` 只会根据可能给定的排序顺序，替换符合查询条件的第一个文档。

[[mongo-template.delete]]
=== 删除文档的方法

你可以使用五个重载方法中的一个来从数据库中删除一个对象。

====
[source,java]
----
template.remove(tywin, "GOT");                                              <1>

template.remove(query(where("lastname").is("lannister")), "GOT");           <2>

template.remove(new Query().limit(3), "GOT");                               <3>

template.findAllAndRemove(query(where("lastname").is("lannister"), "GOT");  <4>

template.findAllAndRemove(new Query().limit(3), "GOT");                     <5>
----
<1> 从关联的集合中移除由其 `_id` 指定的单个实体。
<2> 从 `GOT` 集合中删除所有符合查询条件的文文档。
<3> 删除 `GOT` 集合中的前三个文档。与 <2> 不同的是，要删除的文档是通过它们的 `_id` 来识别的，运行给定的查询，先应用 `sort`、`limit` 和 `skip` 选项，然后在一个单独的步骤中一次性删除所有的文档。
<4> 从 `GOT` 集合中删除所有符合查询条件的文档。与<3>不同，文档不会被批量删除，而是一个一个地删除。
<5> 删除 `GOT` 集合中的前三个文档。与 <3> 不同，文档不会被批量删除，而是一个一个地删除。
====

[[mongo-template.optimistic-locking]]
=== 乐观锁

`@Version` 注解提供了类似于 JPA 在 MongoDB 上下文中的语法，并确保更新只应用于具有匹配 `version` 的文档。因此，`version` 属性的实际值被添加到更新查询中，如果在此期间另一个操作改变了文档，那么更新就不会有任何影响。在这种情况下，会抛出一个 `OptimisticLockingFailureException`。下面的例子显示了这些特征。

====
[source,java]
----
@Document
class Person {

  @Id String id;
  String firstname;
  String lastname;
  @Version Long version;
}

Person daenerys = template.insert(new Person("Daenerys"));                            <1>

Person tmp = template.findOne(query(where("id").is(daenerys.getId())), Person.class); <2>

daenerys.setLastname("Targaryen");
template.save(daenerys);                                                              <3>

template.save(tmp); // throws OptimisticLockingFailureException                       <4>
----
<1> 部分插入文档。 `version` 设置为 `0`。
<2> 加载刚插入的文档。`version` 仍为 `0`。
<3> 用 `version = 0` 来更新文件。设置 `lastname` 并将 `version` 自增到 `1`。
<4> 尝试更新先前加载的文件，该文件仍然是 `version = 0`。由于当前的 `version` 是 `1`，操作失败，出现了 `OptimisticLockingFailureException`。
====

IMPORTANT: 乐观锁要求将 `WriteConcern` 设置为 `ACKNOWLEDGED`。否则， `OptimisticLockingFailureException` 会被吞掉。

NOTE: 从 2.2 版开始，`MongoOperations` 在从数据库中删除实体时也包括 `@Version` 属性。要删除一个没有版本检查的 `Document`，请使用 `MongoOperations#remove(Query,…)` 而不是 `MongoOperations#remove(Object)`。

NOTE: 从 2.2 版本开始，repository 在删除有 `version` 实体时检查确认的删除结果。如果一个有 `version` 的实体不能通过 `CrudRepository.delete(Object)` 被删除，就会引发一个 `OptimisticLockingFailureException`。在这种情况下，`version` 被改变了，或者该对象在这期间被删除了。
使用 `CrudRepository.deleteById(ID)` 可以绕过乐观锁特性，删除对象而不考虑其版本。

[[mongo.query]]
== 查询文档

你可以使用 `Query` 和 `Criteria` 类来表达你的查询。它们的方法名称反映了 MongoDB 的本地操作符名称，如 `lt`、`lte`、`is` 等。`Query` 和 `Criteria` 类遵循 fluent API 风格，
因此你可以将多个 `criteria` 和 `query` 方法连在一起，同时拥有易于理解的代码。 为了提高可读性，静态导入让你避免使用 'new' 关键字来创建 `Query` 和 `Criteria` 实例。你也可以使用 `BasicQuery` 来从普通的 JSON 字符串中创建 `Query` 实例，如下例所示。

.从一个普通的 JSON 字符串创建一个 Query 实例
====
[source,java]
----
BasicQuery query = new BasicQuery("{ age : { $lt : 50 }, accounts.balance : { $gt : 1000.00 }}");
List<Person> result = mongoTemplate.find(query, Person.class);
----
====

Spring MongoDB 还支持 `GeoSpatial` 查询（见 <<mongo.geospatial,GeoSpatial Queries>>）和 Map-Reduce 操作（见 <<mongo.mapreduce,Map-Reduce>>  部分）。

[[mongodb-template-query]]
=== 查询集合中的文档

在前面，我们看到了如何通过使用 `MongoTemplate` 上的 `findOne` 和 `findById` 方法来检索单个文档。这些方法返回一个单一的 domain 对象。
我们也可以查询一个文档的集合，将其作为 domain 对象的列表返回。假设我们有一些带有 `name` 和 `age` 的 `Person` 对象作为文档存储在一个集合中，
并且每个 `person` 都有一个带有 `balance` 的嵌入的 `account` 文档，我们现在可以使用下面的代码运行一个查询。

.使用 `MongoTemplate` 查询文档
====
[source,java]
----
import static org.springframework.data.mongodb.core.query.Criteria.where;
import static org.springframework.data.mongodb.core.query.Query.query;

// ...

List<Person> result = template.query(Person.class)
  .matching(query(where("age").lt(50).and("accounts.balance").gt(1000.00d)))
  .all();
----
====

所有的查找方法都需要一个 `Query` 对象作为参数。这个对象定义了用于执行查询的 `criteria` 和选项。`criteria` 是通过使用一个 `Criteria` 对象来指定的，该对象有一个静态工厂方法，名为 `where`，用来实例化一个新的 `Criteria` 对象。我们推荐使用 `org.springframework.data.mongodb.core.query.Criteria.where` 和 `Query.query` 的静态导入，使 `query` 更易读。

该查询应该返回一个符合指定条件（criteria）的 `Person` 对象的列表。本节的其余部分列出了 `Criteria` 和 `Query` 类的方法，这些方法对应于 MongoDB 中提供的操作符。大多数方法都返回 `Criteria` 对象，以便为 API 提供一种 fluent 的风格。

[[mongodb-template-query.criteria]]
==== Criteria 类的方法

`Criteria` 类提供了以下方法，它们都对应于 MongoDB 中的操作符。

* `Criteria` *all* `(Object o)` 使用 `$all` 操作符创建一个 criterion。
* `Criteria` *and* `(String key)` 在当前的 `Criteria` 中添加一个带有指定 `key` 的 `Criteria` 调用链 ，并返回新创建的 `Criteria` 。
* `Criteria` *andOperator* `(Criteria... criteria)` 使用 `$and` 操作符为所有提供的 `criteria` 创建一个 `and` 查询（需要 MongoDB 2.0 或更高版本）。
* `Criteria` *andOperator* `(Collection<Criteria> criteria)` 使用 `$and` 操作符为所有提供的 `criteria` 创建一个 `and` 查询（需要 MongoDB 2.0 或更高版本）。
* `Criteria` *elemMatch* `(Criteria c)` 使用 `$elemMatch` 操作符创建一个 criteria。
* `Criteria` *exists* `(boolean b)` 使用 `$exists` 操作符创建一个 criteria
* `Criteria` *gt* `(Object o)` 使用 `$gt` 操作符创建一个 criteria
* `Criteria` *gte* `(Object o)` 使用 `$gte` 操作符创建一个 criteria
* `Criteria` *in* `(Object... o)` 使用 `$in` 操作符为可边长参数创建一个 criteria。
* `Criteria` *in* `(Collection<?> collection)` 使用 `$in` 操作符创建一个 criteria，使用一个集合。
* `Criteria` *is* `(Object o)` 使用字段匹配（`{ key:value }`）创建一个 criteria。如果指定的值是一个文档，那么字段的顺序和在文档中的完全相等就很重要。
* `Criteria` *lt* `(Object o)` 使用 `$lt` 操作符创建一个 criteria。
* `Criteria` *lte* `(Object o)` 使用 `$lte` 操作符创建一个 criteria。
* `Criteria` *mod* `(Number value, Number remainder)` 使用 `$mod` 操作符创建一个 criteria。
* `Criteria` *ne* `(Object o)` 使用 `$ne` 操作符创建一个 criteria。
* `Criteria` *nin* `(Object... o)` 使用 `$nin` 操作符创建一个 criteria。
* `Criteria` *norOperator* `(Criteria... criteria)` 使用 `$nor` 操作符对所有提供的 criteria 创建一个 nor 查询。
* `Criteria` *norOperator* `(Collection<Criteria> criteria)`  使用 `$nor` 操作符对所有提供的 criteria 创建一个 nor 查询。
* `Criteria` *not* `()` 使用 `$not` 元操作符创建一个 criteria，该 criteria 会影响到后面直接的子句。
* `Criteria` *orOperator* `(Criteria... criteria)` 使用 `$or` 操作符为所有提供的 criteria 创建一个 or 查询。
* `Criteria` *orOperator* `(Collection<Criteria> criteria)` 使用 `$or` 操作符为所有提供的 criteria 创建一个 or 查询。
* `Criteria` *regex* `(String re)` 使用 `$regex` 操作符创建一个 criteria。
* `Criteria` *sampleRate* `(double sampleRate)` 使用 `$sampleRate` 操作符创建一个 criteria。
* `Criteria` *size* `(int s)` 使用 `$size` 操作符创建一个 criteria。
* `Criteria` *type* `(int t)` 使用 `$type` 操作符创建一个 criteria。
* `Criteria` *matchingDocumentStructure* `(MongoJsonSchema schema)` 使用 `$jsonSchema` 操作符为 <<mongo.jsonSchema,JSON schema criteria>> 创建一个 criteria。 `$jsonSchema` 只能应用于查询的顶层，而不是特定的属性。使用 schema 的 `properties` 属性来匹配嵌套字段。
* `Criteria` *bits()* 是通往 https://docs.mongodb.com/manual/reference/operator/query-bitwise/[MongoDB bit 数查询操作符] （如 `$bitsAllClear`）的 gateway。

Criteria 类还为地理空间（geospatial）查询提供了以下方法（见 <<mongo.geospatial,GeoSpatial Queries>> 一节，可以看到它们的实际应用）。

* `Criteria` *within* `(Circle circle)` 使用 `$geoWithin $center` 运算符创建一个地理空间 criteria。
* `Criteria` *within* `(Box box)` 使用 `$geoWithin $box` 运算符创建一个地理空间 criteria。
* `Criteria` *withinSphere* `(Circle circle)` 使用 `$geoWithin $center` 运算符创建一个地理空间 criteria。
* `Criteria` *near* `(Point point)` 使用 `$near` 运算符创建一个地理空间 criteria。
* `Criteria` *nearSphere* `(Point point)` 使用 `$nearSphere$center` 运算符创建一个地理空间 criteria。这仅适用于 MongoDB 1.7 及以上版本。
* `Criteria` *minDistance* `(double minDistance)` 使用 `$minDistance` 运算符创建一个地理空间 criteria，供 `$near` 使用。
* `Criteria` *maxDistance* `(double maxDistance)` 使用 `$maxDistance` 运算符创建一个地理空间 criteria，供 `$near` 使用。


[[mongodb-template-query.query]]
==== Query 类的方法

`Query` 类有一些额外的方法，为查询提供选项。

* `Query` *addCriteria* `(Criteria criteria)` 用来为 query 添加额外的 criteria。
* `Field` *fields* `()` 用于定义要包含在 query 结果中的字段。
* `Query` *limit* `(int limit)` 用于将返回结果的大小限制在所提供的限度内（用于分页）。
* `Query` *skip* `(int skip)` 用来跳过结果中所提供的文档数量（用于分页）。
* `Query` *with* `(Sort sort)` 用来为结果提供排序定义。

[[mongo-template.querying.field-selection]]
==== 选择字段

MongoDB 支持 对查询返回的 https://docs.mongodb.com/manual/tutorial/project-fields-from-query-results/[字段投影] 。一个投影可以根据字段的名称包括和排除字段（除非明确排除，否则 `_id` 字段总是包括在内）。

.选择结果字段
====
[source,java]
----
public class Person {

    @Id String id;
    String firstname;

    @Field("last_name")
    String lastname;

    Address address;
}

query.fields().include("lastname");              <1>

query.fields().exclude("id").include("lastname") <2>

query.fields().include("address")                <3>

query.fields().include("address.city")           <4>


----
<1> 结果将同时包含 `_id` 和 `last_name`，`{ "last_name" : 1 }`。
<2> 结果只包含 `last_name`，`{ "_id" : 0, "last_name" : 1 }`。
<3> 结果将包含 `_id` 和整个 `address` 对象，`{ "address" : 1 }`。
<4> 结果将包含 `_id` 和 `address` 对象，该对象只包含 `city` 字段， `{ "address.city" : 1 }`.
====

从 MongoDB 4.4 开始，你可以使用聚合表达式进行字段投影，如下所示。

.使用表达式计算结果字段
====
[source,java]
----
query.fields()
  .project(MongoExpression.create("'$toUpper' : '$last_name'"))         <1>
  .as("last_name");                                                     <2>

query.fields()
  .project(StringOperators.valueOf("lastname").toUpper())               <3>
  .as("last_name");

query.fields()
  .project(AggregationSpELExpression.expressionOf("toUpper(lastname)")) <4>
  .as("last_name");
----
<1> 使用一个原生表达式。使用的字段名必须是指数据库文档中的字段名。
<2> 指定表达式结果被投射到的字段名。由此产生的字段名不会针对 domain model 进行映射。
<3> 使用 `AggregationExpression`。除了原生的 `MongoExpression` 外，字段名被映射到 domain 模型中使用的字段名。
<4> 使用 SpEL 和 `AggregationExpression` 来调用表达式函数。字段名被映射到 domain 模型中使用的字段名。
====

`@Query(fields="…")` 允许在 Repository 级别使用表达式字段投影，如 <<mongodb.repositories.queries.json-based>> 中所述。

[[mongo-template.querying]]
=== 文档查询方法

这些查询方法需要指定返回的目标类型 `T`，而且它们被重载了，有一个明确的集合名称，用于查询应该操作的集合，而不是返回类型所指示的那个。下面的查询方法让你找到一个或多个文档。

* *findAll*: 从集合中查询类型为 `T` 的对象列表。
* *findOne*: 将集合上的临时查询结果映射到一个指定类型的对象的单个实例。
* *findById*: 返回一个具有给定ID和目标类的对象。
* *find*: 将集合上的临时查询结果映射到指定类型的 List。
* *findAndRemove*: 将集合上的临时查询结果映射到一个指定类型的对象的单个实例。匹配查询的第一个文档被返回并从数据库中的集合中删除。

[[mongo-template.query.distinct]]
=== 查询不同（Distinct ）的值

MongoDB 提供了一个操作，通过使用从结果文档中的查询来获取单个字段的不同值。结果值不需要具有相同的数据类型，该功能也不限于简单类型。对于检索来说，实际的结果类型对于 conversion 和 typing 来说的确很重要。下面的例子显示了如何查询不同的值。

.检索不同的值
====
[source,java]
----
template.query(Person.class)  <1>
  .distinct("lastname")       <2>
  .all();                     <3>
----
<1> 查询 `Person` 集合。
<2> 选择 `lastname` 字段的不同值。字段名根据 domain 类型属性声明进行映射，考虑到潜在的 `@Field` 注解。
<3> 以 `Object` 的 `List` 形式检索所有不同的值（由于没有明确指定结果类型）。
====

检索不同的值到 `Object` 的 `Collection` 中是最灵活的方式，因为它试图确定 domain 类型的属性值，并将结果转换为所需的类型或映射 `Document` 结构。

有时，当所需字段的所有值都固定为某一类型时，直接获得一个正确类型的 `Collection` 更为方便，如下例所示。

.检索强类型的不同值
====
[source,java]
----
template.query(Person.class)  <1>
  .distinct("lastname")       <2>
  .as(String.class)           <3>
  .all();                     <4>
----
<1> 查询 `Person` 的集合。
<2> 选择 `lastname` 字段的不同值。字段名根据domain类型属性声明进行映射，考虑到潜在的 `@Field` 注解。
<3> 检索到的值被转换为所需的目标类型 — 在本例中是 `String`。如果存储的字段包含一个文档，也有可能将值映射到一个更复杂的类型。
<4> 检索所有不同的值，作为一个 `List<String>` 。如果该类型不能被转换为所需的目标类型，该方法会抛出一个 `DataAccessException`。
====

[[mongo.geospatial]]
=== GeoSpatial 查询

MongoDB通过使用 `$near`、`$within`、`geoWithin` 和 `$nearSphere` 等操作符支持地理空间查询。地理空间查询的特定方法在 `Criteria` 类中可用。还有一些形状类（`Box`、`Circle` 和 `Point`）可以与地理空间相关的 `Criteria` 方法一起使用。

NOTE: 在 MongoDB 事务中使用 GeoSpatial 查询时需要注意，见 <<mongo.transactions.behavior>>。

为了了解如何进行 GeoSpatial 查询，请考虑以下 `Venue` 类（取自集成测试，并依赖于丰富的 `MappingMongoConverter`）。

[source,java]
----
@Document(collection="newyork")
public class Venue {

  @Id
  private String id;
  private String name;
  private double[] location;

  @PersistenceConstructor
  Venue(String name, double[] location) {
    super();
    this.name = name;
    this.location = location;
  }

  public Venue(String name, double x, double y) {
    super();
    this.name = name;
    this.location = new double[] { x, y };
  }

  public String getName() {
    return name;
  }

  public double[] getLocation() {
    return location;
  }

  @Override
  public String toString() {
    return "Venue [id=" + id + ", name=" + name + ", location="
        + Arrays.toString(location) + "]";
  }
}
----

要找到一个 `Circle` 内的地点，你可以使用以下查询。

[source,java]
----
Circle circle = new Circle(-73.99171, 40.738868, 0.01);
List<Venue> venues =
    template.find(new Query(Criteria.where("location").within(circle)), Venue.class);
----

要想用球面坐标找到 `Circle` 内的地点，可以使用以下查询。

[source,java]
----
Circle circle = new Circle(-73.99171, 40.738868, 0.003712240453784);
List<Venue> venues =
    template.find(new Query(Criteria.where("location").withinSphere(circle)), Venue.class);
----

要在一个 `Box` 里找到地点，你可以使用以下查询。

[source,java]
----
//lower-left then upper-right
Box box = new Box(new Point(-73.99756, 40.73083), new Point(-73.988135, 40.741404));
List<Venue> venues =
    template.find(new Query(Criteria.where("location").within(box)), Venue.class);
----

要找到一个 `Point` 附近的地点，你可以使用以下查询。

[source,java]
----
Point point = new Point(-73.99171, 40.738868);
List<Venue> venues =
    template.find(new Query(Criteria.where("location").near(point).maxDistance(0.01)), Venue.class);
----

[source,java]
----
Point point = new Point(-73.99171, 40.738868);
List<Venue> venues =
    template.find(new Query(Criteria.where("location").near(point).minDistance(0.01).maxDistance(100)), Venue.class);
----

要使用球面坐标找到一个 `Point` 附近的位置，可以使用以下查询。

[source,java]
----
Point point = new Point(-73.99171, 40.738868);
List<Venue> venues =
    template.find(new Query(
        Criteria.where("location").nearSphere(point).maxDistance(0.003712240453784)),
        Venue.class);
----

[[mongo.geo-near]]
==== 地域附近查询

[WARNING]
====
*Changed in 2.2!* +
https://docs.mongodb.com/master/release-notes/4.2-compatibility/[MongoDB 4.2] 删除了对 `geoNear` 命令的支持，该命令之前被用于运行 `NearQuery`。

Spring Data MongoDB 2.2 `MongoOperations#geoNear` 使用 `$geoNear`  https://docs.mongodb.com/manual/reference/operator/aggregation/geoNear/[aggregation] 而不是 `geoNear` 命令来运行 `NearQuery`。

以前在包装类型中返回的计算距离（使用 `geoNear` 命令时的 `dis`）现在被嵌入到结果文档中。如果给定的 domain 类型已经包含了一个具有该名称的属性，那么计算出的距离将被命名为带有潜在随机后缀的 `calculated-distance`。

目标类型可以包含一个以返回的距离命名的属性，以（另外）直接读回 domain 类型中，如下图所示。

[source,java]
----
GeoResults<VenueWithDisField> = template.query(Venue.class) <1>
    .as(VenueWithDisField.class)                            <2>
    .near(NearQuery.near(new GeoJsonPoint(-73.99, 40.73), KILOMETERS))
    .all();
----
<1> 用于识别目标集合和潜在查询映射的domain类型。
<2> 目标类型包含一个 `Number` 类型的 `dis` 字段。
====

MongoDB 支持查询数据库中的地理位置，并同时计算与给定原点的距离。通过地理距离查询，你可以表达诸如 "找到周围 10 英里内的所有餐馆" 这样的查询。为了让你这样做， `MongoOperations` 提供了 `geoNear(…)` 方法，该方法以 `NearQuery` 为参数（以及已经熟悉的实体类型和集合），如下面的例子中所示。

[source,java]
----
Point location = new Point(-73.99171, 40.738868);
NearQuery query = NearQuery.near(location).maxDistance(new Distance(10, Metrics.MILES));

GeoResults<Restaurant> = operations.geoNear(query, Restaurant.class);
----

我们使用 `NearQuery` builder API 来设置一个查询，以返回给定 `Point` 周围 10 英里以内的所有 `Restaurant` 实例。这里使用的 `Metrics` 枚举实际上实现了一个接口，这样其他的度量（metric）也可以插入到一个距离中。一个 `Metric` 由一个乘数支持，用于将给定度量标准的距离值转换成本地距离。这里显示的例子会认为10是英里。使用一个内置的度量（英里和公里）会自动触发球形标志在查询中被设置。如果你想避免这种情况，可以将普通的 double 值传入 `maxDistance(…)`。欲了解更多信息，请参见 `NearQuery` 和 `Distance` 的  https://docs.spring.io/spring-data/mongodb/docs/{version}/api/index.html[JavaDoc]。

geo-near 操作返回一个封装 `GeoResult` 实例的 `GeoResults` 包装对象。包裹 `GeoResults` 可以访问所有结果的平均距离。一个 `GeoResult` 对象携带着所发现的实体以及它与原点的距离。

[[mongo.geo-json]]
=== GeoJSON 支持

MongoDB 支持地理空间数据的 https://geojson.org/[GeoJSON] 和简单（遗留）坐标对。这些格式既可用于存储，也可用于查询数据。请参阅 https://docs.mongodb.org/manual/core/2dsphere/#geospatial-indexes-store-geojson/[MongoDB 关于 GeoJSON 支持]  的手册，以了解有关要求和限制。

[[mongo.geo-json.domain.classes]]
==== Domain 类中的 GeoJSON 类型

在 domain 类中使用 https://geojson.org/[GeoJSON] 类型是很直接的。`org.springframework.data.mongodb.core.geo` 包包含了 `GeoJsonPoint`、 `GeoJsonPolygon` 和其他类型。这些类型是对现有 `org.springframework.data.geo` 类型的扩展。下面的例子使用了一个 `GeoJsonPoint`。

====
[source,java]
----
public class Store {

	String id;

	/**
	 * location is stored in GeoJSON format.
	 * {
	 *   "type" : "Point",
	 *   "coordinates" : [ x, y ]
	 * }
	 */
	GeoJsonPoint location;
}
----
====

[TIP]
====
如果一个 GeoJSON 对象的坐标（`coordinates`）代表经度和纬度对，则首先是经度（`latitude`），然后是纬度（`longitude`）。 因此，`GeoJsonPoint` 将 `getX()` 视为经度，将 `getY()` 视为纬度。
====

[[mongo.geo-json.query-methods]]
==== Repository 查询方法中的 GeoJSON 类型

使用 GeoJSON 类型作为 repository 的查询参数，在创建查询时必须使用 `$geometry` 操作符，如下例所示。

====
[source,java]
----
public interface StoreRepository extends CrudRepository<Store, String> {

	List<Store> findByLocationWithin(Polygon polygon);  <1>

}

/*
 * {
 *   "location": {
 *     "$geoWithin": {
 *       "$geometry": {
 *         "type": "Polygon",
 *         "coordinates": [
 *           [
 *             [-73.992514,40.758934],
 *             [-73.961138,40.760348],
 *             [-73.991658,40.730006],
 *             [-73.992514,40.758934]
 *           ]
 *         ]
 *       }
 *     }
 *   }
 * }
 */
repo.findByLocationWithin(                              <2>
  new GeoJsonPolygon(
    new Point(-73.992514, 40.758934),
    new Point(-73.961138, 40.760348),
    new Point(-73.991658, 40.730006),
    new Point(-73.992514, 40.758934)));                 <3>

/*
 * {
 *   "location" : {
 *     "$geoWithin" : {
 *        "$polygon" : [ [-73.992514,40.758934] , [-73.961138,40.760348] , [-73.991658,40.730006] ]
 *     }
 *   }
 * }
 */
repo.findByLocationWithin(                              <4>
  new Polygon(
    new Point(-73.992514, 40.758934),
    new Point(-73.961138, 40.760348),
    new Point(-73.991658, 40.730006)));
----
<1> Repository 方法的定义使用共通类型，允许用 GeoJSON 和传统格式调用它。
<2> 使用 GeoJSON 类型来使用 `$geometry` 运算符。
<3> 请注意，GeoJSON 多边形需要定义一个封闭的环（closed ring）。
<4> 使用传统格式的 `$polygon` 操作符。
====

[[mongo.geo-json.metrics]]
==== 指标（Metric）和距离（Distance）计算

然后 MongoDB 的 `$geoNear` 运算符允许使用 GeoJSON 点或传统的坐标对。

====
[source,java]
----
NearQuery.near(new Point(-73.99171, 40.738868))
----
[source,json]
----
{
  "$geoNear": {
    //...
    "near": [-73.99171, 40.738868]
  }
}
----
====
====
[source,java]
----
NearQuery.near(new GeoJsonPoint(-73.99171, 40.738868))
----
[source,json]
----
{
  "$geoNear": {
    //...
    "near": { "type": "Point", "coordinates": [-73.99171, 40.738868] }
  }
}

----
====

虽然在语法上不同，但无论集合中的目标文档使用什么格式，服务器都能接受这两种格式。

WARNING: 在距离计算方面有很大的不同。使用传统格式的操作 在一个类似于地球的球体上操作 Radians，而 GeoJSON 格式则使用 Meters。

为了避免这种头痛的问题，请确保将 `Metric` 设置为所需的测量单位，以确保正确计算距离。

换言之:

====
假设你有5个像下面这样的文档。
[source,json]
----
{
    "_id" : ObjectId("5c10f3735d38908db52796a5"),
    "name" : "Penn Station",
    "location" : { "type" : "Point", "coordinates" : [  -73.99408, 40.75057 ] }
}
{
    "_id" : ObjectId("5c10f3735d38908db52796a6"),
    "name" : "10gen Office",
    "location" : { "type" : "Point", "coordinates" : [ -73.99171, 40.738868 ] }
}
{
    "_id" : ObjectId("5c10f3735d38908db52796a9"),
    "name" : "City Bakery ",
    "location" : { "type" : "Point", "coordinates" : [ -73.992491, 40.738673 ] }
}
{
    "_id" : ObjectId("5c10f3735d38908db52796aa"),
    "name" : "Splash Bar",
    "location" : { "type" : "Point", "coordinates" : [ -73.992491, 40.738673 ] }
}
{
    "_id" : ObjectId("5c10f3735d38908db52796ab"),
    "name" : "Momofuku Milk Bar",
    "location" : { "type" : "Point", "coordinates" : [ -73.985839, 40.731698 ] }
}
----
====

使用GeoJSON获取从 `[-73.99171, 40.738868]` 的 400 米半径内的所有文档，看起来像这样。

.GeoNear with GeoJSON
====
[source,json]
----
{
    "$geoNear": {
        "maxDistance": 400, <1>
        "num": 10,
        "near": { type: "Point", coordinates: [-73.99171, 40.738868] },
        "spherical":true, <2>
        "key": "location",
        "distanceField": "distance"
    }
}
----
返回以下3个文档:
[source,json]
----
{
    "_id" : ObjectId("5c10f3735d38908db52796a6"),
    "name" : "10gen Office",
    "location" : { "type" : "Point", "coordinates" : [ -73.99171, 40.738868 ] }
    "distance" : 0.0 <3>
}
{
    "_id" : ObjectId("5c10f3735d38908db52796a9"),
    "name" : "City Bakery ",
    "location" : { "type" : "Point", "coordinates" : [ -73.992491, 40.738673 ] }
    "distance" : 69.3582262492474 <3>
}
{
    "_id" : ObjectId("5c10f3735d38908db52796aa"),
    "name" : "Splash Bar",
    "location" : { "type" : "Point", "coordinates" : [ -73.992491, 40.738673 ] }
    "distance" : 69.3582262492474 <3>
}
----
<1> 与中心点的最大距离，单位：米 (Meters)。
<2> GeoJSON 总是在一个球体上操作。
<3> 与中心点的距离，单位是米(Meters)。
====

现在，当使用传统的坐标对时，就像之前讨论的那样，在 `Radians` 上操作。所以我们在构建 `$geoNear` 命令时使用 `Metrics#KILOMETERS`。`Metric` 确保距离乘数被正确设置。

.GeoNear with Legacy Coordinate Pairs
====
[source,json]
----
{
    "$geoNear": {
        "maxDistance": 0.0000627142377, <1>
        "distanceMultiplier": 6378.137, <2>
        "num": 10,
        "near": [-73.99171, 40.738868],
        "spherical":true, <3>
        "key": "location",
        "distanceField": "distance"
    }
}
----
返回 3 个文档，就像 GeoJSON 的变体。:
[source,json]
----
{
    "_id" : ObjectId("5c10f3735d38908db52796a6"),
    "name" : "10gen Office",
    "location" : { "type" : "Point", "coordinates" : [ -73.99171, 40.738868 ] }
    "distance" : 0.0 <4>
}
{
    "_id" : ObjectId("5c10f3735d38908db52796a9"),
    "name" : "City Bakery ",
    "location" : { "type" : "Point", "coordinates" : [ -73.992491, 40.738673 ] }
    "distance" : 0.0693586286032982 <4>
}
{
    "_id" : ObjectId("5c10f3735d38908db52796aa"),
    "name" : "Splash Bar",
    "location" : { "type" : "Point", "coordinates" : [ -73.992491, 40.738673 ] }
    "distance" : 0.0693586286032982 <4>
}
----
<1> 与中心点的最大距离，单位：弧度(Radians)。
<2> 距离的乘数，所以我们得到公里(Kilometers)作为结果距离。
<3> 确保我们对 2d_sphere 索引进行操作。
<4> 与中心点的距离，以公里(Kilometers)为单位—​取其1000倍以匹配GeoJSON变量的米(Meters)数。
====

[[mongo.geo-json.jackson-modules]]
==== GeoJSON Jackson 模块

通过使用 <<core.web>>，Spring Data 为 `ObjectMapper` 注册了额外的 Jackson Moduless，用于反/序列化常见的 Spring Data Domain 类型。请参考 <<core.web.basic.jackson-mappers>> 部分，以了解更多关于此功能的基础设施设置。

MongoDB 模块还通过其暴露于 `GeoJsonModule` 的 `GeoJsonConfiguration` 为以下 GeoJSON 类型注册了 `JsonDeserializer`。
----
org.springframework.data.mongodb.core.geo.GeoJsonPoint
org.springframework.data.mongodb.core.geo.GeoJsonMultiPoint
org.springframework.data.mongodb.core.geo.GeoJsonLineString
org.springframework.data.mongodb.core.geo.GeoJsonMultiLineString
org.springframework.data.mongodb.core.geo.GeoJsonPolygon
org.springframework.data.mongodb.core.geo.GeoJsonMultiPolygon
----

[NOTE]
====
`GeoJsonModule` 只注册了 `JsonDeserializer` ! 为了给 `ObjectMapper` 配备一套对称的 `JsonSerializer`，你需要为 `ObjectMapper` 手动配置这些，
或者提供一个自定义的 `SpringDataJacksonModules` 配置，将 `GeoJsonModule.serializers()` 作为一个 Spring Bean 公开。

[source,java]
----
class GeoJsonConfiguration implements SpringDataJacksonModules {

	@Bean
	public Module geoJsonSerializers() {
		return GeoJsonModule.serializers();
	}
}
----
====

[WARNING]
====
下一个主要版本（`4.0`）将同时注册 `JsonDeserializer` 和 `JsonSerializer`，默认为 GeoJSON 类型。
====

[[mongo.textsearch]]
=== 全文检索

从 MongoDB 的 2.6 版本开始，你可以通过使用 `$text` 操作符来运行全文检索。在 `TextQuery` 和 `TextCriteria` 中，有专门针对全文检索的方法和操作。在进行全文检索时，请参见 https://docs.mongodb.org/manual/reference/operator/query/text/#behavior[MongoDB 参考文档] ，了解其行为和限制。

==== 全文搜索

在你真正使用全文搜索之前，你必须正确设置搜索索引。关于如何创建索引结构的更多细节，请参见 <<mapping-usage-indexes.text-index,Text Index>> 。下面的例子显示了如何设置全文搜索。

[source,javascript]
----
db.foo.createIndex(
{
  title : "text",
  content : "text"
},
{
  weights : {
              title : 3
            }
}
)
----

一个搜索 `coffee cake` 的查询可以被定义并运行如下。

.全文检索
====
[source,java]
----
Query query = TextQuery
  .queryText(new TextCriteria().matchingAny("coffee", "cake"));

List<Document> page = template.find(query, Document.class);
----
====

要根据 `weights` 按相关性对结果进行排序，请使用 `TextQuery.sortByScore`。

.全文查询 - 按 Score 排序
====
[source,java]
----
Query query = TextQuery
  .queryText(new TextCriteria().matchingAny("coffee", "cake"))
  .sortByScore() <1>
  .includeScore(); <2>

List<Document> page = template.find(query, Document.class);
----
<1> 使用 score 属性按相关性对结果进行排序，这会触发 `.sort({'score': {'$meta': 'textScore'}})`。
<2> 使用 `TextQuery.includeScore()` 将计算出的相关性包括在结果的 `Document` 中。
====

你可以通过在搜索词前加上 `-` 或者使用 `notMatching` 来排除搜索词，如下例所示（注意，这两行有相同的效果，因此是多余的）。

[source,java]
----
// search for 'coffee' and not 'cake'
TextQuery.queryText(new TextCriteria().matching("coffee").matching("-cake"));
TextQuery.queryText(new TextCriteria().matching("coffee").notMatching("cake"));
----

`TextCriteria.matching` 将提供的术语作为原样。因此，你可以通过把短语放在双引号之间（例如，`\"coffee cake\"`)）或使用 `TextCriteria.phrase` 来定义短语。下面的例子显示了定义短语的两种方式。

[source,java]
----
// search for phrase 'coffee cake'
TextQuery.queryText(new TextCriteria().matching("\"coffee cake\""));
TextQuery.queryText(new TextCriteria().phrase("coffee cake"));
----

你可以通过使用 `TextCriteria` 上的相应方法为 `$caseSensitive` 和 `$diacriticSensitive` 设置标志。请注意，这两个可选的标志在 MongoDB 3.2 中被引入，除非明确设置，否则不包括在查询中。

[[mongo.collation]]
=== Collations

从 3.4 版本开始，MongoDB 支持用于集合和索引创建以及各种查询操作的校对。Collations 定义了基于 http://userguide.icu-project.org/collation/concepts[ICU collations] 的字符串比较规则。一个 collation 文档由各种属性组成，这些属性被封装在 `Collation` 中，如下面的列表所示。

====
[source,java]
----
Collation collation = Collation.of("fr")         <1>

  .strength(ComparisonLevel.secondary()          <2>
    .includeCase())

  .numericOrderingEnabled()                      <3>

  .alternate(Alternate.shifted().punct())        <4>

  .forwardDiacriticSort()                        <5>

  .normalizationEnabled();                       <6>
----
<1> `Collation` 需要一个 locale 来创建。这可以是一个字符串表示的 locale，一个 `Locale`（考虑到语言、国家和变体）或一个 `CollationLocale`。locale 对于创建来说是强制性的。
<2> `Collation` 强度定义了表示字符之间差异的比较级别。你可以根据选择的强度配置各种选项（大小写敏感度、大小写排序和其他）。
<3> 指定是将数字字符串作为数字还是字符串进行比较。
<4> 指定整理是否应将空白和标点符号作为比较的基础字符。
<5> 指定带有变音符的字符串是否从字符串的后面排序，如某些法语词典的排序。
<6> 指定是否检查文本是否需要规范化以及是否执行规范化。
====

Collation 可以被用来创建集合和索引。如果你创建了一个指定了 Collation 的集合，除非你指定了不同的 Collation，否则该 Collation 将应用于索引的创建和查询。一个 Collation 对整个操作是有效的，不能在每个字段的基础上指定。

像其他元数据一样，整理可以通过 `@Document` 注解的 `collation` 属性从 domain 类型中导出，并将在运行查询、创建集合或索引时直接应用。


NOTE: 当 MongoDB 在第一次交互时自动创建一个集合时，将不使用注解的排序。这将需要额外的存储互动，延迟整个过程。请在这些情况下使用 `MongoOperations.createCollection`。

[source,java]
----
Collation french = Collation.of("fr");
Collation german = Collation.of("de");

template.createCollection(Person.class, CollectionOptions.just(collation));

template.indexOps(Person.class).ensureIndex(new Index("name", Direction.ASC).collation(german));
----

NOTE: 如果没有指定 collation （`Collation.simple()`），MongoDB 使用简单的二进制比较。

在集合操作中使用 collation，只需在查询或操作选项中指定一个 `Collation` 实例，正如下面两个例子所示。

.使用 `find` 的 collation
====
[source,java]
----
Collation collation = Collation.of("de");

Query query = new Query(Criteria.where("firstName").is("Amél")).collation(collation);

List<Person> results = template.find(query, Person.class);
----
====

.用 `aggregate` 的 collation
====
[source,java]
----
Collation collation = Collation.of("de");

AggregationOptions options = AggregationOptions.builder().collation(collation).build();

Aggregation aggregation = newAggregation(
  project("tags"),
  unwind("tags"),
  group("tags")
    .count().as("count")
).withOptions(options);

AggregationResults<TagCount> results = template.aggregate(aggregation, "tags", TagCount.class);
----
====

WARNING: 只有当操作使用 collation 与索引 collation 匹配时，才会使用索引。

<<mongo.repositories>>  通过 `@Query` 注解的 `collation` 属性支持 `Collations`。

.对 Repository 的 Collation 的支持
====
[source,java]
----
public interface PersonRepository extends MongoRepository<Person, String> {

  @Query(collation = "en_US")  <1>
  List<Person> findByFirstname(String firstname);

  @Query(collation = "{ 'locale' : 'en_US' }") <2>
  List<Person> findPersonByFirstname(String firstname);

  @Query(collation = "?1") <3>
  List<Person> findByFirstname(String firstname, Object collation);

  @Query(collation = "{ 'locale' : '?1' }") <4>
  List<Person> findByFirstname(String firstname, String collation);

  List<Person> findByFirstname(String firstname, Collation collation); <5>

  @Query(collation = "{ 'locale' : 'en_US' }")
  List<Person> findByFirstname(String firstname, @Nullable Collation collation); <6>
}
----

<1> 静态 `collation` 定义导致 `{ 'locale' : 'en_US' }`。
<2> 静态 `collation` 定义导致 `{ 'locale' : 'en_US' }`。
<3> 根据第2个方法参数进行动态 `collation`。允许的类型包括 `String`（例如：'en_US'），`Locacle`（例如：Locacle.US）。 和 `Document` (例如，`new Document("locale", "en_US")`)
<4> 根据第2个方法参数进行动态 `collation` 。
<5> 在查询中应用 `Collation` 方法参数。
<6> 如果不为 `null`，`Collation` 方法参数将覆盖来自 `@Query` 的默认 `collation`。

NOTE: 如果你启用了 repository 查找方法的自动索引创建功能，那么在创建索引时将包括潜在的静态 collation 定义，如 `(1)` 和 `(2)` 所示。

TIP: 最具体的 `Collation` 比潜在的其他定义更重要。这意味着方法参数优于查询方法注解优于domain类型注解。
====

为了简化整个代码库中 `collation` 属性的使用，也可以使用 `@Collation` 注解，它可以作为上述属性的元注解。同样的规则和位置适用，此外，`@Collation` 的直接使用取代了在 `@Query` 和其他注释中定义的任何 `collation` 值。
这意味着，如果通过 `@Query` 和 `@Collation` 声明了一个 `collation`，那么就从 `@Collation` 中挑选一个。

.使用 `@Collation`
====
[source,java]
----
@Collation("en_US") <1>
class Game {
  // ...
}

interface GameRepository extends Repository<Game, String> {

  @Collation("en_GB")  <2>
  List<Game> findByTitle(String title);

  @Collation("de_AT")  <3>
  @Query(collation="en_GB")
  List<Game> findByDescriptionContaining(String keyword);
}
----
<1> 代替 `@Document(collation=...)`.
<2> 代替 `@Query(collation=...)`.
<3> 倾向于 `@Collation` 而不是 meta 的使用。
====

include::./mongo-json-schema.adoc[leveloffset=+1]

[[mongo.query.fluent-template-api]]
=== Fluent Template API

`MongoOperations` 接口是与 MongoDB 进行更多底层交互的核心组件之一。它提供了广泛的方法，涵盖了从集合创建、索引创建、CRUD操作到更高级的功能，如 Map-Reduce 和聚合。你可以为每个方法找到多个重载。它们中的大多数涵盖了 API 的可选或可忽略的部分。

`FluentMongoOperations` 为 `MongoOperations` 的常用方法提供了一个更窄的接口，并提供了一个更可读的、fluent API。入口点（`insert(…)`、`find(…)`、`update(…)` 等）遵循基于要运行的操作的自然命名模式。从入口点开始，API 被设计成只提供与上下文相关的方法，这些方法会导致一个终止方法，调用实际的 `MongoOperations` 对应的方法—在下面的例子中是 `all` 方法。

====
[source,java]
----
List<SWCharacter> all = ops.find(SWCharacter.class)
  .inCollection("star-wars")                        <1>
  .all();
----
<1> 如果 `SWCharacter` 用 `@Document` 定义了 collection，或者你用类的名字作为 collection 的名字，那就跳过这一步。
====

有时，MongoD 中的一个集合持有不同类型的实体，比如 `SWCharacters` 集合中的 `Jedi`。为了在查询和返回值映射中使用不同的类型，你可以使用 `as(Class<?> targetType)` 来对结果进行不同的映射，如下例所示。

====
[source,java]
----
List<Jedi> all = ops.find(SWCharacter.class)    <1>
  .as(Jedi.class)                               <2>
  .matching(query(where("jedi").is(true)))
  .all();
----
<1> 查询字段是针对 `SWCharacter` 类型进行映射的。
<2> 结果文档被映射到 `Jedi`。
====

TIP: 你可以通过 `as(Class<?>)` 提供目标类型，直接将 <<projections>> 应用于结果文档。

NOTE: 使用投影允许 `MongoTemplate` 通过将实际响应限制在投影目标类型所要求的字段上，来优化结果映射。只要 `Query` 本身不包含任何字段限制，并且目标类型是一个封闭的接口或 DTO 投影，这就适用。

WARNING: 投影不得应用于 <<mapping-usage-references,DBRefs>>。

你可以通过终止方法：`first()`、`one()`、`all()` 或 `stream()`，在检索单个实体和以 `List` 或 `Stream` 形式检索多个实体之间进行切换。

当用 `near(NearQuery)` 编写地理空间查询时，终止方法的数量被改变，只包括在 MongoDB 中运行 `geoNear` 命令的有效方法（在 `GeoResults` 中作为 `GeoResult` 获取实体），如下例所示。

====
[source,java]
----
GeoResults<Jedi> results = mongoOps.query(SWCharacter.class)
  .as(Jedi.class)
  .near(alderaan) // NearQuery.near(-73.9667, 40.78).maxDis…
  .all();
----
====

[[mongo.query.kotlin-support]]
=== Kotlin 的类型安全的查询

Kotlin 通过其语言语法和扩展系统拥抱特定领域的语言创建。Spring Data MongoDB 提供了一个 Kotlin 扩展，用于使用 https://kotlinlang.org/docs/reference/reflection.html#property-references[Kotlin 属性引用]  来构建类型安全的查询。
使用该扩展的查询通常会受益于可读性的提高。`Criteria` 上的大多数关键字都有匹配的 Kotlin 扩展，例如 `inValues` 和 `regex`。

考虑下面的例子，解释类型安全的查询。

====
[source,kotlin]
----
import org.springframework.data.mongodb.core.query.*

mongoOperations.find<Book>(
  Query(Book::title isEqualTo "Moby-Dick")               <1>
)

mongoOperations.find<Book>(
  Query(titlePredicate = Book::title exists true)
)

mongoOperations.find<Book>(
  Query(
    Criteria().andOperator(
      Book::price gt 5,
      Book::price lt 10
    ))
)

// Binary operators
mongoOperations.find<BinaryMessage>(
  Query(BinaryMessage::payload bits { allClear(0b101) }) <2>
)

// Nested Properties (i.e. refer to "book.author")
mongoOperations.find<Book>(
  Query(Book::author / Author::name regex "^H")          <3>
)
----
<1> `isEqualTo()` 是一个 `infix` 扩展函数，接收器（receiver）类型为 `KProperty<T>`，返回 `Criteria`。
<2> 对于位操作符，传递一个 lambda 参数，在这里你调用 `Criteria.BitwiseCriteriaOperators` 中的一个方法。
<3> 要构建嵌套属性，请使用 `/` 字符（重载操作符 `div`）。
====

[[mongo.query.additional-query-options]]
=== 其他查询选项

MongoDB 提供了各种应用元信息的方法，如 comment 或 batch size，到查询中。直接使用 `Query` API，有几种方法可以实现这些选项。

====
[source,java]
----
Query query = query(where("firstname").is("luke"))
    .comment("find luke")         <1>
    .batchSize(100)                                 <2>
----
<1> 该 comment 传播到 MongoDB profile 日志
<2> 每个 response batch 中要返回的文档数量。
====

在 repository 层面，`@Meta` 注解提供了以声明的方式添加查询选项的方法

====
[source,java]
----
@Meta(comment = "find luke", batchSize = 100, flags = { SLAVE_OK })
List<Person> findByFirstname(String firstname);
----
====

include::{spring-data-commons-location}/query-by-example.adoc[leveloffset=+1]
include::query-by-example.adoc[leveloffset=+1]

[[mongo.query.count]]
== 统计文档

在 SpringData MongoDB 3.x 之前的版本中，count 操作使用 MongoDB 的内部集合统计。随着 <<mongo.transactions>> 的引入，这已不再可能，因为统计数据无法正确反映事务过程中的潜在变化，需要采用基于聚合的 count 方法。
因此，在2.x版本中，如果没有事务正在进行，`MongoOperations.count()` 将使用集合统计数据，如果有，则使用聚合变量。

从 Spring Data MongoDB 3.x 开始，任何 `count` 操作都会通过 MongoDB 的 `countDocuments` 使用基于聚合的 `count` 方法，而不考虑过滤条件的存在。如果应用程序对基于集合统计的工作限制没有意见，`MongoOperations.estimatedCount()` 提供了一个替代方案。

[TIP]
====
通过将 `MongoTemplate#useEstimatedCount(…)` 设置为 `true`，`MongoTemplate#count(…)` 操作，即使用空的过滤器查询，将被委托给 `estimatedCount`，只要没有事务活动和 template 没有绑定到  <<mongo.sessions,session>>。仍然可以通过 `MongoTemplate#exactCount` 获得精确的数字，但可能会加快事情的进展。
====

[NOTE]
====
MongoDB 的原生 `countDocuments` 方法和 `$match` 聚合，不支持 `$near` 和 `$nearSphere`，但需要 `$geoWithin` 以及不支持 `$minDistance` 的 `$center` 或 `$centerSphere`（见 https://jira.mongodb.org/browse/SERVER-37043）。

因此，一个给定的 `Query` 将使用 `Reactive`-/`MongoTemplate` 重写 `count` 操作，以绕过这个问题，如下所示。

[source,javascript]
----
{ location : { $near : [-73.99171, 40.738868], $maxDistance : 1.1 } } <1>
{ location : { $geoWithin : { $center: [ [-73.99171, 40.738868], 1.1] } } } <2>

{ location : { $near : [-73.99171, 40.738868], $minDistance : 0.1, $maxDistance : 1.1 } } <3>
{$and :[ { $nor :[ { location :{ $geoWithin :{ $center :[ [-73.99171, 40.738868 ], 0.01] } } } ]}, { location :{ $geoWithin :{ $center :[ [-73.99171, 40.738868 ], 1.1] } } } ] } <4>
----
<1> 使用 `$near` 进行 Count source 查询。
<2> 重写的 query 现在使用 `$geoWithin` 与 `$center`。
<3> 使用 `$near` 与 `$minDistance` 和 `$maxDistance` 进行 Count source 查询。
<4> 重写的 query 现在是 `$nor` `$geowithin` 标准的组合，以解决不支持 `$minDistance` 的问题。
====

[[mongo.mapreduce]]
== Map-Reduce 操作

你可以通过使用 Map-Reduce 来查询 MongoDB，这对批量处理、数据聚合以及查询语言不能满足你的需求时非常有用。

Spring 通过在 `MongoOperations` 上提供方法来简化 Map-Reduce 操作的创建和运行，提供了与 MongoDB 的 Map-Reduce 的集成。它可以将 Map-Reduce 操作的结果转换为 POJO，并与 https://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/core.html#resources[Spring 的 `Resource` 抽象 集成] 。
这让你可以将你的 JavaScript 文件放在文件系统、classpath、HTTP 服务器或任何其他 Spring 资源实现上，然后通过简单的 URI 风格的语法来引用 JavaScript 资源—例如， `classpath:reduce.js;`。
在文件中外部化 JavaScript 代码通常比在代码中作为 Java 字符串嵌入更可取。注意，如果你愿意，你仍然可以将 JavaScript 代码作为 Java 字符串传递。

[[mongo.mapreduce.example]]
=== 使用示例

为了了解如何进行 Map-Reduce 操作，我们使用 _MongoDB - The Definitive Guide_ footnote:[一书中的一个例子。在这个例子中，我们创建了三个文档，其值分别为 [a,b]、[b,c] 和 [c,d]。每个文档中的值都与key "x" 相关，如下例所示（假设这些文档都在一个名为 `jmr1` 的集合中）。]

[source]
----
{ "_id" : ObjectId("4e5ff893c0277826074ec533"), "x" : [ "a", "b" ] }
{ "_id" : ObjectId("4e5ff893c0277826074ec534"), "x" : [ "b", "c" ] }
{ "_id" : ObjectId("4e5ff893c0277826074ec535"), "x" : [ "c", "d" ] }
----


下面的 map 函数对每个文件的每个字母在数组中的出现情况进行统计。

[source,java]
----
function () {
    for (var i = 0; i < this.x.length; i++) {
        emit(this.x[i], 1);
    }
}
----

下面的 reduce 函数对所有文件中每个字母的出现次数进行了累加。

[source,java]
----
function (key, values) {
    var sum = 0;
    for (var i = 0; i < values.length; i++)
        sum += values[i];
    return sum;
}
----

运行前面的函数会得到以下 collection。

[source]
----
{ "_id" : "a", "value" : 1 }
{ "_id" : "b", "value" : 2 }
{ "_id" : "c", "value" : 2 }
{ "_id" : "d", "value" : 1 }
----

假设 map 和 reduce 函数位于 `map.js` 和 `reduce.js` 中，并捆绑在你的 jar 中，因此它们在 classpath 上是可用的，你可以按如下方式运行 Map-Reduce 操作。

[source,java]
----
MapReduceResults<ValueObject> results = mongoOperations.mapReduce("jmr1", "classpath:map.js", "classpath:reduce.js", ValueObject.class);
for (ValueObject valueObject : results) {
  System.out.println(valueObject);
}
----

前面的例子产生了以下输出:

[source]
----
ValueObject [id=a, value=1.0]
ValueObject [id=b, value=2.0]
ValueObject [id=c, value=2.0]
ValueObject [id=d, value=1.0]
----

`MapReduceResults` 类实现了 `Iterable`，并提供了对原始输出、时间和计数统计的访问。下面列出了 `ValueObject` 类:

[source,java]
----
public class ValueObject {

  private String id;
  private float value;

  public String getId() {
    return id;
  }

  public float getValue() {
    return value;
  }

  public void setValue(float value) {
    this.value = value;
  }

  @Override
  public String toString() {
    return "ValueObject [id=" + id + ", value=" + value + "]";
  }
}
----

默认情况下，使用 `INLINE` 的输出类型，因此不需要指定输出集合。要指定额外的 Map-Reduce 选项，请使用一个重载方法，该方法需要一个额外的 `MapReduceOptions` 参数。 `MapReduceOptions` 类有一个 fluent API，所以添加额外的选项可以用紧凑的语法完成。下面的例子将输出集合设置为 `jmr1_out`（注意，只设置输出集合是假设默认输出类型为 `REPLACE`）。

[source,java]
----
MapReduceResults<ValueObject> results = mongoOperations.mapReduce("jmr1", "classpath:map.js", "classpath:reduce.js",
                                                                     new MapReduceOptions().outputCollection("jmr1_out"), ValueObject.class);
----

还有一个静态导入（`import static org.springframework.data.mongodb.core.mapreduce.MapReduceOptions.options;`），可以用来使语法稍微紧凑一些，如下例所示。

[source,java]
----
MapReduceResults<ValueObject> results = mongoOperations.mapReduce("jmr1", "classpath:map.js", "classpath:reduce.js",
                                                                     options().outputCollection("jmr1_out"), ValueObject.class);
----

你也可以指定一个 query ，以减少送入Map-Reduce操作的数据集。下面的例子将包含 [a,b] 的文档从 Map-Reduce 操作的考虑中删除。

[source,java]
----
Query query = new Query(where("x").ne(new String[] { "a", "b" }));
MapReduceResults<ValueObject> results = mongoOperations.mapReduce(query, "jmr1", "classpath:map.js", "classpath:reduce.js",
                                                                     options().outputCollection("jmr1_out"), ValueObject.class);
----

注意，你可以在查询上指定额外的 limit 和 sort 值，但你不能跳过这些值。

[[mongo.server-side-scripts]]
== 脚本操作

[WARNING]
====
https://docs.mongodb.com/master/release-notes/4.2-compatibility/[MongoDB 4.2] 删除了对 `ScriptOperations` 所使用的 `eval` 命令的支持。 对于被删除的功能，没有任何替代物。
====

MongoDB 允许通过直接发送脚本或调用存储的脚本在服务器上运行 `JavaScript` 函数。`ScriptOperations` 可以通过 `MongoTemplate` 访问，并为 `JavaScript` 的使用提供基本抽象。
下面的例子展示了如何使用 `ScriptOperations` 类。

====
[source,java]
----
ScriptOperations scriptOps = template.scriptOps();

ExecutableMongoScript echoScript = new ExecutableMongoScript("function(x) { return x; }");
scriptOps.execute(echoScript, "directly execute script");     <1>

scriptOps.register(new NamedMongoScript("echo", echoScript)); <2>
scriptOps.call("echo", "execute script via name");            <3>
----
<1> 直接运行脚本，而不在服务器端存储函数。
<2> 用 'echo' 作为它的名字来存储脚本。给定的名称可以识别该脚本，并允许以后调用它。
<3> 使用所提供的参数运行名称为 'echo' 的脚本。
====

[[mongo.group]]
== Group 操作

作为使用 Map-Reduce 进行数据聚合的替代方法，你可以使用 https://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Group[`group` operation]，这感觉类似于使用 SQL 的按查询方式分组，所以与使用 Map-Reduce 相比，
它可能感觉更容易接近。使用分组操作确实有一些限制，例如，在共享环境中不支持分组操作，而且它在一个 BSON 对象中返回全部结果集，所以结果应该很小，少于 10000 个键。

Spring 通过在 `MongoOperations` 上提供方法来简化 group 操作的创建和运行，从而提供了与 MongoDB 的 group 操作的集成。它可以将 group 操作的结果转换为 POJO，还可以与 Spring 的 https://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/core.html#resources[Resource 抽象]  集成。
这将让你把你的 JavaScript 文件放在文件系统、classpath、http 服务器或任何其他 Spring 资源实现上，然后通过简单的 URI 风格的语法引用 JavaScript 资源，例如 `classpath:reduce.js`;。在文件中外部化 JavaScript 代码通常比在代码中作为 Java 字符串嵌入要好。
请注意，如果你愿意，你仍然可以将 JavaScript 代码作为 Java 字符串传递。

[[mongo.group.example]]
=== 使用示例

为了理解 group 操作是如何工作的，我们使用了下面的例子，这在一定程度上是有意而为之的。对于一个更真实的例子，请参考《MongoDB—权威指南》一书。创建了一个名为 `group_test_collection` 的集合，有以下几条记录。

[source]
----
{ "_id" : ObjectId("4ec1d25d41421e2015da64f1"), "x" : 1 }
{ "_id" : ObjectId("4ec1d25d41421e2015da64f2"), "x" : 1 }
{ "_id" : ObjectId("4ec1d25d41421e2015da64f3"), "x" : 2 }
{ "_id" : ObjectId("4ec1d25d41421e2015da64f4"), "x" : 3 }
{ "_id" : ObjectId("4ec1d25d41421e2015da64f5"), "x" : 3 }
{ "_id" : ObjectId("4ec1d25d41421e2015da64f6"), "x" : 3 }
----

我们想按每行中唯一的字段，即 `x` 字段进行分组，并汇总 x 的每个特定值出现的次数。要做到这一点，我们需要创建一个初始文件，其中包含我们的 `count` 变量和一个 `reduce` 函数，该函数将在每次遇到它时增加它。
运行分组操作的 Java 代码如下所示。

[source,java]
----
GroupByResults<XObject> results = mongoTemplate.group("group_test_collection",
                                                      GroupBy.key("x").initialDocument("{ count: 0 }").reduceFunction("function(doc, prev) { prev.count += 1 }"),
                                                      XObject.class);
----

第一个参数是要运行 group 操作的集合的名称，第二个参数是一个 fluent API，通过 `GroupBy` 类指定 group 操作的属性。在这个例子中，我们只使用 `intialDocument` 和 `reduceFunction` 方法。你也可以指定一个 key-function，以及一个 finalizer 作为 fluent API 的一部分。如果你有多个 key 要 group，你可以传入一个逗号分隔的 key 列表。

group 操作的原始结果是一个 JSON 文档，看起来像这样：

[source]
----
{
  "retval" : [ { "x" : 1.0 , "count" : 2.0} ,
               { "x" : 2.0 , "count" : 1.0} ,
               { "x" : 3.0 , "count" : 3.0} ] ,
  "count" : 6.0 ,
  "keys" : 3 ,
  "ok" : 1.0
}
----

"retval" 字段下的文档被映射到 group 方法的第三个参数上，在这种情况下是 XObject，如下所示。

[source,java]
----
public class XObject {

  private float x;

  private float count;


  public float getX() {
    return x;
  }

  public void setX(float x) {
    this.x = x;
  }

  public float getCount() {
    return count;
  }

  public void setCount(float count) {
    this.count = count;
  }

  @Override
  public String toString() {
    return "XObject [x=" + x + " count = " + count + "]";
  }
}
----

你也可以通过调用 `GroupByResults` 类上的 `getRawResults` 方法来获得原始结果作为一个 `Document`。

`MongoOperations` 的 group 方法有一个额外的方法重载，可以让你指定一个 `Criteria` 对象来选择一个行的子集。下面是一个使用 `Criteria` 对象的例子，其中使用了一些静态导入的语法，并通过 Spring 资源字符串引用了一个 key-function 和 reduce function javascript 文件。

[source]
----
import static org.springframework.data.mongodb.core.mapreduce.GroupBy.keyFunction;
import static org.springframework.data.mongodb.core.query.Criteria.where;

GroupByResults<XObject> results = mongoTemplate.group(where("x").gt(0),
                                        "group_test_collection",
                                        keyFunction("classpath:keyFunction.js").initialDocument("{ count: 0 }").reduceFunction("classpath:groupReduce.js"), XObject.class);
----

include::aggregation-framework.adoc[]

[[mongo-template.index-and-collections]]
== 索引和 Collection 管理

`MongoTemplate` 为管理索引和集合提供了一些方法。这些方法被收集到一个名为 `IndexOperations` 的辅助接口中。你可以通过调用 `indexOps` 方法并传入集合名称或实体的 `java.lang.Class` 来访问这些操作（集合名称是由 .class 派生出来的，可以是名称，也可以是注解元数据）。

下面的列表显示了 `IndexOperations` 接口。

[source,java]
----
public interface IndexOperations {

  void ensureIndex(IndexDefinition indexDefinition);

  void dropIndex(String name);

  void dropAllIndexes();

  void resetIndexCache();

  List<IndexInfo> getIndexInfo();
}
----

[[mongo-template.index-and-collections.index]]
=== 创建索引的方法

你可以通过使用 `MongoTemplate` 类在一个集合上创建一个索引来提高查询性能，如下例所示。

[source,java]
----
mongoTemplate.indexOps(Person.class).ensureIndex(new Index().on("name",Order.ASCENDING));
----

`ensureIndex` 确保为所提供的 `IndexDefinition` 的索引在集合中存在。

你可以通过使用 `IndexDefinition`、`GeoSpatialIndex` 和 `TextIndexDefinition` 类来创建标准、地理空间和文本索引。例如，给定前一节中定义的 `Venue` 类，你可以声明一个地理空间查询，如下例所示。

[source,java]
----
mongoTemplate.indexOps(Venue.class).ensureIndex(new GeospatialIndex("location"));
----

NOTE: Index 和 GeospatialIndex 支持配置 <<mongo.collation,collations>>.

[[mongo-template.index-and-collections.access]]
=== 获取索引信息

`IndexOperations` 接口有 `getIndexInfo` 方法，该方法返回一个 `IndexInfo` 对象的列表。这个列表包含在集合上定义的所有索引。下面的例子在 `Person` 类上定义了一个索引，该索引有一个 `age` 属性。

[source,java]
----
template.indexOps(Person.class).ensureIndex(new Index().on("age", Order.DESCENDING).unique());

List<IndexInfo> indexInfoList = template.indexOps(Person.class).getIndexInfo();

// Contains
// [IndexInfo [fieldSpec={_id=ASCENDING}, name=_id_, unique=false, sparse=false],
//  IndexInfo [fieldSpec={age=DESCENDING}, name=age_-1, unique=true, sparse=false]]
----

[[mongo-template.index-and-collections.collection]]
=== 使用 Collection 的方法

下面的例子显示了如何创建一个 collection:

.通过使用 `MongoTemplate` 来处理collection
====
[source,java]
----
MongoCollection<Document> collection = null;
if (!mongoTemplate.getCollectionNames().contains("MyNewCollection")) {
    collection = mongoTemplate.createCollection("MyNewCollection");
}

mongoTemplate.dropCollection("MyNewCollection");
----
====

* *getCollectionNames*: 返回一组 collection 的名称。
* *collectionExists*: 检查是否存在一个具有给定名称的 collection 。
* *createCollection*: 创建一个无上限的 collection。
* *dropCollection*: 删除collection.
* *getCollection*: 通过名字获取一个collection，如果它不存在，则创建它。

NOTE: Collection 创建允许使用 `CollectionOptions` 进行定制，并支持 <<mongo.collation,collations>>.。

[[mongo-template.commands]]
== 运行命令

你可以通过使用 `MongoTemplate` 上的 `executeCommand(…)` 方法来获得 MongoDB 驱动程序的 `MongoDatabase.runCommand()` 方法。这些方法还可以将异常转化为 Spring 的 `DataAccessException` 层次结构。

[[mongo-template.commands.execution]]
=== 运行命令的方法

* `Document` *executeCommand* `(Document command)`: 运行一个 MongoDB 命令。
* `Document` *executeCommand* `(Document command, ReadPreference readPreference)`: 用给定的可忽略的 MongoDB `ReadPreference` 运行一个 MongoDB 命令。
* `Document` *executeCommand* `(String jsonCommand)`: 运行一个以 JSON 字符串表示的 MongoDB 命令。

[[mongodb.mapping-usage.events]]
== 生命周期事件

MongoDB 映射框架包括几个 `org.springframework.context.ApplicationEvent` 事件，你的应用程序可以通过在 `ApplicationContext` 中注册特殊的 Bean 来响应。基于 Spring 的 `ApplicationContext` 事件基础设施，其他产品（如Spring Integration）可以轻松接收这些事件，因为它们是基于 Spring 的应用程序中众所周知的事件机制。

实体生命周期事件可能是昂贵的，当加载大型结果集时，你可能会注意到性能概况的变化。你可以在 link:https://docs.spring.io/spring-data/mongodb/docs/{version}/api/org/springframework/data/mongodb/core/MongoTemplate.html#setEntityLifecycleEventsEnabled(boolean)[Template API] 上停用生命周期事件。

要在一个对象通过转换过程（将你的 domain 对象变成 `org.bson.Document`）之前拦截它，你可以注册一个 `AbstractMongoEventListener` 的子类，重写 `onBeforeConvert` 方法。当事件被派发时，你的监听器被调用，并在 domain 对象进入转换器之前传递给它。下面的例子展示了如何做到这一点。

====
[source,java]
----
public class BeforeConvertListener extends AbstractMongoEventListener<Person> {
  @Override
  public void onBeforeConvert(BeforeConvertEvent<Person> event) {
    ... does some auditing manipulation, set timestamps, whatever ...
  }
}
----
====

要在对象进入数据库之前对其进行拦截，你可以注册一个 `org.springframework.data.mongodb.core.mapping.event.AbstractMongoEventListener` 的子类，重写 `onBeforeSave` 方法。当事件被派发时，你的监听器被调用并传递给 domain 对象和转换后的 `com.mongodb.Document`。下面的例子展示了如何做到这一点。

====
[source,java]
----
public class BeforeSaveListener extends AbstractMongoEventListener<Person> {
  @Override
  public void onBeforeSave(BeforeSaveEvent<Person> event) {
    … change values, delete them, whatever …
  }
}
----
====

在你的 Spring `ApplicationContext` 中声明这些 Bean 会导致它们在事件被分派时被调用。

`AbstractMappingEventListener` 中存在以下回调方法:

* `onBeforeConvert`: 在 `MongoTemplate` `insert`、`insertList` 和 `save` 操作中，在对象被 `MongoConverter` 转换为 `Document` 之前被调用。
* `onBeforeSave`: 在数据库中插入或保存 `Document` 之前，在 `MongoTemplate` 的 `insert`、 `insertList` 和 `save` 操作中调用。
* `onAfterSave`: 在数据库中插入或保存 `Document` 后，在 `MongoTemplate` `insert`、`insertList` 和 `save` 操作中被调用。
* `onAfterLoad`: 在 `MongoTemplate` 的 `find`、`findAndRemove`、`findOne` 和 `getCollection` 方法中，在 `Document` 被从数据库中检索出来后被调用。
* `onAfterConvert`: 在 `MongoTemplate` 的 `find`、`findAndRemove`、`findOne` 和 `getCollection` 方法中，在 `Document` 从数据库中被检索出来并被转换为 POJO 后被调用。

NOTE: 生命周期事件只针对根级别的类型发布。在文档根中作为属性使用的复杂类型不受事件发布的影响，除非它们是用 `@DBRef` 注解的文档引用。

WARNING: 生命周期事件依赖于 `ApplicationEventMulticaster`，在 `SimpleApplicationEventMulticaster` 的情况下，它可以用 `TaskExecutor` 来配置，因此在事件被处理时没有保证。

include::{spring-data-commons-location}/entity-callbacks.adoc[leveloffset=+1]
include::./mongo-entity-callbacks.adoc[leveloffset=+2]

[[mongo.exception]]
== 异常（Exception）转换

Spring 框架为各种各样的数据库和映射技术提供了异常转换。这在传统上是针对 JDBC 和 JPA 的。Spring 对 MongoDB 的支持通过提供 `org.springframework.dao.support.PersistenceExceptionTranslator` 接口的实现，将该功能扩展到了 MongoDB 数据库。

映射到 https://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/data-access.html#dao-exceptions[Spring 一致的数据访问异常层次结构] 背后的动机是，你能够编写可移植的、描述性的异常处理代码，而不需要借助于针对 MongoDB 错误代码的编码。Spring 的所有数据访问异常都是从根 `DataAccessException` 类中继承的，因此你可以确保在一个 `try-catch` 块中捕捉所有与数据库相关的异常。
请注意，并非所有由 MongoDB 驱动抛出的异常都继承自 `MongoException` 类。内部的异常和消息被保留下来，这样就不会丢失任何信息。

`MongoExceptionTranslator` 执行的一些映射是 `com.mongodb.Network` 到 `DataAccessResourceFailureException` 和 `MongoException` 错误代码 1003、1201、12010、12011 和 12012 到 `InvalidDataAccessApiUsageException`。查看实现，了解更多关于映射的细节。

[[mongo.executioncallback]]
== execute 回调

所有 Spring template 类的一个共同设计特点是，所有的功能都被路由到模板的一个 `execute` 回调方法中。这样做有助于确保异常和任何可能需要的资源管理都得到一致执行。虽然 JDBC 和 JMS 比 MongoDB 更需要这个功能，但它仍然提供了一个发生异常转换和记录的单一地点。
因此，使用这些 `execute` 回调是访问 MongoDB 驱动程序的 `MongoDatabase` 和 `MongoCollection` 对象的首选方式，以执行 `MongoTemplate` 上没有暴露为方法的不常见操作。

下面的列表描述了 `execute` 回调方法:

* `<T> T` *execute* `(Class<?> entityClass, CollectionCallback<T> action)`: 为指定类别的实体 collection 运行给定的 `CollectionCallback`。

* `<T> T` *execute* `(String collectionName, CollectionCallback<T> action)`: 在给定名称的 collection 上运行给定的 `CollectionCallback`。

* `<T> T` *execute* `(DbCallback<T> action)`:  运行一个 `DbCallback`，必要时转换任何异常。Spring Data MongoDB 为 2.2 版本中引入 MongoDB 的聚合框架提供支持。

* `<T> T` *execute* `(String collectionName, DbCallback<T> action)`: 在给定名称的集合上运行一个 `DbCallback`，必要时转换任何异常。

* `<T> T` *executeInSession* `(DbCallback<T> action)`: 在与数据库的同一连接中运行给定的 `DbCallback`，以确保在一个“多写”的环境中的一致性，你可能会读取你写的数据。

下面的例子使用 `CollectionCallback` 来返回关于一个索引的信息。

[source,java]
----
boolean hasIndex = template.execute("geolocation", new CollectionCallbackBoolean>() {
  public Boolean doInCollection(Venue.class, DBCollection collection) throws MongoException, DataAccessException {
    List<Document> indexes = collection.getIndexInfo();
    for (Document document : indexes) {
      if ("location_2d".equals(document.get("name"))) {
        return true;
      }
    }
    return false;
  }
});
----

include::gridfs.adoc[]
include::tailable-cursors.adoc[]
include::change-streams.adoc[]
include::time-series.adoc[]
