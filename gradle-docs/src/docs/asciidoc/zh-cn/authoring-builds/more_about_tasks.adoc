// Copyright 2017 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[more_about_tasks]]
= 编写 Tasks

在 <<tutorial_using_tasks.adoc#tutorial_using_tasks,入门教程>>中,我们学习了如何创建简单的任务. 并且向这些任务添加其他行为,
还学习了如何在任务之间创建依赖. 这些都是比较简单的任务,但是 Gradle 将任务的概念进一步扩展了. Gradle 支持具有自己的属性和方法的任务.
 这些任务要么由您提供,要么内置在 Gradle 中.

[[sec:task_outcomes]]
== Task 结果

当 Gradle 执行任务时,它可以通过 <<third_party_integration.adoc#embedding,Tooling API>> 将任务标记为不同的结果并在控制台 UI 中显示. 这些标签基于任务是否具有要执行的动作,是否应执行那些动作,是否确实执行了这些动作以及这些动作是否进行了任何更改.

`(no label)` or `EXECUTED`::
任务执行动作
+
* Task 有动作,Gradle 已确定应将其作为构建的一部分执行.
* Task 没有动作,并且有一些依赖,并且任何依赖都将执行.另请参见 <<#sec:lifecycle_tasks,Lifecycle Tasks>>.

`UP-TO-DATE`::
Task 的输出不改变.
+
* 任务具有输出和输入,并且它们没有改变.请参阅 <<#sec:up_to_date_checks,增量构建>>.
* 任务有动作,但是任务告诉 Gradle 它没有更改其输出.
* 任务没有任何动作,并且有一些依赖,但是所有依赖都是最新的,已跳过或来自缓存.另请参见  <<#sec:lifecycle_tasks,Lifecycle Tasks>>.
* 任务没有动作,也没有依赖.

`FROM-CACHE`::
任务的输出可以从先前的执行中找到.
+
* 任务的输出已从构建缓存中还原.请参阅 See <<build_cache.adoc#build_cache,构建缓存>>.

`SKIPPED`::
任务未执行其动作.
+
* 任务已从命令行中明确排除. 请参阅 <<command_line_interface.adoc#sec:excluding_tasks_from_the_command_line,从执行中排除任务>>.
* 任务具有 `onlyIf` 断言,返回false. See <<#sec:using_a_predicate,使用 predicate>>.

`NO-SOURCE`::
任务不需要执行其动作
+
* 任务具有输入和输出,但没有 <<#skip-when-empty,no sources>>.例如,源文件是 link:{groovyDslPath}/org.gradle.api.tasks.compile.JavaCompile.html[JavaCompile] 的 `.java` 文件.


[[sec:defining_tasks]]
== 定义 tasks

在 <<tutorial_using_tasks.adoc#tutorial_using_tasks,本章>> 中,我们已经看到了如何使用字符串作为任务名称来定义任务.当然也有一些定义形式来适应特殊的情况


[NOTE]
====
有关任务配置的 API 将在 <<task_configuration_avoidance#,task configuration avoidance 章节进行详细说明>>.
====

.使用 strings 来定义任务的名字
====
include::{snippets-dir}/tasks/defineUsingStringTaskNames/groovy/build.gradle[]
include::{snippets-dir}/tasks/defineUsingStringTaskNames/kotlin/build.gradle.kts[]
====

将任务添加到 `tasks` 集合中. 可以看一看 link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html[TaskContainer] 来深入了解 `register()` 方法.

在 Kotlin DSL 中还有一个特定的链接：link:https://kotlinlang.org/docs/reference/delegated-properties.html[delegated properties] 语法，如果您需要注册的任务以供进一步参考，该语法很有用。

.使用 DSL 特定语法将任务分配给变量
====
include::{snippets-dir}/tasks/defineAsKotlinDelegatedProperty/groovy/build.gradle[]
include::{snippets-dir}/tasks/defineAsKotlinDelegatedProperty/kotlin/build.gradle.kts[]
====

[WARNING]
====
如果您查看 _tasks_ 容器的 API，您可能会注意到 _create_ 任务还有其他方法。
不鼓励使用这些方法，并将在未来的版本中弃用。 这些方法的存在只是为了向后兼容，因为它们是在将 <<task_configuration_avoidance#,task configuration Avoidance>> 添加到 Gradle 之前引入的。
====

[[sec:locating_tasks]]
== 定位 tasks

你经常需要在构建文件里找到你定义的 tasks,举个例子,为了配置他们或者使用他们作为依赖,有许多方式都可以来实现定位.首先,就像定义任务一样,Groovy 和 Kotlin DSL也有特定于语言的语法

通常，可以通过 `tasks` 集合获得可用任务。
你应该使用返回 _task provider_ 的方法 —— `register()` 或 `named()` —— 确保你不会破坏 <<task_configuration_avoidance#,task configuration Avoidance>>。

.Accessing tasks via tasks collection
====
include::{snippets-dir}/tasks/accessFromTaskContainer/groovy/build.gradle[]
include::{snippets-dir}/tasks/accessFromTaskContainer/kotlin/build.gradle.kts[]
====

也可以使用 `tasks.withType()` 方法访问特定类型的任务。这可以避免代码重复并减少冗余。

.Accessing tasks by their type
====
include::{snippets-dir}/tasks/accessUsingType/groovy/build.gradle[]
include::{snippets-dir}/tasks/accessUsingType/kotlin/build.gradle.kts[]
====

[WARNING]
====
下面展示了如何通过路径访问任务。 这不再是推荐的做法，因为它破坏了 <<task_configuration_avoidance#,task configuration Avoidance>> 和项目隔离。
项目之间的依赖关系 <<declaring_dependencies_between_subprojects.adoc#,应该声明为依赖关系>>。
====

你可以使用 `tasks.getByPath()` 方法通过任务的路径来使用任何 project 里的任务,你可以通过使用任务的名字,任务的相对路径或者绝对路径作为  `getByPath()` 方法的输入

.通过路径获取 tasks
====
include::{snippets-dir}/tasks/accessUsingPath/groovy/project-a/build.gradle[];build.gradle[]
include::{snippets-dir}/tasks/accessUsingPath/kotlin/project-a/build.gradle.kts[];build.gradle.kts[]

.**`gradle -q hello`** 输出
----
> gradle -q hello
include::{snippets-dir}/tasks/accessUsingPath/tests/accessUsingPath.out[]
----
====

参考 link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html[TaskContainer] 可以知道更多关于定位 tasks 的选项

[[sec:configuring_tasks]]
== 配置 tasks

举个例子,让我们看一看 Gradle 自带的 `Copy` task ,为了注册一个 `Copy` task ,你需要在你的构建脚本里先声明他:

.注册一个 copy task
====
include::{snippets-dir}/tasks/configureUsingBlock/groovy/build.gradle[tags=declare-task]
include::{snippets-dir}/tasks/configureUsingBlock/kotlin/build.gradle.kts[tags=declare-task]
====

它注册了一个没有默认行为的 `Copy` task .这个 task 可以通过它的 API(see link:{groovyDslPath}/org.gradle.api.tasks.Copy.html[Copy]) 来配置,接下来的例子展示了不同的实现方法

补充说明一下,这个 task 的名字是  "`myCopy`" , 但是它的类型是  "`Copy`" .你可以有许多相同类型不同名字的 task,这个在实现特定类型的所有任务的 cross-cutting concerns 时特别有用

.配置 task
====
include::{snippets-dir}/tasks/configureUsingVar/groovy/build.gradle[tags=configure]
include::{snippets-dir}/tasks/configureUsingVar/kotlin/build.gradle.kts[tags=configure]
====

您还可以将任务引用存储在变量中，并在后面的脚本中进一步配置任务。

.Retrieve a task reference and use it to configuring the task
====
include::{snippets-dir}/tasks/configureUsingBlock/groovy/build.gradle[tags=configure]
include::{snippets-dir}/tasks/configureUsingBlock/kotlin/build.gradle.kts[tags=configure]
====

参考 link:{javadocPath}/org/gradle/api/tasks/TaskContainer.html[TaskContainer] 可以知道更多关于配置 tasks 的选项

[TIP]
====
如果您使用 _Kotlin DSL_ 并且您要配置的任务是由插件添加的，您可以为任务使用简便的方法访问。
也就是说，你可以只写 `tasks.test` 而不是 `tasks.named("test")`。
====

你也可以直接在定义 task 时使用闭包.

.Defining a task with a configuration block
====
include::{snippets-dir}/tasks/defineAndConfigure/groovy/build.gradle[tags=no-description]
include::{snippets-dir}/tasks/defineAndConfigure/kotlin/build.gradle.kts[tags=no-description]
====

[TIP]
.请不要忘了构建的各个阶段
====
每个任务都有 configuration 和 actions. 当使用 `doLast` 时, 你只是简单的使用捷径定义了动作. 定义在配置区域的代码只会在构建的配置阶段执行, 而且不论执行哪个任务. 可以参考 <<build_lifecycle.adoc#build_lifecycle,Build Lifecycle>>获取更多的细节
====

[[sec:passing_arguments_to_a_task_constructor]]
== 给 task 构造函数传递参数

与创建 task 后在赋予属性相反,你可以将参数值传递给 `Task`  构造函数.
为了将值传递给  `Task` ,你必须使用  `@javax.inject.Inject` 注解相关的构造函数

.Task class with `@Inject` constructor
====
include::{snippets-dir}/tasks/taskConstructorArgs-onTaskContainer/groovy/build.gradle[tags=inject-task-constructor]
include::{snippets-dir}/tasks/taskConstructorArgs-onTaskContainer/kotlin/build.gradle.kts[tags=inject-task-constructor]
====

然后,您可以创建一个任务,并在参数列表的末尾传递构造函数参数.

.Registering a task with constructor arguments using TaskContainer
====
include::{snippets-dir}/tasks/taskConstructorArgs-onTaskContainer/groovy/build.gradle[tags=on-task-container]
include::{snippets-dir}/tasks/taskConstructorArgs-onTaskContainer/kotlin/build.gradle.kts[tags=on-task-container]
====

[NOTE]
====
建议使用 <<task_configuration_avoidance.adoc#,Task Configuration Avoidance>> API来缩短配置时间.
====

在所有情况下,作为构造函数参数传递的值都必须为非 null.

如果您尝试传递 `null` 值,则 Gradle 将抛出 `NullPointerException`,指示哪个运行时值为 `null`.

[[sec:adding_dependencies_to_tasks]]
== 给 task 加入依赖

有许多种加入依赖的方式. 在  <<tutorial_using_tasks.adoc#sec:task_dependencies,任务依赖>> 章节中,你已经学习了如何使用任务的名称定义依赖. 任务名称可以指向同一个项目里的任务, 或者其他项目里的任务. 为了指向其他项目, 你
必须在任务的名称前加入项目的路径. 下面的例子给 `project-a:taskX` 加入依赖  `project-b:taskY`

.从另外一个项目给任务加入依赖
====
include::{snippets-dir}/tasks/addDependencyUsingPath/groovy/build.gradle[]
include::{snippets-dir}/tasks/addDependencyUsingPath/kotlin/build.gradle.kts[]

.**`gradle -q taskX`** 的输出
----
> gradle -q taskX
include::{snippets-dir}/tasks/addDependencyUsingPath/tests/addDependencyUsingPath.out[]
----
====

您可以使用 `TaskProvider` 对象来定义依赖,而不是使用任务名称,如下例所示:

.使用 task provider 对象添加依赖
====
include::{snippets-dir}/tasks/addDependencyUsingTask/groovy/build.gradle[]
include::{snippets-dir}/tasks/addDependencyUsingTask/kotlin/build.gradle.kts[]

.**`gradle -q taskX`** 的输出
----
> gradle -q taskX
include::{snippets-dir}/tasks/addDependencyUsingTask/tests/addDependencyUsingTask.out[]
----
====

更加先进的用法, 你可以通过闭包定义一个任务依赖. 闭包只能返回一个单独的 `Task` 或者 `Task` 对象的 collection, 这些返回的任务就将被当做依赖. 接下来的例子给 `taskX` 加入了一个
复杂的依赖, 所有以 `lib` 开头的任务都将在 `taskX` 之前执行:

.Adding dependency using a lazy block
====
include::{snippets-dir}/tasks/addDependencyUsingClosure/groovy/build.gradle[]
include::{snippets-dir}/tasks/addDependencyUsingClosure/kotlin/build.gradle.kts[]

.**`gradle -q taskX`** 的输出
----
> gradle -q taskX
include::{snippets-dir}/tasks/addDependencyUsingClosure/tests/addDependencyUsingClosure.out[]
----
====

有关任务依赖性的更多信息,请参见链接: link:{groovyDslPath}/org.gradle.api.Task.html[Task] API.

[[sec:ordering_tasks]]
== 给 tasks 排序

在某些情况下, 我们希望能控制任务的的执行顺序, 这种控制并不是向上一张那样去显示地加入依赖. 最主要的区别是我们设定的排序规则不会影响那些要被执行的任务, 只是影响执行的顺序本身. 好吧, 我知道可能有点抽象.

我们来看看以下几种有用的场景:

* 执行连续的任务: eg. 'build' 从来不会在 'clean' 之前执行.
* 在 build 的一开始先运行构建确认 (build validations): eg. 在正式的发布构建前先确认我的证书是正确的.
* 在运行长时间的检测任务前先运行快速的检测任务来获得更快的反馈: eg. 单元测试总是应该在集成测试之前被执行.
* 一个聚集 (aggregates) 某种特定类型的所有任务结果的任务: eg. 测试报告任务 (test report task) 包含了所有测试任务的运行结果.

目前, 有 2 种可用的排序规则: "must run after" 和 "should run after".

当你使用 "must run after"  时即意味着 `taskB` 必须总是在 `taskA` 之后运行, 无论 `taskA` 和 `taskB` 是否将要运行 `taskB.mustRunAfter(taskA)`

"should run after" 规则其实和 "must run after" 很像, 只是没有那么的严格, 在 2 种情况下它会被忽略:

. 首先,使用规则来阐述一个执行的循环.
. 当并行执行并且一个任务的所有依赖除了 "should run after"  任务其余都满足了, 那么这个任务无论它的 "should run after"  依赖是否执行, 它都可以执行.

总之, 当要求不是那么严格时, "should run after"  是非常有用的.

即使有目前的这些规则, 我们仍可以执行 `taskA` 而不管 `taskB`, 反之亦然

.Adding a 'must run after' task ordering
====
include::{snippets-dir}/tasks/mustRunAfter/groovy/build.gradle[]
include::{snippets-dir}/tasks/mustRunAfter/kotlin/build.gradle.kts[]

.**`gradle -q taskY taskX`** 的输出
----
> gradle -q taskY taskX
include::{snippets-dir}/tasks/mustRunAfter/tests/mustRunAfter.out[]
----
====

.Adding a 'should run after' task ordering
====
include::{snippets-dir}/tasks/shouldRunAfter/groovy/build.gradle[]
include::{snippets-dir}/tasks/shouldRunAfter/kotlin/build.gradle.kts[]

.**`gradle -q taskY taskX`** 的输出
----
> gradle -q taskY taskX
include::{snippets-dir}/tasks/shouldRunAfter/tests/shouldRunAfter.out[]
----
====

在上面的例子里, 我们仍可以直接执行 `taskY` 而不去  `taskX`  :

.Task ordering does not imply task execution
====
.**`gradle -q taskY`** 的输出
----
> gradle -q taskY
include::{snippets-dir}/tasks/mustRunAfter/tests/mustRunAfterSingleTask.out[]
----
====

为了在 2 个任务间定义 "must run after"  或者 "should run after"  排序, 我们需要使用
link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:mustRunAfter(java.lang.Object++[]++)[Task.mustRunAfter(java.lang.Object++...++)] 和 link:{javadocPath}/org/gradle/api/Task.html#shouldRunAfter-java.lang.Object++...++-[Task.shouldRunAfter(java.lang.Object++...++)] 方法. 这些方法接收一个任务的实例,　任务的
名字或者任何 link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object++[]++)[Task.dependsOn(java.lang.Object++...++)] 可以接收的输入.

注意 "`B.mustRunAfter(A)`"  或者 "`B.shouldRunAfter(A)`"  并不影响任何任务间的执行依赖:

* tasks `A` 和 `B` 可以被独立的执行. 排序规则只有当 2 个任务同时执行时才会被应用.
* 在运行时加上 `--continue`, 当 `A` 失败时 `B` 仍然会执行.

之前提到过, "should run after"  规则在一个执行循环中将被忽略:

.A 'should run after' task ordering is ignored if it introduces an ordering cycle
====
include::{snippets-dir}/tasks/shouldRunAfterWithCycle/groovy/build.gradle[]
include::{snippets-dir}/tasks/shouldRunAfterWithCycle/kotlin/build.gradle.kts[]

.**`gradle -q taskX`** 的输出
----
> gradle -q taskX
include::{snippets-dir}/tasks/shouldRunAfterWithCycle/tests/shouldRunAfterWithCycle.out[]
----
====

[[sec:adding_a_description_to_a_task]]
== 给 task 加入描述

你可以给你的任务加入一段描述性的文字. 它将会在执行 `gradle tasks` 的时候显示出来.

.Adding a description to a task
====
include::{snippets-dir}/tasks/defineAndConfigure/groovy/build.gradle[tags=all]
include::{snippets-dir}/tasks/defineAndConfigure/kotlin/build.gradle.kts[tags=all]
====

[[sec:skipping_tasks]]
== 跳过任务

Gradle 提供了多种方法来跳过任务的执行.


[[sec:using_a_predicate]]
=== 使用断言(predicate))

您可以使用 `onlyIf()` 方法将断言附加到任务. 仅当断言评估为 `true` 时,才执行任务的动作. 您将断言实现为闭包. 闭包作为参数传递给任务,如果任务应执行,则应返回 `true`; 如果应跳过任务,则应返回 `false`.
在即将执行任务之前对断言进行评估.

.Skipping a task using a predicate
====
include::{snippets-dir}/tutorial/taskOnlyIf/groovy/build.gradle[]
include::{snippets-dir}/tutorial/taskOnlyIf/kotlin/build.gradle.kts[]

.**`gradle hello -PskipHello`** 的输出
----
> gradle hello -PskipHello
include::{snippets-dir}/tutorial/taskOnlyIf/tests/taskOnlyIf.out[]
----
====


[[sec:using_stopexecutionexception]]
=== 使用 StopExecutionException

如果无法使用断言来表示跳过任务的逻辑,则可以使用 link:{javadocPath}/org/gradle/api/tasks/StopExecutionException.html[StopExecutionException].如果这个异常是被一个任务要执行的动作抛出的, 这个动作之后的执行以及所有紧跟它的动作都会被跳过. 构建将会继续执行下一个任务.

.Skipping tasks with StopExecutionException
====
include::{snippets-dir}/tutorial/stopExecutionException/groovy/build.gradle[]
include::{snippets-dir}/tutorial/stopExecutionException/kotlin/build.gradle.kts[]

.**`gradle -q myTask`** 的输出
----
> gradle -q myTask
include::{snippets-dir}/tutorial/stopExecutionException/tests/stopExecutionException.out[]
----
====

如果您使用 Gradle 提供的任务,此功能将非常有用.它允许您添加此类任务的内置动作的 _conditional_ 执行.footnote:[您可能想知道为什么既没有导入 `StopExecutionException`,也没有通过它的全限定名来访问它. 原因是,Gradle 向您的脚本添加了一组默认导入(see <<writing_build_scripts.adoc#script-default-imports,默认导入>>).]


[[sec:enabling_and_disabling_tasks]]
=== 启用和禁用任务

每个任务都有一个 `enabled` 标志,默认为 `true`. 将其设置为  `false` 会阻止执行任何任务动作. 禁用的任务将标记为 SKIPPED.

.启用和禁用任务
====
include::{snippets-dir}/tutorial/disableTask/groovy/build.gradle[]
include::{snippets-dir}/tutorial/disableTask/kotlin/build.gradle.kts[]

.**`gradle disableMe`** 的输出
----
> gradle disableMe
include::{snippets-dir}/tutorial/disableTask/tests/disableTask.out[]
----
====

[[sec:task_timeouts]]
=== 任务超时

每个任务都有一个 `timeout` 属性,可用于限制其执行时间.当任务达到超时时,其任务执行线程将被中断.该任务将被标记为失败.  Finalizer 任务仍将运行.
如果使用 `--continue`,其他任务可以在它之后继续运行.不响应中断的任务无法超时.Gradle 的所有内置任务均会及时响应超时.

.Specifying task timeouts
====
include::{snippets-dir}/tasks/timeout/groovy/build.gradle[]
include::{snippets-dir}/tasks/timeout/kotlin/build.gradle.kts[tags=without-import]
====

[[sec:up_to_date_checks]]
== Up-to-date 检查 (AKA Incremental Build)

任何构建工具的重要组成部分都具有避免执行已经完成的工作的能力.考虑编译过程. 编译完源文件后,除非更改了一些会影响输出的内容 (例如修改源文件或删除输出文件) ,否则就无需重新编译它们. 而且编译可能要花费大量时间,因此在不需要时跳过该步骤可以节省大量时间.

Gradle 通过调用增量构建的功能来开箱即用地支持此行为. 您几乎可以肯定已经在实际中看到了它: 运行构建时,几乎每次在任务名称旁边出现 `UP-TO-DATE` 文本时,它就处于活动状态. 任务结果在 <<#sec:task_outcomes,Task outcomes>> 中描述.

增量构建如何工作?  在自己的任务中需要使用什么呢?  让我们来看看.

[[sec:task_inputs_outputs]]
=== 任务输入和输出

在最常见的情况下,任务需要一些输入并产生一些输出. 如果使用前面的编译示例,则可以看到源文件是输入,对于 Java,生成的类文件是输出. 其他输入可能包括诸如是否应包含调试信息之类的内容.

.任务输入和输出示例
image::{image-dir}/taskInputsOutputs.png[]

如上图所示,输入的一个重要特征是它会影响一个或多个输出. 根据源文件的内容以及要在其上运行代码的 Java 运行时的最低版本,会生成不同的字节码. 这使它们成为任务输入. 但是,编译是否具有 500MB 或 600MB 的最大可用内存 (由 `memoryMaximumSize` 属性确定) 对生成什么字节码没有影响. 用 Gradle 术语来说,`memoryMaximumSize` 只是一个内部任务属性.

作为增量构建的一部分,Gradle 会测试自上次构建以来是否已更改任何任务输入或输出.如果还没有,Gradle 可以则认为该任务是最新的,因此跳过执行其动作.另请注意,除非一个任务至少具有一个任务输出,否则增量构建将无法正常工作,尽管任务通常也至少具有一个输入.

对于构建作者来说,这很简单: 您需要告诉 Gradle 哪些任务属性是输入,哪些是输出.如果任务属性影响输出,请确保将其注册为输入,否则,该任务将被视为最新任务.相反,如果属性不会影响输出,则不要将其注册为输入,否则任务可能会在不需要时执行.另外,请注意不确定的任务,这些任务可能会为完全相同的输入生成不同的输出: 不应配置这些任务以进行增量构建,因为无法检查其是不是最新的.

现在,让我们看一下如何将任务属性注册为输入和输出.

[[sec:task_input_output_annotations]]
==== 自定义任务类型

如果您要以 class 的形式实现自定义任务,那么只需两步即可使其与增量构建一起使用:

. 为每个任务输入和输出创建类型化的属性 (通过getter方法)
. 向每个属性添加适当的注解

[NOTE]
====
注解必须放在 getters 或 Groovy 属性上. 放置在 setter 上或没有相应带注解的 getter 的 Java 字段上的注解将被忽略.
====

Gradle支持三种主要的输入和输出类别:

* 简单值
+
诸如字符串和数字之类的东西. 一般来说,简单值可以是实现 `Serializable` 的任何类型.

* 文件系统类型
+
这些由标准的 `File` 类组成,还包括 Gradle link:{javadocPath}/org/gradle/api/file/FileCollection.html[FileCollection] 类型以及可以传递给 link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)[Project.file(java.lang.Object)] 方法 (用于单个文件/目录属性) 或 link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object++[]++)[Project.files(java.lang.Object++...++)] 方法.

* 嵌套值
+
自定义类型不符合其他两个类别,但具有自己的属性,即输入或输出. 实际上,任务输入或输出嵌套在这些自定义类型中.
Custom types that don’t conform to the other two categories but have their own properties that are inputs or outputs. In effect, the task inputs or outputs are nested inside these custom types.

例如,假设您有一个任务来处理各种类型的模板,例如 FreeMarker,Velocity,Moustache 等.它需要模板源文件,并将它们与一些模型数据结合起来以生成模板文件的填充版本.

该任务将具有三个输入和一个输出:

* Template 源文件
* 模型数据(Model data)
* 模板引擎(Template engine)
* 写入输出文件的位置

在编写自定义任务类时,可以很容易地通过注解将属性注册为输入或输出.为了演示,这是一个 skeleton 任务实现,其中包含一些适当的输入和输出以及它们的注解:

.自定义任务类
====
[source,java]
.buildSrc/src/main/java/org/example/ProcessTemplates.java
----
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/groovy/buildSrc/src/main/java/org/example/ProcessTemplates.java[tag=custom-task-class]
----

[source,java]
.buildSrc/src/main/java/org/example/TemplateData.java
----
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/groovy/buildSrc/src/main/java/org/example/TemplateData.java[]
----

.`gradle processTemplates` 的输出
----
> gradle processTemplates
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/tests/customTaskClassWithInputOutputAnnotations.out[]
----

.`gradle processTemplates` (run again) 的输出
----
> gradle processTemplates
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/tests/customTaskClassWithInputOutputAnnotationsUpToDate.out[]
----
====

在这个示例中有很多要讨论的内容,所以让我们依次讨论每个输入和输出属性

* `templateEngine`
+
表示处理源模板时要使用的引擎,例如 FreeMarker,Velocity 等.您可以将其实现为字符串,但是在这种情况下,我们使用了自定义枚举,因为它提供了更多的类型信息和安全性. 由于枚举自动实现 `Serializable`,
因此我们可以将其视为简单值并使用 `@Input` 注解,就像使用 String 属性一样.

* `sourceFiles`
+
任务将要处理的源模板. 单个文件和文件集合需要它们自己的特殊注解. 在这种情况下,我们正在处理输入文件的集合,因此我们使用 `@InputFiles` 注解. 稍后,您会在表格中看到更多面向文件的注解.

* `templateData`
+
在此示例中,我们使用自定义类来表示模型数据. 但是,它没有实现 `Serializable`,因此我们不能使用 `@Input` 注解. 这不是问题,因为 TemplateData 中的属性 (具有可序列化类型参数的字符串和哈希图) 是可序列化的,并且可以使用 `@Input` 进行注解. 我们在 templateData 上使用 `@Nested`,以使 Gradle 知道这是具有嵌套输入属性的值.

* `outputDir`
+
生成文件所在的目录. 与输入文件一样,输出文件和目录也有一些注解. 表示单个目录的属性需要 `@OutputDirectory`. 您很快就会了解其他内容.

这些带注解的属性意味着,自从 Gradle 上次执行任务以来,如果源文件,模板引擎,模型数据或生成的文件均未更改,则 Gradle 将跳过任务. 这通常会节省大量时间. 您可以稍后了解 Gradle 如何  <<#sec:how_does_it_work,检测更改>>.

这个示例特别有趣,因为它可以处理源文件的集合. 如果仅更改一个源文件,会发生什么?  该任务会再次处理所有源文件还是仅处理已修改的源文件?  这取决于任务的实现. 如果是后者,那么任务本身就是增量任务,但这与我们在此讨论的功能不同. Gradle 通过其 <<custom_tasks.adoc#incremental_tasks,增量任务输入>>功能确实可以帮助任务实施者.

既然您已经在实践中看到了一些输入和输出注解,那么让我们看一下所有可用的注解以及何时使用它们. 下表列出了可用的注解以及可以与每个注解一起使用的相应属性类型.

[[table:incremental_build_annotations]]
.增量构建属性类型注解
[cols="a,a,a", options="header"]
|===
| 注解
| 期望属性类型
| 描述

| `@link:{javadocPath}/org/gradle/api/tasks/Input.html[Input]`
| 任何 `Serializable` 类型
| 一个简单的输入值

| `@link:{javadocPath}/org/gradle/api/tasks/InputFile.html[InputFile]`
| `File`*
| 一个简单的输入文件 (没有目录)

| `@link:{javadocPath}/org/gradle/api/tasks/InputDirectory.html[InputDirectory]`
| `File`*
| 一个简单的输入目录 (没有文件)

| `@link:{javadocPath}/org/gradle/api/tasks/InputFiles.html[InputFiles]`
| `Iterable&lt;File&gt;`*
| 输入文件和目录的迭代

| `@link:{javadocPath}/org/gradle/api/tasks/Classpath.html[Classpath]`
| `Iterable&lt;File&gt;`*
| 代表 Java 类路径的输入文件和目录的.这使任务可以忽略对属性的不相关更改,例如相同文件的名称不同. 它类似于对属性 `@PathSensitive(RELATIVE)` 进行注解,但是它将忽略直接添加到类路径中的 JAR 文件的名称,并且会将文件顺序的更改视为类路径中的更改. Gradle 将检查类路径上 jar 文件的内容,并忽略不影响类路径语义的更改 (例如文件日期和输入顺序) . 另请参阅 <<#sec:task_input_using_classpath_annotations,使用 classpath 注解>>.

**Note:** `@Classpath` 注解是在 Gradle 3.2 中引入的. 为了与Gradle的早期版本保持兼容,类路径属性也应使用  `@InputFiles` 进行注解.

| `@link:{javadocPath}/org/gradle/api/tasks/CompileClasspath.html[CompileClasspath]`
| `Iterable&lt;File&gt;`*
| 代表 Java 编译类路径的输入文件和目录的可迭代项. 这使任务可以忽略不影响 classpath 中类 API 的无关更改. 另请参阅  <<#sec:task_input_using_classpath_annotations,使用 classpath 注解>>.

对类路径的以下更改将被忽略:

* 更改jar或顶级目录的路径.
* 更改时间戳和Jars中条目的顺序.
* 对资源和 Jar 清单的更改,包括添加或删除资源.
* 更改私有类元素,例如私有字段,方法和内部类.
* 对代码的更改,例如方法体,static initializers 和 field initializers  (常量除外) .
* 调试信息的更改,例如,对注解的更改会影响类调试信息中的行号.
* 更改目录,包括Jars中的目录条目

[NOTE]
====
`@CompileClasspath` 注解是在 Gradle 3.4 中引入的. 为了与 Gradle 3.3 和 3.2 保持兼容,编译类路径属性也应使用 `@Classpath` 注解. 为了与 3.2 之前的 Gradle 版本兼容,该属性也应使用 `@InputFiles` 进行注解.
====

| `@link:{javadocPath}/org/gradle/api/tasks/OutputFile.html[OutputFile]`
| `File`*
| 单个输出文件 (不是目录)

| `@link:{javadocPath}/org/gradle/api/tasks/OutputDirectory.html[OutputDirectory]`
| `File`*
| 单个输出目录 (不是文件)

| `@link:{javadocPath}/org/gradle/api/tasks/OutputFiles.html[OutputFiles]`
| `Map&lt;String, File&gt;`+++**+++ or `Iterable&lt;File&gt;`+++*+++
| 输出文件的可迭代或映射.使用文件树将关闭该任务的<<build_cache.adoc#sec:task_output_caching, 缓存>>.

| `@link:{javadocPath}/org/gradle/api/tasks/OutputDirectories.html[OutputDirectories]`
| `Map&lt;String, File&gt;`+++**+++ or `Iterable&lt;File&gt;`+++*+++
| 可迭代的输出目录.使用文件树将关闭该任务的<<build_cache.adoc#sec:task_output_caching, 缓存>>.

| `@link:{javadocPath}/org/gradle/api/tasks/Destroys.html[Destroys]`
| `File` or `Iterable&lt;File&gt;`+++*+++
| 指定此任务删除的一个或多个文件.请注意,任务可以定义输入/输出或可销毁对象,但不能同时定义两者.

| `@link:{javadocPath}/org/gradle/api/tasks/LocalState.html[LocalState]`
| `File` or `Iterable&lt;File&gt;`+++*+++
| 指定一个或多个表示  <<custom_tasks.adoc#sec:storing_incremental_task_state,任务本地状态>> 的文件.从缓存中加载任务时,将删除这些文件.

| `@link:{javadocPath}/org/gradle/api/tasks/Nested.html[Nested]`
| Any custom type
| 一种自定义类型,可能无法实现 `Serializable` ,但至少具有一个用此表中的注解之一标记的字段或属性.它甚至可能是另一个 `@Nested`.

| `@link:{javadocPath}/org/gradle/api/tasks/Console.html[Console]`
| Any type
| 指示该属性既不是输入也不是输出.它只是以某种方式影响任务的控制台输出,例如增加或减少任务的详细程度.

| `@link:{javadocPath}/org/gradle/api/tasks/Internal.html[Internal]`
| Any type
| 指示该属性在内部使用,但既不是输入也不是输出.

| `@link:{javadocPath}/org/gradle/api/model/ReplacedBy.html[ReplacedBy]`
| Any type
| 指示该属性已被另一个属性替代,应作为输入或输出忽略.

| [[skip-when-empty]]`@link:{javadocPath}/org/gradle/api/tasks/SkipWhenEmpty.html[SkipWhenEmpty]`
| `File`+++*+++
| 与 `@InputFiles` 或  `@InputDirectory`  一起使用,以指示 Gradle 如果相应的文件或目录为空以及使用此注解声明的所有其他输入文件为空,则跳过任务. 由于使用该注解声明为空的所有输入文件而被跳过的任务将导致明显的 "无源" 结果. 例如,在控制台输出中将发出 `NO-SOURCE`.

暗示 `<<#incremental,@Incremental>>`.

| [[incremental]]`@link:{javadocPath}/org/gradle/work/Incremental.html[Incremental]`
| `Provider<FileSystemLocation>` or `FileCollection`
| 与 `@InputFiles` 或 `@InputDirectory` 一起使用,以指示 Gradle 跟踪对带注解的文件属性的更改,因此可以通过 `@link:{groovyDslPath}/org.gradle.work.InputChanges.html[InputChanges.getFileChanges()]` 查询更改.<<custom_tasks.adoc#incremental_tasks,增量任务>>必需.

| `@link:{javadocPath}/org/gradle/api/tasks/Optional.html[Optional]`
| Any type
| 与 link:{javadocPath}/org/gradle/api/tasks/Optional.html[Optional] API 文档中列出的任何属性类型注解一起使用. 该注解禁用对相应属性的验证检查. 有关更多详细信息,请参见 <<#sec:task_input_output_validation,验证部分>>.

| `@link:{javadocPath}/org/gradle/api/tasks/PathSensitive.html[PathSensitive]`
| `File`+++*+++
| [[inputs_path_sensitivity]]与任何输入文件属性一起使用,以告诉 Gradle 仅将文件路径的给定部分视为重要. 例如,如果使用  `@PathSensitive(PathSensitivity.NAME_ONLY)` 注解属性,则在不更改文件内容的情况下移动文件不会使任务过时.

| `@link:{javadocPath}/org/gradle/api/tasks/IgnoreEmptyDirectories.html[IgnoreEmptyDirectories]`
| `Iterable&lt;File&gt;`*
| 和`@InputFiles` 或 `@InputDirectory` 一起使用，表示 Gradle 仅跟踪目录内容的更改，而不是目录自己本身，例如，在目录中删除、重命名或添加空目录不会使任务 out-of-date.
|===

[NOTE]
====
[horizontal]
+++*+++::
实际上, `File`  可以是 link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)[Project.file(java.lang.Object)] 接受的任何类型,`Iterable&lt;File&gt;` 可以是 link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object++[]++)[Project.files(java.lang.Object...)] 接受的任何类型.
这包括 `Callable` 实例,例如闭包,允许对属性值进行延迟评估. 请注意, `FileCollection` 和 `FileTree`  类型是 ``Iterable&lt;File&gt;``s.

+++**+++::
与上述类似,`File` 可以是 link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)[Project.file(java.lang.Object)] 接受的任何类型. `Map` 本身可以包装在 `Callables` 中,例如闭包.
====

注解从所有父类型 (包括已实现的接口) 继承. 属性类型注解会覆盖在父类型中声明的任何其他属性类型注解. 这样,可以将 `@InputFile` 属性转换为子任务类型中的 `@InputDirectory` 属性.

用类型声明的属性上的注解将覆盖超类和任何已实现接口中声明的类似注解.超类注解优先于已实现接口中声明的注解.

表格中的 link:{javadocPath}/org/gradle/api/tasks/Console.html[Console] 和 link:{javadocPath}/org/gradle/api/tasks/Internal.html[Internal] 注解是特殊情况,因为它们未声明任务输入或任务输出. 那为什么要使用它们呢?  这样一来,您就可以利用 <<java_gradle_plugin.adoc#java_gradle_plugin,Java Gradle 插件开发插件>>来帮助您开发和发布自己的插件. 该插件检查您的自定义任务类的任何属性是否缺少增量构建注解. 这样可以防止您在开发过程中忘记添加适当的注解.

[[sec:task_input_using_classpath_annotations]]
===== 使用 classpath 注解

除了 `@InputFiles` 外,对于与 JVM 相关的任务,Gradle 还了解类路径输入的概念. 当 Gradle 寻找更改时,对运行时和编译类路径的处理会有所不同.

与用 `@link:{javadocPath}/org/gradle/api/tasks/InputFiles.html[InputFiles]` 注解的输入属性相反,对于类路径属性,文件集合中条目的顺序很重要. 另一方面,类路径本身上的目录和 jar 文件的名称和路径将被忽略. 类路径上 jar 文件中的时间戳以及类文件和资源的顺序也将被忽略,因此重新创建具有不同文件日期的 jar 文件不会使任务过期.

运行时类路径用 `@link:{javadocPath}/org/gradle/api/tasks/Classpath.html[Classpath]` 标记,它们通过  <<#sec:configure_input_normalization,classpath 规范化>> 提供进一步的自定义.

用 `@link:{javadocPath}/org/gradle/api/tasks/CompileClasspath.html[CompileClasspath]` 注解的输入属性被视为 Java 编译类路径. 除上述常规类路径规则外,编译类路径会忽略对除类文件以外的所有内容的更改. Gradle 使用 Java 避免编译中描述的相同类分析来进一步过滤不影响类 ABI 的更改. 这意味着仅涉及类实现的更改不会使任务过时

[[sec:task_input_nested_inputs]]
===== Nested 输出

在分析  `@link:{javadocPath}/org/gradle/api/tasks/Nested.html[Nested]`  任务属性以获取已声明的输入和输出子属性时,Gradle 使用实际值的类型. 因此,它可以发现运行时子类型声明的所有子属性.

将 `@link:{javadocPath}/org/gradle/api/tasks/Nested.html[Nested]`  添加到 `link:{javadocPath}/org/gradle/api/provider/Provider.html[Provider]` 时,该 `Provider` 的值将被视为嵌套输入.

将 `@link:{javadocPath}/org/gradle/api/tasks/Nested.html[Nested]` 添加到可迭代对象时,每个元素都被视为单独的嵌套输入. 在 Iterable 中为每个嵌套输入分配一个名称,默认情况下是美元符号,后跟 Iterable 中的索引,例如 `$2`. 如果 iterable 的元素实现 `link:{javadocPath}/org/gradle/api/Named.html[Named]`,则将该名称用作属性名称.
如果不是所有元素都实现 `link:{javadocPath}/org/gradle/api/Named.html[Named]`,则可迭代元素的顺序对于可靠的最新检查和缓存至关重要. 不允许使用多个具有相同名称的元素.

将 `@link:{javadocPath}/org/gradle/api/tasks/Nested.html[Nested]` 添加到 `Map` 时,然后使用键作为名称为每个值添加一个嵌套输入.

嵌套输入的类型和类路径也将被跟踪. 这确保了对嵌套输入的实现的更改会导致构建过时. 通过这种方式,还可以添加用户提供的代码作为输入,例如 通过使用 `@link:{javadocPath}/org/gradle/api/tasks/Nested.html[Nested]` 注解 `@link:{javadocPath}/org/gradle/api/Action.html[Action]` 属性.
请注意,应通过操作上的注解属性或通过在任务中手动注册这些操作来跟踪对此类操作的任何输入.

使用嵌套输入可以为任务提供更丰富的建模和可扩展性,例如 由 link:{groovyDslPath}/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:jvmArgumentProviders[Test.getJvmArgumentProviders()] 显示.

这使我们可以对 JaCoCo Java 代理进行建模,从而声明必要的JVM参数并将输入和输出提供给 Gradle:

====
[source,java]
.JacocoAgent.java
----
class JacocoAgent implements CommandLineArgumentProvider {
    private final JacocoTaskExtension jacoco;

    public JacocoAgent(JacocoTaskExtension jacoco) {
        this.jacoco = jacoco;
    }

    @Nested
    @Optional
    public JacocoTaskExtension getJacoco() {
        return jacoco.isEnabled() ? jacoco : null;
    }

    @Override
    public Iterable<String> asArguments() {
        return jacoco.isEnabled() ? ImmutableList.of(jacoco.getAsJvmArg()) : Collections.<String>emptyList();
    }
}

test.getJvmArgumentProviders().add(new JacocoAgent(extension));
----
====

为此,`link:{groovyDslPath}/org.gradle.testing.jacoco.plugins.JacocoTaskExtension.html[JacocoTaskExtension]` 需要具有正确的输入和输出注解.

该方法适用于 Test JVM 参数,因为 `link:{groovyDslPath}/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:jvmArgumentProviders[Test.getJvmArgumentProviders()]`  是使用 `@link:{javadocPath}/org/gradle/api/tasks/Nested.html[Nested]` 注解的 `Iterable`.

还有其他类型的嵌套输入可用的任务类型:

* link:{groovyDslPath}/org.gradle.api.tasks.JavaExec.html#org.gradle.api.tasks.JavaExec:argumentProviders[JavaExec.getArgumentProviders()] - model e.g. custom tools
* link:{groovyDslPath}/org.gradle.api.tasks.JavaExec.html#org.gradle.api.tasks.JavaExec:jvmArgumentProviders[JavaExec.getJvmArgumentProviders()] - used for Jacoco Java agent
* link:{groovyDslPath}/org.gradle.api.tasks.compile.CompileOptions.html#org.gradle.api.tasks.compile.CompileOptions:compilerArgumentProviders[CompileOptions.getCompilerArgumentProviders()] - model e.g annotation processors
* link:{groovyDslPath}/org.gradle.api.tasks.Exec.html#org.gradle.api.tasks.Exec:argumentProviders[Exec.getArgumentProviders()] - model e.g custom tools

同样,这种建模可用于自定义任务.

[[sec:task_input_validation]]
===== 运行时验证

执行构建时,Gradle 检查任务类型是否用适当的注解声明. 它试图找出问题所在,例如 注解用于不兼容的类型或 setter 等.未标记有输入/输出注解的任何 getter 也会被标记. 然后,在执行任务时,这些问题就会变成弃用警告.

[[sec:task_input_output_runtime_api]]
==== Runtime API

自定义任务类是将您自己的构建逻辑带入增量构建领域的一种简便方法,但是您不一定总是有这种选择. 因此,Gradle 还提供了可用于任何任务的替代API,我们接下来将介绍.

如果您无权访问自定义任务类的源,则无法添加上一节中介绍的任何注解. 幸运的是,Gradle 为此类场景提供了 Runtime API. 如下所述,它也可以用于临时任务.

[[sec:runtime_api_for_adhoc]]
===== Using it for ad-hoc tasks

此 runtime API 是通过每个 Gradle 任务上可用的几个恰当命名的属性提供的:

* link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:inputs[Task.getInputs()] of type link:{javadocPath}/org/gradle/api/tasks/TaskInputs.html[TaskInputs]
* link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:outputs[Task.getOutputs()] of type link:{javadocPath}/org/gradle/api/tasks/TaskOutputs.html[TaskOutputs]
* link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:destroyables[Task.getDestroyables()] of type link:{javadocPath}/org/gradle/api/tasks/TaskDestroyables.html[TaskDestroyables]

这些对象具有允许您指定构成任务输入和输出的文件,目录和值的方法. 实际上,运行时 API 与注解几乎具有同等功能. 它缺少的只是 `@link:{javadocPath}/org/gradle/api/tasks/Nested.html[Nested]` 的替代.

让我们以前面的模板处理示例为例,看看使用 runtime API 的即席任务的外观如何:

.Ad-hoc task
====
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/groovy/build.gradle[tags=ad-hoc-task]
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/kotlin/build.gradle.kts[tags=ad-hoc-task]

.**`gradle processTemplatesAdHoc`** 的输出
----
> gradle processTemplatesAdHoc
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/tests/incrementalAdHocTask.out[]
----
====

和以前一样,还有很多要讨论的. 首先,您确实应该为此编写一个自定义任务类,因为它是一个非常简单的实现,具有多个配置选项. 在这种情况下,没有任务属性可以存储根源文件夹,输出目录的位置或任何其他设置. 故意强调这一事实,即运行时 API 不需要任务具有任何状态. 在增量构建方面,上述临时任务的行为与自定义任务类相同.

所有输入和输出定义都是通过 `inputs`  和 `outputs` 上的方法完成的,例如 `property()`, `files()` 和 `dir()`. Gradle 对参数值执行最新检查,以确定任务是否需要再次运行. 每个方法都对应一个增量构建注解,例如, `inputs.property()` 映射到 `@Input`,`outputs.dir()` 映射到 `@OutputDirectory`.

可以通过  `destroyables.register()` 指定任务删除的文件.

.Ad-hoc task declaring a destroyable
====
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/groovy/build.gradle[tags=adhoc-destroyable-task]
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/kotlin/build.gradle.kts[tags=adhoc-destroyable-task]
====

运行时 API 与注解之间的一个显着区别是缺少直接与 `@Nested` 对应的方法. 这就是为什么该示例对模板数据使用两个  `property()` 声明,对每个 `TemplateData` 属性使用一个声明的原因.
在将运行时API与嵌套值一起使用时,应使用相同的技术. 任何给定任务都可以声明可销毁物品或输入/输出,但不能同时声明两者

[[sec:runtime_api_configuration]]
===== 细粒度配置

运行时API方法仅允许您自己声明输入和输出. 但是,面向文件的工具会返回一个生成器,类型为 link:{javadocPath}/org/gradle/api/tasks/TaskInputFilePropertyBuilder.html[TaskInputFilePropertyBuilder],它使您可以提供有关这些输入和输出的其他信息.

您可以在其 API 文档中了解该构建器提供的所有选项,但是我们将在此处向您展示一个简单的示例,让您大致了解您可以做什么.

假设如果没有源文件,我们就不希望运行 `processTemplates` 任务,无论它是否是干净的版本. 毕竟,如果没有源文件,则无需执行任何任务. 构建器允许我们这样配置:

.Using skipWhenEmpty() via the runtime API
====
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/groovy/build.gradle[tags=ad-hoc-task-skip-when-empty]
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/kotlin/build.gradle.kts[tags=ad-hoc-task-skip-when-empty]

.**`gradle clean processTemplatesAdHocSkipWhenEmpty`** 的输出
----
> gradle clean processTemplatesAdHocSkipWhenEmpty
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/tests/incrementalAdHocTaskNoSource.out[]
----
====

`TaskInputs.files()` 方法返回一个具有 `skipWhenEmpty()` 方法的构建器. 调用此方法等效于使用 <<#skip-when-empty,`@SkipWhenEmpty`>> 注解属性.

现在您已经看到了注解和运行时 API,您可能想知道应该使用哪个 API. 我们的建议是尽可能使用注解,有时值得创建自定义任务类,以便您可以使用它们. 对于您无法使用注解的情况,运行时 API 更适用.

[[sec:runtime_api_for_custom_tasks]]
===== 将其用于自定义任务类型

另一类示例涉及为自定义任务类的实例注册其他输入和输出. 例如,假设 `ProcessTemplates` 任务还需要读取 `src/headers/headers.txt` (例如,因为它是从一个来源中包含的) . 您希望 Gradle 知道此输入文件,以便只要此文件的内容更改,它就可以重新执行任务. 使用运行时API,您可以做到这一点:

.将运行时API与自定义任务类型一起使用
====
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/groovy/build.gradle[tags=custom-class-runtime-api]
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/kotlin/build.gradle.kts[tags=custom-class-runtime-api]
====

像这样使用运行时API有点像使用 `doLast()` 和 `doFirst()` 将额外的动作附加到任务上,除了在这种情况下,我们将附加关于输入和输出的信息.

[WARNING]
====
如果任务类型已经在使用增量构建注解,则使用相同的属性名称注册输入或输出将导致错误.
====

[[sec:task_input_output_side_effects]]
==== 重要的有益副作用

声明任务的正式输入和输出后,Gradle 即可推断出有关这些属性的信息. 例如,如果将一个任务的输入设置为另一个任务的输出,则意味着第一个任务取决于第二个任务,对吗?  Gradle知道这一点并可以对此采取行动.

接下来,我们将介绍此功能,以及 Gradle 了解输入和输出方面的其他一些功能.

[[sec:inferred_task_dependencies]]
===== 推断的任务依赖性

考虑一个归档任务,该任务打包了 `processTemplates` 任务的输出. 构建作者将看到,存档任务显然需要首先运行 `processTemplates`,因此可以添加显式的 `dependsOn`. 但是,如果您这样定义归档任务:

.通过任务输出推断任务依赖性
====
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/groovy/build.gradle[tags=inferred-task-dep-via-outputs]
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/kotlin/build.gradle.kts[tags=inferred-task-dep-via-outputs]

.**`gradle clean packageFiles`** 的输出
----
> gradle clean packageFiles
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/tests/inferredTaskDep.out[]
----
====

Gradle 将自动使 packageFiles 依赖于 `processTemplates`. 这样做是因为它知道 packageFiles 的输入之一需要 `processTemplates` 任务的输出. 我们称其为推断的任务依赖性.

上面的例子也可以写成

.Inferred task dependency via a task argument
====
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/groovy/build.gradle[tags=inferred-task-dep-via-task]
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/kotlin/build.gradle.kts[tags=inferred-task-dep-via-task]

.**`gradle clean packageFiles2`** 的输出
----
> gradle clean packageFiles2
include::{snippets-dir}/tasks/incrementalBuild-customTaskClass/tests/inferredTaskDep2.out[]
----
====

这是因为 `from()` 方法可以接受任务对象作为参数. 在幕后,`from()` 使用 `project.files()` 方法包装参数,从而将任务的正式输出公开为文件集合. 换句话说,这是特例

[[sec:task_input_output_validation]]
===== 输入输出验证

增量构建注解为 Gradle 提供足够的信息,以对注解的属性执行一些基本验证.特别是,在任务执行之前,它将对每个属性执行以下操作:

* `@InputFile` - 验证该属性具有值,并且该路径对应于存在的文件 (不是目录) .
* `@InputDirectory` - 与 `@InputFile` 相同,只不过路径必须与目录相对应.
* `@OutputDirectory` - 验证路径与文件不匹配,并在目录不存在的情况下创建目录.

这种验证提高了构建的健壮性,使您可以快速识别与输入和输出有关的问题.

您有时会希望禁用某些验证,特别是在输入文件可能确实不存在的情况下. 这就是 Gradle 提供 `@Optional` 注解的原因: 您使用它来告诉 Gradle 特定输入是可选的,因此,如果相应的文件或目录不存在,构建也不会失败.

[[sec:task_input_output_continuous_build]]
===== 持续构建

定义任务输入和输出的另一个好处是连续构建. 由于 Gradle 知道任务所依赖的文件,因此如果其任何输入发生更改,它可以自动再次运行任务. 通过在运行Gradle时激活连续构建 (通过 `--continuous` 或 `-t` 选项) ,可以使 Gradle 处于不断检查更改并在遇到此类更改时执行所请求任务的状态.

您可以在  <<command_line_interface.adoc#sec:continuous_build,持续构建>>中找到有关此功能的更多信息

[[sec:task_input_output_parallelism]]
===== 任务并行

定义任务输入和输出的最后一个好处是,当使用 "--parallel"  选项时,Gradle 可以使用此信息来决定如何运行任务. 例如,Gradle 在选择要运行的下一个任务时将检查任务的输出,并且将避免并发执行写入同一输出目录的任务.
同样,Gradle 将使用有关任务销毁哪些文件的信息 (例如由 `Destroys` 注解指定) ,并避免在运行另一个消耗或创建相同文件的任务时运行运行删除一组文件的任务 (反之亦然) .
它还可以确定创建一组文件的任务已经运行,并且消耗这些文件的任务尚未运行,并且将避免运行将两者之间的文件删除的任务. 通过以这种方式提供任务输入和输出信息,Gradle 可以推断任务之间的创建/消耗/销毁关系,并可以确保任务执行不违反那些关系.

[[sec:how_does_it_work]]
=== 它是如何工作的?

当一个任务是首次执行时, Gradle 会取一个输入的快照 (snapshot). 该快照包含组输入文件和
每个文件的内容的散列. 然后当 Gradle 执行任务时, 如果任务成功完成,Gradle 会获得一个
输出的快照. 该快照包含输出文件和每个文件的内容的散列. Gradle 会保留这两个快照用来在
该任务的下一次执行时进行判断.
之后, 每次在任务执行之前, Gradle 都会为输入和输出取一个新的快照, 如果这个快照和之前
的快照一样, Gradle 就会假定这个任务已经是最新的 (up-to-date) 并且跳过任务, 反之亦然.
需要注意的是, 如果一个任务有指定的输出目录, 自从该任务上次执行以来被加入到该目录的
任务文件都会被忽略, 并且不会引起任务过时 (out of date). 这是因为不相关任务也许会共用同
一个输出目录. 如果这并不是你所想要的情况, 可以考虑使用 TaskOutputs.upToDateWhen())

在第一次执行任务之前,Gradle 会对输入进行指纹识别. 此指纹包含输入文件的路径以及每个文件内容的哈希. 然后 Gradle 执行任务. 如果任务成功完成,则 Gradle 将对输出进行指纹识别. 此指纹包含一组输出文件以及每个文件内容的哈希值.Gradle会在下一次执行任务时保留两个指纹.

每次之后,在执行任务之前,Gradle 都会对输入和输出使用新的指纹. 如果新的指纹与以前的指纹相同,则 Gradle 会假定输出是最新的,并跳过该任务. 如果它们不相同,则 Gradle 执行任务. Gradle 会在下一次执行任务时保留两个指纹.

如果文件的统计信息 (即 `lastModified` 和 `size` ) 未更改,则 Gradle 将重复使用上次运行的文件指纹. 这意味着当文件的统计信息未更改时,Gradle 不会检测到更改.

Gradle 还将任务代码视为任务输入的一部分. 当任务,其动作或其依赖在两次执行之间发生变化时,Gradle 会将任务视为过时的.

Gradle 会了解文件属性 (例如,持有 Java 类路径的文件属性) 是否对顺序敏感. 比较此类属性的指纹时,即使文件顺序发生更改,也将导致任务过时.

请注意,如果任务指定了输出目录,则自上次执行该任务以来添加到该目录的所有文件都将被忽略,并且不会导致该任务过时. 这样一来,不相关的任务可以共享一个输出目录,而不会互相干扰. 如果由于某种原因这不是您想要的行为,请考虑使用 link:{javadocPath}/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen-groovy.lang.Closure-[TaskOutputs.upToDateWhen(groovy.lang.Closure)]

还要注意,将通过最新检查来检测和处理更改不可用文件的可用性 (例如,将断开的符号链接的目标修改为有效文件,反之亦然) .

任务的输入还用于计算 <<build_cache.adoc#build_cache,构建缓存>> key,该 key 在启用后将加载任务输出. 有关更多详细信息,请参阅  <<build_cache.adoc#sec:task_output_caching,任务缓存输出>>.

[NOTE]
====
为了跟踪任务,任务动作和嵌套输入的实现,Gradle使用类名和包含实现的类路径标识符. 在某些情况下,Gradle无法准确跟踪实现:

Unknown classloader::
当 Gradle 尚未创建加载实现的类加载器时,无法确定类路径.

Java lambda::
Java lambda 类是在运行时使用不确定的类名创建的.因此,类名不能标识 lambda 的实现,并且不能在不同的 Gradle 运行之间进行更改.

当无法精确跟踪任务,任务动作或嵌套输入的实现时,Gradle 将禁用该任务的任何缓存.这意味着该任务永远不会是最新的,也不会从<<build_cache.adoc#sec:task_output_caching,构建缓存>>中加载.
====

[[sec:advanced_inc_build]]
=== 更高级的技术

到目前为止,您在本节中看到的所有内容都将涵盖您将遇到的大多数用例,但是有些情况需要特殊对待.接下来,我们将介绍其中一些解决方案

[[sec:add_cached_input_output_methods]]
==== 添加您自己的缓存的输入/输出方法

您是否想过复制任务的 `from()`  方法如何工作?  它没有使用 `@InputFiles` 进行注解,但是传递给它的所有文件都被视为任务的正式输入. 发生了什么?

实现非常简单,您可以针对自己的任务使用相同的技术来改进其 API. 编写您的方法,以便它们将文件直接添加到适当的带注解的属性. 举例来说,以下是向我们前面介绍的自定义 `ProcessTemplates` 类添加一个 `sources()` 方法的方法:

.声明一个方法并添加到任务的输出
====
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/groovy/build.gradle[tags=custom-task-class]
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/kotlin/build.gradle.kts[tags=custom-task-class]

.ProcessTemplates.java
[source,java]
----
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/groovy/buildSrc/src/main/java/org/example/ProcessTemplates.java[tag=custom-task-class]
----

.`gradle processTemplates` 的输出
----
> gradle processTemplates
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/tests/incrementalBuildCustomMethods.out[]
----
====

换句话说,只要您在配置阶段将值和文件添加到正式任务的输入和输出中,无论您在构建中的何处添加它们,它们都将被视为此类.

如果我们也要支持任务作为参数,并将其输出作为输入,则可以使用 `project.layout.files()`  方法,如下所示:

.Declaring a method to add a task as an input
====
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/groovy/build.gradle[tags=task-arg-method]
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/kotlin/build.gradle.kts[tags=task-arg-method]

.ProcessTemplates.java
[source,java]
----
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/groovy/buildSrc/src/main/java/org/example/ProcessTemplates.java[tag=task-arg-method]
----

.`gradle processTemplates2` 的输出
----
> gradle processTemplates2
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/tests/incrementalBuildCustomMethodsWithTaskArg.out[]
----
====

此技术可以使您的自定义任务更易于使用,并生成更干净的构建文件. 另一个好处是,我们使用  `getProject().getLayout().files()` 意味着我们的自定义方法可以设置推断的任务依赖.

最后需要注意的一件事: 如果要开发一个将源文件集合作为输入的任务,如本例所示,请考虑使用内置的 link:{groovyDslPath}/org.gradle.api.tasks.SourceTask.html[SourceTask]. 这将使您不必实施我们放入 `ProcessTemplates` 中的某些管道

[[sec:link_output_dir_to_input_files]]
==== 将 `@OutputDirectory` 链接到 `@InputFiles`

当您要将一个任务的输出链接到另一任务的输入时,类型通常匹配,并且简单的属性分配将提供该链接. 例如,可以将  `File` 输出属性分配给  `File` 输入.

不幸的是,当您希望一个任务的 `@OutputDirectory` (`File` 类型) 中的文件成为另一个任务的 `@InputFiles` 属性 (类型为 `FileCollection`) 的源时,这种方法会失效. 由于这两种类型不同,因此无法进行属性分配.

例如,假设您想将 Java 编译任务的输出 (通过 `destinationDir` 属性) 用作定制任务的输入,该定制任务检测一组包含 Java 字节码的文件. 这个自定义任务 (我们称为 `Instrument`) 具有 `classFiles` 属性,该属性带有 `@InputFiles` 注解. 您最初可能会尝试像这样配置任务:

.尝试设置推断的任务依赖失败
====
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/groovy/build.gradle[tags=failed-inferred-task-dep]
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/kotlin/build.gradle.kts[tags=failed-inferred-task-dep]

.**`gradle clean badInstrumentClasses`** 的输出
----
> gradle clean badInstrumentClasses
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/tests/incrementalBuildBadInputFilesConfig.out[]
----
====

这段代码显然没有错,但是您可以从控制台输出中看到缺少编译任务. 在这种情况下,您将需要通过 `dependsOn` 在 `instrumentClasses` 和 `compileJava` 之间添加显式任务依赖. 使用 `fileTree()` 意味着 Gradle 无法推断任务依赖本身.

一种解决方案是使用 `TaskOutputs.files` 属性,如以下示例所示:

.在输出目录和输入文件之间设置推断的任务依赖
====
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/groovy/build.gradle[tags=inferred-task-dep]
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/kotlin/build.gradle.kts[tags=inferred-task-dep]

.**`gradle clean instrumentClasses`** 的输出
----
> gradle clean instrumentClasses
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/tests/incrementalBuildInputFilesConfig.out[]
----
====

另外,您可以通过使用 `project.files()`, `project.layout.files()` 或  `project.objects.fileCollection()` 之一来代替 `project.fileTree()` 来使 Gradle 本身访问适当的属性:

.使用 `layout.files()` 设置推断的任务依赖
====
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/groovy/build.gradle[tags=inferred-task-dep-with-files]
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/kotlin/build.gradle.kts[tags=inferred-task-dep-with-files]

.**`gradle clean instrumentClasses2`** 的输出
----
> gradle clean instrumentClasses2
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/tests/incrementalBuildInputFilesConfigUsingTask.out[]
----
====

请记住,`files()`, `layout.files()` 和 `objects.fileCollection()` 可以将任务作为参数,而 `fileTree()`  不能.

这种方法的缺点是,源任务的所有文件输出都将成为目标 (在这种情况下为 `instrumentClasses`) 的输入文件. 只要源任务只有一个基于文件的输出 (如 `JavaCompile` 任务) 就可以了. 但是,如果您只需要链接多个输出属性中的一个,则需要使用 `builtBy` 方法明确告诉 Gradle 哪个任务生成输入文件:

.Setting up an inferred task dependency with builtBy()
====
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/groovy/build.gradle[tags=inferred-task-dep-with-builtby]
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/kotlin/build.gradle.kts[tags=inferred-task-dep-with-builtby]

.**`gradle clean instrumentClassesBuiltBy`** 的输出
----
> gradle clean instrumentClassesBuiltBy
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/tests/inferredTaskDependencyWithBuiltBy.out[]
----
====

当然,您可以通过 `dependsOn` 添加一个显式的任务依赖,但是上述方法提供了更多的语义含义,解释了为什么必须提前运行 `compileJava`

[[sec:custom_up_to_date_logic]]
==== 提供自定义的 up-to-date 逻辑

Gradle 自动处理输出文件和目录的最新检查,但是如果任务输出完全是其他东西怎么办?  也许是对 Web 服务或数据库表的更新. 在这种情况下,Gradle 无法知道如何检查任务是否最新.

这就是  `TaskOutputs`  的 `upToDateWhen()` 方法的来源.它带有一个断言函数,该函数用于确定任务是否最新. 一种用例是完全禁用一项任务的最新检查,如下所示:

.Ignoring up-to-date checks
====
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/groovy/build.gradle[tags=up-to-date-when]
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/kotlin/build.gradle.kts[tags=up-to-date-when]

.`gradle clean alwaysInstrumentClasses` 的输出
----
> gradle clean alwaysInstrumentClasses
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/tests/incrementalBuildUpToDateWhen.out[]
----

.`gradle alwaysInstrumentClasses` 的输出
----
> gradle alwaysInstrumentClasses
include::{snippets-dir}/tasks/incrementalBuild-incrementalBuildAdvanced/tests/incrementalBuildUpToDateWhenAgain.out[]
----
====

`{ false }` 闭包确保将始终执行 `alwaysInstrumentClasses`,而不管输入或输出是否不变.

您当然可以在闭包中添加更复杂的逻辑. 例如,您可以检查数据库表中的特定记录是否存在或已更改. 请注意,最新的检查应该可以节省您的时间. 不要添加比标准执行任务花费更多或更多时间的支票.
实际上,如果某个任务由于经常是最新的而最终频繁运行,那么完全不值得进行最新的检查. 请记住,如果任务在执行任务图中,则检查将始终运行.

一个常见的错误是使用 `upToDateWhen()` 而不是 `Task.onlyIf()`. 如果要基于与任务输入和输出无关的某些条件跳过任务,则应使用 `onlyIf()`. 例如,在您要跳过设置或未设置特定属性的任务的情况下

[[sec:configure_input_normalization]]
==== 配置输入标准化

对于最新检查和 <<build_cache.adoc#build_cache,构建缓存>>,Gradle 需要确定两个任务输入属性是否具有相同的值. 为此,Gradle 首先将两个输入标准化,然后比较结果. 例如,对于编译类路径,Gradle 从类路径上的类中提取ABI签名,然后按照 <<java_plugin.adoc#sec:java_compile_avoidance,Java 避免编译>>中的描述,比较上一次 Gradle 运行和当前 Gradle 运行之间的签名.

规范化适用于类路径上的所有zip文件 (例如jar,wars,ars,apk等) . 这使Gradle能够识别两个zip文件在功能上何时相同,即使zip文件本身由于元数据 (例如时间戳或文件顺序) 而可能略有不同. 标准化不仅适用于直接在类路径上的 zip 文件,而且还适用于嵌套在目录中或类路径上其他 zip 文件内的 zip 文件.

可以自定义Gradle的内置策略,以实现运行时类路径规范化. 用 `@link:{javadocPath}/org/gradle/api/tasks/Classpath.html[Classpath]` 注解的所有输入都被视为运行时类路径.

假设您要向所有产生的 jar 文件中添加一个文件 `build-info.properties`,其中包含有关构建的信息,例如 构建开始的时间戳或用于标识发布 artifacts 的 CI 作业的 ID. 该文件仅用于审计目的,对运行测试的结果没有影响.
但是,该文件是测试任务的运行时类路径的一部分,并且在每次构建调用时都会更改. 因此,测试永远不会是最新的,也不会从构建缓存中提取. 为了再次从增量构建中受益,您可以通过使用 link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:normalization(org.gradle.api.Action)[Project.normalization(org.gradle.api.Action)]  (在使用项目中) 在项目级别告诉Gradle在运行时类路径上忽略此文件:

.Runtime classpath normalization
====
include::{snippets-dir}/tasks/inputNormalization/groovy/build.gradle[tags=ignore-build-info-properties]
include::{snippets-dir}/tasks/inputNormalization/kotlin/build.gradle.kts[tags=ignore-build-info-properties]
====

如果要对 jar 文件中的所有项目执行此文件添加操作,并且要为所有使用者过滤此文件,则应考虑在 <<sharing_build_logic_between_subprojects#sec:convention_plugins,约定插件>> 中配置此类规范化以便在子项目之间共享.

此配置的结果是,对于最新检查和 <<build_cache.adoc#build_cache,构建缓存>> key 计算,对 `build-info.properties` 的更改将被忽略. 请注意,这不会改变测试任务的运行时行为-也就是说,任何测试仍然能够加载 `build-info.properties`,并且运行时类路径仍与之前相同

[[sec:property_file_normalization]]
===== 属性文件规范化

默认情况下，属性文件（即以 `.properties` 扩展名结尾的文件）将被规范化，忽略注释、空格和属性顺序的差异。
Gradle 的规范化在加载属性文件和 up-to-date（最新检查） 或构建缓存键计算期间考虑各个属性。

但是，有时某些属性会对运行时产生影响，而有些则不会。 如果正在更改的某个属性对运行时类路径没有影响，则可能需要将其排除在最新检查和 <<build_cache.adoc#build_cache,build cache>> 键计算之外。
但是，排除整个文件也会排除确实会影响运行时的属性。 在这种情况下，可以有选择地从运行时类路径上排除任何或所有属性文件中属性。

可以使用 link:{groovyDslPath}/org.gradle.normalization.RuntimeClasspathNormalization.html[RuntimeClasspathNormalization] 中描述的模式将忽略属性的规则应用于一组特定的文件。
如果文件与规则匹配，但无法作为属性文件加载（例如，因为它没有正确格式化或使用非标准编码），它将被合并到最新或构建缓存键中 计算为普通文件。 换句话说，如果文件不能作为属性文件加载，对空格、属性顺序或注释的任何更改都可能导致任务过期或导致缓存未命中。

.Ignore a property in selected properties files
====
include::{snippets-dir}/tasks/inputNormalizationPropertiesFiles/groovy/build.gradle[tags=ignore-property-selected]
include::{snippets-dir}/tasks/inputNormalizationPropertiesFiles/kotlin/build.gradle.kts[tags=ignore-property-selected]
====

.Ignore a property in all properties files
====
include::{snippets-dir}/tasks/inputNormalizationPropertiesFiles/groovy/build.gradle[tags=ignore-property-all]
include::{snippets-dir}/tasks/inputNormalizationPropertiesFiles/kotlin/build.gradle.kts[tags=ignore-property-all]
====

[[sec:meta_inf_normalization]]
===== Java `META-INF` 标准化

对于 jar 归档文件的 `META-INF` 目录中的文件,由于其对运行时间的影响,并非总是能够完全忽略文件.

对 `META-INF` 中的清单和属性文件进行了标准化,以忽略注解,空格和顺序差异. 清单属性名称不区分大小写进行比较. 属性文件密钥不区分顺序.

清单属性文件根据 <<more_about_tasks.adoc#sec:property_file_normalization,Properties File Normalization>> 进行规范化。

.忽略 `META-INF` manifest 属性
====
include::{snippets-dir}/tasks/inputNormalizationMetaInf/groovy/build.gradle[tags=ignore-metainf-attribute]
include::{snippets-dir}/tasks/inputNormalizationMetaInf/kotlin/build.gradle.kts[tags=ignore-metainf-attribute]
====

.Ignore `META-INF` property keys
====
include::{snippets-dir}/tasks/inputNormalizationMetaInf/groovy/build.gradle[tags=ignore-metainf-properties]
include::{snippets-dir}/tasks/inputNormalizationMetaInf/kotlin/build.gradle.kts[tags=ignore-metainf-properties]
====

.Ignore `META-INF/MANIFEST.MF`
====
include::{snippets-dir}/tasks/inputNormalizationMetaInf/groovy/build.gradle[tags=ignore-metainf-manifest]
include::{snippets-dir}/tasks/inputNormalizationMetaInf/kotlin/build.gradle.kts[tags=ignore-metainf-manifest]
====

.Ignore all files and directories inside `META-INF`
====
include::{snippets-dir}/tasks/inputNormalizationMetaInf/groovy/build.gradle[tags=ignore-metainf-completely]
include::{snippets-dir}/tasks/inputNormalizationMetaInf/kotlin/build.gradle.kts[tags=ignore-metainf-completely]
====


[[sec:stale_task_outputs]]
=== Stale task outputs

当 Gradle 版本更改时,Gradle 检测到需要删除使用较旧版本的 Gradle 运行的任务的输出,以确保最新版本的任务从已知的干净状态开始.

[NOTE]
====
仅针对源集的输出 (Java/Groovy/Scala 编译) 实现了对陈旧的输出目录的自动清除.
====

[[sec:task_rules]]
== Task 规则

有时候也想要一个任务的行为是基于已经定义好的取值范围或者特定规则, 下面的例子就提供了一种很直观漂亮的方式:

.Task rule
====
include::{snippets-dir}/tasks/addRules/groovy/build.gradle[tags=task-rule]
include::{snippets-dir}/tasks/addRules/kotlin/build.gradle.kts[tags=task-rule]

.**`gradle -q pingServer1`** 的输出
----
> gradle -q pingServer1
include::{snippets-dir}/tasks/addRules/tests/taskRule.out[]
----
====

这里的 String 参数就是用来定义规则的描述,执行 `gradle tasks` 时显示..


规则不仅在从命令行调用任务时使用. 您还可以在基于规则的任务上创建 dependsOn 关系:

.基于规则的任务依赖
====
include::{snippets-dir}/tasks/addRules/groovy/build.gradle[tags=all]
include::{snippets-dir}/tasks/addRules/kotlin/build.gradle.kts[tags=all]

.**`gradle -q groupPing`** 的输出
----
> gradle -q groupPing
include::{snippets-dir}/tasks/addRules/tests/taskRuleDependsOn.out[]
----
====

如果你运行 `gradle -q tasks` , 你并不能找到名叫 `pingServer1`  或者 `pingServer2`  的任务, 但是这个脚本仍然会执行这些任务.

[[sec:finalizer_tasks]]
== 终止 tasks

计划运行终结任务时,终结任务会自动添加到任务图中.

.加入一个任务终止器
====
include::{snippets-dir}/tasks/finalizers/groovy/build.gradle[]
include::{snippets-dir}/tasks/finalizers/kotlin/build.gradle.kts[]

.**`gradle -q taskX`** 的输出
----
> gradle -q taskX
include::{snippets-dir}/tasks/finalizers/tests/taskFinalizers.out[]
----
====

即使要终止的任务失败了, 终止任务仍会继续执行.

.Task finalizer for a failing task
====
include::{snippets-dir}/tasks/finalizersWithFailure/groovy/build.gradle[]
include::{snippets-dir}/tasks/finalizersWithFailure/kotlin/build.gradle.kts[]

.**`gradle -q taskX`** 的输出
----
> gradle -q taskX
include::{snippets-dir}/tasks/finalizersWithFailure/tests-groovy/taskFinalizersWithFailureGroovy.out[]
----
====

另一方面,如果完成任务没有做任何工作 (例如,如果该任务被认为是最新的或从属任务失败) ,则不会执行终止任务.

当构建创建了一个资源, 无论构建失败还是成功都必须清除的资源的情况下,终止任务很有用. 这样的资源的一个示例是一个 Web 容器,它在集成测试任务之前启动,并且即使某些测试失败,也应始终将其关闭.

要使用终止任务,请使用 link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:finalizedBy(java.lang.Object++[]++)[Task.finalizedBy(java.lang.Object...)] 方法. 此方法接受任务实例,任务名称或 link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object++[]++)[Task.dependsOn(java.lang.Object...)] 接受的任何其他输入.

[[sec:lifecycle_tasks]]
== Lifecycle tasks

生命周期任务是无法自行工作的任务.他们通常没有任何任务动作.生命周期任务可以代表几个概念:

* 工作流程步骤 (例如,使用 `check` 运行所有检查)
* 可构建的事物 (例如,使用 `debug32MainExecutable` 为本地组件创建调试的32位可执行文件)
* 一个方便的任务,可以执行许多相同的逻辑任务 (例如,使用 `compileAll` 运行所有编译任务)

Base 插件定义了一些<<base_plugin#sec:base_tasks,标准的 lifecycle tasks>>,例如 `build`, `assemble` 和  `check`. 所有核心语言插件 (例如  <<java_plugin#java_plugin,Java 插件>>) 都应用 Base 插件,因此具有相同的生命周期任务基本集.

除非生命周期任务具有操作,否则其 <<#sec:task_outcomes,结果>> 取决于其任务依赖性. 如果执行了这些依赖中的任何一个,则生命周期任务将被视为已执行. 如果所有任务相关性都是最新的,已跳过或已从缓存中删除,则生命周期任务将被视为 `UP-TO-DATE`.

[[sec:the_idea_behind_gradle_tasks]]
== 总结

如果您来自 Ant,那么增强的 Gradle 任务 (例如 Copy) 似乎是 Ant 目标和 Ant 任务之间的交叉. 尽管 Ant 的任务和目标实际上是不同的实体,但是 Gradle 将这些概念组合到一个实体中. 简单的 Gradle task 就像 Ant 的 target一样,但是增强的 Gradle 任务也包括 Ant 任务的各个方面. Gradle 的所有任务共享一个通用的 API,您可以在它们之间创建依赖. 这些任务比 Ant 任务容易配置. 它们充分利用了类型系统,并且更具表现力且易于维护.