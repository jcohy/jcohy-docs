 [[sec:dynamic_versions_and_changing_modules]]
= 处理随时间变化的版本

在许多情况下,您想使用特定模块依赖的最新版本或一系列版本中的最新版本. 这可能是开发过程中的要求,或者您可能正在开发旨在与一系列依赖版本一起使用的库. 您可以使用动态版本轻松地依赖这些不断变化的依赖.
<<dynamic_versions.adoc#sub:declaring_dependency_with_dynamic_version,dynamic version>> 可以是版本范围 (例如 `2.+`) ,也可以是可用的最新版本的占位符,例如. `latest.integration`.

或者,您请求的模块甚至可以针对相同版本 (即所谓的更改版本) 随时间更改. 此类 <<dynamic_versions.adoc#sub:declaring_dependency_with_changing_version,changing version>> 的一个示例是 Maven `SNAPSHOT` 模块,该模块始终指向最新发布的 artifacts . 换句话说,标准的Maven快照是一个不断发展的模块,它是一个"不断变化的模块" .

[NOTE]
====
使用动态版本和更改模块可能导致无法复制的构建. 随着特定模块的新版本发布,其 API 可能与您的源代码不兼容. 请谨慎使用此功能！
====

[[sub:declaring_dependency_with_dynamic_version]]
== 声明动态版本

项目可能会采用更积极的方法来消耗对模块的依赖. 例如,您可能希望始终集成最新版本的依赖,以便在任何给定时间使用最先进的功能. 动态版本允许解析给定模块的最新版本或版本范围的最新版本.

[NOTE]
====
在构建中使用动态版本会承担潜在破坏它的风险.包含不兼容的 API 更改的依赖的新版本发布后,您的源代码可能会停止编译.
====

.Declaring a dependency with a dynamic version
====
include::{snippets-dir}/dependencyManagement/declaringDependencies-dynamicVersion/groovy/build.gradle[tags=dependencies]
include::{snippets-dir}/dependencyManagement/declaringDependencies-dynamicVersion/kotlin/build.gradle.kts[tags=dependencies]
====

link:https://scans.gradle.com/[build scan] 可以有效地可视化动态依赖版本及其各自的选定版本.

.Dynamic dependencies in build scan
image::{image-dir}/dependency-management-dynamic-dependency-build-scan.png[]

默认情况下,Gradle 将动态版本的依赖缓存 24 小时. 在此时间范围内,Gradle 不会尝试从声明的存储库中解析较新的版本. 可以根据需要 <<#sec:controlling-dynamic-version-caching, 配置 threshold>>,例如,如果您想更早地解析新版本.

[[sub:declaring_dependency_with_changing_version]]
== 声明版本变更

在发布应用程序或库的新版本之前,团队可能会决定实施一系列功能. 允许消费者尽早集成其成品的未完成版本的常见策略通常是发布具有所谓更改版本的模块. 版本变更表示该功能集仍在积极开发中,尚未发布稳定的版本以供普遍使用.

在 Maven 存储库中,更改的版本通常称为 link:https://maven.apache.org/guides/getting-started/index.html#What_is_a_SNAPSHOT_version[snapshot versions]. 快照版本包含后缀 `-SNAPSHOT`. 以下示例演示了如何在 Spring 依赖上声明快照版本.

.Declaring a dependency with a changing version
====
include::{snippets-dir}/dependencyManagement/declaringDependencies-changingVersion/groovy/build.gradle[tags=dependencies]
include::{snippets-dir}/dependencyManagement/declaringDependencies-changingVersion/kotlin/build.gradle.kts[tags=dependencies]
====

默认情况下,Gradle将更改的依赖版本缓存24小时. 在此时间范围内,Gradle不会尝试从声明的存储库中解析较新的版本. 可以根据需要 <<#sec:controlling-dynamic-version-caching, 配置 threshold>>,例如,如果您想更早地解析新的快照版本.

Gradle 足够灵活,可以将任何版本视为更改版本,例如 如果要为 Ivy module 建模快照行为. 您需要做的就是将属性 link:{javadocPath}/org/gradle/api/artifacts/ExternalModuleDependency.html#setChanging-boolean-[ExternalModuleDependency.setChanging(boolean)]设置为 `true`

[[sec:controlling-dynamic-version-caching]]
== 控制动态版本缓存

默认情况下,Gradle 会在 24 小时内缓存动态版本和更改模块. 在这段时间内,Gradle 不会与任何已声明的远程存储库联系以获取新版本. 如果您希望 Gradle 更频繁地检查远程存储库或在每次执行构建时检查远程存储库,则需要更改生存时间 (TTL) 阈值.

[NOTE]
====
由于HTTP (s) 调用的数量增加,因此对于动态版本或更改版本使用较短的TTL阈值可能会导致构建时间更长.
====

您可以使用 <<#sec:controlling_dependency_caching_command_line,command line options>> 覆盖默认的缓存模式. 您还可以使用解析策略 <<#sec:controlling_dependency_caching_programmatically,以编程方式更改构建中的缓存过期时间>>.

[[sec:controlling_dependency_caching_programmatically]]
== 以编程方式控制依赖缓存

您可以使用 link:{javadocPath}/org/gradle/api/artifacts/ResolutionStrategy.html[ResolutionStrategy] 对配置进行编程来微调缓存的某些方面. 如果您想永久更改设置,则编程方式非常有用.

默认情况下,Gradle 将动态版本缓存 24 小时. 要更改 Gradle 将解析后的版本缓存为动态版本的时间,请使用:

.Dynamic version cache control
====
include::{snippets-dir}/dependencyManagement/troubleshooting-cache-dynamic/groovy/build.gradle[tags=dynamic-version-cache-control]
include::{snippets-dir}/dependencyManagement/troubleshooting-cache-dynamic/kotlin/build.gradle.kts[tags=dynamic-version-cache-control]
====

默认情况下,Gradle 将更改的模块缓存 24 小时. 要更改 Gradle 将为更改的模块缓存元数据和 artifacts 的时间,请使用:

.Changing module cache control
====
include::{snippets-dir}/dependencyManagement/troubleshooting-cache-changing/groovy/build.gradle[tags=changing-module-cache-control]
include::{snippets-dir}/dependencyManagement/troubleshooting-cache-changing/kotlin/build.gradle.kts[tags=changing-module-cache-control]
====

[[sec:controlling_dependency_caching_command_line]]
== 从命令行控制依赖缓存

[[sec:offline-mode]]
=== 使用离线模式避免网络访问

`--offline` 命令告诉 Gradle 始终使用缓存中的依赖模块，无论它们是否需要再次检查。 当离线运行时，Gradle 永远不会尝试访问网络来执行依赖解析。 如果依赖缓存中不存在所需的模块，则构建执行将失败。

[[sec:refreshing-dependencies]]
=== 刷新依赖

您可以从命令行控制各种构建调用的依赖缓存行为。 命令行选项有助于为单次构建的执行做出选择性的、临时的选择。


有时，Gradle 依赖缓存可能与已配置存储库的实际状态不同步。 也许一个存储库最初配置错误，或者一个 "non-changing" 的模块发布不正确。
要刷新依赖项缓存中的所有依赖项，请在命令行上使用 `--refresh-dependencies` 选项。

`--refresh-dependencies` 选项告诉 Gradle 忽略已解析模块和工件的所有缓存条目。 将对所有配置的存储库执行新的解析，重新计算动态版本，刷新模块并下载工件。 但是，在有的情况下，Gradle 将在再次下载之前检查先前下载的工件是否有效。
这是通过将存储库中发布的 SHA1 值与现有下载工件的 SHA1 值进行比较来完成的。

- 新版本的动态依赖
- 更改模块的新版本 （使用相同版本字符串但可以具有不同内容的模块）

[NOTE]
====
刷新依赖将导致 Gradle 使其列表缓存无效。
然而：

- 它将对元数据文件执行 HTTP HEAD 请求，如果它们相同， _不会重新下载它们_
- 它将对工件文件执行 HTTP HEAD 请求，如果它们相同， _不会重新下载它们_

换句话说，刷新依赖 _只会对_ 您实际使用动态依赖 _或_ 您有更改的依赖而您不知道（在这种情况下，您有责任将它们正确地声明为 Gradle 作为更改的依赖）有影响。

认为使用 `--refresh-dependencies` 会强制下载依赖项是一个常见的误解。**不是** 这种情况：Gradle 只会执行刷新动态依赖严格要求的操作。
这 _可能_ 涉及下载新的列表或元数据文件，甚至是工件，但如果没有任何改变，影响是最小的。
====

[[sec:component_selection_rules]]
== 使用组件选择规则

当多个版本与版本选择器匹配时，组件选择规则可能会影响应该选择哪个组件实例。
规则适用于每个可用版本，并允许该版本被规则明确拒绝。
这允许 Gradle 忽略任何不满足规则设置的条件的组件实例。
例如：

* 对于像 `1.+` 这样的动态版本，某些版本可能会被明确拒绝。
* 对于像 `1.4` 这样的静态版本，可能会根据额外的组件元数据（例如 Ivy 分支属性）拒绝实例，从而允许使用后续存储库的实例。

规则可以通过 link:{groovyDslPath}/org.gradle.api.artifacts.ComponentSelectionRules.html[ComponentSelectionRules]  对象配置.
每个配置的规则都会调用 link:{groovyDslPath}/org.gradle.api.artifacts.ComponentSelection.html[ComponentSelection] 对象作为参数，其中包含有关正在考虑的候选版本的信息。
调用 link:{groovyDslPath}/org.gradle.api.artifacts.ComponentSelection.html#org.gradle.api.artifacts.ComponentSelection:reject(java.lang.String)[ComponentSelection.reject(java.lang.String)] 原因 要明确拒绝的给定候选版本，在这种情况下，将不会考虑候选版本。

以下示例显示了一个规则，该规则不允许模块的特定版本，但允许动态版本选择下一个最佳候选者。

.Component selection rule
====
include::{snippets-dir}/dependencyManagement/customizingResolution-selectionRule/groovy/build.gradle[tags=reject-version-1-1]
include::{snippets-dir}/dependencyManagement/customizingResolution-selectionRule/kotlin/build.gradle.kts[tags=reject-version-1-1]
====

请注意，首先应用版本选择，从最高版本开始。选择的版本将是找到所有组件选择规则都接受的第一个版本。 如果没有规则明确拒绝某个版本，则认为该版本已被接受。

同样，规则可以针对特定模块。 模块必须以 `group:module` 的形式指定。

.Component selection rule with module target
====
include::{snippets-dir}/dependencyManagement/customizingResolution-selectionRule/groovy/build.gradle[tags=targeted-component-selection]
include::{snippets-dir}/dependencyManagement/customizingResolution-selectionRule/kotlin/build.gradle.kts[tags=targeted-component-selection]
====

组件选择规则在选择版本时也可以考虑组件元数据。
可能考虑其他元数据 link:{javadocPath}/org/gradle/api/artifacts/ComponentMetadata.html[ComponentMetadata] 和 link:{javadocPath}/org/gradle/api/artifacts/ivy/IvyModuleDescriptor.html[IvyModuleDescriptor].
请注意，这些额外信息可能并不总是可用，因此应检查 `null` 值。

.Component selection rule with metadata
====
include::{snippets-dir}/dependencyManagement/customizingResolution-selectionRule/groovy/build.gradle[tags=component-selection-with-metadata]
include::{snippets-dir}/dependencyManagement/customizingResolution-selectionRule/kotlin/build.gradle.kts[tags=component-selection-with-metadata]
====

请注意，在声明组件选择规则时， link:{groovyDslPath}/org.gradle.api.artifacts.ComponentSelection.html[ComponentSelection] 参数始终是必需的参数。
