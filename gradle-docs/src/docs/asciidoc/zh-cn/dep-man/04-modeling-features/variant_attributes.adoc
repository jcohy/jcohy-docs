[[variant_attributes]]
= 使用可变属性

正如在 <<variant_model.adoc#sec:variant-aware-matching,变体匹配>> 一节中所解释的，属性为变体提供语义并用于执行它们之间的选择。

作为 Gradle 的用户，属性通常在他的实现中被隐藏起来。 因此，了解 Gradle 及其核心插件定义的标准属性可能会很有用。

作为插件作者，这些属性及其定义方式可以作为您生态系统插件中 <<#sec:declaring_attributes,构建您自己的属性集>> 的基础。

[[sec:standard_attributes]]
== Gradle 定义的标准属性

Gradle 定义了 Gradle 核心插件使用的标准属性列表.

=== Ecosystem-independent standard attributes

.独立于生态系统的标准变体属性
[%header%autowidth,compact]
|===
| 属性名 | 描述 | 值 | 兼容性和消除歧义规则

| link:{javadocPath}/org/gradle/api/attributes/Usage.html#USAGE_ATTRIBUTE[`org.gradle.usage`]
| 表示变体的主要用途


| `Usage` values built from constants defined in link:{javadocPath}/org/gradle/api/attributes/Usage.html[Usage]
| 遵循生态系统语义（例如，可以使用 `java-runtime` 代替 `java-api`，但不能相反）

| link:{javadocPath}/org/gradle/api/attributes/Category.html#CATEGORY_ATTRIBUTE[`org.gradle.category`]
| 表示此软件组件的类别
| `Category` values built from constants defined in link:{javadocPath}/org/gradle/api/attributes/Category.html[Category]
| 遵循生态系统语义 (例如. 在 JVM 上默认是 `library` , 否则不兼容)

| link:{javadocPath}/org/gradle/api/attributes/LibraryElements.html#LIBRARY_ELEMENTS_ATTRIBUTE[`org.gradle.libraryelements`]
| 表示 `org.gradle.category=library` 变体的内容
| `LibraryElements` 值由 link:{javadocPath}/org/gradle/api/attributes/LibraryElements.html[LibraryElements] 中定义的常量构建
| 遵循生态系统语义(例如. 在 JVM 中, 默认为 `jar` ，并且与 `classes` 兼容)

| link:{javadocPath}/org/gradle/api/attributes/DocsType.html#DOCS_TYPE_ATTRIBUTE[`org.gradle.docstype`]
| 表示 `org.gradle.category=documentation` 变体的内容
| `DocsType` 值由 link:{javadocPath}/org/gradle/api/attributes/DocsType.html[DocsType] 中定义的常量构建
| 没有默认值，没有兼容性

| link:{javadocPath}/org/gradle/api/attributes/Bundling.html#BUNDLING_ATTRIBUTE[`org.gradle.dependency.bundling`]
| 表示如何访问变体的依赖
| `Bundling` 值由 link:{javadocPath}/org/gradle/api/attributes/Bundling.html[Bundling] 中定义的常量构建
| 遵循生态系统语义 (例如. 在 JVM 中, `embedded` 与 `external` 兼容)
|===

.独立于生态系统的标准组件属性
[%header%autowidth,compact]
|===
| 属性名 | 描述 | 值 | 兼容性和消除歧义规则

| `org.gradle.status`
| 组件级别属性
| 基于 <<component_metadata_rules.adoc#sec:custom_status_scheme,a status scheme>>, 有一个基于源存储库的默认值.
| 基于使用的 scheme
|===

[[sub:jvm_default_attributes]]
=== JVM 生态系统特定属性

除了上面定义的与生态系统无关的属性外，JVM 生态系统还增加了以下属性:

.JVM 生态系统标准组件属性
[%header%autowidth,compact]
|===
| 属性名 | 描述 | 值 | 兼容性和消除歧义规则

| link:{javadocPath}/org/gradle/api/attributes/java/TargetJvmVersion.html#TARGET_JVM_VERSION_ATTRIBUTE[`org.gradle.jvm.version`]
| 表示 JVM 版本兼容性。
| 在 Java 1.4 之前使用 `1.` 表示, Java 5  之后使用 major version.
| 默认为 Gradle 使用的 JVM 版本，lower 与 Higher 兼容，首选最高兼容。
|===

JVM 生态系统还包含许多针对不同属性的兼容性和消歧规则。 想了解更多的读者可以看看 `org.gradle.api.internal.artifacts.JavaEcosystemSupport` 的代码。

=== 原生生态系统特定属性

除了上面定义的生态系统独立属性外，原生生态系统还增加了以下属性：

.原生生态系统标准组件属性
[%header%autowidth,compact]
|===
| 属性名 | 描述 | 值 | 兼容性和消除歧义规则

| link:{javadocPath}/org/gradle/language/cpp/CppBinary.html#DEBUGGABLE_ATTRIBUTE[`org.gradle.native.debuggable`]
| 指示二进制文件是否使用调试构建
| Boolean
| N/A

| link:{javadocPath}/org/gradle/language/cpp/CppBinary.html#OPTIMIZED_ATTRIBUTE[`org.gradle.native.optimized`]
| 指示二进制文件是否使用优化构建
| Boolean
| N/A

| link:{javadocPath}/org/gradle/nativeplatform/MachineArchitecture.html#ARCHITECTURE_ATTRIBUTE[`org.gradle.native.architecture`]
| 指示二进制文件的目标架构
| `MachineArchitecture` 值由 link:{javadocPath}/org/gradle/nativeplatform/MachineArchitecture.html[MachineArchitecture] 中定义的常量构建
| None

| link:{javadocPath}/org/gradle/nativeplatform/OperatingSystemFamily.html#OPERATING_SYSTEM_ATTRIBUTE[`org.gradle.native.operatingSystem`]
| 指示二进制文件的目标操作系统
| `OperatingSystemFamily` 值由 link:{javadocPath}/org/gradle/nativeplatform/OperatingSystemFamily.html[OperatingSystemFamily] 中定义的常量构建
| None
|===

[[sec:declaring_attributes]]
== 声明自定义属性

如果您正在扩展 Gradle，例如通过为另一个生态系统编写插件，如果您想在插件中支持变体感知依赖管理功能，则可以选择声明自定义属性。
但是，如果您还尝试发布库，则应谨慎。 新属性的语义通常通过插件定义，插件可以携带 <<#sec:abm_compatibility_rules,compatibility>> 和 <<sec:abm_disambiguation_rules,disambiguation>> 规则。
因此，使用为某个生态系统的库应用相应的插件，以正确解释属性。 如果您的插件面向更多受众，即如果它是公开可用的并且库已发布到公共存储库，则定义新属性有效地扩展了 Gradle 模块元数据的语义并附带一些责任。
例如，对已经发布的属性的支持不应该再次删除，或者应该在插件的未来版本中在某种兼容层中处理。

== 在构建脚本或插件中创建属性

属性为 _typed_. 一个属性可以通过 `Attribute<T>.of` 方法创建:

.Define attributes
====
include::{snippets-dir}/dependencyManagement/attributeMatching/groovy/build.gradle[tags=define_attribute]
include::{snippets-dir}/dependencyManagement/attributeMatching/kotlin/build.gradle.kts[tags=define_attribute]
====

目前，仅支持 `String` 的属性类型，或任何扩展 `Named` 的属性类型。
属性必须在 `dependencies` 处理程序的 _attribute schema_ 中声明：

.Registering attributes on the attributes schema
====
include::{snippets-dir}/dependencyManagement/attributeMatching/groovy/build.gradle[tags=register-attributes]
include::{snippets-dir}/dependencyManagement/attributeMatching/kotlin/build.gradle.kts[tags=register-attributes]
====

然后通过 configurations 配置属性值

.Setting attributes on configurations
====
include::{snippets-dir}/dependencyManagement/attributeMatching/groovy/build.gradle[tags=attributes-on-configurations]
include::{snippets-dir}/dependencyManagement/attributeMatching/kotlin/build.gradle.kts[tags=attributes-on-configurations]
====

对于类型为 `Named` 的属性，属性的值 **必须** 通过 _object factory_ 创建：

.Named attributes
====
include::{snippets-dir}/dependencyManagement/attributeMatching/groovy/build.gradle[tags=named-attributes]
include::{snippets-dir}/dependencyManagement/attributeMatching/kotlin/build.gradle.kts[tags=named-attributes]
====

[[sec:abm_compatibility_rules]]
=== 属性兼容规则

属性可以让引擎选择 _兼容的变体_。 但是，在某些情况下，提供者可能没有 _确切_ 消费者想要的东西，但仍然可以使用它。例如，如果消费者请求库的 API，则生产者可能没有这样的变体，而只有 _runtime_ 变体。
这是在外部存储库上发布的库的典型特征。 在这种情况下，我们知道即使我们没有完全匹配 (API)，我们仍然可以针对运行时变体进行编译（它包含的 _多于_ 我们需要编译的内容，但仍然可以使用）。
为了解决这个问题，Gradle 提供了链接：{javadocPath}/org/gradle/api/attributes/AttributeCompatibilityRule.html[属性兼容性规则]。 兼容性规则的作用是解释哪些变体与消费者要求的内容 _兼容_。

属性兼容性规则必须通过 {javadocPath}/org/gradle/api/attributes/AttributeMatchingStrategy.html[属性匹配策略]，您可以从链接获取：{javadocPath}/org/gradle/api/attributes /AttributesSchema.html[attributes schema] 注册。

[[sec:abm_disambiguation_rules]]
=== 属性消除歧义规则

因为一个属性的多个值可以与请求的属性 _兼容_，所以 Gradle 需要在候选者之间进行选择。
这是通过实现一个链接来完成的：{javadocPath}/org/gradle/api/attributes/AttributeDisambiguationRule.html[attribute disambiguation rule]。

属性消歧规则必须通过 {javadocPath}/org/gradle/api/attributes/AttributeMatchingStrategy.html[属性匹配策略]，您可以从链接获得：{javadocPath}/org/gradle/api/attributes /AttributesSchema.html[attributes schema] 注册：。