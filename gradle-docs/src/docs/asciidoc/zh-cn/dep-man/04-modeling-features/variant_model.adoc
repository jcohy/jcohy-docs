:metadata-file-spec: https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md

[[understanding-variant-selection]]
= 了解变体选择

Gradle 的依赖管理引擎被称为 _variant-aware_。
在像 Apache Maven™ 这样的传统依赖管理引擎中，依赖绑定到在 GAV 坐标上发布的组件。
这意味着一个组件的传递依赖集完全由该组件的 GAV 坐标决定。
_artifact_ 实际解决了什么并不重要，依赖项集_总是相同_。
此外，为组件选择不同的工件（例如，使用 `jdk7` 工件）很麻烦，因为它需要使用 _classifiers_。
这个模型的一个问题是它不能保证全局图的一致性，因为没有与 _classifiers_ 关联的通用语义。
这意味着没有什么可以阻止在类路径上同时拥有单个模块的 `jdk7` 和 `jdk8` 版本，因为引擎不知道什么语义与分类器名称相关联。

.The Maven component model
image::{image-dir}/component-model-maven.png[]

Gradle 除了在 GAV 坐标上发布一个 _module_ 的概念外，还引入了这个模块的 _variants_ 的概念。
变体对应于在相同 GAV 坐标上发布的组件的不同 "views"。 在 Gradle 模型中，工件附加到 _variants_，而不是模块。 这意味着，在实践中，不同的 _artifacts_ 可以有不同的依赖集:

.The Gradle component model
image::{image-dir}/component-model-gradle.png[]

这个中间级别将工件和依赖项与变体相关联，而不是直接与组件相关联，从而允许 Gradle 正确建模每个工件的用途。

然而，这引发了一个关于如何选择变体的问题：当有多个变体时，Gradle 如何知道选择哪个变体？
在实践中，由于使用了 <<variant_attributes.adoc#,attributes>> 来选择变体，它为变体提供语义并帮助引擎实现_一致的解析结果_。

由于历史原因，Gradle 区分了两种组件:

- 本地组件，从源构建，<<#sec:abm_configuration_attributes,变体映射到传出配置>>
- 外部组件，发布在存储库上，在这种情况下，模块是使用 Gradle 模块元数据发布的，并且本机支持变体，或者模块使用 Ivy/Maven 元数据和 <<#sec:mapping-maven-ivy-to-variants,变体来源于元数据>>。

在这两种情况下，Gradle 都会执行 _variant-aware selection_。

[[sec:abm_configuration_attributes]]
== 配置和 variant 属性

本地组件将变体公开为 _outgoing configurations_，即 <<declaring_dependencies.adoc#sec:resolvable-consumable-configs,consumable 配置>>。
当依赖关系解析发生时，引擎将通过选择其 _consumable 配置_之一来选择传出组件的一个变体。

[NOTE]
====
此规则有 2 个明显的例外:

- whenever a producer does _not_ expose any consumable configuration
- whenever the consumer _explicitly selects a target configuration_

In this case, _variant aware resolution is bypassed_.
====

属性用于 _resolvable configurations_ （也称为 _consumer_ ）和 _consumable configurations_（在 _producer_ 上）。
将属性添加到其他类型的配置根本没有效果，因为属性不会在配置之间继承。

依赖解析引擎的作用是在给定由 _consumer_ 表示的约束条件下找到 _producer_ 的合适 _variant_。

这就是属性发挥作用的地方：它们的作用是选择组件的正确 _variant_。

[NOTE]
.Variants vs configurations
====
对于外部组件，使用 _variants_，而不是 _configurations_。 configurations 是 variants 的父集。

这意味着一个外部组件提供了 _variants_，它也有属性。
但是，有时 _configuration_ 这个可能会由于历史原因泄漏到 DSL 中，或者因为您使用的 Ivy 也有 _configuration_ 的概念。
====

[[sec:variant-visual]]
== 可视化变体信息

Gradle 提供了一个名为 `outgoingVariants`  的 reporting 任务，它显示项目的变体，以及它们的功能、属性和构件。
它在概念上类似于 `dependencyInsight` <<viewing_debugging_dependencies.adoc#sec:identifying_reason_dependency_selection,reporting task>>。

默认情况下，`outgoingVariants` 打印有关所有变体的信息。 它提供了可选参数 `--variant <variantName>` 来选择要显示的单个变体。
它还接受 `--all` 标志以包含有关旧版和已弃用配置的信息。

这是新生成的  `java-library` 项目中 `outgoingVariants`  任务的输出：

[listing]
----
> Task :outgoingVariants
--------------------------------------------------
Variant apiElements
--------------------------------------------------
Description = API elements for main.

Capabilities
    - [default capability]
Attributes
    - org.gradle.category            = library
    - org.gradle.dependency.bundling = external
    - org.gradle.jvm.version         = 8
    - org.gradle.libraryelements     = jar
    - org.gradle.usage               = java-api

Artifacts
    - build/libs/variant-report.jar (artifactType = jar)

Secondary variants (*)
    - Variant : classes
       - Attributes
          - org.gradle.category            = library
          - org.gradle.dependency.bundling = external
          - org.gradle.jvm.version         = 8
          - org.gradle.libraryelements     = classes
          - org.gradle.usage               = java-api
       - Artifacts
          - build/classes/java/main (artifactType = java-classes-directory)

--------------------------------------------------
Variant runtimeElements
--------------------------------------------------
Description = Elements of runtime for main.

Capabilities
    - [default capability]
Attributes
    - org.gradle.category            = library
    - org.gradle.dependency.bundling = external
    - org.gradle.jvm.version         = 8
    - org.gradle.libraryelements     = jar
    - org.gradle.usage               = java-runtime

Artifacts
    - build/libs/variant-report.jar (artifactType = jar)

Secondary variants (*)
    - Variant : classes
       - Attributes
          - org.gradle.category            = library
          - org.gradle.dependency.bundling = external
          - org.gradle.jvm.version         = 8
          - org.gradle.libraryelements     = classes
          - org.gradle.usage               = java-runtime
       - Artifacts
          - build/classes/java/main (artifactType = java-classes-directory)
    - Variant : resources
       - Attributes
          - org.gradle.category            = library
          - org.gradle.dependency.bundling = external
          - org.gradle.jvm.version         = 8
          - org.gradle.libraryelements     = resources
          - org.gradle.usage               = java-runtime
       - Artifacts
          - build/resources/main (artifactType = java-resources-directory)


(*) Secondary variants are variants created via the Configuration#getOutgoing(): ConfigurationPublications API which also participate in selection, in addition to the configuration itself.
----

从这里您可以看到 java 库暴露了两个主要变体，`apiElements` 和 `runtimeElements`。
请注意，主要区别在于 `org.gradle.usage` 属性，其值为 `java-api` 和 `java-runtime`。
正如他们所指出的，这就是消费者的 _compile_ 类路径上需要的内容与 _runtime_ 类路径上需要的内容之间的区别所在。

它还显示了 _secondary_ 变体，它们是 Gradle 项目独有的，未发布。
例如，来自 `apiElements` 的二级变体 `classes` 允许 Gradle 在针对 <<java_library_plugin.adoc#sec:java_library_classes_usage,`java-library` 项目>> 进行编译时跳过 JAR 创建。

[[sec:variant-aware-matching]]
== 自动匹配

让我们以 `lib` 库为例，它公开了 2 个变体： API（通过名为 `exposedApi` 暴露）和运行时（通过名为 `exposedRuntime` 暴露）。


[NOTE]
.关于生产者变体
====
_name_ 主要用于调试目，并在错误消息中获得更好的显示。 特别是名称不参与变体的_id_：只有它的属性参与。 也就是说，要搜索一个变体，_必须_ 依赖于它的属性，而不是它的名字。

组件可以暴露的变体数量没有限制。
传统上，一个组件会公开一个 API 和一个 implementation，但我们可能也想暴露一个组件的测试夹具。
也可以为不同的消费者公开 _不同的 APIs_（考虑不同的环境，如 Linux 与 Windows）。
====

消费者需要解释它需要什么变体类型，这是通过在 _consumer_ 上设置 _attributes_ 来完成的。

属性由一个 _name_ 和一个 _value_ 对组成。
例如，Gradle 带有一个名为 `org.gradle.usage` 的标准属性，专门用于处理根据使用者的使用情况（编译、运行时......）选择正确的组件变体的概念。
然而，可以定义任意数量的属性。 作为生产者，我们可以通过将 `(org.gradle.usage,JAVA_API)` 属性附加到变体来表示可消耗配置表示组件的 API。
作为消费者，我们可以通过附加 `(org.gradle.usage,JAVA_API)` 属性来表达我们需要可解析配置的依赖项的 API。 这样做，Gradle 可以通过查看配置属性来 _自动选择适当的变体_：

- 消费者想要 `org.gradle.usage=JAVA_API`
- 对于生产者, `lib`  暴露了 2 个不同的变体。 一个是 `org.gradle.usage=JAVA_API`, 一个是 `org.gradle.usage=JAVA_RUNTIME`.
- Gradle 选择生产者的 `org.gradle.usage=JAVA_API` 变体，因为它 _匹配消费者属性_

换句话说：属性用于根据属性的值进行选择。

更详细的示例涉及多个属性。 通常，Gradle 中的 Java 库项目将涉及 4 个不同的属性，在生产者和消费者端都可以找到：:

- `org.gradle.usage`, 解释变体是组件的 API，还是组件的实现
- `org.gradle.dependency.bundling`, 它声明了组件的依赖项是如何捆绑的（例如，如果构件是一个胖罐子，那么捆绑是 `EMBEDDED`）
- `org.gradle.libraryelements`, 用于解释包含的库的 _parts_（类、资源或所有内容）
- `org.gradle.jvm.version`, 解释了 Java 最小的版本

现在想象我们的库有两种不同的风格：

- one for JDK 8
- one for JDK 9+

在 Maven 中，这通常是通过生成 2 个不同的构件来实现的，一个 "main" 构件和一个 "classified" 构件。
然而，在 Maven 中，消费者在基于运行时无法表达它需要的哪个库。

使用 Gradle，这可以通过让生产者声明 2 个变体来优雅地解决：:

- 一个 `org.gradle.jvm.version=8`, 至少在 JDK 8 上运行
- 一个 `org.gradle.jvm.version=9`, 至少在 JDK 9 上运行

请注意，两种风格的构件会有所不同，但它们的依赖关系 _可能_ 也不同。
通常，JDK 8 可能需要 JDK 9+ 的 "backport" 库才能工作，只有在 JDK 8 上运行的消费者才能获得该库。

在消费者方面，_resolvable configuration_ 将设置上述所有四个属性，并且根据运行时，将其 org.gradle.jvm.version 设置为 8 或更多。

[NOTE]
.A note about compatibility of variants
====
如果消费者将 `org.gradle.jvm.version` 设置为 7 怎么办？

然后解析会 _fail_ 并显示一条错误消息，说明生产者没有匹配的变体。
这是因为 Gradle 认识到消费者想要一个兼容 Java 7 的库，但生产者上可用的 Java 的 _minimal_ 版本是 8。
另一方面，如果消费者需要 _11_，则 Gradle 知道 _8_ 和 _9_ 变体都可以工作，但它会选择 _9_，因为它是最高兼容版本。
====

[[sec:variant-select-errors]]
== 变体选择错误

在识别组件的正确变体的过程中，有两种情况会导致解析错误：

* 来自生产者的多个变体与消费者属性匹配，存在变体歧义
* 生产者没有变体匹配消费者属性

[[sub:variant-ambiguity]]
=== 处理模棱两可的变体选择错误

模棱两可的变体选择如下所示：

[listing]
----
> Could not resolve all files for configuration ':compileClasspath'.
   > Could not resolve project :lib.
     Required by:
         project :ui
      > Cannot choose between the following variants of project :lib:
          - feature1ApiElements
          - feature2ApiElements
        All of them match the consumer attributes:
          - Variant 'feature1ApiElements' capability org.test:test-capability:1.0:
              - Unmatched attribute:
                  - Found org.gradle.category 'library' but wasn't required.
              - Compatible attributes:
                  - Provides org.gradle.dependency.bundling 'external'
                  - Provides org.gradle.jvm.version '11'
                  - Required org.gradle.libraryelements 'classes' and found value 'jar'.
                  - Provides org.gradle.usage 'java-api'
          - Variant 'feature2ApiElements' capability org.test:test-capability:1.0:
              - Unmatched attribute:
                  - Found org.gradle.category 'library' but wasn't required.
              - Compatible attributes:
                  - Provides org.gradle.dependency.bundling 'external'
                  - Provides org.gradle.jvm.version '11'
                  - Required org.gradle.libraryelements 'classes' and found value 'jar'.
                  - Provides org.gradle.usage 'java-api'
----

可以看出，显示了所有 _compatible_ 候选变体及其属性。 然后将它们分为两个部分：

* 首先显示不匹配的属性，因为它们可能是选择正确变体时缺少的部分。
* 兼容属性显示在第二位，因为它们表明消费者想要什么以及这些变体如何匹配该请求。

不能有任何不匹配的属性，因为那时该变体将不是候选者。 类似地，显示的变体集也排除了已消除歧义的变体。

在上面的示例中，修复不在于属性匹配，而在于 <<dependency_capability_conflict.adoc#sub:selecting-between-candidates,capability matching>>，显示在变体名称旁边。
因为这两个变体有效地提供了相同的属性和能力，所以它们不能被消除歧义。 所以在这种情况下，修复最有可能在生产者端（`project :lib`）提供不同的能力，并在消费者端（`project :ui`）表达能力选择。

[[sub:variant-no-match]]
=== 处理没有匹配的变体错误

没有匹配的变体错误类似于以下内容：

[listing]
----
> No variants of project :lib match the consumer attributes:
  - Configuration ':lib:compile':
      - Incompatible attribute:
          - Required artifactType 'dll' and found incompatible value 'jar'.
      - Other compatible attribute:
          - Provides usage 'api'
  - Configuration ':lib:compile' variant debug:
      - Incompatible attribute:
          - Required artifactType 'dll' and found incompatible value 'jar'.
      - Other compatible attributes:
          - Found buildType 'debug' but wasn't required.
          - Provides usage 'api'
  - Configuration ':lib:compile' variant release:
      - Incompatible attribute:
          - Required artifactType 'dll' and found incompatible value 'jar'.
      - Other compatible attributes:
          - Found buildType 'release' but wasn't required.
          - Provides usage 'api'
----

可以看出，_all_ 候选变体及其属性都被显示出来。
然后将它们分为两个部分：

* 首先显示不兼容的属性，因为它们通常是理解为什么无法选择变体的关键。
* 其他属性显示在第二位，这包括 _required_ 和 _compatible_ 属性以及消费者未请求的所有额外 _producer_ 属性。

与模棱两可的变体错误类似，目标是了解要选择哪个变体，并查看可以在消费者身上调整哪些属性或能力以实现这一点。

[[sec:mapping-maven-ivy-to-variants]]
== 从 Maven/Ivy 映射到变体

Maven 和 Ivy 都没有 _variants_ 的概念，只有 Gradle Module Metadata 原生支持。
然而，由于不同的策略，它并没有阻止 Gradle 与他们结合。

[NOTE]
.Relationship with Gradle Module Metadata
====
Gradle Module Metadata 是发布在 Maven、Ivy 或其他类型存储库上的模块的元数据格式。
它类似于 `pom.xml` 或 `ivy.xml` 文件，但这种格式 _aware of variables_。
这意味着，如果您的项目产生其他变体，这些变体将作为模块元数据的一部分可用并发布，从而极大地改善了用户体验。

有关详细信息，请参阅 {metadata-file-spec}[Gradle 模块元数据规范]。
====

[[sub:maven-mapping-to-variants]]
=== 将 POM 文件映射到变体

发布在 Maven 存储库上的模块被转换为变体感知模块。 Maven 模块的一个特殊性是无法知道发布了哪种组件。 特别是，无法区分表示_platform_ 的BOM 和用作超级POM 的BOM。 有时，POM 文件甚至可以同时充当平台和库。

因此，Maven 模块被派生为 6 个不同的变体，这使得 Gradle 用户可以准确地解释他们所依赖的内容：

* 2 "library" 变体 (属性 `org.gradle.category` = `library`)
** `compile` 映射为 `<scope>compile</scope>` 依赖. 和 <java_library_plugin.adoc#,Java Library plugin>>  中的 `apiElements` 等效.
此作用域的所有依赖项都视为 _API dependencies_.
** `runtime` 映射为 `<scope>compile</scope>` 和 `<scope>runtime</scope>` 依赖. 和 <<java_library_plugin.adoc#,Java Library plugin>> 中的 `runtimeElements`  等效.
此作用域的所有依赖项都视为 _runtime dependencies_.
- 在这两种情况下，`<dependencyManagement>` 依赖都不会转换为约束
* 4 "platform" 属于 `<dependencyManagement>` 块 (属性为 `org.gradle.category` = `platform`):
** `platform-compile` 将  `<scope>compile</scope>` 依赖管理映射为 _dependency constraints_ （依赖约束）.
** `platform-runtime` 将 `<scope>compile</scope>` 和 `<scope>runtime</scope>` 依赖管理映射为 _dependency constraints_ （依赖约束）.
** `enforced-platform-compile` 和 `platform-compile` 相似，但约束都是 _forced_
** `enforced-platform-runtime` 和 `platform-runtime` 相似，但约束都是 _forced_

您可以通过查看手册的 <<platforms.adoc#sub:bom_import, importing BOMs>> 部分了解有关平台和强制平台变体的使用的更多信息。
默认情况下，每当您声明对 Maven 模块的依赖项时，Gradle 都会查找 `library` 变体。
但是，使用 `platform` 或 `enforcedPlatform` 关键字，Gradle 现在正在寻找“平台”变体之一，它允许您从 POM 文件导入约束，而不是依赖项。

[[sub:ivy-mapping-to-variants]]
=== 将 Ivy 文件映射到变体

与 <<#sub:maven-mapping-to-variants, Maven>> 相反，默认情况下没有为 Ivy 文件实现继承策略。
这样做的原因是，与 pom 不同，Ivy 是一种灵活的格式，允许您发布任意多个和自定义的 _configurations_。
因此，通常 Ivy 中没有编译/运行时范围或编译/运行时变体的概念。 仅当您使用 <<publishing_ivy.adoc#publishing_ivy,ivy-publish 插件>> 通过 Gradle 发布 ivy 文件时，您会得到一个遵循与 pom 文件类似模式的结构。
但由于不能保证构建使用的*所有* ivy 元数据文件都遵循此模式，Gradle 无法强制执行基于它的派生策略。

但是，如果您想为 Ivy 实现 _compile_ 和 _runtime_ 变体的派生策略，可以使用 <<component_metadata_rules.adoc#sec:component_metadata_rules,component metadata rule>>。
组件元数据规则 API 允许您<<component_metadata_rules.adoc#sec:component_metadata_rules_details,访问 ivy 配置>>并基于它们创建变体。
如果您知道您使用的所有 ivy 模块都已使用 Gradle 发布，而无需进一步自定义 ivy.xml 文件，则可以将以下规则添加到您的构建中：

.Deriving compile and runtime variants for Ivy metadata
====
include::{snippets-dir}/dependencyManagement/customizingResolution-ivyMetadataRule/groovy/build.gradle[tags=ivy-component-metadata-rule]
include::{snippets-dir}/dependencyManagement/customizingResolution-ivyMetadataRule/kotlin/build.gradle.kts[tags=ivy-component-metadata-rule]
====

该规则基于 `compile` 配置创建一个 `apiElements` 变体，并基于每个 ivy 模块的 `default` 配置创建一个 `runtimeElements` 变体。
对于每个变体，它设置相应的<<#sec:variant-aware-matching,Java 生态系统属性>>。
变体的依赖关系和工件取自底层配置。
如果并非所有使用的 ivy 模块都遵循此模式，则可以调整规则或仅将其应用于选定的一组模块。

对于所有没有变体的 ivy 模块，Gradle 回退到旧配置选择（即 Gradle 不会_不_对这些模块执行变体感知解析）。
这意味着要么选择“默认”配置，要么选择在相应模块的依赖项中明确定义的配置。
（请注意，只能从构建脚本或 ivy 元数据中进行显式配置选择，应避免选择变体。）