:maven-optional-deps: https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html[Maven optional dependencies]
:metadata-file-spec: https://github.com/gradle/gradle/blob/master/subprojects/docs/src/docs/design/gradle-module-metadata-latest-specification.md

[[feature_variants]]
= Modeling feature variants and optional dependencies

Gradle 支持 _feature variants_ （功能变体）: 当构建库时, 通常情况下，某些功能仅在存在某些依赖或使用特殊构件时才可用。

功能变体让消费者可以选择他们需要的库的 _features_：依赖管理引擎将选择正确的构件和依赖。

这允许许多不同的场景（列表没有全部列出来）：

- {maven-optional-deps} 更好的替代
- 构建了 _main_ 库 支持运行时功能的不同互斥实现; <<sec::incompatible_variants,有且只能选择一个, 每一个这种特征的实现>>
- 构建了 _main_ 库 支持可选的运行时特性，每个特性都需要一组不同的依赖项
- _main_ 库 包含了一些其他库，例如 _test fixtures_
- _main_ 库有一个 main artifact, 启用额外的 feature 需要额外 artifacts

[[sec::feature_variant_selection]]
== 选择特征变体和功能

声明对组件的依赖通常是通过提供一组坐标（group, artifact, version，也称为 GAV 坐标）来完成的。
这允许引擎确定我们正在寻找的 _component_，但这样的组件可能会提供不同的 _variants_。
通常根据使用情况选择 _variant_。 例如，我们可能会选择不同的变体来针对组件进行编译（在这种情况下，我们需要组件的 API）或在执行代码时（在这种情况下，我们需要组件的运行时）。
组件的所有变体都提供了许多 <<dependency_capability_conflict.adoc#sub:capabilities, capabilities>>，它们使用 GAV 坐标类似地表示。

[NOTE]
====
由 GAV 坐标表示，但您必须将其视为特征描述：
A capability is denoted by GAV coordinates, but you must think of it as feature description:

- "I provide an SLF4J binding"
- "I provide runtime support for MySQL"
- "I provide a Groovy runtime"

一般来说，有两个组件在图中提供 _相同的东西_ 是一个问题（它们冲突）。
====

这是一个重要的概念，因为：:

- 默认情况下，变体提供与其组件的 GAV 坐标相对应的功能
- 如果它们提供相同的能力，则不允许在依赖图中具有不同的组件或组件的不同变体
- 允许选择同一组件的两个变体，只要它们提供 _不同的功能_

一个典型的组件将 *只* 提供具有默认功能的变体。
例如，Java 库公开了两个提供 _相同功能_ 的变体（_API_ 和 _runtime_）。
因此，在依赖图中同时包含单个组件的 _API_ 和 _runtime_ 是错误的。

但是，假设您需要一个组件的 _runtime_ 和 _test fixtures_。
然后，只要库的 _runtime_ 和 _test fixtures_ 变体声明不同的功能，它就被允许。

如果我们这样做，用户将不得不声明两个依赖项：

- one on the "main" variant, the library
- one on the "test fixtures" variant, by _requiring its capability_

[NOTE]
====
虽然引擎支持独立于生态系统的功能变体，但此功能目前仅可使用 Java 插件使用并且正在孵化中。
====

[[sec::declare_feature_variants]]
== 声明功能变体

可以通过应用 `java` 或 `java-library` 插件来声明功能变体。
下面的代码说明了如何声明一个名为 `mongodbSupport` 的功能：

.Declaring a feature variant
====
include::{snippets-dir}/java-feature-variant/producer/groovy/build.gradle[tags=register_variant]
include::{snippets-dir}/java-feature-variant/producer/kotlin/build.gradle.kts[tags=register_variant]
====

Gradle 会自动为您设置许多东西，其方式与 <<java_library_plugin#java_library_plugin,Java Library Plugin>> 设置配置的方式非常相似:

- 配置 `mongodbSupportApi`，用于 _declare API dependencies_ 为此功能
- 配置 `mongodbSupportImplementation`，用于 _declare implementation dependencies_ 为此功能
- 配置 `mongodbSupportApiElements`，用户用来获取此功能的工件和 API 依赖
- 配置 `mongodbSupportRuntimeElements`，用户使用它来获取此功能的工件和运行时依赖

大多数用户只需要关心前两个配置，即可声明此功能的具体依赖关系：

.Declaring dependencies of a feature
====
include::{snippets-dir}/java-feature-variant/producer/groovy/build.gradle[tags=variant_dependencies]
include::{snippets-dir}/java-feature-variant/producer/kotlin/build.gradle.kts[tags=variant_dependencies]
====

[NOTE]
====
按照惯例，Gradle 将功能名称映射到一个功能，其 group 和 version 分别与主组件的 group 和 version 相同，但其名称是主组件名称后跟一个 `-` 短横线命名的名称。

例如，如果组是 `org.gradle.demo`，组件的名称是 `provider`，它的版本是 `1.0`，并且功能命名为 `mongodbSupport`，那么功能变体将是  `org.gradle.demo:provider-mongodb-support:1.0`.。

如果您自己选择功能名称或向变体添加更多功能，建议遵循相同的约定。
====

[[sec:feature_variant_source_set]]
=== Feature variant source set

在前面的示例中，我们声明了一个使用 _main source set_ 的功能变体。
这是 Java 生态系统中的一个典型用例，无论出于何种原因，都无法将项目的源代码拆分为不同的子项目或不同的源代码集。
因此，Gradle 将按照描述的声明配置，还将设置 _main source set_ 的编译类路径和运行时类路径，以便它从功能配置扩展。
换句话说，这允许您在自己的 "bucket" 中声明特定于某个功能的依赖，但所有内容仍被编译为单个源集。
还将有一个工件（组件 Jar），包括对所有功能的支持。

但是，通常更喜欢为功能设置一个_单独的源集_。 Gradle 然后将执行类似的映射，但不会使主组件的编译和运行时类路径从注册功能的依赖项扩展。
按照惯例，它还将创建一个“Jar”任务来捆绑从此功能源集构建的类，使用与该功能的 kebab-case 名称相对应的分类器：

.Declaring a feature variant using a separate source set
====
include::{snippets-dir}/java-feature-variant/producer-separate-sourceset/groovy/build.gradle[tags=register_variant,register_variant2]
include::{snippets-dir}/java-feature-variant/producer-separate-sourceset/kotlin/build.gradle.kts[tags=register_variant,register_variant2]
====

[[sec::publishing_feature_variants]]
== Publishing feature variants

[WARNING]
====
根据元数据文件格式，发布功能变体可能有问题：

- 使用 {metadata-file-spec}[Gradle Module Metadata]，所有内容都已发布，用户将获得功能变体的全部好处
- 使用 POM 元数据 (Maven)，功能变体作为 **可选依赖项** 发布，并且功能变体的工件使用不同的 _classifiers_ 发布
- 使用 Ivy 元数据，功能变体作为额外配置发布，_not_ 由 `default` 配置扩展
====

仅使用 `maven-publish` 和 `ivy-publish` 插件支持发布功能变体。
Java 插件（或 Java 库插件）将负责为您注册额外的变体，因此不需要额外的配置，只需定期发布：

.Publishing a component with feature variants
====
include::{snippets-dir}/java-feature-variant/producer/groovy/build.gradle[tags=plugins,publishing]
include::{snippets-dir}/java-feature-variant/producer/kotlin/build.gradle.kts[tags=plugins,publishing]
====

[[sub:javadoc_sources_features_variants]]
=== 添加 javadoc 和 sources JARs

与 <<building_java_projects.adoc#sec:java_packaging,main Javadoc and sources JARs>> 类似，您可以配置添加的功能变体，以便它为 Javadoc 和源代码生成 JAR。
然而，这仅在使用主源集以外的源集时才有意义。

.Producing javadoc and sources JARs for feature variants
====
include::{snippets-dir}/java-feature-variant/producer-separate-sourceset/groovy/build.gradle[tags=register_variant_extra_jars]
include::{snippets-dir}/java-feature-variant/producer-separate-sourceset/kotlin/build.gradle.kts[tags=register_variant_extra_jars]
====

[[sec::consuming_feature_variants]]
== 依赖 feature variants

[WARNING]
====
如前所述，特征变体在发布时可能是有损的。
因此，消费者只能在以下情况下依赖特征变体:

- 具有项目依赖关系（在多项目构建中）
- 有可用的 Gradle 模块元数据，即发布者必须已发布它
- 在 Ivy 中，通过声明对匹配特性的配置的依赖
====

消费者可以通过声明所需的能力来指定它需要生产者的特定功能。
例如，如果生产者声明了这样的 "MySQL support" 功能:

.A library declaring a feature to support MySQL
====
include::{snippets-dir}/java-feature-variant/requiring-features/groovy/producer/build.gradle[tags=producer]
include::{snippets-dir}/java-feature-variant/requiring-features/kotlin/producer/build.gradle.kts[tags=producer]
====

然后消费者可以通过执行以下操作声明对 MySQL 支持特性的依赖：

.Consuming specific features in a multi-project build
====
include::{snippets-dir}/java-feature-variant/requiring-features/groovy/consumer/build.gradle[tags=consumer]
include::{snippets-dir}/java-feature-variant/requiring-features/kotlin/consumer/build.gradle.kts[tags=consumer]
====

这会将 `mysql-connector-java` 依赖于运行时类路径。
如果存在多个依赖，则所有依赖都将被引入，这意味着可以使用一项功能将有助于一项功能的依赖组合在一起。

类似地，如果使用 {metadata-file-spec}[Gradle Module Metadata] 发布了具有功能变体的外部库，则可以依赖该库提供的功能：

.Consuming specific features from an external repository
====
include::{snippets-dir}/java-feature-variant/requiring-features-external/groovy/project/build.gradle[tags=consumer]
include::{snippets-dir}/java-feature-variant/requiring-features-external/kotlin/project/build.gradle.kts[tags=consumer]
====


[[sec::incompatible_variants]]
== 处理互斥变体

使用 _capabilities_ 作为处理特性的一种方式的主要优点是您可以精确地处理变体的兼容性。
规则很简单:

> It's not allowed to have two variants of components that provide the same capability in a single dependency graph.

每当用户错误配置依赖时，我们可以利用它来要求 Gradle 失败。
想象一下，例如，您的库支持 MySQL、Postgres 和 MongoDB，但它只允许同时选择其中的 _一个_。
Not allowed 应该直接翻译为 "提供相同的能力"，所以必须有一个能力由所有三个特性提供:

.A producer of multiple features that are mutually exclusive
====
include::{snippets-dir}/java-feature-variant/incompatible-variants/groovy/producer/build.gradle[tags=producer]
include::{snippets-dir}/java-feature-variant/incompatible-variants/kotlin/producer/build.gradle.kts[tags=producer]
====

在这里，生产者声明了 3 个变体，一个用于每个数据库运行时支持：

- `mysql-support` 提供了 `db-support` 和 `mysql-support` 能力
- `postgres-support` 提供了 `db-support` 和 `postgres-support` 能力
- `mongo-support` 提供 `db-support` 和 `mongo-support` 功能

然后，如果消费者尝试像这样同时获得 `postgres-support` 和 `mysql-support` （这也可以传递）：

.A consumer trying to use 2 incompatible variants at the same time
====
include::{snippets-dir}/java-feature-variant/incompatible-variants/groovy/consumer/build.gradle[tags=consumer]
include::{snippets-dir}/java-feature-variant/incompatible-variants/kotlin/consumer/build.gradle.kts[tags=consumer]
====

依赖关系解析将失败并出现以下错误:

----
Cannot choose between
   org.gradle.demo:producer:1.0 variant mysqlSupportRuntimeElements and
   org.gradle.demo:producer:1.0 variant postgresSupportRuntimeElements
   because they provide the same capability: org.gradle.demo:producer-db-support:1.0
----
