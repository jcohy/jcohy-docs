[[cross_project_publications]]
= 在项目之间共享输出

在多项目构建中，一个常见的模式是一个项目使用另一个项目的构件。 一般来说，Java 生态中最简单的形式是当 `A` 依赖于 `B` 时，`A` 会依赖于 `B` 项目产生的 `jar`。
如本章前面所述，这是由 `A` 建模的，取决于 `B` 的 _variant_，其中根据 `A` 的需要选择变量。 对于编译，我们需要 `apiElements` 提供的 `B` 的 API 依赖。 对于运行时，我们需要由 `runtimeElements` 提供的 `B` 的运行时依赖。

但是，如果您需要一个与主要工件不同的构件怎么办？
例如，Gradle 提供了对依赖另一个项目的 <<java_testing.adoc#sec:java_test_fixtures,test fixtures>> 的内置支持，但有时您需要依赖的构件根本不会作为变量公开。

为了在项目之间 _安全地共享_ 并允许最大性能（并行性），此类构件必须通过 _outgoing configurations_ 暴露。

[WARNING]
.Don't reference other project tasks directly
====
A frequent anti-pattern to declare cross-project dependencies is:

[source,groovy]
----
dependencies {
   // this is unsafe!
   implementation project(":other").tasks.someOtherJar
}
----

This publication model is _unsafe_ and can lead to non-reproducible and hard to parallelize builds.
This section explains how to _properly create cross-project boundaries_ by defining "exchanges" between projects by using _variants_.
====

有两个互补的选项可以在项目之间共享构件。
<<#sec:simple-sharing-artifacts-between-projects,simplified version>> 仅适用于您需要共享的是不依赖于消费者的简单构件的情况。
简单的解决方案也仅限于此工件未发布到存储库的情况。 这也意味着消费者不会发布对这个构件的依赖。
如果消费者在不同的上下文（例如，不同的目标平台）中解析到不同的构件或需要发布，则需要使用 <<#sec:variant-aware-sharing,advanced version>>。

[[sec:simple-sharing-artifacts-between-projects]]
== Simple sharing of artifacts between projects

首先，生产者需要声明一个将 _exposed_  给消费者的配置。
正如在 <<declaring_dependencies.adoc#sec:resolvable-consumable-configs, 配置章节>> 中解释的，这对应于一个 _consumable configuration_。

让我们假设消费者需要来自生产者的 _instrumented classes_，但是这个构件 _不是_ 主要的。 生产者可以通过创建将 "carry"  此构件的配置来暴露其检测类：

.Declaring an outgoing variant
====
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-simple/groovy/producer/build.gradle[tags=declare-outgoing-configuration]
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-simple/kotlin/producer/build.gradle.kts[tags=declare-outgoing-configuration]
====

此配置是 _consumable_，这意味着它是针对消费者的 "exchange"。
我们现在要向这个配置添加构件，消费者在使用它时会得到：

.Attaching an artifact to an outgoing configuration
====
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-simple/groovy/producer/build.gradle[tags=attach-outgoing-artifact]
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-simple/kotlin/producer/build.gradle.kts[tags=attach-outgoing-artifact]
====

这里我们附加的  "artifact"  是一个 _task_，它实际上生成了一个 Jar。 这样做，Gradle 可以自动跟踪此任务的依赖关系并根据需要构建它们。
这是可能的，因为 `Jar` 任务扩展了 `AbstractArchiveTask`。
如果不是这种情况，您将需要明确声明构件是如何生成的。

.Explicitly declaring the task dependency of an artifact
====
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-simple/groovy/producer/build.gradle[tags=attach-outgoing-artifact-explicit]
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-simple/kotlin/producer/build.gradle.kts[tags=attach-outgoing-artifact-explicit]
====

现在 _consumer_ 需要依赖此配置才能获得正确的工件：

.An explicit configuration dependency
====
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-simple/groovy/consumer/build.gradle[tags=explicit-configuration-dependency]
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-simple/kotlin/consumer/build.gradle.kts[tags=explicit-configuration-dependency]
====

[WARNING]
====
如果您计划发布具有此依赖关系的组件，则 _不建议_ 声明对显式目标配置的依赖关系：
这可能会导致元数据损坏。 如果您需要在远程存储库上发布组件，请按照 <<#sec:variant-aware-sharing,variant-aware cross publishing documentation>> 的说明进行操作。
====

在这种情况下，我们将依赖项添加到 _instrumentedClasspath_ 配置，这是一个 _consumer specific configuration_。
在 Gradle 术语中，这称为 <<declaring_dependencies.adoc#sec:resolvable-consumable-configs,resolvable configuration>>，它是这样定义的:

.Declaring a resolvable configuration on the consumer
====
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-simple/groovy/consumer/build.gradle[tags=resolvable-configuration]
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-simple/kotlin/consumer/build.gradle.kts[tags=resolvable-configuration]
====

[[sec:variant-aware-sharing]]
== Variant-aware sharing of artifacts between projects

在 <<#sec:simple-sharing-artifacts-between-projects, 简单共享解决方案>>中，我们在生产者端定义了一个配置，作为生产者和消费者之间的构件交换。
然而，消费者必须明确地告诉它依赖于哪个配置，这是我们想要在 _variant-aware resolution_ 中避免的事情。
事实上，我们也 <<variant_model.adoc#understanding-variant-selection, 已经解释>>消费者可以使用 _attributes_ 来表达需求，并且生产者也应该使用属性提供适当的输出变量。
这允许更智能的选择，因为使用单个依赖声明，没有任何明确的目标配置，消费者可以解决不同的事情。
典型的例子是使用单个依赖声明 `project(":myLib")`，我们会根据架构选择 `arm64` 或 `i386` 版本的 `myLib`。

为此，我们将为消费者和生产者添加属性。

[WARNING]
====
重要的是要理解，一旦配置具有属性，它们就会参与 _变量感知解析_，这意味着只要使用像 `project(":myLib")` 这样的 _any_ 符号，它们就会被考虑。
换句话说，生产者上设置的属性_必须与同一项目上生产的其他变量一致_。
他们尤其不能为现有的选择引入歧义。

在实践中，这意味着您创建的配置上使用的属性集可能依赖于正在使用的 _ecosystem_（Java、C++、...），因为这些生态系统的相关插件通常使用不同的属性。
====

让我们增强我们之前的示例，该示例恰好是一个 Java 库项目。
Java 库向它们的消费者暴露了几个变量，`apiElements` 和 `runtimeElements`。 现在，我们添加了第三个，`instrumentedJars`。

因此，我们需要了解我们的新变量的用途，以便为其设置适当的属性。 让我们看看我们在 `runtimeElements` 配置中找到的属性：

.gradle outgoingVariants --variant runtimeElements
----
Attributes
    - org.gradle.category            = library
    - org.gradle.dependency.bundling = external
    - org.gradle.jvm.version         = 11
    - org.gradle.libraryelements     = jar
    - org.gradle.usage               = java-runtime
----

它告诉我们的是 Java 库插件生成具有 5 个属性的变量：

- `org.gradle.category` 告诉我们这个变量代表一个 _library_
- `org.gradle.dependency.bundling` 告诉我们这个变量的依赖是作为 jars 找到的（例如，它们不会在 jar 中重新打包）
- `org.gradle.jvm.version` 告诉我们这个库支持的最低 Java 版本是 Java 11
- `org.gradle.libraryelements` 告诉我们这个变量包含 jar 中的所有元素（类和资源）
- `org.gradle.usage` 表示此变量是 Java 运行时，因此适用于 Java 编译器，但也适用于运行时

因此，如果我们希望在执行测试时使用我们的检测类代替这个变量，我们需要将类似的属性附加到我们的变量。
实际上，我们关心的属性是 `org.gradle.libraryelements`，它解释了 _变量包含的内容_，所以我们可以这样设置变量：

.Declaring the variant attributes
====
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/groovy/producer/build.gradle[tags=declare-outgoing-configuration]
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/kotlin/producer/build.gradle.kts[tags=declare-outgoing-configuration]
====

[NOTE]
====
选择正确的属性来设置是这个过程中最难的事情，因为它们带有变量的语义。
因此，在添加 _新属性_ 之前，您应该始终问自己是否没有带有您需要的语义的属性。
如果没有，那么您可以添加一个新属性。
添加新属性时，您还必须小心，因为它可能会在选择过程中产生歧义。
通常添加属性意味着将其添加到 _所有_ 现有变量中。
====

我们在这里所做的是添加了一个 _new_ 变量，它可以在 _at runtime_ 使用，但包含检测类而不是普通类。
但是，现在这意味着对于运行时，消费者必须在两种变量之间进行选择：

- `runtimeElements`，`java-library` 插件提供的常规变量
- `instrumentedJars`，我们创建的变量

特别是，假设我们想要测试运行时类路径上的检测类。
现在，我们可以在消费者上将我们的依赖项声明为常规项目依赖项：

.Declaring the project dependency
====
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/groovy/consumer/build.gradle[tags=test_dependency]
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/kotlin/consumer/build.gradle.kts[tags=test_dependency]
====

如果我们停在这里，Gradle 仍然会选择 `runtimeElements` 变量来代替我们的 `instrumentedJars` 变量。
这是因为 `testRuntimeClasspath` 配置要求配置 `libraryelements` 属性是 `jar`，而我们的新 `instrumented-jars` 值是 _不兼容_。

所以我们需要更改请求的属性，以便我们现在寻找检测的 jar：

.Changing the consumer attributes
====
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/groovy/consumer/build.gradle[tags=ask-for-instrumented-classes]
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/kotlin/consumer/build.gradle.kts[tags=ask-for-instrumented-classes]
====

现在，我们告诉我们，每当我们要解析测试运行时类路径时，我们正在寻找的是 _instrumented classes_。
但是有一个问题：在我们的依赖项列表中，我们有 JUnit，很明显，它 _not_ instrumented。
因此，如果我们停在这里，Gradle 将会失败，并解释说没有提供检测类的 JUnit 变量。
这是因为我们没有解释如果没有可用的检测版本，可以使用常规 jar。
为此，我们需要编写一个 _兼容性规则_：

.A compatibility rule
====
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/groovy/consumer/build.gradle[tags=compatibility-rule]
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/kotlin/consumer/build.gradle.kts[tags=compatibility-rule]
====

我们需要在属性 schema 上声明:

.Making use of the compatibility rule
====
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/groovy/consumer/build.gradle[tags=compatibility-rule-use]
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-advanced/kotlin/consumer/build.gradle.kts[tags=compatibility-rule-use]
====

就是这样！ 现在我们有：

- 添加了一个提供 instrumented jars 的变量
- 解释这个变量是运行时的替代品
- 解释消费者需要此变量 _仅用于测试运行时_

因此，Gradle 提供了一种强大的机制来根据偏好和兼容性选择正确的变量
更多详细信息可以在 <<variant_attributes.adoc#, 文档的变量感知插件部分>> 中找到。

[WARNING]
====
通过像我们所做的那样向现有属性添加值，或者通过定义新属性，我们正在扩展模型。
这意味着 _所有消费者_ 都必须了解这个扩展模型。
对于本地消费者来说，这通常不是问题，因为所有项目都理解并共享相同的模式，但是如果您必须将此新变量发布到外部存储库，这意味着外部消费者必须将相同的规则添加到他们的构建中 他们通过。
对于 _生态系统插件_（例如：Kotlin 插件）来说，这通常不是问题，在任何情况下，如果不应用插件，消费是不可能的，但如果您添加自定义值或属性，就会出现问题。

因此，**避免发布自定义变量**，如果它们仅供内部使用。
====

[[targeting-different-platforms]]
== 针对不同平台

库通常针对不同的平台。
在 Java 生态系统中，我们经常看到同一个库的不同构件，通过不同的 _classifier_ 来区分。
一个典型的例子是 Guava，它是这样发布的:

- `guava-jre` for JDK 8 and above
- `guava-android` for JDK 7

这种方法的问题是没有与分类器相关的语义。 特别是依赖解析引擎不能根据消费者的要求自动确定使用哪个版本。
例如，最好表示你对 Guava 有依赖，让引擎根据兼容情况在 jre 和 android 之间进行选择。

Gradle 为此提供了一个改进的模型，它没有分类器的弱点：attributes。

特别是在 Java 生态系统中，Gradle 提供了一个内置属性，库作者可以使用该属性来表示与 Java 生态系统的兼容性：`org.gradle.jvm.version`。
该属性表示 _消费者为了正常工作而必须拥有的最低版本_。

当您应用 `java` 或 `java-library` 插件时，Gradle 会自动将此属性关联到传出的变量。
这意味着所有使用 Gradle 发布的库都会自动告诉他们使用哪个目标平台。

默认情况下，`org.gradle.jvm.version` 设置为主编译任务的 <<building_java_projects#sec:java_cross_compilation,`release` 属性>>（或作为 `targetCompatibility` 值的后备）的值的源集。

虽然此属性是自动设置的，但默认情况下，Gradle _不会_ 让您为不同的 JVM 构建项目。
如果您需要这样做，那么您将需要按照 <<#sec:variant-aware-sharing,instructions on variant-aware matching>> 创建其他变量。

[NOTE]
Gradle 的未来版本将提供为不同 Java 平台自动构建的方法。
