[[composite_builds]]
= 复合构建

[[composite_build_intro]]
== 什么是复合构建?

复合构建是包含其他构建的构建。复合构建类似于 gradle 多项目构建，不同之处在于不包括单个项目，而是包括完整的构建。

复合构建允许您:

* 组合通常独立开发的构建，例如在应用程序使用的库中尝试 bug 修复时
* 将大型多项目构建分解为更小、更独立的块，这些块可以根据需要单独或一起工作

* combine builds that are usually developed independently, for instance when trying out a bug fix in a library that your application uses
* decompose a large multi-project build into smaller, more isolated chunks that can be worked in independently or together as needed

包含在复合构建中的构建称为 "included build"（包含构建）。 包含构建不与复合构建或其他的包含构建共享任何配置。 每个包含构建都是独立配置和执行的。

包含构建通过  <<resolution_rules.adoc#sec:dependency_substitution_rules,_dependency substitution_>> 与其他构建交互。
如果被包含构建和其他构建之间满足依赖关系，那么他们之间的依赖将被替换为工程依赖。_由于对替换依赖的依赖，复合构建可能会在组合任务执行图时强制提前解析配置。
这会对整体构建性能产生负面影响，因为这些配置不是并行解决的。_

默认情况下，Gradle 将尝试确定可以被包含构建替换的依赖。但是，为了获得更大的灵活性，如果 Gradle 确定的默认替换不正确，则可以显式声明这些替换。请参阅 <<#included_build_declaring_substitutions,声明替换>>。

除了通过项目依赖使用输出外，复合构建还可以直接在包含构建上声明任务依赖。包含构建是独立的，并且无法声明对复合构建或其他包含构建的任务依赖关系。
请参阅 <<#included_build_task_dependencies,取决于包含构建中的任务>>。

[[defining_composite_builds]]
== 定义复合构建

以下示例演示了将通常单独开发的 2 个 Gradle 构建组合成复合构建的各种方式。 在这些例子中，`my-utils` 多项目构建会生成 2 个不同的 java 库（`number-utils` 和 `string-utils`），而 `my-app` 构建会使用这些库中的函数生成可执行文件。

`my-app` 构建没有直接依赖于 `my-utils`。 相反，它声明了对 `my-utils` 生成的库的二进制依赖。

.Dependencies of my-app
====
include::{samples-dir}/build-organization/composite-builds/basic/groovy/my-app/app/build.gradle[]
include::{samples-dir}/build-organization/composite-builds/basic/kotlin/my-app/app/build.gradle.kts[]
====


[[command_line_composite]]
=== 通过 `--include-build` 定义复合构建

`--include-build` 命令行参数将执行的构建转换为复合，将包含构建中的依赖替换为执行的构建。

=== Example: 声明一个命令行的复合构建

.**`gradle --include-build ../my-utils run`** 的输出
----
> gradle --include-build ../my-utils run
include::{samples-dir}/build-organization/composite-builds/basic/tests/basicCli.out[]
----

[[settings_defined_composite]]
=== 通过 settings.gradle 定义组合构建

如果需要将上述的改动持久化，我们需要在 `settings.gradle` (或 Kotlin 中 `settings.gradle.kts` )  文件中用 link:{groovyDslPath}/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:includeBuild(java.lang.Object)[Settings.includeBuild(java.lang.Object)]
来声明一个包含构建。这个 `settings.gradle` 文件可以被同时用于添加子项目（subproject）和包含构建。包含构建通过文件路径来添加。如下例子所示。

[[separate_composite]]
=== 定义单独的复合构建

上述方法的一个缺点是它需要您修改现有构建，使其作为独立的构建没有什么用。 为了避免这点，我们可以定义一个单独的复合构建，只用于组合其他独立的构建过程。

.Declaring a separate composite
====
include::{samples-dir}/build-organization/composite-builds/basic/groovy/settings.gradle[]
include::{samples-dir}/build-organization/composite-builds/basic/kotlin/settings.gradle.kts[]
====

在这种情况下，执行的 'main'  构建是复合的，它没有定义任何有用的任务来执行自身。 为了在 'my-app' 构建中执行 'run' 任务，复合构建必须定义一个委派任务。

.Depending on task from included build
====
include::{samples-dir}/build-organization/composite-builds/basic/groovy/build.gradle[tags=run]
include::{samples-dir}/build-organization/composite-builds/basic/kotlin/build.gradle.kts[tags=run]
====

下面是有关依赖于包含构建任务的任务的更多详细信息。

[[included_builds]]
=== 对包含构建的限制

大多数构建都可以包含在复合中，包括其他复合构建。 但是有一些限制。

每个包含构建:

* 必须与其他的包含构建的 `rootProject.name` 不同.
* 必须与复合构建顶级项目的 `rootProject.name` 不同.
* 必须与复合构建的 `rootProject.name` 不同.


[[interacting_with_composite_builds]]
== 与复合构建交互

通常，与复合构建的交互和常规的多项目构建非常相似。 可以执行任务，可以运行测试，并且可以将构建导入 IDE。


[[composite_build_executing_tasks]]
=== 执行任务

复合构建中的任务可以从命令行或您的 IDE 执行。执行一个task，将会导致直接依赖的 task，以及包含构建中的被依赖的 task 也被执行。

[NOTE]
====
这里并不是说用命令行直接执行一个包含构建里的 task。包含构建里的 task 是在生成依赖关系的时候自动执行，或者 <<#included_build_task_dependencies,可以声明对来自包含构建的任务的依赖>>。

====

[[composite_build_ide_integration]]
=== 导入 IDE

复合构建最有用的特性之一是 IDE 集成。 通过将 <<idea_plugin.adoc#idea_plugin,idea>> 或 <<eclipse_plugin.adoc#eclipse_plugin,eclipse>> 插件应用于您的构建，可以生成单个 IDEA 或 Eclipse 项目，从而可以对复合构建中的所有项目进行开发工作。

除了这些 Gradle 插件，最新版本的 https://www.jetbrains.com/idea/[IntelliJ IDEA] 和 https://projects.eclipse.org/projects/tools.buildship[Eclipse Buildship] 支持直接导入复合构建。

导入复合构建允许将来自不同 Gradle 构建轻松地一起开发。 对于每个包含构建，每个子项目都包含为一个 IDEA 模块或 Eclipse 项目。 配置源依赖项，提供跨构建导航和重构。

[[included_build_declaring_substitutions]]
== 声明由包含构建替换的依赖

默认情况下，Gradle 为了识别包含构建的能够提供的依赖项目，会对每一个包含构建做一次配置。
执行此操作的算法非常简单：Gradle 将检查包含构建中项目的组和名称，并用项目依赖替换任何与  `${project.group}:${project.name}` 匹配的外部依赖。

在某些情况下，由 Gradle 默认提供的替换可能不能满足项目需要，甚至一部分是错误的。 对于这些情况，可以显式声明包含构建的替换关系。
以单项目构建 'anonymous-library' 为例，它生成一个 java 实用程序库，但不声明 group 属性的值：

.Build that does not declare group attribute
====
include::{samples-dir}/build-organization/composite-builds/declared-substitution/groovy/anonymous-library/build.gradle[]
include::{samples-dir}/build-organization/composite-builds/declared-substitution/kotlin/anonymous-library/build.gradle.kts[]
====

当我们在复合构建中编译它的时候，它将尝试替换依赖模块 "undefined:anonymous-library" （"undefined" 是  `project.group` 的默认值，"anonymous-library"  是根项目姓）。
很明显在组合构建中，这是无效的。 要在组合构建中使用未修改的未发布库，组合构建可以显式声明它提供的替换：

.Declaring the substitutions for an included build
====
include::{samples-dir}/build-organization/composite-builds/declared-substitution/groovy/settings.gradle[]
include::{samples-dir}/build-organization/composite-builds/declared-substitution/kotlin/settings.gradle.kts[]
====

使用此配置，"my-app" 复合构建将用对 "anonymous-library" 根项目的依赖替换对 `org.sample:number-utils` 的任何依赖。

[[included_build_substitution_requirements]]
=== 包含构建项目替换关系必须被明确声明的场景

那些使用 `uploadArchives` task 来发布构建成果的构建过程，在作为一个包含构建时会自动生效，而无需声明替换关系。但是仍然有些场景，是需要明确声明的：

* `archivesBaseName` 属性被用来设置构件的名字.
* 当发布 `default` 以外的配置时：这通常意味着使用了 `uploadArchives` 以外的任务。
* 当使用 `MavenPom.addFilter()` 发布与项目名称不匹配的构件时。
* 当使用 `maven-publish` 或 `ivy-publish` 插件发布坐标与  `${project.group}:${project.name}` 不匹配时。

[[included_build_substitution_limitations]]
=== 组合构建替换关系失败的场景

有些构建过程，甚至是明确声明了依赖替换关系也不能在复合构建中正确执行。这个限制是因为项目依赖替换是按照被目标项目的默认配置来实现的。当一个项目默认配置下的依赖和构件与实际发布到中央仓库中的不匹配时，复合构建就可能表现出不一致的行为。 以下是发布项目的配置和项目默认配置可能会出现不一致的情况：

* 发布 `default` 以外的配置时。
* 当使用 `maven-publish` 或 `ivy-publish` 插件时。
* 当 `POM` 或 `ivy.xml` 文件作为发布的一部分进行调整时。


使用这些特性的构建过程，被加入到复合构建的时候就不能正确执行。我们计划在将来改善这点。

[[included_build_task_dependencies]]
== 取决于包含构建中的任务

虽然包含构建彼此隔离并且不能声明直接依赖关系，但复合构建能够在其包含构建上声明任务依赖关系。 使用 link:{groovyDslPath}/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:includedBuilds[Gradle.getIncludedBuilds()]
 或 link:{groovyDslPath}/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:includedBuild(java.lang.String)[Gradle.includedBuild(java.lang.String)] 访问包含构建。

使用这些 API，可以在特定的包含构建中声明对任务的依赖关系，或者在所有或部分包含的构建中声明具有特定路径的任务。

.取决于包含构建中的单个任务
====
include::{samples-dir}/build-organization/composite-builds/basic/groovy/build.gradle[tags=run]
include::{samples-dir}/build-organization/composite-builds/basic/kotlin/build.gradle.kts[tags=run]
====

.取决于所有包含构建中具有特定路径的任务
====
include::{samples-dir}/build-organization/composite-builds/hierarchical-multirepo/groovy/build.gradle[]
include::{samples-dir}/build-organization/composite-builds/hierarchical-multirepo/kotlin/build.gradle.kts[]
====

[[current_limitations_and_future_work]]
== 复合构建的当前限制和未来计划

我们认为复合构建已经非常有用了。 但是，有些事情还没有按照我们想要的方式工作，而我们认为其他改进会让事情变得更好。

当前实现的限制包括:

* 不支持包含构建使用不同于默认配置发布。请参阅 <<#included_build_substitution_limitations,复合构建不起作用的情况>>。
* 不支持 Native 构建（字节码依赖还不能支持 Native 构建）
* 如果多个复合构建包含相同的构建，则并行运行时可能会发生冲突。 Gradle 不会在 Gradle 调用之间共享共享复合构建的项目锁，以防止并发执行。

我们为即将发布的版本计划的改进包括：

* 为那些自定义了发布配置的构建过程，以及会输出多个组件的构建等，提供更好的依赖替换检测机制，从而减少需要明确声明依赖替换关系的场景。
* 直接从命令行定位包含构建中的一个或多个任务的能力。我们目前正在探索允许此功能的语法选项，这将消除复合构建中需要委派任务的许多情况。
* 使隐式 `buildSrc` 项目成为包含的构建。
