= 自定义 publishing

[[sec:adding-variants-to-existing-components]]
== 修改变体并将其添加到现有组件以进行发布

Gradle 的发布模型基于组件的概念，组件由插件定义。 例如，Java 库插件定义了一个对应于 library 的组件，但 Java 平台插件定义了另一种  `javaPlatform`, 组件，它实际上是一种不同类型的软件组件（平台）。

有时，我们希望向现有组件添加更多变体或修改现有组件的变体。 例如，如果您 <<cross_project_publications.adoc#targeting-different-platforms, 为不同平台添加了 Java 库的变体>> ，您可能只想在 `java` 组件本身上声明此附加变体。
通常，声明附加变体通常是发布其他项目的最佳解决方案。

为了执行这样的添加或修改，`AdhocComponentWithVariants`  接口声明了两个 `addVariantsFromConfiguration` 和 `withVariantsFromConfiguration` 方法，它们接受两个参数:

- 用作变体源的 <<declaring_dependencies.adoc#sec:resolvable-consumable-configs,输出配置>>
- 自定义操作，允许您筛选将要发布的变体

要使用这些方法，您必须确保您使用的 `SoftwareComponent` 本身就是一个 `AdhocComponentWithVariants`，Java 插件（Java、Java Library、Java Platform）创建的组件就是这种情况。

.Adding a variant to an existing software component
====
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-advanced-published/groovy/buildSrc/src/main/groovy/com/acme/InstrumentedJarsPlugin.groovy[tags=add_variant_to_existing_component]
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-advanced-published/kotlin/buildSrc/src/main/kotlin/com/acme/InstrumentedJarsPlugin.kt[tags=add_variant_to_existing_component]
====

在其他情况下，您可能希望修改由其中一个 Java 插件添加的变体。 例如，如果您激活 Javadoc 和 sources 代码的发布，它们将成为 `java` 组件的附加变体。 如果您只想发布其中一个，例如仅发布 Javadoc 而没有源代码，您可以将 `sources` 变体修改为不发布。

.Publish a java library with Javadoc but without sources
====
include::{snippets-dir}/maven-publish/javaProject/groovy/build.gradle[tags=publish-modify-component]
include::{snippets-dir}/maven-publish/javaProject/kotlin/build.gradle.kts[tags=publish-modify-component]
====

[[sec:publishing-custom-components]]
== 创建和发布自定义组件

在  <<sec:adding-variants-to-existing-components, 前面的示例中>>，我们已经演示了如何扩展或修改现有组件，例如 Java 插件提供的组件。 但是 Gradle 还允许您构建自定义组件（不是 Java 库，不是 Java 平台，也不是 Gradle 原生支持的东西）。

要创建自定义组件，首先需要创建一个空的 _adhoc_ 组件。 目前，这只能通过插件实现，因为您需要处理 link:{javadocPath}/org/gradle/api/component/SoftwareComponentFactory.html[SoftwareComponentFactory]：

.Injecting the software component factory
====
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-advanced-published/groovy/buildSrc/src/main/groovy/com/acme/InstrumentedJarsPlugin.groovy[tags=inject_software_component_factory]
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-advanced-published/kotlin/buildSrc/src/main/kotlin/com/acme/InstrumentedJarsPlugin.kt[tags=inject_software_component_factory]
====

声明自定义组件发布的内容仍然通过 link:{javadocPath}/org/gradle/api/component/AdhocComponentWithVariants.html[AdhocComponentWithVariants]  完成。 对于自定义组件，第一步是按照 <<cross_project_publications.adoc#sec:variant-aware-sharing, 本章>> 中的说明创建自定义 outgoing 变体。
在这个阶段，你应该拥有可以在跨项目依赖项中使用的变体，但我们现在要发布到外部存储库。

.Creating a custom, adhoc component
====
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-advanced-published/groovy/buildSrc/src/main/groovy/com/acme/InstrumentedJarsPlugin.groovy[tags=create_adhoc_component]
include::{snippets-dir}/dependencyManagement/modelingFeatures-crossProjectPublications-advanced-published/kotlin/buildSrc/src/main/kotlin/com/acme/InstrumentedJarsPlugin.kt[tags=create_adhoc_component]
====

首先，我们使用工厂创建一个新的 adhoc 组件。 然后我们通过 `addVariantsFromConfiguration` 方法添加一个变体，这在 <<sec:adding-variants-to-existing-components,上一节中>>有更详细的描述。


在简单的情况下，`Configuration` 和变体之间存在一对一的映射，在这种情况下，您可以发布从单个 `Configuration` 发出的所有变体，因为它们实际上是同一件事。
但是，在某些情况下，`Configuration` 与附加 link:{javadocPath}/org/gradle/api/artifacts/ConfigurationPublications.html[configuration publications] 相关联，我们也称为 _secondary variables_。
这样的配置在 <<cross_project_publications.adoc#,cross-project Publications>> 用例中是有意义的，但在外部发布时则不然。
例如，当您在项目之间共享一个 _directory of files_ 时就是这种情况，但是您无法直接在 Maven 存储库上发布一个 _directory_（只能打包 jar 或 zip 之类的东西）。
查看 link:{javadocPath}/org/gradle/api/component/ConfigurationVariantDetails.html[ConfigurationVariantDetails] 类以获取有关如何跳过特定变体发布的详细信息。
如果已经为配置调用了 `addVariantsFromConfiguration`，则可以使用 `withVariantsFromConfiguration` 对结果变体进行进一步修改。

像这样发布临时组件时:

- Gradle 模块元数据将准确表示已发布的变体。特别是，所有输出变体都将继承已发布配置的依赖、构件和属性。
- 将生成 Maven 和 Ivy 元数据文件，但您需要声明依赖项如何通过  link:{javadocPath}/org/gradle/api/component/ConfigurationVariantDetails.html[ConfigurationVariantDetails] 类映射到 Maven 作用域。

实际上，这意味着 Gradle 可以像使用 "local components" 一样使用以这种方式创建的组件。

[[sec:publishing_custom_artifacts_to_maven]]
== 将自定义构件添加到 publication

[WARNING]
====
与其考虑构件，不如采用 Gradle 的变体感知模型。 预计单个模块可能需要多个构件。 但是，这很少止步于此，如果其他工件表示  <<feature_variants.adoc#,可选功能>>，则它们也可能具有不同的依赖等等。

Gradle 通过 Gradle 模块元数据支持发布其他变体，这些变体使依赖解析引擎知道这些构件。 请参阅 <<cross_project_publications.adoc#sec:variant-aware-sharing, 变体感知>>  部分以了解如何声明此类变体并<<#sec:publishing-custom-components,查看如何发布自定义组件>>。

如果将额外的构件直接附加到 publication，则会 "out of context" 发布这些构件。 这意味着，它们根本不会在元数据中引用，然后只能通过依赖上的 classifier 直接寻址。 与 Gradle 模块元数据相比，Maven pom 元数据不会包含有关其他构件的信息，
无论它们是通过变体添加还是直接添加，因为变体无法以 pom 格式表示。
====

如果您确定元数据（例如 Gradle 或 POM 元数据）与您的用例无关，以下部分将介绍如何直接发布构件。
例如，如果您的项目不需要被其他项目使用，并且发布后唯一需要的就是构件本身。

一般来说，有两种选择:

- 仅使用项目创建发布
- 基于具有元数据的组件将项目添加到发布中（不建议使用，而是 <<sec:adding-variants-to-existing-components,调整组件>>  或使用 <<#sec:publishing-custom-components,adhoc 组件发布>>，这两者都会生成适合您的项目的元数据）

要基于构件创建发布，请首先定义自定义构件并将其附加到您选择的 Gradle <<dependency_management_terminology.adoc#sub:terminology_configuration,configuration>> 。 以下示例定义由 antask 生成的 RPM 工件（未显示），并将该工件附加到配置。
以下示例定义了一个由 `rpm` 任务（未显示）生成的 RPM 构件，并将该构件附加到 `archives` 配置：

.Defining a custom artifact for a configuration
====
include::{snippets-dir}/maven-publish/publish-artifact/groovy/build.gradle[tags=custom-artifact]
include::{snippets-dir}/maven-publish/publish-artifact/kotlin/build.gradle.kts[tags=custom-artifact]
====

`artifacts.add()` 方法 — link:{groovyDslPath}/org.gradle.api.artifacts.dsl.ArtifactHandler.html[ArtifactHandler]  — 返回 link:{javadocPath}/org/gradle/api/artifacts/PublishArtifact.html[PublishArtifact] 类型的构件对象
，然后可用于定义 publication，如以下示例所示:

.Attaching a custom PublishArtifact to a publication
====
include::{snippets-dir}/maven-publish/publish-artifact/groovy/build.gradle[tags=custom-artifact-publication]
include::{snippets-dir}/maven-publish/publish-artifact/kotlin/build.gradle.kts[tags=custom-artifact-publication]
====

* `artifact()` 方法接受 _publish artifacts_ 作为参数 - 就像示例中的 `rpmArtifact` - 以及 link:{groovyDslPath}/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)[Project.file(java.lang.Object)] 接受的任何类型的参数 ，例如 `File` 实例、字符串文件路径或 archive 任务。
* 发布插件支持不同的构件配置属性，因此请务必查看插件文档以获取更多详细信息。 <<publishing_maven.adoc#publishing_maven,Maven Publish Plugin>> 和 <<publishing_ivy.adoc#publishing_ivy,Ivy Publish Plugin>> 都支持 `classifier` 和 `extension` 属性。
* 自定义工件需要在 publication 中区分，通常通过 `classifier` 和 `extension` 的独特组合。有关确切要求，请参阅您正在使用的插件的文档。
* 如果您将 `artifact()` 用于 archive 任务，Gradle 会自动使用该任务的 `classifier` 和 `extension` 属性填充工件的元数据。

现在您可以发布 RPM。

如果你真的想在基于组件的发布中添加一个构件，而不是 <<#sec:adding-variants-to-existing-components,adjusting the component>> 本身，你可以结合 `from components.someComponent` 和 `artifact someArtifact` 符号。

[[sec:publishing_maven:conditional_publishing]]
== 将发布限制在特定的存储库中

当您定义了多个 publications 或 repositories 时，您通常希望控制将哪些 publications 发布到哪些存储库。 例如，考虑以下示例，它定义了两个发布 — 一个仅包含一个二进制文件，另一个包含二进制和相关源——以及两个存储库 — 一个供内部使用，一个供外部消费者使用：

.Adding multiple publications and repositories
====
include::{snippets-dir}/maven-publish/conditional-publishing/groovy/build.gradle[tags=publishing]
include::{snippets-dir}/maven-publish/conditional-publishing/kotlin/build.gradle.kts[tags=publishing]
====

发布插件将创建允许您将任一 publications 发布到任何一个存储库的任务。 他们还将这些任务附加到  `publish`  聚合任务。 但是，假设您想将仅二进制发布限制到外部存储库，将二进制发布限制到内部存储库。 为此，您需要设置发布 _conditional_。

Gradle 允许您通过以 link:{groovyDslPath}/org.gradle.api.Task.html#org.gradle.api.Task:onlyIf(org.gradle.api.specs.Spec)[Task.onlyIf(org.gradle.api.specs.Spec)] 根据条件跳过您想要的任何任务

.Configuring which artifacts should be published to which repositories
====
include::{snippets-dir}/maven-publish/conditional-publishing/groovy/build.gradle[tags=task-config]
include::{snippets-dir}/maven-publish/conditional-publishing/kotlin/build.gradle.kts[tags=task-config]
====

.`gradle publish` 的输出
----
> gradle publish
include::{snippets-dir}/maven-publish/conditional-publishing/tests/publishingMavenConditionally.out[]
----

您可能还想定义自己的 aggregate 任务来帮助您的工作流程。 例如，假设您有几个应该发布到外部存储库的 publications。 在不发布内部文件的情况下一次性发布所有这些文件可能非常有用。

以下示例演示了如何通过定义一个聚合任务来做到这一点 - `publishToExternalRepository` - 这取决于所有相关的发布任务:

.Defining your own shorthand tasks for publishing
====
include::{snippets-dir}/maven-publish/conditional-publishing/groovy/build.gradle[tags=shorthand-tasks]
include::{snippets-dir}/maven-publish/conditional-publishing/kotlin/build.gradle.kts[tags=shorthand-tasks]
====

此特定示例通过使用 link:{javadocPath}/org/gradle/api/tasks/TaskCollection.html#withType-java.lang.Class-[TaskCollection.withType(java.lang.Class)] 自动处理相关发布任务的引入或删除带有 link:{groovyDslPath}/org.gradle.api.publish.maven.tasks.PublishToMavenRepository.html[PublishToMavenRepository]  任务类型。
如果要发布到与 Ivy 兼容的存储库，则可以对 link:{groovyDslPath}/org.gradle.api.publish.ivy.tasks.PublishToIvyRepository.html[PublishToIvyRepository]  执行相同操作

[[sec:configuring_publishing_tasks]]
== Configuring publishing tasks

发布插件在评估项目后创建它们的非聚合任务，这意味着您不能直接从构建脚本中引用它们。 如果您想配置这些任务中的任何一个，您应该使用延迟任务配置。 这可以通过项目的 `tasks` 集合以多种方式完成。

例如，假设您想更改 `generatePomFileFor__PubName__Publication` 任务写入 POM 文件的位置。 您可以使用  link:{javadocPath}/org/gradle/api/tasks/TaskCollection.html#withType-java.lang.Class-[TaskCollection.withType(java.lang.Class)]  来执行此操作:

.Configuring a dynamically named task created by the publishing plugins
====
include::{snippets-dir}/publishing/javaLibrary/groovy/build.gradle[tags=configure-generate-task]
include::{snippets-dir}/publishing/javaLibrary/kotlin/build.gradle.kts[tags=configure-generate-task]
====

上面的示例使用正则表达式从任务名称中提取 publication 名称。 这样就不会在可能生成的所有 POM 文件的文件路径之间发生冲突。 如果您只有一个 publication，那么您不必担心这种冲突，因为只有一个 POM 文件。