// Copyright 2020 the original author or authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

[[toolchains]]
= Toolchains for JVM projects

By default, Gradle uses the same Java version for running Gradle itself and building JVM projects.

This is not always desirable.
Building projects with different Java versions on different developer machines and CI servers may lead to unexpected issues.
Additionally, you may want to build a project using a Java version that is not supported for running Gradle.

A Java Toolchain (from now on referred to simply as toolchain) is a set of tools, usually taken from a local JRE/JDK installation that are used to configure different aspects of a build.
Compile tasks may use `javac` as their compiler, test and exec tasks may use the `java` command while `javadoc` will be used to generate documentation.

[[sec:consuming]]
== Consuming Toolchains

A build can globally define what toolchain it targets by stating the Java Language version it needs and optionally the vendor:

====
include::sample[dir="samples/java/jvm-multi-project-with-toolchains/groovy/",files="buildSrc/src/main/groovy/myproject.java-conventions.gradle[tags=toolchain]"]
include::sample[dir="samples/java/jvm-multi-project-with-toolchains/kotlin/",files="buildSrc/src/main/kotlin/myproject.java-conventions.gradle.kts[tags=toolchain]"]
====

Executing the build (e.g. using `gradle check`) will now handle several things for you and others running your build

1. Setup all compile, test and javadoc tasks to use the defined toolchain which may be different than the one Gradle itself uses
2. Gradle detects <<#sec:auto_detection,locally installed JVMs>>
3. Gradle chooses a JRE/JDK matching the requirements of the build (in this case a JVM supporting Java 11)
4. If no matching JVM is found, it will automatically download a matching JDK from https://adoptopenjdk.net/[AdoptOpenJDK]

[NOTE]
====
Toolchain support is only available in the Java plugins and for the tasks they define.
For the Groovy plugin, compilation is supported but not yet Groovydoc generation.

Support for the Scala plugin will be released later.

However, _running tests_ can leverage the toolchain support since the `Test` task does support toolchains.
====

[[sec:vendors]]
=== Using toolchains by specific vendors

In case your build has specific requirements from the used JRE/JDK, you may want to define the vendor for the toolchain as well.
link:{javadocPath}/org/gradle/jvm/toolchain/JvmVendorSpec.html[`JvmVendorSpec`] has a list of well-known JVM vendors recognized by Gradle.
The advantage is that Gradle can handle any inconsistencies across JDK versions in how exactly the JVM encodes the vendor information.

====
include::sample[dir="snippets/java/toolchain-filters/groovy/",files="build.gradle[tags=toolchain-known-vendor]"]
include::sample[dir="snippets/java/toolchain-filters/kotlin/",files="build.gradle.kts[tags=toolchain-known-vendor]"]
====

If the vendor you want to target is not a known vendor, you can still restrict the toolchain to those matching the `java.vendor` system property of the available toolchains.

Given the snippet below, only toolchain are taken into accounts whose `java.vendor` property contains the given match string. Matching is done case-insensitive.

====
include::sample[dir="snippets/java/toolchain-filters/groovy/",files="build.gradle[tags=toolchain-matching-vendor]"]
include::sample[dir="snippets/java/toolchain-filters/kotlin/",files="build.gradle.kts[tags=toolchain-matching-vendor]"]
====

=== Selecting toolchains by their virtual machine implementation

If your project requires a specific implementation, you can filter based on the implementation as well.
Currently available implementations to choose from are:

`VENDOR_SPECIFIC`::
Acts as a placeholder and matches any implementation from any vendor (e.g. hotspot, zulu, ...)
`J9`::
Matches only virtual machine implementations using the OpenJ9/IBM J9 runtime engine.

For example, to use an https://www.eclipse.org/openj9/[Open J9] JVM, distributed via https://adoptopenjdk.net/[AdoptOpenJDK],
you can specify the filter as shown in the example below.

====
include::sample[dir="snippets/java/toolchain-filters/groovy/",files="build.gradle[tags=toolchain-matching-implementation]"]
include::sample[dir="snippets/java/toolchain-filters/kotlin/",files="build.gradle.kts[tags=toolchain-matching-implementation]"]
====

[NOTE]
====
The Java major version, the vendor (if specified) and implementation (if specified)
will be tracked as an input for compilation and test execution.
====


== Specify custom toolchains for individual tasks

In case you want to tweak which toolchain is used for a specific task, you can specify the exact tool a task is using.
For example, the `Test` task exposes a `JavaLauncher` property that defines which java executable to use for launching the tests.

In the example below, we configure all java compilation tasks to use JDK8.
Additionally, we introduce a new `Test` task that is going to run our unit tests but using a JDK 14.

====
include::sample[dir="samples/java/jvm-multi-project-with-toolchains/groovy/",files="list/build.gradle[tags=customToolchain]"]
include::sample[dir="samples/java/jvm-multi-project-with-toolchains/kotlin",files="list/build.gradle.kts[tags=customToolchain]"]
====

In addition, in the `application` subproject, we add another Java execution task to run our application with JDK 14.

====
include::sample[dir="samples/java/jvm-multi-project-with-toolchains/groovy/",files="application/build.gradle[tags=customExec]"]
include::sample[dir="samples/java/jvm-multi-project-with-toolchains/kotlin",files="application/build.gradle.kts[tags=customExec]"]
====

Depending on the task, a JRE might be enough while for other tasks (e.g. compilation), a JDK is required.
By default, Gradle prefers installed JDKs over JREs if they can satisfy the requirements.

Toolchains tool providers can be obtained from the link:{javadocPath}/org/gradle/jvm/toolchain/JavaToolchainService.html[`javaToolchains`] extension.

Three tools are available:

* A `JavaCompiler` which is the tool used by the link:{groovyDslPath}/org.gradle.api.tasks.compile.JavaCompile.html#org.gradle.api.tasks.compile.JavaCompile:javaCompiler[JavaCompile] task
* A `JavaLauncher` which is the tool used by the link:{groovyDslPath}/org.gradle.api.tasks.JavaExec.html#org.gradle.api.tasks.JavaExec:javaLauncher[JavaExec] or link:{groovyDslPath}/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:javaLauncher[Test] tasks
* A `JavadocTool` which is the tool used by the link:{groovyDslPath}/org.gradle.api.tasks.javadoc.Javadoc.html#org.gradle.api.tasks.javadoc.Javadoc:javadocTool[Javadoc] task

=== Integration with tasks relying on a Java executable or Java home

Any tasks that can be configured with a path to a Java executable, or a Java home location, can benefit from toolchains.

While you will not be able to wire a toolchain tool directly, they all have metadata that gives access to their full path or to the path of the Java installation they belong to.

For example, you can configure the executable for a Kotlin compile tasks as follows:

====
include::sample[dir="snippets/java/toolchain-kotlin/groovy/",files="build.gradle[tags=compiler-kotlin]"]
include::sample[dir="snippets/java/toolchain-kotlin/kotlin/",files="build.gradle.kts[tags=compiler-kotlin]"]
====

Similarly, doing `compiler.get().executablePath` would give you the full path to `javac` for the given toolchain.
Please note however that this may realize (and provision) a toolchain eagerly.

[[sec:auto_detection]]
== Auto detection of installed toolchains

By default, Gradle automatically detects local JRE/JDK installations so no further configuration is required by the user.
The following is a list of common package managers and locations that are supported by the JVM auto detection.

Operation-system specific locations:

* Linux
* MacOs
* Windows

Supported Package Managers:

* https://asdf-vm.com/#/[Asdf-vm]
* https://github.com/shyiko/jabba[Jabba]
* https://sdkman.io/[SDKMAN!]

[[sub:disable_auto_detect]]
=== How to disable auto-detection

In order to disable auto-detection, you can use the `org.gradle.java.installations.auto-detect` Gradle property:

* Either start gradle using `-Porg.gradle.java.installations.auto-detect=false`
* Or put `org.gradle.java.installations.auto-detect=false` into your `gradle.properties` file.

[[sec:provisioning]]
== Auto Provisioning

If Gradle can't find a locally available toolchain which matches the requirements of the build, it will automatically try to download it from AdoptOpenJDK.
By default, it will request a HotSpot JDK matching the current operating system and architecture.
Provisioning JDKs are installed in the <<directory_layout.adoc#dir:gradle_user_home,Gradle User Home directory>>.

[NOTE]
====
Gradle will only download JDK versions for GA releases.
There is no support for downloading early access versions.
====

By default, the public https://api.adoptopenjdk.net/[AdoptOpenJDK APIs] are used to determine and download a matching JDK.
In case you want to use another server that is compatible with v3 of the AdoptOpenJDK API, you can point Gradle to use a different host.
For that you use the Gradle property as in the example below:

----
org.gradle.jvm.toolchain.install.adoptopenjdk.baseUri=https://api.company.net/
----

[WARNING]
====
Only secure protocols like `https` are accepted.
This is required to make sure no one can tamper with the download in flight.
====

[[sub:viewing_toolchains]]
=== Viewing and debugging toolchains

Gradle can display the list of all detected toolchains including their metadata.

For example, to show all toolchains of a project, run:

```
gradle -q javaToolchains
```

.Output of **`gradle -q javaToolchains`**
----
> gradle -q javaToolchains

 + Options
     | Auto-detection:     Enabled
     | Auto-download:      Enabled

 + AdoptOpenJDK 1.8.0_242
     | Location:           /Users/username/myJavaInstalls/8.0.242.hs-adpt/jre
     | Language Version:   8
     | Vendor:             AdoptOpenJDK
     | Is JDK:             true
     | Detected by:        system property 'org.gradle.java.installations.paths'

 + OpenJDK 15-ea
     | Location:           /Users/username/.sdkman/candidates/java/15.ea.21-open
     | Language Version:   15
     | Vendor:             AdoptOpenJDK
     | Is JDK:             true
     | Detected by:        SDKMAN!

 + OpenJDK 16
     | Location:           /Users/user/customJdks/16.ea.20-open
     | Language Version:   16
     | Vendor:             AdoptOpenJDK
     | Is JDK:             true
     | Detected by:        environment variable 'JDK16'

 + Oracle JDK 1.7.0_80
     | Location:           /Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/jre
     | Language Version:   7
     | Vendor:             Oracle
     | Is JDK:             true
     | Detected by:        macOS java_home
----

This can help to debug which toolchains are available to the build, how they are detected and what kind of metadata Gradle knows about those toolchains.

[[sub:disable_auto_provision]]
=== How to disable auto provisioning

In order to disable auto-provisioning, you can use the `org.gradle.java.installations.auto-download` Gradle property:

* Either start gradle using `-Porg.gradle.java.installations.auto-download=false`
* Or put `org.gradle.java.installations.auto-download=false` into a `gradle.properties` file.

[[sec:custom_loc]]
== Custom Toolchain locations

If auto-detecting local toolchains is not sufficient or disabled, there are additional ways you can let Gradle know about installed toolchains.

If your setup already provides environment variables pointing to installed JVMs, you can also let Gradle know about which environment variables to take into account.
Assuming the environment variables `JDK8` and `JRE14` point to valid java installations, the following instructs Gradle to resolve those environment variables and consider those installations when looking for a matching toolchain.

----
org.gradle.java.installations.fromEnv=JDK8,JRE14
----

Additionally, you can provide a comma-separated list of paths to specific installations using the `org.gradle.java.installations.paths` property.
For example, using the following in your `gradle.properties` will let Gradle know which directories to look at when detecting JVMs.
Gradle will treat these directories as possible installations but will not descend into any nested directories.

----
org.gradle.java.installations.paths=/custom/path/jdk1.8,/shared/jre11
----

[[sec:plugins]]
== Toolchains for plugin authors

Custom tasks that require a tool from the JDK should expose a `Property<T>` with the desired tool as generic type.
The property should be declared as a <<more_about_tasks.adoc#sec:task_input_nested_inputs,`@Nested` input>>.
By injecting the `JavaToolchainService` in the plugin or task, it is also possible to wire a convention in those properties by obtaining the `JavaToolchainSpec` from the `java` extension on the project.
The example below showcases how to use the default toolchain as convention while allowing users to individually configure the toolchain per task.

====
include::sample[dir="snippets/java/toolchain-task/groovy/",files="build.gradle"]
include::sample[dir="snippets/java/toolchain-task/kotlin/",files="build.gradle.kts"]
====

[NOTE]
====
With the property correctly configured as `@Nested`, it will automatically track the Java major version, the vendor (if specified) and implementation (if specified) as an input.
====
