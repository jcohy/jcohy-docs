[[webflux]]
= Spring WebFlux
:doc-spring-security: {doc-root}/spring-security/site/docs/current/reference

Spring 框架中包含的原始 Web 框架 Spring Web MVC 是专门为 Servlet API 和 Servlet 容器而构建的. reactive-stack Web 框架 Spring WebFlux 在更高版本 5.0 中添加.
它是完全非阻塞的,支持 https://www.reactive-streams.org/[Reactive Streams] 背压,并在 Netty,Undertow 和 Servlet 3.1+ 容器等服务器上运行.

这两个 Web 框架的模块 ({spring-framework-main-code}/spring-webmvc[spring-webmvc] 和
{spring-framework-main-code}/spring-webflux[spring-webflux]),都在 Spring Framework 中. 每个模块都是可选的.
两种框架可以任选一个,也可以并存使用.例如,带有响应式 `WebClient` 的 Spring MVC 控制器.


[[webflux-new-framework]]
== 概述

为什么创建 Spring WebFlux?

部分原因是我们需要使用较少的线程和硬件资源来处理高并发非阻塞 I/O 请求. Servlet 3.1 确实提供了用于非阻塞 I/O 的 API.但是,使用它会导致 Servlet API 的其余部分偏离,在这些 API 中,(`Filter`, `Servlet`) 是同步的 ,(`getParameter`,
`getPart`) 是阻塞的.这是促使新的通用 API 成为所有非阻塞运行时的基础的动机,更重要的原因是一些服务框架 比如 Netty 已经完美实现了异步和 non-blocking 服务开发方式.

另一个原因是函数式编程.除了在 Java5 提供的注解编程外(例如带注解的 REST 控制器或单元测试),Java 8 提供 lambda 函数编程 API.这对于非阻塞的应用程序和延续样式的 API (如由 `CompletableFuture` 和 http://reactivex.io/[ReactiveX] 流式的 API)是有利的,
这些 API 允许以声明方式构成异步逻辑.在编程模型级别,Java 8 使 Spring WebFlux 能够与带注解的控制器一起提供功能性的 Web 端点.


[[webflux-why-reactive]]
=== 定义 "`Reactive`"

我们谈到了 "`non-blocking`" 和 "`functional`" ,但是 reactive 意味着什么?

术语  "`reactive,`"  是基于事件响应的编程模型,事件包括 网络 I/O 事件、页面的鼠标点击事件等等.也就是说非阻塞编程就是 Reactive,因为相对阻塞式编程而言,非阻塞编程以响应事件的通知为主,这些事件通知包括系统操作的状态变化和数据的状态变化.

我们 Spring 研发组考虑到一个非常重要的机制,那就是在 non-blocking 情况下的限流控制(又称 背压)问题.在同步调用情况下,阻塞调用是背压的自然形式,迫使调用者等待.在非阻塞代码中,去控制响应事件的速率就变得非常重要,可以防止生产者生产过快而导致消费者跟不上.

Reactive Streams 是一个 https://github.com/reactive-streams/reactive-streams-jvm/blob/master/README.md#specification[small spec](在 Java 9 中也 https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html[adopted]),
它定义了带有响应式的异步组件之间的交互.例如,数据存储库(充当 https://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Publisher.html[Publisher])可以生成 HTTP 服务器(充当 https://www.reactive-streams.org/reactive-streams-1.0.1-javadoc/org/reactivestreams/Subscriber.html[Subscriber])然后可以写入响应的数据.响应式流的主要目的是让订阅者控制发布者生成数据的速度.

NOTE: *常见问题: 如果 publisher 太快怎么办?* +
Reactive Streams 的目的仅仅是建立机制和边界.
如果 publisher 无法放慢速度,那就让它 buffer 缓存,丢弃消息 甚至失败.

[[webflux-reactive-api]]
=== Reactive API

Reactive Streams 对于交互设计中扮演着一个非常重要的角色.但是由于它太底层了,对于编写应用层 API 没有太大作用.编写一个应用需要更高级的,功能更丰富,且具有函数编程特性的 API.这与 Java 8 Stream API 相似,但不仅适用于集合.这就是 reactive 库的作用.

https://github.com/reactor/reactor[Reactor] 是 Spring WebFlux 的首选 reactive 库.它提供了 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[`Mono`] 和 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[`Flux`] API 类型,
`ReactiveX` http://reactivex.io/documentation/operators.html[vocabulary of operators] 提供了非常丰富的操作 API 来处理 0..1 (`Mono`) 和 0..N (`Flux`)  的数据序列. Reactor 是 Reactive Streams 库,因此,它的所有运算符都支持无阻塞背压. Reactor 非常注重服务器端 Java.它是与 Spring 紧密合作开发的.

WebFlux 需要 Reactor 作为核心依赖,同时又可以与其他符合 Reactive Streams 规范的代码库结合使用.通常,WebFlux API 接受普通的 Publisher 作为输入,在内部将其适应于 Reactor 类型,使用它,然后返回 Flux 或 Mono 作为输出.
因此,您可以将任何 `Publisher` 作为输入传递,并且可以对输出应用操作,但是您需要调整输出以与其他 reactive 库一起使用.只要可行(例如,带注解的控制器),WebFlux 就会透明地适应 RxJava 或其他响应式库的使用.有关更多详细信息,请参见 <<webflux-reactive-libraries>> .

NOTE: 除了 Reactive API 外,WebFlux 还可以与 Kotlin 中的 <<languages.adoc#coroutines, Coroutines>> API 一起使用,从而提供了更强的编程风格.

[[webflux-programming-models]]
=== 编程模型

`spring-web` 模块包含 Spring WebFlux reactive 基础,包括 HTTP 抽象,用于支持的服务器的 Reactive Streams <<webflux-httphandler, adapters>>,<<webflux-codecs, codecs>>,以及与 Servlet API 相似但具有非阻塞的核心 <<webflux-web-handler-api>> .

在此基础上,Spring WebFlux 提供了两种编程模型的选择:

* <<webflux-controller>>: 与 Spring MVC 一致,并且使用和 `spring-web` 模块的相同注解. Spring MVC 和 WebFlux 控制器都支持 响应式(Reactor 和 RxJava)返回类型,因此,区分它们并不容易.
一个显着的区别是 WebFlux 还支持响应式 `@RequestBody` 参数.
* <<webflux-fn>>: 基于 Lambda 的轻量级功能编程模型. 你可将函数式编程看做是一个小的代码库,或者是可以路由和处理请求的一组应用套件.这与基于注解的编程最大的区别是应用程序从头到尾负责请求处理,而不通过注解来声明调用方法.

[[webflux-framework-choice]]
=== 适用性

Spring MVC 或 WebFlux?

这是个很平常的问题,但却还是有歧义的.实际上,两者可以相互辅助来解决更大范围的问题. 两者的设计旨在实现彼此的连续性和一致性,你可以同时使用两个框架的功能,每个框架来处理自己擅长的问题,这对双方都是有益的.下图展示了两者之间的关系,并列出了两者共同点和差异.

image::{image-resource}/spring-mvc-and-webflux-venn.png[]

我们建议您考虑以下几点:

* 如果您有运行正常的 Spring MVC 应用程序,则无需更改. 命令式编程是编写,理解和调试代码的最简单方法.因为从历史上看,大多数代码库都是阻塞的,你可以选择更多的库,结合到现有的框架中.

* 如果你已经有一个非阻塞的 web 技术栈,那么你可以考虑使用 Spring WebFlux 作为替代方案,它可以提供同样的功能,同时 Spring WebFlux 提供了多种服务端容器支持(Netty,Tomcat,Jetty,Undertow 和 Servlet 3.1+ 容器),注解和函数式编程,以及与其他 Reactor 代码库的集成(Reactor, RxJava 等等)

* 如果您对与 Java 8 lambda 或 Kotlin 提供的轻量级函数式编程比较感兴趣,你可以考虑使用 Spring WebFlux .也可以使用 Spring WebFlux 作为 web 服务的站点. 对于要求较低复杂性的较小应用程序或微服务(可以受益于更高的透明度和控制)而言,这也是一个不错的选择.

* 在微服务架构中,您可以混合使用带有 Spring MVC 或 Spring WebFlux 控制器或带有 Spring WebFlux 功能端点的应用程序. 在两个框架中都支持相同的基于注解的编程模型,这使得重用知识变得更加容易,同时还为正确的工作选择了正确的工具.

* 评估应用程序技术上扩展性的一个简单方法是检查它的依赖那些组件,如果您要使用阻塞性 api (JPA、JDBC)或网络api,那么 Spring MVC 至少是系统架构上的最佳选择.从技术上讲,同时在单独的线程上使用 Reactor 和 RxJava 是可行的,但是你无法最大的利用非阻塞技术栈的优点.

* 如果你已经有了一个 Spring MVC 应用程序,同时又需要远程调用其他的服务,这时可以尝试事件响应式客户端 `WebClient`. 通过 `WebClient` , 您可以直接从 Spring MVC 控制器方法返回响应式返回结果(Reactor,RxJava 或 <<webflux-reactive-libraries, or other>>). 并且每次远程调用的延迟或调用之间的相互依赖性越大,得到的好处就越大. Spring MVC控制器也可以通过 WebClient 调用其他支持事件响应的功能组件.

* 如果您有庞大的团队,还要用 Spring WebFlux 技术栈,就必须要权衡陡峭的学习曲线和收益了.一个切实可行的方式就是使用 Spring WebFlux 部分技术栈 比如 WebClient,除此外,可以从小的地方着手使用 Spring WebFlux.我们认为对于绝大部分的应用程序,转变到基于事件响应式编程是不必要的.如果你还不确定使用响应式编程有哪些好处,可以首先了解下非阻塞 I/O 的工作原理及其效果(例如,单线程 Node.js 的并发性).

[[webflux-server-choice]]
=== Servers

Tomcat,Jetty,Servlet 3.1+ 容器以及无服务器运行时(例如 Netty 和 Undertow)都支持 Spring WebFlux. 所有服务器都适应于底层 <<webflux-httphandler, 公共的 API>>,因此可以跨服务器支持更高级别的<<webflux-programming-models, programming models>>.

Spring WebFlux 并没有提供内嵌的停止或者启动的服务的功能组件. 但是,从 Spring 配置和 <<webflux-config, WebFlux 基础结构>> <<webflux-web-handler-api, assemble>> 应用程序并用几行代码 <<webflux-httphandler, run it>>它很容易.

Spring Boot 具有一个 WebFlux starter 组件,可以自动执行这些步骤.默认使用 Netty,但是通过更改 Maven 或 Gradle 依赖,可以轻松切换到 Tomcat,Jetty 或 Undertow. Spring Boot 默认为 Netty,因为它更广泛地用于异步和非阻塞编程,同时并允许客户端和服务器共享接入层代码.

Tomcat 和 Jetty 可以与 Spring MVC 和 WebFlux 一起使用. 但是请记住,它们的使用方式非常不同. Spring MVC 依靠 Servlet 阻塞 I/O,并允许应用程序在需要时直接使用 Servlet API. Spring WebFlux 依赖于 Servlet 3. 1 非阻塞 I/O,并在底层适配器后面使用 Servlet API,并且不暴露供直接使用.

对于 Undertow,Spring WebFlux 直接使用 Undertow API,而无需使用 Servlet API.

[[webflux-performance]]
=== 性能

性能具有许多特征和意义.基于响应的非阻塞编程并不意味着应用程序一定会运行得更快,在某些情况下,他们是高性能的,例如,使用 `WebClient` 并行执行远程调用.总的来说,以非阻塞的方式实现应用需要更多的工作,并且有可能会稍微增加请求的处理时间.

响应式非阻塞编程的预期好处是能够使用少量固定数量的线程和更少的内存进行伸缩.这使得应用程序在高负载下以更可预测的方式进行伸缩.你需要在有一些延迟的情况下来观察它的好处,(包括慢速和不可预测的网络 I/O 混合).这时响应式非阻塞编程会开始显示其优势,依照不通的情况,其最终结果的差异可能是巨大的.

[[webflux-concurrency-model]]
=== 并发模型

Spring MVC 和 Spring WebFlux 都支持带注解的控制器,但是在并发模型和阻塞线程的假定设置上,有一个关键的区别.

在 Spring MVC(通常是 servlet 应用程序)中,假定应用程序可以阻塞当前线程(例如,用于远程调用),因此 servlet 容器会使用一个大的线程池来应对请求处理过程中可能出现的阻塞问题.

在 Spring WebFlux (通常是非阻塞服务器)中,假定应用程序不阻塞,因此,非阻塞服务器使用一个小的、固定大小的线程池(event loop workers)来处理请求.

TIP: "`可扩展`" 和 "`少量线程`" 可能听起来是矛盾的,但是由于不会阻塞当前线程(而是依赖回调)意味着你不需要额外的线程来预防阻塞的情况出现.

.Invoking a Blocking API(阻塞式 API)
如果确实需要使用阻塞怎么办? Reactor 和 RxJava 都提供了 `publishOn` 操作函数来控制线程的执行.这意味着在这种编程模型上开了一个口子.但是要记住,阻塞 api 并不适合这种并发模型.

.Mutable State(可变状态)
在 Reactor 和 RxJava 中,您可以通过操作符声明逻辑,并且在运行时提供一个响应式管道,数据在管道中可以在不同的阶段按都顺序进行处理.这样做的一个好处是,它使应用程序不必关心数据状态的变化,因为管道中的应用程序代码永远不会被其他应用程序并发调用.

.Threading Model(线程模型)
您期望在运行 Spring WebFlux 的服务器上看到哪些线程?

* 在"普通的" Spring WebFlux 服务器上(例如,没有数据访问,也没有其他可选的依赖),你可以设置一个线程用于服务器端接收请求,设置几个线程用于处理请求,通常处理请求的线程数与 CPU 内核的数量一样多.但是,Servlet 容器可以设置更多的线程(例如,Tomcat 上的 10 个线程),以支持阻塞式 I/O 的 servlet 和非阻塞式 I/O 的 Servlet 3.1.
* 响应式的 WebClient 采用 `event-loop` 方式.因此,你可以看到与之相关的少量固定数量的处理线程(例如, Netty 连接器中的 `reactor-http-nio`).. 但是,如果客户端和服务器都使用 Reactor Netty,则默认情况下,这两个共享 `event-loop` 资源.
* Reactor 和 RxJava 都提供抽象线程池,称为调度器,以与 `publishOn`  运算符配合使用,该运算符用于将处理切换到其他线程池.
调度器都有一种特定的并发策略-例如, "`parallel`"(针对有限线程数量的cpu密集型程序)或  "`elastic`"(针对大量线程的 I/O 密集型程序). 如果您看到这样的线程,这意味着某些代码正在使用特定的线程池调度器策略.
* 允许数据访问库和其他第三方依赖包也可以创建和使用它们自己的线程.

.配置
Spring 框架不支持启动和停止 <<webflux-server-choice, servers>>. 要为服务端配置线程模型,需要使用特定于服务端的配置功能,如果使用 Spring Boot,请检查每个服务器的 Spring Boot 配置选项. 您可以直接 <<web-reactive.adoc#webflux-client-builder, configure>> `WebClient`. 对于所有其他库,请参阅其各自的文档.


[[webflux-reactive-spring-web]]
== Reactive Core

`spring-web` spring-web 模块包含以下对响应式 web 应用程序的基本支持.

* 在服务端请求处理过程中,提供了两个层次的支持,
** <<webflux-httphandler, HttpHandler>>: 提供了用于非阻塞 I/O 和响应式流背压机制的处理机制.以及用于响应式 Netty、Undertow、Tomcat、Jetty 和任何 Servlet 3.1+ 容器的适配器.
** <<webflux-web-handler-api>>: 用于处理请求的高级通用 web API,使用这个 API 可以构建具体的编程模型,如带注解的控制器和功能入口.
* 对于客户端,有一个基本的 `ClientHttpConnector` 来执行带有非阻塞 I/O 和响应式流背压机制的 HTTP 请求,以及用于 https://github.com/reactor/reactor-netty[Reactor Netty] 和 https://github.com/jetty-project/jetty-reactive-httpclient[Jetty HttpClient] 和 https://hc.apache.org/[Apache HttpComponents] 的 API.
在实际的应用开发过程中,我们使用的更高层级的  <<web-reactive.adoc#webflux-client, WebClient>> 就是构建在这个基本的 `ClientHttpConnector` 之上.
* 对于客户端和服务器, <<webflux-codecs, codecs>> 用于序列化和反序列化 HTTP 请求和响应内容.

[[webflux-httphandler]]
=== `HttpHandler`

{api-spring-framework}/http/server/reactive/HttpHandler.html[HttpHandler] 是一个简单的契约或者编程规范,它是被故意设计成最小化的,且只有一个方法来处理请求和响应.其主要的、也是唯一的目的是对不同的 HTTP 服务器 api 进行最小的抽象.

下表描述了它支持的服务器 api:

[cols="1,2,2", options="header"]
|===
| Server name | Server API used | Reactive Streams support

| Netty
| Netty API
| https://github.com/reactor/reactor-netty[Reactor Netty]

| Undertow
| Undertow API
| spring-web: Undertow to Reactive Streams bridge

| Tomcat
| Servlet 3.1 non-blocking I/O; Tomcat API to read and write ByteBuffers vs byte[]
| spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge

| Jetty
| Servlet 3.1 non-blocking I/O; Jetty API to write ByteBuffers vs byte[]
| spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge

| Servlet 3.1 container
| Servlet 3.1 non-blocking I/O
| spring-web: Servlet 3.1 non-blocking I/O to Reactive Streams bridge
|===

下表描述了不同服务端容器的程序依赖 (也参见 https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-the-Spring-Framework[支持的版本]):

|===
|Server name|Group id|Artifact name

|Reactor Netty
|io.projectreactor.netty
|reactor-netty

|Undertow
|io.undertow
|undertow-core

|Tomcat
|org.apache.tomcat.embed
|tomcat-embed-core

|Jetty
|org.eclipse.jetty
|jetty-server, jetty-servlet
|===

下面的代码片段显示如何在不同的服务端容器中使用 `HttpHandler` 适配器

*Reactor Netty*
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	HttpHandler handler = ...
	ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler);
	HttpServer.create().host(host).port(port).handle(adapter).bind().block();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val handler: HttpHandler = ...
	val adapter = ReactorHttpHandlerAdapter(handler)
	HttpServer.create().host(host).port(port).handle(adapter).bind().block()
----

*Undertow*
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	HttpHandler handler = ...
	UndertowHttpHandlerAdapter adapter = new UndertowHttpHandlerAdapter(handler);
	Undertow server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build();
	server.start();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val handler: HttpHandler = ...
	val adapter = UndertowHttpHandlerAdapter(handler)
	val server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build()
	server.start()
----

*Tomcat*
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	HttpHandler handler = ...
	Servlet servlet = new TomcatHttpHandlerAdapter(handler);

	Tomcat server = new Tomcat();
	File base = new File(System.getProperty("java.io.tmpdir"));
	Context rootContext = server.addContext("", base.getAbsolutePath());
	Tomcat.addServlet(rootContext, "main", servlet);
	rootContext.addServletMappingDecoded("/", "main");
	server.setHost(host);
	server.setPort(port);
	server.start();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val handler: HttpHandler = ...
	val servlet = TomcatHttpHandlerAdapter(handler)

	val server = Tomcat()
	val base = File(System.getProperty("java.io.tmpdir"))
	val rootContext = server.addContext("", base.absolutePath)
	Tomcat.addServlet(rootContext, "main", servlet)
	rootContext.addServletMappingDecoded("/", "main")
	server.host = host
	server.setPort(port)
	server.start()
----

*Jetty*

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	HttpHandler handler = ...
	Servlet servlet = new JettyHttpHandlerAdapter(handler);

	Server server = new Server();
	ServletContextHandler contextHandler = new ServletContextHandler(server, "");
	contextHandler.addServlet(new ServletHolder(servlet), "/");
	contextHandler.start();

	ServerConnector connector = new ServerConnector(server);
	connector.setHost(host);
	connector.setPort(port);
	server.addConnector(connector);
	server.start();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val handler: HttpHandler = ...
	val servlet = JettyHttpHandlerAdapter(handler)

	val server = Server()
	val contextHandler = ServletContextHandler(server, "")
	contextHandler.addServlet(ServletHolder(servlet), "/")
	contextHandler.start();

	val connector = ServerConnector(server)
	connector.host = host
	connector.port = port
	server.addConnector(connector)
	server.start()
----

*Servlet 3.1+ Container*

要将其作为 WAR 部署到任何 Servlet 3.1+ 容器中,您可以扩展 WAR 并将其包括在 {api-spring-framework}/web/server/adapter/AbstractReactiveWebInitializer.html[`AbstractReactiveWebInitializer`] 中. 该类使用 `ServletHttpHandlerAdapter` 包装 `HttpHandler` 并将其注册为 Servlet.

[[webflux-web-handler-api]]
=== `WebHandler` API

`org.springframework.web.server` 包建立在 <<webflux-httphandler>> 的基础上,为多个 {api-spring-framework}/web/server/WebExceptionHandler.html[`WebExceptionHandler`] ,
多个 {api-spring-framework}/web/server/WebFilter.html[`WebFilter`] ,和单个 {api-spring-framework}/web/server/WebHandler.html[`WebHandler`] 组件链等处理请求提供通用的 Web API.
通过简单地指向 <<webflux-web-handler-api-special-beans, 自动检测>> 组件的 Spring `ApplicationContext` 和/或 通过向构建器注册组件,可以将该链与 `WebHttpHandlerBuilder` 放在一起.

尽管 `HttpHandler` 的目标很简单,即抽象化不同 HTTP 服务器的使用,但 `WebHandler` API 的目的是提供 Web 应用程序中常用的更广泛的功能集,例如:

* User session with attributes.
* Request attributes.
* 解析请求中的 `Locale` 或 `Principal`.
* 访问已解析和缓存的表单数据..
* multipart data 数据的抽象.
* 更多..

[[webflux-web-handler-api-special-beans]]
==== 特殊的 bean 类型

下表列出了 `WebHttpHandlerBuilder` 可以在 Spring `ApplicationContext` 中自动检测的组件,或可以直接向其注册的组件:

[cols="2,2,1,3", options="header"]
|===
| Bean name | Bean type | Count | Description

| <any>
| `WebExceptionHandler`
| 0..N
| 提供对 `WebFilter` 实例链和目标 `WebHandler` 的异常的处理.  有关更多详细信息， 请参见<<webflux-exception-handler>>.

| <any>
| `WebFilter`
| 0..N
| 在其余的过滤器链和目标 `WebHandler` 之前或之后使用拦截器风格的逻辑， 有关更多详细信息， 请参考 <<webflux-filters>>

| `webHandler`
| `WebHandler`
| 1
| 请求处理器.

| `webSessionManager`
| `WebSessionManager`
| 0..1
| 通过  `ServerWebExchange` 上的方法公开的  `WebSession` 实例的管理器.  默认为  `DefaultWebSessionManager`.

| `serverCodecConfigurer`
| `ServerCodecConfigurer`
| 0..1
| 用于访问 `HttpMessageReader` 实例解析表单数据和多部分数据， 然后通过 `ServerWebExchange` 方法暴露这些数据.  默认情况下， `ServerCodecConfigurer.create()`.

| `localeContextResolver`
| `LocaleContextResolver`
| 0..1
| 通过 `ServerWebExchange` 上的方法暴露的 `LocaleContext` 解析程序.  默认为 `AcceptHeaderLocaleContextResolver`.

| `forwardedHeaderTransformer`
| `ForwardedHeaderTransformer`
| 0..1
| 对于处理转发的类型的请求头， 可以通过提取和删除它们或仅通过删除它们来进行.  默认情况下不使用.
|===


[[webflux-form-data]]
==== 表单数据

`ServerWebExchange` 使用以下方法访问表单数据:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Mono<MultiValueMap<String, String>> getFormData();
----
[source,Kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	suspend fun getFormData(): MultiValueMap<String, String>
----

`DefaultServerWebExchange` 使用配置的 `HttpMessageReader` 将表单数据(`application/x-www-form-urlencoded`)解析为 `MultiValueMap`. 默认情况下,`FormHttpMessageReader` 配置为由 `ServerCodecConfigurer` Bean使用(请参阅 <<webflux-web-handler-api, Web Handler API>>).

[[webflux-multipart]]
==== Multipart Data
[.small]#<<web.adoc#mvc-multipart, Web MVC>>#

`ServerWebExchange` 使用以下方法访问 multipart data:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Mono<MultiValueMap<String, Part>> getMultipartData();
----
[source,Kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	suspend fun getMultipartData(): MultiValueMap<String, Part>
----

`DefaultServerWebExchange` 使用配置的 `HttpMessageReader<MultiValueMap<String, Part>>` 将 `multipart/form-data` 内容解析为 `MultiValueMap`. 默认情况下,这是没有任何第三方依赖的 `DefaultPartHttpMessageReader`.
或者， 可以使用基于 https://github.com/synchronoss/nio-multipart[Synchronoss NIO Multipart] 库的 `SynchronossPartHttpMessageReader`. 两者都是通过 `ServerCodecConfigurer` bean 配置的
 (请参阅 <<webflux-web-handler-api, Web Handler API>>) .

要以流方式解析多部分数据,可以使用从 `HttpMessageReader<Part>` 返回的  `Flux<Part>`. 例如,在带注解的控制器中,使用 `@RequestPart` 意味着按名称对各个部分进行类似于 Map 的访问,因此需要完全解析多部分数据.
相反,您可以使用 `@RequestBody` 将内容解码为  `Flux<Part>` 而不收集到 `MultiValueMap`.

[[webflux-forwarded-headers]]
==== Forwarded Headers
[.small]#<<web.adoc#filters-forwarded-headers, Web MVC>>#

当请求通过代理(例如负载均衡)进行处理时,主机,端口和 scheme 可能会更改,从客户端的角度来看,要创建指向正确的主机,端口和 scheme 的 url 是一个挑战.

https://tools.ietf.org/html/rfc7239[RFC 7239] 定义了 `Forwarded` HTTP header ,代理可以使用原始请求的信息. 还有其他非标准 header,包括 `X-Forwarded-Host`, `X-Forwarded-Port`, `X-Forwarded-Proto`, `X-Forwarded-Ssl`, 和 `X-Forwarded-Prefix`.

`ForwardedHeaderTransformer` 是一个组件,可根据转发的 header 修改请求的主机,端口和 scheme,然后删除这些 header. 您可以将其声明为名称为 `forwardedHeaderTransformer` 的 Bean,并对其进行<<webflux-web-handler-api-special-beans, 检测>> 和使用.

对于转发的 header,存在安全方面的考虑,因为应用程序无法知道 header 是由代理添加的,还是由恶意客户端添加的. 这就是为什么应配置信任边界处的代理以删除来自外部的不受信任的转发流量的原因. 您还可以使用 `removeOnly=true` 配置 `ForwardedHeaderTransformer`,在这种情况下,它将删除但不使用 header.

NOTE: 在 5.1 中,`ForwardedHeaderFilter` 被 `ForwardedHeaderTransformer` 弃用并取代,因此可以在创建交换之前更早地处理转发的 header . 如果仍然配置了过滤器,则将其从过滤器列表中删除,而改用 `ForwardedHeaderTransformer`.

[[webflux-filters]]
=== Filters
[.small]#<<web.adoc#filters, Web MVC>>#

在 <<webflux-web-handler-api>> 中,您可以使用 `WebFilter` 在其余的过滤器处理链和目标 `WebHandler` 之前和之后应用拦截器样式的逻辑. 使用  <<webflux-config>> 时,注册 WebFilter 就像将其声明为 Spring bean 一样简单,并且(可选)通过在bean声明上使用 `@Order` 或实现 `Ordered` 接口来表达优先级.

[[webflux-filters-cors]]
==== CORS
[.small]#<<web.adoc#filters-cors, Web MVC>>#

Spring WebFlux 通过控制器上的注解为 CORS 配置提供了细粒度的支持. 但是,当您将其与 Spring Security 结合使用时,我们建议您依赖内置的 `CorsFilter`,因为它必须在 Spring Security 的过滤器链之前.

有关更多详细信息,请参见  <<webflux-cors>> 和 <<webflux-cors-webfilter>>  上的部分.

[[webflux-exception-handler]]
=== Exceptions
[.small]#<<web.adoc#mvc-ann-customer-servlet-container-error-page, Web MVC>>#

在 <<webflux-web-handler-api>> 中,可以使用 `WebExceptionHandler` 来处理 `WebFilter` 实例链和目标 `WebHandler` 链中的异常. 使用 <<webflux-config>> 时,注册 `WebExceptionHandler` 就像将其声明为 Spring bean 一样简单,并且(可选)通过在 bean 声明上使用 `@Order` 或实现 `Ordered` 接口来表达优先级.

下表描述了可用的 `WebExceptionHandler` 实现:

[cols="1,2", options="header"]
|===
| Exception Handler | Description

| `ResponseStatusExceptionHandler`
| 通过将响应设置为异常的 HTTP 状态码， 提供对   {api-spring-framework}/web/server/ResponseStatusException.html[`ResponseStatusException`] 类型的异常的处理.

| `WebFluxResponseStatusExceptionHandler`
| `ResponseStatusExceptionHandler` 的扩展， 它也可以确定 `@ResponseStatus` 注解上的任何异常的 HTTP 状态码.
  该处理程序在  <<webflux-config>> 中声明.

|===



[[webflux-codecs]]
=== Codecs(编解码器)
[.small]#<<integration.adoc#rest-message-conversion, Web MVC>>#

`spring-web` 和 `spring-core` 模块支持通过具有 Reactive Streams 背压的非阻塞 I/O,可以将字节内容与更高级别的对象之间的字节序列进行序列化和反序列化. 以下介绍了此支持:

* {api-spring-framework}/core/codec/Encoder.html[`Encoder`] 和
{api-spring-framework}/core/codec/Decoder.html[`Decoder`] 用于独立于HTTP编码和解码内容.
* {api-spring-framework}/http/codec/HttpMessageReader.html[`HttpMessageReader`] 和
{api-spring-framework}/http/codec/HttpMessageWriter.html[`HttpMessageWriter`] 是对HTTP消息内容进行编码和解码.
* 可以使用 `EncoderHttpMessageWriter` 包装 `Encoder` ,使它能在 Web 应用程序中使用.同样,可以使用 `DecoderHttpMessageReader` 来包装 `Decoder`.
* {api-spring-framework}/core/io/buffer/DataBuffer.html[`DataBuffer`] 抽象了不同的字节缓冲区表示形式 (例如 Netty `ByteBuf`, `java.nio.ByteBuffer`, 等.) 请参见 <<core#databuffers,Data Buffers and Codecs>> 部分中的数据缓冲区和编解码器.

`spring-core` 模块提供 `byte[]`, `ByteBuffer`, `DataBuffer`, `Resource` 和 `String` 编码器和解码器实现. `spring-web` 模块提供了 Jackson JSON, Jackson Smile, JAXB2, Protocol Buffers 和其他编码器和解码器,
以及仅用于 Web 的 HTTP 消息读取器和写入器实现,用于表单数据,多部分内容,服务器发送事件等.

`ClientCodecConfigurer` 和 `ServerCodecConfigurer` 通常用于配置和自定义编解码器. 请参阅有关 <<webflux-config-message-codecs>> 的部分.

[[webflux-codecs-jackson]]
==== Jackson JSON

Jackson 支持 JSON 和二进制 JSON(https://github.com/FasterXML/smile-format-specification[Smile]) .

`Jackson2Decoder` 的工作方式如下:

* Jackson 以异步, 非阻塞的形式解析,将字节块流聚合到 `TokenBuffer` 的每个块中,每个代表 JSON 对象.
* 每个 `TokenBuffer` 都传递给 Jackson `ObjectMapper` 以创建更高级别的对象.
* 当解码为一个简单的 publisher (例如 `Mono`) 时, 有一个 `TokenBuffer`.
* 当解码为多个 publisher (例如 `Flux`), 一旦为完整格式的对象接收到足够的字节,每个 `TokenBuffer` 就会传递给 `ObjectMapper`. 输入内容可以是 JSON 数组,也可以是 https://en.wikipedia.org/wiki/JSON_streaming[line-delimited JSON], 例如 NDJSON, JSON Lines, 或 JSON Text Sequences.

`Jackson2Encoder` 的工作方式如下:

* 对于单个 publisher (例如 `Mono`), 只需通过 `ObjectMapper` 对其进行序列化即可.
* 对于具有 "application/json" 的多个 publisher, 默认情况下使用 `Flux#collectToList()` 将值收集起来,然后序列化结果集合.
* 对于具有流媒体类型 `application/x-ndjson` 或 `application/stream+x-jackson-smile` 的多个 publisher, 请使用 https://en.wikipedia.org/wiki/JSON_streaming[line-delimited JSON] 格式分别对每个值进行编码,写入和刷新.其他流媒体类型可能已在编码器中注册
* 对于 SSE 将为每个事件调用 `Jackson2Encoder` 并刷新输出以确保交付没有延迟.

[NOTE]
====
默认情况下,`Jackson2Encoder` 和 `Jackson2Decoder` 都不支持 `String` 类型的元素. 相反,假设需要表示一个字符串或字符串序列,则由 `CharSequenceEncoder` 序列化 JSON 内容.
如果您需要从 `Flux<String>` 呈现 JSON 数组,请使用 `Flux#collectToList()` 并对 `Mono<List<String>>` 进行编码.
====

[[webflux-codecs-forms]]
==== 表单数据

`FormHttpMessageReader` 和 `FormHttpMessageWriter` 支持对 `application/x-www-form-urlencoded` 内容进行解码和编码..

服务器端经常需要从多个位置访问表单内容,`ServerWebExchange` 提供了 `getFormData()` 方法,该方法通过 `FormHttpMessageReader` 解析内容,然后缓存结果以进行重复访问. 请参阅 <<webflux-web-handler-api>> 部分中的 <<webflux-form-data>> .

一旦使用 `getFormData()`,就无法再从请求正文中读取原始内容. 因此,应用程序应始终通过 `ServerWebExchange` 来访问缓存的表单数据,而不是从原始请求正文中进行读取.

[[webflux-codecs-multipart]]
==== Multipart

`MultipartHttpMessageReader` 和 `MultipartHttpMessageWriter` 支持对 "multipart/form-data" 内容进行解码和编码. 反过来,`MultipartHttpMessageReader` 委托 `HttpMessageReader` 进行实际解析为 `Flux<Part>` 然后将这些内容简单地收集到 `MultiValueMap`.

默认情况下,使用的是 `DefaultPartHttpMessageReader`,但是可以通过 `ServerCodecConfigurer` 改变默认行为.

有关 `DefaultPartHttpMessageReader` 的更多信息， 请参考 {api-spring-framework}/http/codec/multipart/DefaultPartHttpMessageReader.html[javadoc of `DefaultPartHttpMessageReader`].

服务器端经常需要从多个位置访问表单内容,`ServerWebExchange` 提供了 `getMultipartData()` 方法,该方法通过 `MultipartHttpMessageReader` 解析内容,然后缓存结果以进行重复访问. 请参阅 <<webflux-web-handler-api>> 部分中的 <<webflux-multipart>>.

一旦使用 `getMultipartData()` ,就无法再从请求正文中读取原始原始内容. 因此,应用程序必须始终使用 `getMultipartData()` 来重复访问,否则必须依赖 `SynchronossPartHttpMessageReader` 来一次性访问 `Flux<Part>`

[[webflux-codecs-limits]]
==== 限制

可以通过 `Decoder` 和 `HttpMessageReader` 的实现来对 部分 buffer 或 全部的输入流进行配置,比如,可以限制内存中缓冲的最大字节数.在某些情况下,由于输入被汇总并表示为单个对象而发生缓冲,
例如,具有 `@RequestBody byte[]`,
`x-www-form-urlencoded` 数据的控制器方法,等等. 在分割输入流(例如,定界文本,JSON 对象流等)时,流处理也会发生缓冲. 对于那些流情况,该限制适用于与流中一个对象关联的字节数.

要配置缓冲区大小,您可以检查给定的 `Decoder` 或 `HttpMessageReader` 是否暴露了 `maxInMemorySize` 属性,如果这样,则 Javadoc 将具有有关默认值的详细信息. 在服务端,`ServerCodecConfigurer` 通过默认编码解码器的 `maxInMemorySize` 属性,
提供了一个设置所有编码解码器的 <<webflux-config-message-codecs,single place>>. 在客户端,可以在  <<web-reactive.adoc#webflux-client-builder-maxinmemorysize, WebClient.Builder>> 中更改限制.

对于 <<webflux-codecs-multipart,Multipart parsing>>,`maxInMemorySize` 属性限制了非文件部分的大小. 对于文件部件,它确定将部件写入磁盘的阈值. 对于写入磁盘的文件部件,还有一个额外的 `maxDiskUsagePerPart` 属性可限制每个部件的磁盘空间量.
还有一个 `maxParts` 属性,用于限制多部分请求中的部分总数. 要在 `WebFlux` 中配置所有3个,您需要向 `ServerCodecConfigurer` 提供一个预先配置的 `MultipartHttpMessageReader` 实例.

[[webflux-codecs-streaming]]
==== Streaming
[.small]#<<web.adoc#mvc-ann-async-http-streaming, Web MVC>>#

在流式传输到 HTTP 响应(例如 `text/event-stream`,`application/x-ndjson`) 时,定期发送数据很重要,这样才能尽快(而不是稍后)可靠地检测到断开连接的客户端. 这样的发送可以是仅注解的空 SSE 事件,也可以是有效用作心跳的任何其他"无操作”数据.

[[webflux-codecs-buffers]]
==== `DataBuffer`

`DataBuffer` 是 WebFlux 中字节缓冲区的表示形式. 该部分参考的 Spring Core 中 <<core#databuffers, Data Buffers and Codecs>> 部分.
要理解的关键点是,在诸如 Netty 之类的某些服务器上,字节缓冲区是池化的,并且对引用计数进行计数,并且在使用时必须将其释放,以避免内存泄漏.

WebFlux 应用程序通常不需要关心此类问题,除非它们直接使用或产生数据缓冲区,而不是依赖于编解码器与更高级别的对象之间进行转换,或者除非它们选择创建自定义编解码器. 对于这种情况,请查看<<core#databuffers, Data Buffers and Codecs>>中的信息,尤其是有关<<core#databuffers-using, Using DataBuffer>>的部分.

[[webflux-logging]]
=== Logging
[.small]#<<web.adoc#mvc-logging, Web MVC>>#

Spring WebFlux 中的 `DEBUG` 级别日志记录意图提供一个紧密的,最小化的并且对用户友好的. 它侧重于一遍又一遍有用的高价值信息,而其他信息则仅在调试特定问题时才有用.

`TRACE` 级别的日志记录通常遵循与 `DEBUG` 相同的原理(例如,也不应成为 firehose),但可用于调试任何问题. 另外,某些日志消息在 `TRACE` vs `DEBUG` 上可能显示不同级别的详细信息.

良好的日志记录来自使用日志的经验. 如果您发现任何不符合既定目标的东西,请告诉我们.

[[webflux-logging-id]]
==== Log Id

在 WebFlux 中,单个请求可以在多个线程上执行,并且线程 ID 对于关联属于特定请求的日志消息没有用. 这就是为什么默认情况下 WebFlux 日志消息以特定于请求的ID为前缀的原因.

在服务器端,日志 ID 存储在 `ServerWebExchange` 属性 ({api-spring-framework}/web/server/ServerWebExchange.html#LOG_ID_ATTRIBUTE[`LOG_ID_ATTRIBUTE`]),中,而可从 `ServerWebExchange#getLogPrefix()` 获得基于该 ID 的全格式前缀. 在 WebClient 端,日志 ID 存储在 `ClientRequest` 属性 ({api-spring-framework}/web/reactive/function/client/ClientRequest.html#LOG_ID_ATTRIBUTE[`LOG_ID_ATTRIBUTE`]) 中,而完全格式的前缀可从 `ClientRequest#logPrefix()` 获得.

[[webflux-logging-sensitive-data]]
==== 敏感数据
[.small]#<<web.adoc#mvc-logging-sensitive-data, Web MVC>>#

`DEBUG` 和 `TRACE`  日志记录可以记录敏感信息. 这就是默认情况下屏蔽表单参数和标题的原因,并且必须显式启用它们的完整日志记录.

下面的示例说明如何针对服务器端请求执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	class MyConfig implements WebFluxConfigurer {

		@Override
		public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
			configurer.defaultCodecs().enableLoggingRequestDetails(true);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class MyConfig : WebFluxConfigurer {

		override fun configureHttpMessageCodecs(configurer: ServerCodecConfigurer) {
			configurer.defaultCodecs().enableLoggingRequestDetails(true)
		}
	}
----

下面的示例说明如何针对客户端请求执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Consumer<ClientCodecConfigurer> consumer = configurer ->
			configurer.defaultCodecs().enableLoggingRequestDetails(true);

	WebClient webClient = WebClient.builder()
			.exchangeStrategies(strategies -> strategies.codecs(consumer))
			.build();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val consumer: (ClientCodecConfigurer) -> Unit  = { configurer -> configurer.defaultCodecs().enableLoggingRequestDetails(true) }

	val webClient = WebClient.builder()
			.exchangeStrategies({ strategies -> strategies.codecs(consumer) })
			.build()
----

[[webflux-logging-appenders]]
==== Appenders

日志库 (例如 SLF4J 和 Log4J 2) 提供了避免阻塞的异步记录器.  尽管它们有其自身的缺点， 例如可能丢弃无法进行排队日志记录的消息， 但它们是当前在响应式， 非阻塞应用程序中使用的最佳可用选项.


[[webflux-codecs-custom]]
==== Custom codecs

应用程序可以注册自定义编解码器以支持其他媒体类型,也可以注册默认编解码器不支持的特定行为.

开发人员表达的某些配置选项在默认编解码器上强制执行. 自定义编解码器可能希望有机会与这些首选项保持一致,例如 <<webflux-codecs-limits, 强制执行缓冲限制>> 或 <<webflux-logging-sensitive-data, 记录敏感数据>>.

下面的示例说明如何针对客户端请求执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	WebClient webClient = WebClient.builder()
			.codecs(configurer -> {
					CustomDecoder decoder = new CustomDecoder();
                    configurer.customCodecs().registerWithDefaultConfig(decoder);
			})
			.build();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val webClient = WebClient.builder()
			.codecs({ configurer ->
					val decoder = CustomDecoder()
            		configurer.customCodecs().registerWithDefaultConfig(decoder)
			 })
			.build()
----

[[webflux-dispatcher-handler]]
== `DispatcherHandler`
[.small]#<<web.adoc#mvc-servlet, Web MVC>>#

Spring WebFlux 与 Spring MVC 类似,是围绕前端控制器模式设计的,其中核心 `WebHandler` `DispatcherHandler` 提供了用于请求处理的共享算法,而实际工作是由可配置的委托组件执行的. 该模型非常灵活,并支持多种工作流程.

`DispatcherHandler` 从 Spring 配置中发现所需的委托组件. 它还被设计为 Spring Bean 本身,并实现 `ApplicationContextAware` 来访问其运行的上下文.
如果以 `WebHandler` 的 bean 名称声明了 `DispatcherHandler`,则 {api-spring-framework}/web/server/adapter/WebHttpHandlerBuilder.html[`WebHttpHandlerBuilder`] 会发现它,而 `WebHttpHandlerBuilder` 会按照 <<webflux-web-handler-api>> 中的描述将请求处理链组合在一起.

WebFlux 应用程序中的 Spring 配置通常包含:

* Bean 名称为 `webHandler` 的 `DispatcherHandler`
* `WebFilter` 和 `WebExceptionHandler` beans
* <<webflux-special-bean-types,`DispatcherHandler` special beans>>
* 其他

将配置提供给 `WebHttpHandlerBuilder` 以构建处理链,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	ApplicationContext context = ...
	HttpHandler handler = WebHttpHandlerBuilder.applicationContext(context).build();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val context: ApplicationContext = ...
	val handler = WebHttpHandlerBuilder.applicationContext(context).build()
----

生成的 `HttpHandler` 已准备好与 <<webflux-httphandler, server adapter>> 一起使用.

[[webflux-special-bean-types]]
=== 特殊的 Bean 类型
[.small]#<<web.adoc#mvc-servlet-special-bean-types, Web MVC>>#

`DispatcherHandler` 委托特殊bean处理请求并渲染视图. "special beans” 是指实现 WebFlux 框架的 Spring 管理的 `Object` 实例. 这些通常带有内置联系,但您可以自定义其属性并扩展或替换它们.

下表列出了 `DispatcherHandler` 检测到的特殊 bean. 请注意,在较低级别还检测到其他一些 Bean(请参阅 <<webflux-web-handler-api-special-beans>>  中的特殊 Bean 类型).

[[webflux-special-beans-table]]
[cols="1,2", options="header"]
|===
| Bean type | Explanation

| `HandlerMapping`
| 将请求映射到处理程序. 其映射规则基于某些标准,其细节因 `HandlerMapping` 实现而异. `HandlerMapping` 的主要实现是 `RequestMappingHandlerMapping`(它支持带 `@RequestMapping` 注解的方法) 和 SimpleUrlHandlerMapping (它维护对处理程序的 URI 路径模式的显式注册) .


| `HandlerAdapter`
| 无论实际调用处理程序如何,都可以帮助 `DispatcherServlet` 调用映射到请求的处理程序. 例如,调用带有注解的控制器,需要从注解中解析一些信息. `HandlerAdapter` 的主要目的是保护 `DispatcherServlet` 不受此类细节的影响.

| `HandlerResultHandler`
| 处理来自处理程序调用的结果， 并最终确定响应. 请参阅 <<webflux-resulthandling>>.
|===

[[webflux-framework-config]]
=== WebFlux 配置
[.small]#<<web.adoc#mvc-servlet-config, Web MVC>>#

应用程序可以声明处理请求所需的基础结构 bean(在 <<webflux-web-handler-api-special-beans, Web Handler API>>  和 <<webflux-special-bean-types, `DispatcherHandler`>> 下列出).

在大多数情况下,<<webflux-config>> 是最佳起点.  它声明了所需的 bean,并提供更高级别的配置回调 API 来自定义它.

NOTE: Spring Boot 依靠 WebFlux 配置来配置 Spring WebFlux,并且还提供了许多额外的方便选项.

[[webflux-dispatcher-handler-sequence]]
=== 处理
[.small]#<<web.adoc#mvc-servlet-sequence, Web MVC>>#

`DispatcherHandler` 处理请求过程:

* 为每个 `HandlerMapping` 查找一个匹配的处理程序,并使用第一个匹配项.
* 如果找到处理程序,则通过适当的 `HandlerAdapter` 执行该处理程序,该适配器将执行返回的值暴露为 `HandlerResult`.
* 通过直接写入响应或使用视图渲染,将 `HandlerResult` 提供给适当的 `HandlerResultHandler` 以完成处理.

[[webflux-resulthandling]]
=== 结果处理

通过 `HandlerAdapter` 调用处理程序的返回值连同其他一些上下文一起包装为 `HandlerResult`,并传递给第一个要求其支持的 `HandlerResultHandler`. 下表显示了可用的 `HandlerResultHandler` 实现,所有实现都在 <<webflux-config>> 中声明:

[cols="1,2,1", options="header"]
|===
| Result Handler Type | Return Values | Default Order

| `ResponseEntityResultHandler`
| `ResponseEntity`, 通常来自 `@Controller` 实例.
| 0

| `ServerResponseResultHandler`
| `ServerResponse`, 通常来自功能端点.
| 0

| `ResponseBodyResultHandler`
| 处理 `@ResponseBody` 方法 或 `@RestController` 类的返回值.
| 100

| `ViewResolutionResultHandler`
| `CharSequence`, {api-spring-framework}/web/reactive/result/view/View.html[`View`],
  {api-spring-framework}/ui/Model.html[Model], `Map`,
  {api-spring-framework}/web/reactive/result/view/Rendering.html[Rendering],
  或其他任何一个 `Object` 被视为一个 model attribute.

  See also <<webflux-viewresolution>>.

| `Integer.MAX_VALUE`
|===

[[webflux-dispatcher-exceptions]]
=== 异常
[.small]#<<web.adoc#mvc-exceptionhandlers, Web MVC>>#

从 `HandlerAdapter` 返回的 `HandlerResult` 可以暴露基于某些特定于处理程序的机制进行错误处理的函数. 在以下情况下将调用此错误函数:

* 处理程序(例如,`@Controller`)调用失败
* 通过 `HandlerResultHandler` 处理处理程序返回值失败.

只要在从处理程序返回的响应类型产生任何数据项之前发生错误信号,错误函数就可以更改响应(例如,更改为错误状态).

这就是支持 `@Controller` 类中的 `@ExceptionHandler` 方法的方式. 相比之下,Spring MVC 中对相同功能的支持是基于 `HandlerExceptionResolver` 建立的. 这通常不重要.
但是,请记住,在 WebFlux 中,不能使用 `@ControllerAdvice` 来处理在选择处理程序之前发生的异常.

另请参见 "`Annotated Controller`"  部分中的 <<webflux-ann-controller-exceptions>>  或 <<webflux-exception-handler>>  部分中的"异常”.

[[webflux-viewresolution]]
=== 视图解析
[.small]#<<web.adoc#mvc-viewresolver, Web MVC>>#

视图解析使您可以使用 HTML 模板和数据模型渲染浏览器,而无需将您与特定的视图技术联系在一起. 在 Spring WebFlux 中,通过专用的 <<webflux-resulthandling, HandlerResultHandler>> 支持视图解析,该 `HandlerResultHandler` 使用 `ViewResolver` 实例将 String (代表逻辑视图名称)映射到 `View` 实例. 然后使用 `View` 渲染视图.

[[webflux-viewresolution-handling]]
==== Handling
[.small]#<<web.adoc#mvc-viewresolver-handling, Web MVC>>#

传递给 `ViewResolutionResultHandler` 的 `HandlerResult` 包含处理程序的返回值和包含请求处理期间添加的属性的模型. 返回值将作为以下值之一进行处理:

* `String`, `CharSequence`: 通过配置的 `ViewResolver` 实现列表解析为 `View` 的逻辑视图名称.
* `void`: 根据请求路径选择一个默认视图名称,去掉前面和后面的斜杠,然后将其解析为视图. 当未提供视图名称(例如,返回模型属性)或异步返回值(例如,`Mono` 完成为空)时,也会发生同样的情况.
* {api-spring-framework}/web/reactive/result/view/Rendering.html[Rendering]: 用于视图解析方案的API. 通过代码完成探索IDE中的选项.
* `Model`, `Map`: 要添加到请求模型的额外模型属性.
* 任何其他返回值(由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty]) 确定的简单类型除外)都将被视为要添加到模型的模型属性. 属性名称是通过使用 {api-spring-framework}/core/Conventions.html[约定]从类名称继承的,除非存在处理程序方法 `@ModelAttribute` 注解.

该模型可以包含异步,响应式类型(例如,来自 Reactor 或 RxJava). 在渲染之前,`AbstractView` 将此类模型属性解析为具体值并更新模型. 单值电抗类型解析为单个值或无值(如果为空),而多值电抗类型(例如 `Flux<T>`)被收集并解析为  `List<T>`.

配置视图解析就像将一个 `ViewResolutionResultHandler` bean 添加到您的 Spring 配置中一样简单.  <<webflux-config-view-resolvers, WebFlux Config>> 提供了专用于视图解析的配置 API.

有关与 Spring WebFlux 集成的视图技术的更多信息,请参见  <<webflux-view>> .

[[webflux-redirecting-redirect-prefix]]
==== 重定向
[.small]#<<web.adoc#mvc-redirecting-redirect-prefix, Web MVC>>#

您可以在视图中使用 `redirect:` 前缀来执行重定向. `UrlBasedViewResolver` (及其子类) 将此识别为需要重定向的指令.  视图名称的其余部分是重定向URL.

控制器本身可以根据逻辑视图名称进行操作.  逻辑视图名称(例如 `redirect:/myapp/some/resource` ) 相对于当前 Servlet 上下文重定向,而名称如 `redirect:http://myhost.com/some/arbitrary/path`  重定向到绝对 URL.

[[webflux-multiple-representations]]
==== 内容协商
[.small]#<<web.adoc#mvc-multiple-representations, Web MVC>>#

`ViewResolutionResultHandler` 支持内容协商. 它将请求媒体类型与每个选定视图支持的媒体类型进行比较. 使用支持请求的媒体类型的第一个视图.

为了支持 JSON 和 XML 之类的媒体类型,Spring WebFlux 提供了 `HttpMessageWriterView`,这是一个通过 <<webflux-codecs, HttpMessageWriter>> 呈现的特殊视图.
通常,您可以通过 <<webflux-config-view-resolvers, WebFlux Configuration>> 将其配置为默认视图. 如果默认视图与请求的媒体类型匹配,则始终会选择和使用它们.

[[webflux-controller]]
== 注解控制器
[.small]#<<web.adoc#mvc-controller, Web MVC>>#

Spring WebFlux 提供了基于注解的编程模型,其中 `@Controller` 和 `@RestController` 组件使用注解来表示请求映射、请求输入、异常处理等. 被注解的控制器拥有灵活的方法签名,并且无需扩展基类或实现特定的接口. 以下示例显示了由注解定义的控制器:

以下清单显示了一个基本示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RestController
	public class HelloController {

		@GetMapping("/hello")
		public String handle() {
			return "Hello WebFlux";
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RestController
	class HelloController {

		@GetMapping("/hello")
		fun handle() = "Hello WebFlux"
	}
----

在前面的示例中,该方法接受 `Model` 并将视图名称作为 `String` 返回,但是存在许多其他选项,本章稍后将对其进行说明.

[[webflux-ann-controller]]
=== `@Controller`
[.small]#<<web.adoc#mvc-ann-controller, Web MVC>>#

您可以使用标准的 Spring bean 定义来定义控制器 bean. `@Controller` 模板允许自动检测, 与 Spring 支持检测类路径中的 `@Component` 类一样,并会自动注册 bean 定义. 它还充当注解类的模板,表示它充当的是 Web 组件的角色.

要启用 `@Controller` bean的自动检测,您可以将组件扫描添加到 Java 配置中,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan("org.example.web") // <1>
	public class WebConfig {

		// ...
	}
----
<1> 扫描 `org.example.web` 包.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan("org.example.web") // <1>
	class WebConfig {

		// ...
	}
----
<1> 扫描 `org.example.web` 包.

`@RestController` 是一个 <<core.adoc#beans-meta-annotations, 组合注解>>,它本身由 `@Controller` 和 `@ResponseBody` 元注解组成.  其每个方法都继承类型级别(type-level) 的 `@ResponseBody` 注解,因此,直接写入响应主体与视图渲染和使用 HTML 模板.

[[webflux-ann-requestmapping]]
=== Request Mapping
[.small]#<<web.adoc#mvc-ann-requestmapping, Web MVC>>#

`@RequestMapping` 注解用于将请求映射到控制器方法. 它具有各种属性,可以通过 URL、HTTP 方法、请求参数、请求头参数(headers) 和媒体类型进行匹配.  可以在类级别使用它来表示共享映射,或在方法级别上用于缩小到特定的端点映射范围.

还有 `@RequestMapping` 的 HTTP 方法特定的缩写变量:

* `@GetMapping`
* `@PostMapping`
* `@PutMapping`
* `@DeleteMapping`
* `@PatchMapping`

这些简洁的注解是<<webflux-ann-requestmapping-composed,自定义注解>>,因为,大多数的控制器方法应该映射到 HTTP 方法而不是使用 `@RequestMapping`. 默认情况下, `@RequestMapping` 和所有 HTTP 方法匹配. 在类上定义的仍然需要 `@RequestMapping` 来表示共享映射.

以下示例具有类型和方法级别映射:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RestController
	@RequestMapping("/persons")
	class PersonController {

		@GetMapping("/{id}")
		public Person getPerson(@PathVariable Long id) {
			// ...
		}

		@PostMapping
		@ResponseStatus(HttpStatus.CREATED)
		public void add(@RequestBody Person person) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RestController
	@RequestMapping("/persons")
	class PersonController {

		@GetMapping("/{id}")
		fun getPerson(@PathVariable id: Long): Person {
			// ...
		}

		@PostMapping
		@ResponseStatus(HttpStatus.CREATED)
		fun add(@RequestBody person: Person) {
			// ...
		}
	}
----


[[webflux-ann-requestmapping-uri-templates]]
==== URI 模式
[.small]#<<web.adoc#mvc-ann-requestmapping-uri-templates, Web MVC>>#

您可以使用以下全局模式和通配符来映射请求:

[cols="2,3,5"]
|===
|Pattern |Description |Example

| `+?+`
| 匹配一个字符
| `+"/pages/t?st.html"+` matches `+"/pages/test.html"+` and `+"/pages/t3st.html"+`

| `+*+`
| 匹配路径段一个或多个字符
| `+"/resources/*.png"+` matches `+"/resources/file.png"+`

`+"/projects/*/versions"+` matches `+"/projects/spring/versions"+` but does not match `+"/projects/spring/boot/versions"+`

| `+**+`
| 匹配 0 个或多个路径
| `+"/resources/**"+` matches `+"/resources/file.png"+` and `+"/resources/images/file.png"+`

`+"/resources/**/file.png"+` is invalid as `+**+` is only allowed at the end of the path.

| `+{name}+`
| 将匹配到的路径命名为 "name" 的变量
| `+"/projects/{project}/versions"+` matches `+"/projects/spring/versions"+` and captures `+project=spring+`

| `+{name:[a-z]+}+`
| 匹配路径正则表达式 `+"[a-z]+"+` 并将其命名为 "name" 变量
| `+"/projects/{project:[a-z]+}/versions"+` matches `+"/projects/spring/versions"+` but not `+"/projects/spring1/versions"+`

| `+{*path}+`
| 匹配零个或多个路径,直到路径结尾,并将其命名为 "path" 的变量
| `+"/resources/{*file}"+` matches `+"/resources/images/file.png"+` and captures `+file=/images/file.png+`

|===

您还可以使用 `@PathVariable` 声明 URI 变量并访问它们的值,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {
		// ...
	}
----

您可以在类和方法级别声明 URI 变量,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@RequestMapping("/owners/{ownerId}") // <1>
	public class OwnerController {

		@GetMapping("/pets/{petId}") // <2>
		public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
			// ...
		}
	}
----
<1> 类级别的 URI 映射.
<2> 方法级别的 URI 映射.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	@RequestMapping("/owners/{ownerId}") // <1>
	class OwnerController {

		@GetMapping("/pets/{petId}") // <2>
		fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {
			// ...
		}
	}
----
<1> 类级别的 URI 映射
<2> 方法级别的 URI 映射.

URI 变量会自动转换为适当的类型,或者引发 `TypeMismatchException`.  默认情况下支持简单类型(`int`, `long`, `Date` 等) ,您也可以注册对任何其他数据类型的支持.  请参见 <<webflux-ann-typeconversion>> 和 <<webflux-ann-initbinder>>.

你可以显示命名 URI 变量(例如, `@PathVariable("customId")` ),但是如果名称是相同的,并且代码是使用调试信息编译的,或者在 Java 8 中使用 `-parameters` 编译器标记.  则可以保留该详细信息.

语法  `{*varName}` 声明了一个与零个或多个剩余路径段匹配的 URI 变量. 例如,`/resources/{*path}` 匹配所有文件 `/resources/`,并且 `"path"`  变量捕获 `/resources` 下的完整路径.

语法 `{varName:regex}` 声明一个具有正则表达式的 URI 变量,其语法为 `{varName:regex}`. 例如,给定URL `/spring-web-3.0.5.jar`,以下方法提取名称,版本和文件扩展名:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
	public void handle(@PathVariable String version, @PathVariable String ext) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
	fun handle(@PathVariable version: String, @PathVariable ext: String) {
		// ...
	}
----

URI 路径模式还可以嵌入 `${…}`,在启动时通过 `PropertyPlaceHolderConfigurer` 解析本地、系统、环境和其他属性源时解析的占位符. 例如,这种模式可以使用基于某些外部配置对基于 URL 进行参数化

NOTE: Spring WebFlux 使用 `PathPattern` 和 `PathPatternParser` 获得 URI 路径匹配支持. 这两个类都位于 `spring-web` 中,并且专门设计用于在运行时匹配大量 URI 路径模式的 Web 应用程序中的 HTTP URL 路径.

Spring WebFlux 不支持后缀模式匹配,这与 Spring MVC 不同,后者的映射(例如  `/person`)也匹配到 `/person.{asterisk}`. 对于基于 URL 的内容协商,如果需要,我们建议使用查询参数,该参数更简单,更明确,并且不易受到基于 URL 路径的攻击.

[[webflux-ann-requestmapping-pattern-comparison]]
==== 模式比较
[.small]#<<web.adoc#mvc-ann-requestmapping-pattern-comparison, Web MVC>>#

当多个模式与 URL 匹配时,必须对它们进行比较以找到最佳匹配.  这是通过使用 `PathPattern.SPECIFICITY_COMPARATOR` 来完成的,它会查找更具体的模式.

对于每个模式,都会根据 URI 变量和通配符的数量计算得分,其中 URI 变量的得分低于通配符. 总得分较低的模式将获胜. 如果两个模式的分数相同,则选择更长的时间.

默认映射模式(`/{asterisk}{asterisk}`, `{*varName}`)从评分中排除,并始终排在最后.  如果两种模式都适用,则选择较长的模式.

[[webflux-ann-requestmapping-consumes]]
==== 消费者媒体类型
[.small]#<<web.adoc#mvc-ann-requestmapping-consumes, Web MVC>>#

您可以根据请求的 `Content-Type` 缩小请求映射范围,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping(path = "/pets", consumes = "application/json")
	public void addPet(@RequestBody Pet pet) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/pets", consumes = ["application/json"])
	fun addPet(@RequestBody pet: Pet) {
		// ...
	}
----


`consumes` 属性还支持否定表达式 - 例如,`!text/plain` 表示除 `text/plain` 之外的任何内容类型.

您可以在类级别声明共享 `consumes` 属性.  但是,与大多数其他请求映射属性不同,在类级别使用时,方法级别会 `consumes` 属性覆盖而不是扩展类级别声明.

TIP: `MediaType` 为常用媒体类型提供常量,例如 `APPLICATION_JSON_VALUE` 和 `APPLICATION_XML_VALUE`.

[[webflux-ann-requestmapping-produces]]
==== 生产者媒体类型
[.small]#<<web.adoc#mvc-ann-requestmapping-produces, Web MVC>>#

您可以根据 `Accept` 请求头和控制器方法生成的内容类型列表来缩小请求映射,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path = "/pets/{petId}", produces = "application/json")
	@ResponseBody
	public Pet getPet(@PathVariable String petId) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/pets/{petId}", produces = ["application/json"])
	@ResponseBody
	fun getPet(@PathVariable String petId): Pet {
		// ...
	}
----

媒体类型可以指定字符集.  支持否定表达式 - 例如, `!text/plain` 表示 "text/plain" 以外的任何内容类型.

您可以在类级别声明共享的 `produces` 属性.  但是,与大多数其他请求映射属性不同,在类级别使用时,方法级别会生成属性覆盖,而不是扩展类级别声明.

TIP: `MediaType` 为常用媒体类型提供常量,例如 `APPLICATION_JSON_UTF8_VALUE` 和 `APPLICATION_XML_VALUE`.

[[webflux-ann-requestmapping-params-and-headers]]
==== 参数, 请求头
[.small]#<<web.adoc#mvc-ann-requestmapping-params-and-headers, Web MVC>>#

您可以根据请求参数条件缩小请求映射.  您可以测试是否存在请求参数( `myParam` ) ,缺少一个( `!myParam` ) 或特定值( `myParam=myValue` ) .  以下示例显示如何测试特定值:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") // <1>
	public void findPet(@PathVariable String petId) {
		// ...
	}
----
<1> 测试 `myParam` 是否等于 `myValue`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/pets/{petId}", params = ["myParam=myValue"]) // <1>
	fun findPet(@PathVariable petId: String) {
		// ...
	}
----
<1> 检查 `myParam` 是否等于 `myValue`.

你可以使用请求头条件, 如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path = "/pets", headers = "myHeader=myValue") // <1>
	public void findPet(@PathVariable String petId) {
		// ...
	}
----
<1> 测试 `myHeader` 是否等于 `myValue`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/pets", headers = ["myHeader=myValue"]) // <1>
	fun findPet(@PathVariable petId: String) {
		// ...
	}
----
<1> 检查 `myHeader` 是否等于 `myValue`.


[[webflux-ann-requestmapping-head-options]]
==== HTTP HEAD, OPTIONS
[.small]#<<web.adoc#mvc-ann-requestmapping-head-options, Web MVC>>#

`@GetMapping` (和 `@RequestMapping(method=HttpMethod.GET)`)一样,为了请求映射的目的,透明地支持 HTTP HEAD 以进行请求映射. 控制器方法无需更改.  在 `javax.servlet.http.HttpServlet` 中应用的响应包确保有 `Content-Length` 头并且设置为写入的字节数,但实际上不会写入响应.

默认情况下,HTTP OPTIONS 通过设置 `Allow` 响应头来为所有具有匹配URL模式的 `@RequestMapping` 方法中列出的 HTTP 方法列表来处理 HTTP 选项.

对于没有 HTTP 方法声明的 `@RequestMapping`,`Allow` 请求头可以设置为 `GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS`.  控制器方法应始终声明支持的 HTTP 方法(例如,通过使用特定于 HTTP 方法的变体: `@GetMapping`, `@PostMapping` 等) .

您可以将 `@RequestMapping` 方法显式映射到 HTTP HEAD 和 HTTP OPTIONS,但在常见情况下这不是必需的.

[[webflux-ann-requestmapping-composed]]
==== 自定义注解
[.small]#<<web.adoc#mvc-ann-requestmapping-composed, Web MVC>>#

Spring WebFlux 支持使用 <<core.adoc#beans-meta-annotations, 组合注解>>进行请求映射.  这些注解本身是使用 `@RequestMapping` 进行元注解的,并且用于重新声明具有更窄,更具体目的的 `@RequestMapping` 属性的子集(或全部) .

`@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`, 和 `@PatchMapping` 就是组合注解最好的示例, 提供它们是因为.
可以说,大多数控制器方法应该映射到特定的 HTTP 方法,而不是使用 `@RequestMapping`,默认情况下,它与所有 HTTP 方法匹配.  如果您需要组合注解的示例,请查看如何声明这些注解.

Spring WebFlux 还支持使用自定义请求匹配逻辑的自定义请求映射属性. 这是一个更高级的选项,需要继承 `RequestMappingHandlerMapping` 并覆盖 `getCustomMethodCondition` 方法, 您可以在其中检查自定义属性并返回自己的 `RequestCondition`.

[[webflux-ann-requestmapping-registration]]
==== 显式注册
[.small]#<<web.adoc#mvc-ann-requestmapping-registration, Web MVC>>#

您可以以编程方式注册处理程序方法,您可以将其用于动态注册或高级情况,例如不同 URL 下的同一处理程序的不同实例.  以下示例注册处理程序方法:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class MyConfig {

		@Autowired
		public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) // <1>
				throws NoSuchMethodException {

			RequestMappingInfo info = RequestMappingInfo
					.paths("/user/{id}").methods(RequestMethod.GET).build(); // <2>

			Method method = UserHandler.class.getMethod("getUser", Long.class); // <3>

			mapping.registerMapping(info, handler, method); // <4>
		}

	}
----
<1> 为控制器注入目标处理程序和处理程序映射
<2> 准备映射元数据的请求
<3> 获取处理程序方法
<4> 添加注册

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class MyConfig {

		@Autowired
		fun setHandlerMapping(mapping: RequestMappingHandlerMapping, handler: UserHandler) { // <1>

			val info = RequestMappingInfo.paths("/user/{id}").methods(RequestMethod.GET).build() // <2>

			val method = UserHandler::class.java.getMethod("getUser", Long::class.java) // <3>

			mapping.registerMapping(info, handler, method) // <4>
		}
	}
----
<1> 为控制器注入目标处理程序和处理程序映射
<2> 准备映射元数据的请求
<3> 获取处理程序方法
<4> 添加注册


[[webflux-ann-methods]]
=== 程序处理方法
[.small]#<<web.adoc#mvc-ann-methods, Web MVC>>#

`@RequestMapping` 处理程序方法具有灵活的签名,可以从一系列受支持的控制器方法参数和返回值中进行选择.

[[webflux-ann-arguments]]
==== 方法参数
[.small]#<<web.adoc#mvc-ann-arguments, Web MVC>>#

下表显示了受支持的控制器方法参数,任何参数都不支持响应式(Reactive)类型.

需要解析 I/O (例如,读取请求正文)的自变量支持响应式类型(Reactor,RxJava 或  <<webflux-reactive-libraries, 其他>>). 这在"描述”列中进行了标记. 不需要阻塞的参数不应使用响应类型.

JDK 8  `java.util.Optional` 作为方法参数来支持的,它与具有必需属性的注解(例如 `@RequestParam`, `@RequestHeader` 等相结合).  并且等同于 `required=false`.

[cols="1,2", options="header"]
|===
| Controller method argument | Description

| `ServerWebExchange`
| 访问完整的 `ServerWebExchange` -- 包含 HTTP 请求和响应,
  request 和 session 属性, `checkNotModified` 方法等等.

| `ServerHttpRequest`, `ServerHttpResponse`
| 访问 HTTP 请求或响应.

| `WebSession`
| 访问 session. 除非添加了属性， 否则不会强制打开一个新的会话. 支持 reactive 类型.

| `java.security.Principal`
| 当前经过身份验证的用户 -- 可能是 `Principal` 的实现类. 支持 reactive 类型.

| `org.springframework.http.HttpMethod`
| 请求的 HTTP 方法.

| `java.util.Locale`
| 当前请求的语言环境, 具体取决于可用的 `LocaleResolver` -- 实际上是配置的 `LocaleResolver`/`LocaleContextResolver`.

| `java.util.TimeZone` + `java.time.ZoneId`
| 与当前请求关联的时区, 由 `LocaleContextResolver` 决定.

| `@PathVariable`
| 访问 URI 模板变量. See <<webflux-ann-requestmapping-uri-templates>>.

| `@MatrixVariable`
| 用于访问 URI 路径段中的键值对. 请参阅 <<webflux-ann-matrix-variables>>.

| `@RequestParam`
| 用于访问 Servlet 请求参数. 参数值将转换为声明的方法参数类型. 请参阅 <<webflux-ann-requestparam>>.

  请注意， 使用 `@RequestParam` 是可选的 -- 例如， 设置其属性. 请参阅此表后面的 "其他任何参数".

| `@RequestHeader`
| 用于访问请求头. 请求头的值将转换为声明的方法参数类型. 请参阅 <<webflux-ann-requestheader>>.

| `@CookieValue`
| 用于访问 cookie. Cookie 值将转换为声明的方法参数类型. 请参阅 <<webflux-ann-cookievalue>>.

| `@RequestBody`
| 用于访问 HTTP 请求正文. 正文内容通过使用 `HttpMessageReader` 实例转换为声明的方法参数类型. 支持 reactive 类型. 请参阅 <<webflux-ann-requestbody>>.

| `HttpEntity<B>`
| 用于访问请求头和正文. 主体将通过 `HttpMessageReader` 实例进行转换. 支持 reactive 类型. 请参阅 <<webflux-ann-httpentity>>.

| `@RequestPart`
| 用于访问 `multipart/form-data` 请求中的数据. 支持 reactive 类型.
  请参阅 <<webflux-multipart-forms>> 和 <<webflux-multipart>>.

| `java.util.Map`, `org.springframework.ui.Model`, and `org.springframework.ui.ModelMap`.
| 用于访问在 HTML 控制器中使用的模型， 并作为视图渲染的一部分暴露给模板.

| `@ModelAttribute`
| 用于访问模型中的现有属性 (如果不存在， 则进行实例化) ， 并应用数据绑定和验证. 见 <<webflux-ann-modelattrib-method-args>>  以及 <<webflux-ann-modelattrib-methods>> 和 <<webflux-ann-initbinder>>.

请注意， 使用 `@ModelAttribute` 是可选的-例如， 设置其属性. 请参阅此表后面的 "其他任何参数"

| `Errors`, `BindingResult`
| 用于访问命令对象 (即 `@ModelAttribute` 变量) 的验证和数据绑定中的错误 . `Errors` 或 `BindingResult` 参数必须在验证方法参数后声明.

| `SessionStatus` + class-level `@SessionAttributes`
| 为了标记表单处理完成, 将触发通过声明的类级别的 `@SessionAttributes` 注解清楚会话属性.
  请参阅 <<webflux-ann-sessionattributes>> 获取更多的细节.

| `UriComponentsBuilder`
| 为当前请求的 host, port, scheme, 和 context path 准备 URL.
  请参阅 <<webflux-uri-building>>.

| `@SessionAttribute`
| 访问任何 session 属性 -- 与类级别 `@SessionAttributes` 注解声明而存储在会话中的模型属性相反. 请参阅
  <<webflux-ann-sessionattribute>> 获取更多的细节.

| `@RequestAttribute`
| 访问 request 属性. 请参阅 <<webflux-ann-requestattrib>> 获取更多细节.

| Any other argument
| 如果一个方法参数不匹配于任何上述的， 它是， 在默认情况下， 解析为 `@RequestParam`， 如果它是一个简单的类型， 如由 `BeanUtils#isSimpleProperty`， 否则,作为 `@ModelAttribute`.
|===


[[webflux-ann-return-types]]
==== 返回值
[.small]#<<web.adoc#mvc-ann-return-types, Web MVC>>#

下表描述了支持的控制器方法返回值.请注意,所有返回值通常都支持 Reactor,RxJava  <<webflux-reactive-libraries, 其他>> 的库中的响应类型.

[cols="1,2", options="header"]
|===
| 控制器方法返回值 | 描述

| `@ResponseBody`
| 返回值通过 `HttpMessageWriter` 实现转换并写入响应. 请参阅 <<webflux-ann-responsebody>>.

| `HttpEntity<B>`, `ResponseEntity<B>`
| 指定完整响应(包括 HTTP 头和主体) 的返回值将通过 `HttpMessageWriter` 实现转换并写入响应. 请参阅 <<webflux-ann-responseentity>>.

| `HttpHeaders`
| 用于返回带头部信息且没有正文的响应.

| `String`
| 要使用 `ViewResolver` 实现解析的视图名称,并与隐式模型一起使用 - 通过命令对象和 `@ModelAttribute` 方法确定. 处理程序方法还可以通过声明 `Model` 参数(<<webflux-viewresolution-handling, 如上所述>>) 以编程方式丰富模型 

| `View`
| 用于与隐式模型一起呈现的 `View` 实例 - 通过命令对象和 `@ModelAttribute` 方法确定. 处理程序方法还可以通过声明 `Model` 参数(<<webflux-viewresolution-handling, 如上所述>>)以编程方式丰富模型.

| `java.util.Map`, `org.springframework.ui.Model`
| 要添加到隐式模型的属性,其中视图名称是根据请求路径隐式确定的.

| `@ModelAttribute`
| 要添加到模型的属性， 视图名称根据请求路径隐式确定.

  请注意 `@ModelAttribute` 是可选的. 参考此表后面的 "`Any other return value`" 

| `Rendering`
| 用于模型和视图渲染方案的 API.

| `void`
| 具有 `void` 返回类型的方法可能是异步的(例如, `Mono<Void>`) 的返回类型， 或返回值为 `null` 的方法(如果它还具有 ServerHttpResponse,ServerWebExchange 参数或 @ResponseStatus 注解) 则认为已完全处理该响应. 如果控制器已进行正 ETag 或 lastModified 进行时间戳检查,则也是如此
// TODO: See <<webflux-caching-etag-lastmodified>> for details.

如果以上条件都不成立， 则 `void` 返回类型还可以为 REST 控制器表示 "无响应正文"， 或者为 HTML 控制器表示默认视图名称选择.

| `Flux<ServerSentEvent>`, `Observable<ServerSentEvent>`, or other reactive type
| Emit server-sent events. The `ServerSentEvent` wrapper can be omitted when only data needs
  to be written (however, `text/event-stream` must be requested or declared in the mapping
  through the `produces` attribute).

| Any other return value
| 任何与此表中任何早期值不匹配且返回值为 `String` 或 `void` 的返回值都被视为视图名称 , 前提是它不是简单类型,由   {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty],
 确定,简单类型的值仍未解决.
|===


[[webflux-ann-typeconversion]]
==== 类型转换
[.small]#<<web.adoc#mvc-ann-typeconversion, Web MVC>>#

如果参数声明为 `String` 以外的其他参数,则表示某些带注解的控制器方法参数(例如 `@RequestParam`, `@RequestHeader`, `@PathVariable`, `@MatrixVariable`, 和 `@CookieValue`) 可能需要进行类型转换.

对于此类情况,将根据配置的转换器自动应用类型转换.  默认情况下,支持简单类型(`int`, `long`, `Date` 和其他) .  您可以通过 `WebDataBinder`(请参阅<<webflux-ann-initbinder>>) 或使用 `FormattingConversionService` 注册 `Formatters` 来自定义类型转换.  请参见 <<core.adoc#format, Spring Field Formatting>>.

类型转换中的一个实际问题是处理空的 String 值. 如果该值由于类型转换而变为 `null`， 则将其视为丢失. `Long`, `UUID`, 和其他目标类型.  如果要允许注入 `null`， 则可以在参数注解中使用 `required` 标志， 或将参数声明为 `@Nullable`.

[[webflux-ann-matrix-variables]]
==== 矩阵变量
[.small]#<<web.adoc#mvc-ann-matrix-variables, Web MVC>>#

https://tools.ietf.org/html/rfc3986#section-3.3[RFC 3986] 讨论了路径段中的携带键值对.  在 Spring MVC 中,我们将那些基于 Tim Berners-Lee 的 https://www.w3.org/DesignIssues/MatrixURIs.html["`old post`"] 称为 "`matrix variables(矩阵变量) `" ,但它们也可以称为 URI 路径参数.

矩阵变量可以在任意路径段落中出现,每对矩阵变量之间使用分号隔开,多个值可以用逗号隔开(例如,`/cars;color=red,green;year=2012`) , 也可以通过重复的变量名称指定多个值(例如,`color=red;color=green;color=blue`) .

与 Spring MVC 不同,在 WebFlux 中,URL 中是否存在矩阵变量不会影响请求映射. 换句话说,您不需要使用 URI 变量来屏蔽变量内容. 就是说,如果要从控制器方法访问矩阵变量,则需要将 URI 变量添加到期望矩阵变量的路径段中. 以下示例显示了如何执行此操作

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /pets/42;q=11;r=22

	@GetMapping("/pets/{petId}")
	public void findPet(@PathVariable String petId, @MatrixVariable int q) {

		// petId == 42
		// q == 11
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /pets/42;q=11;r=22

	@GetMapping("/pets/{petId}")
	fun findPet(@PathVariable petId: String, @MatrixVariable q: Int) {

		// petId == 42
		// q == 11
	}
----

由于任意路径段落中都可以含有矩阵变量,在某些场景下,开发者需要用更精确的信息来指定矩阵变量的位置. 以下示例说明如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /owners/42;q=11/pets/21;q=22

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public void findPet(
			@MatrixVariable(name="q", pathVar="ownerId") int q1,
			@MatrixVariable(name="q", pathVar="petId") int q2) {

		// q1 == 11
		// q2 == 22
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	fun findPet(
			@MatrixVariable(name = "q", pathVar = "ownerId") q1: Int,
			@MatrixVariable(name = "q", pathVar = "petId") q2: Int) {

		// q1 == 11
		// q2 == 22
	}
----

矩阵变量可以定义为可选,并指定默认值,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /pets/42

	@GetMapping("/pets/{petId}")
	public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {

		// q == 1
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /pets/42

	@GetMapping("/pets/{petId}")
	fun findPet(@MatrixVariable(required = false, defaultValue = "1") q: Int) {

		// q == 1
	}
----

要获取所有矩阵变量,可以使用 `MultiValueMap`,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public void findPet(
			@MatrixVariable MultiValueMap<String, String> matrixVars,
			@MatrixVariable(pathVar="petId") MultiValueMap<String, String> petMatrixVars) {

		// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
		// petMatrixVars: ["q" : 22, "s" : 23]
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	fun findPet(
			@MatrixVariable matrixVars: MultiValueMap<String, String>,
			@MatrixVariable(pathVar="petId") petMatrixVars: MultiValueMap<String, String>) {

		// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
		// petMatrixVars: ["q" : 22, "s" : 23]
	}
----


[[webflux-ann-requestparam]]
==== `@RequestParam`
[.small]#<<web.adoc#mvc-ann-requestparam, Web MVC>>#

您可以使用 `@RequestParam` 注解将请求参数绑定到控制器中的方法参数.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@RequestMapping("/pets")
	public class EditPetForm {

		// ...

		@GetMapping
		public String setupForm(@RequestParam("petId") int petId, Model model) { <1>
			Pet pet = this.clinic.loadPet(petId);
			model.addAttribute("pet", pet);
			return "petForm";
		}

		// ...
	}
----
<1> 使用 `@RequestParam`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.ui.set

	@Controller
	@RequestMapping("/pets")
	class EditPetForm {

		// ...

		@GetMapping
		fun setupForm(@RequestParam("petId") petId: Int, model: Model): String { // <1>
			val pet = clinic.loadPet(petId)
			model["pet"] = pet
			return "petForm"
		}

		// ...
	}
----
<1> 使用 `@RequestParam`.

TIP: Servlet API 的 "请求参数” 概念将查询参数,表单数据和多部分合并为一个. 但是,在 WebFlux 中,每个服务器都可以通过 `ServerWebExchange` 单独访问. 虽然 `@RequestParam` 仅绑定到查询参数,但是您可以使用数据绑定将查询参数, 表单数据和多部分应用到<<webflux-ann-modelattrib-method-args, command object>>.

若参数使用了该注解,则该参数默认是必须提供的.但您可以通过将 `@RequestParam` 注解的 `required` 属性设置为 `false` 或通过使用 `java.util.Optional` 包装器声明参数来指定方法参数是可选的.

如果目标方法参数类型不是 `String`,则会自动应用类型转换.  请参阅 <<webflux-ann-typeconversion>>.

当 `@RequestParam` 注解声明为 `Map<String, String>` 或 `MultiValueMap<String, String>` 时, 如果注解中未指定参数名称,则会使用每个给定参数名称的请求参数值填充映射.

请注意,使用 `@RequestParam` 是可选的(例如,设置其属性) .  默认情况下, 任何属于简单值类型的参数(由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty]) 确定 并且未被任何其他参数解析器解析,都被视为使用 `@RequestParam` 进行注解.

[[webflux-ann-requestheader]]
==== `@RequestHeader`
[.small]#<<web.adoc#mvc-ann-requestheader, Web MVC>>#


您可以使用 `@RequestHeader` 注解将请求头绑定到控制器中的方法参数.

考虑以下请求,请求头为:

[literal]
[subs="verbatim,quotes"]
----
Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300
----

以下示例获取 `Accept-Encoding` 和 `Keep-Alive` 头的值:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/demo")
	public void handle(
			@RequestHeader("Accept-Encoding") String encoding, // <1>
			@RequestHeader("Keep-Alive") long keepAlive) { // <2>
		//...
	}
----
<1> 获取 `Accept-Encoding` 头部信息
<2> 获取 `Keep-Alive` 头部信息.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/demo")
	fun handle(
			@RequestHeader("Accept-Encoding") encoding: String, // <1>
			@RequestHeader("Keep-Alive") keepAlive: Long) { // <2>
		//...
	}
----
<1> 获取 `Accept-Encoding` 头部信息
<2> 获取 `Keep-Alive` 头部信息.

如果目标方法参数类型不是 String,则会自动应用类型转换.  请参阅<<webflux-ann-typeconversion>>.

在 `Map<String, String>,MultiValueMap<String, String>` 或 `HttpHeaders` 参数上使用 `@RequestHeader` 注解时,将使用所有请求头值填充映射.

TIP: 内置支持可用于将逗号分隔的字符串转换为字符串或字符串集或类型转换系统已知的其他类型.  例如,使用 `@RequestHeader("Accept")` 注解的方法参数可以是 `String` 类型,也可以是 `String[]` 或 `List<String>`.

[[webflux-ann-cookievalue]]
==== `@CookieValue`
[.small]#<<web.adoc#mvc-ann-cookievalue, Web MVC>>#

您可以使用 `@CookieValue` 注解将 HTTP cookie 的值绑定到控制器中的方法参数.

考虑使用以下 cookie 的请求:

[literal,subs="verbatim,quotes"]
----
JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84
----

以下示例显示了如何获取 cookie 值:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/demo")
	public void handle(@CookieValue("JSESSIONID") String cookie) { // <1>
		//...
	}
----
<1> 获取 cookie 的值

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/demo")
	fun handle(@CookieValue("JSESSIONID") cookie: String) { // <1>
		//...
	}
----
<1> 获取 cookie 的值

如果目标方法参数类型不是 `String`,则会自动应用类型转换.  请参阅<<webflux-ann-typeconversion>>.

[[webflux-ann-modelattrib-method-args]]
==== `@ModelAttribute`
[.small]#<<web.adoc#mvc-ann-modelattrib-method-args, Web MVC>>#

您可以在方法参数上使用 `@ModelAttribute` 注解来从模型访问属性,或者如果不存在则将其实例化.  model 属性还覆盖了名称与字段名称匹配的请求参数和表单字段的值.  这称为数据绑定,它使您不必处理解析和转换单个查询参数和表单字段.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public String processSubmit(@ModelAttribute Pet pet) { } // <1>
----
<1> 绑定一个 `Pet` 的实例.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	fun processSubmit(@ModelAttribute pet: Pet): String { } // <1>
----
<1> 绑定一个 `Pet` 的实例.

上面的 `Pet` 实例解析如下:

* 它可能来自已经添加的<<webflux-ann-modelattrib-methods>>.
* 它可能因为 <<webflux-ann-sessionattributes>> 注解的使用已经存在在model中.
* 它可能是调用了自身的默认构造器被实例化出来的.
* 他可能从调用具有与请求参数或表单字段匹配的参数的 `"primary constructor"`.  参数名称通过 JavaBeans `@ConstructorProperties` 或字节码中的运行时保留参数名称确定.

下一步就是数据的绑定,`WebExchangeDataBinder` 类能将请求参数,包括字符串的查询参数和表单字段等,通过名称匹配到 model 的属性上.
成功匹配的字段在需要的时候会进行一次类型转换(从 String 类型到目标字段的类型) ,然后被填充到model对应的属性中, 有关数据绑定(和验证) 的更多信息,请参阅<<core.adoc#validation, Validation>>.  有关自定义数据绑定的更多信息,请参阅<<webflux-ann-initbinder>>.

数据绑定可能导致错误.  默认情况下,会引发 `WebExchangeBindException` .  但是,要在控制器方法中检查此类错误,可以在 `@ModelAttribute` 旁边添加一个 `BindingResult` 参数,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) { <1>
		if (result.hasErrors()) {
			return "petForm";
		}
		// ...
	}
----
<1> 添加一个 `BindingResult`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	fun processSubmit(@ModelAttribute("pet") pet: Pet, result: BindingResult): String { // <1>
		if (result.hasErrors()) {
			return "petForm"
		}
		// ...
	}
----
<1> 添加一个 `BindingResult`.

通过添加 `javax.validation.Valid` 注解或 Spring 的 `@Validated` 注解(<<core.adoc#validation-beanvalidation, Bean Validation>> 和<<core.adoc#validation, Spring validation>>) ,您可以在数据绑定后自动应用验证.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public String processSubmit(@Valid @ModelAttribute("pet") Pet pet, BindingResult result) { // <1>
		if (result.hasErrors()) {
			return "petForm";
		}
		// ...
	}
----
<1> 验证 `Pet` 实例.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	fun processSubmit(@Valid @ModelAttribute("pet") pet: Pet, result: BindingResult): String { // <1>
		if (result.hasErrors()) {
			return "petForm"
		}
		// ...
	}
----
<1> 验证 `Pet` 实例.

与 Spring MVC 不同,Spring WebFlux 支持模型中的响应类型,例如 `Mono<Account>` 或 `io.reactivex.Single<Account>`. 您可以声明一个 `@ModelAttribute` 参数,带或不带响应类型包装器,并将根据需要将其解析为实际值.
但是,请注意,要使用 `BindingResult` 参数,必须在 `@ModelAttribute` 参数之前声明 `@ModelAttribute` 参数,而不必使用响应类型包装器,如前所示. 另外,您可以通过响应式处理任何错误,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public Mono<String> processSubmit(@Valid @ModelAttribute("pet") Mono<Pet> petMono) {
		return petMono
			.flatMap(pet -> {
				// ...
			})
			.onErrorResume(ex -> {
				// ...
			});
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	fun processSubmit(@Valid @ModelAttribute("pet") petMono: Mono<Pet>): Mono<String> {
		return petMono
				.flatMap { pet ->
					// ...
				}
				.onErrorResume{ ex ->
					// ...
				}
	}
----

请注意,使用 `@ModelAttribute` 是可选的(例如,设置其属性) .  默认情况下,任何非简单值类型的参数(由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty]) 确定 并且未被任何其他参数解析器解析,都被视为使用 `@ModelAttribute` 进行注解.

[[webflux-ann-sessionattributes]]
==== `@SessionAttributes`
[.small]#<<web.adoc#mvc-ann-sessionattributes, Web MVC>>#

`@SessionAttributes` 用于在请求之间的 `WebSession`  中存储 model 属性.  它是一个类型级别的注解,用于声明特定控制器使用的会话属性.  这通常列出 model 属性的名称或 model 属性的类型,这些属性应该透明地存储在会话中以供后续访问请求使用.

以下示例使用 `@SessionAttributes` 注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@SessionAttributes("pet") <1>
	public class EditPetForm {
		// ...
	}
----
<1> 使用 `@SessionAttributes` 注解.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	@SessionAttributes("pet") // <1>
	class EditPetForm {
		// ...
	}
----
<1> 使用 `@SessionAttributes` 注解.

在第一个请求中,当名称为 `pet` 的 model 属性添加到模型中时,他会自动保存到 `WebSession` 会话中,并保持不变,直到另一个控制器方法使用 `SessionStatus` 方法参数来清除存储,如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@SessionAttributes("pet") // <1>
	public class EditPetForm {

		// ...

		@PostMapping("/pets/{id}")
		public String handle(Pet pet, BindingResult errors, SessionStatus status) { // <2>
			if (errors.hasErrors()) {
				// ...
			}
				status.setComplete();
				// ...
			}
		}
	}
----
<1> 使用 `@SessionAttributes` 注解.
<2> 使用一个 `SessionStatus` 变量.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	@SessionAttributes("pet") // <1>
	class EditPetForm {

		// ...

		@PostMapping("/pets/{id}")
		fun handle(pet: Pet, errors: BindingResult, status: SessionStatus): String { // <2>
			if (errors.hasErrors()) {
				// ...
			}
			status.setComplete()
			// ...
		}
	}
----
<1> 使用 `@SessionAttributes` 注解.
<2> 使用一个 `SessionStatus` 变量.


[[webflux-ann-sessionattribute]]
==== `@SessionAttribute`
[.small]#<<web.adoc#mvc-ann-sessionattribute, Web MVC>>#

如果需要访问已存在的被全局 session 属性,例如在控制器之外(如通过过滤器) 的(可有可无) ,请在方法参数上使用 `@SessionAttribute` 注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/")
	public String handle(@SessionAttribute User user) { // <1>
		// ...
	}
----
<1> 使用 `@SessionAttribute`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/")
	fun handle(@SessionAttribute user: User): String { // <1>
		// ...
	}
----
<1> 使用 `@SessionAttribute`.

对于需要添加或删除会话属性的用例,请考虑将 `WebSession`  注入控制器方法.

作为控制器工作流的一部分,在会话中临时存储模型属性的方法可以使用 `@SessionAttributes`,详情请参阅 <<webflux-ann-sessionattributes>>

[[webflux-ann-requestattrib]]
==== `@RequestAttribute`
[.small]#<<web.adoc#mvc-ann-requestattrib, Web MVC>>#

与 `@SessionAttribute` 类似,`@RequestAttribute` 注解可用于访问由过滤器( `WebFilter` )创建的已存在的请求属性:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/")
	public String handle(@RequestAttribute Client client) { <1>
		// ...
	}
----
<1> 使用 `@RequestAttribute`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/")
	fun handle(@RequestAttribute client: Client): String { // <1>
		// ...
	}
----
<1> 使用 `@RequestAttribute`.


[[webflux-multipart-forms]]
==== Multipart Content
[.small]#<<web.adoc#mvc-multipart-forms, Web MVC>>#


如 <<webflux-multipart>> 中所述,`ServerWebExchange` 提供对多部分内容的访问. 在控制器中处理文件上传表单(例如,从浏览器)的最佳方法是通过将数据绑定到 <<webflux-ann-modelattrib-method-args, command object>>,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	class MyForm {

		private String name;

		private MultipartFile file;

		// ...

	}

	@Controller
	public class FileUploadController {

		@PostMapping("/form")
		public String handleFormUpload(MyForm form, BindingResult errors) {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyForm(
			val name: String,
			val file: MultipartFile)

	@Controller
	class FileUploadController {

		@PostMapping("/form")
		fun handleFormUpload(form: MyForm, errors: BindingResult): String {
			// ...
		}

	}
----

您还可以在 RESTful 服务方案中从非浏览器客户端提交多部分请求. 以下示例将文件与 JSON 一起使用:

[literal,subs="verbatim,quotes"]
----
POST /someUrl
Content-Type: multipart/mixed

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="meta-data"
Content-Type: application/json; charset=UTF-8
Content-Transfer-Encoding: 8bit

{
	"name": "value"
}
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="file-data"; filename="file.properties"
Content-Type: text/xml
Content-Transfer-Encoding: 8bit
... File Data ...
----

您可以使用 `@RequestPart` 访问各个部分,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/")
	public String handle(@RequestPart("meta-data") Part metadata, // <1>
			@RequestPart("file-data") FilePart file) { // <2>
		// ...
	}
----
<1> 使用 `@RequestPart` 获取元数据.
<2> 使用 `@RequestPart` 获取文件

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/")
	fun handle(@RequestPart("meta-data") Part metadata, // <1>
			@RequestPart("file-data") FilePart file): String { // <2>
		// ...
	}
----
<1> 使用 `@RequestPart` 获取元数据.
<2> 使用 `@RequestPart` 获取文件

要反序列化的内容(例如,转换为JSON(类似于 `@RequestBody`)),可以声明一个具体的目标 `Object` 而不是 `Part`,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/")
	public String handle(@RequestPart("meta-data") MetaData metadata) { // <1>
		// ...
	}
----
<1> 使用 `@RequestPart` 获取元数据

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/")
	fun handle(@RequestPart("meta-data") metadata: MetaData): String { // <1>
		// ...
	}
----
<1> 使用 `@RequestPart` 获取元数据

您可以将 `@RequestPart` 与 `javax.validation.Valid` 结合使用,或使用Spring的 `@Validated` 注解,这两种注解都会导致应用标准 Bean 验证.
默认情况下,验证错误会导致 `WebExchangeBindException`, 并将其转换为 400(BAD_REQUEST) 响应.  或者,您可以通过 `BindingResult` 参数在控制器内本地处理验证错误,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/")
	public String handle(@Valid @RequestPart("meta-data") Mono<MetaData> metadata) {
		// use one of the onError* operators...
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/")
	fun handle(@Valid @RequestPart("meta-data") metadata: MetaData): String {
		// ...
	}
----

要将所有多部分数据作为 `MultiValueMap` 进行访问,可以使用 `@RequestBody`,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/")
	public String handle(@RequestBody Mono<MultiValueMap<String, Part>> parts) { // <1>
		// ...
	}
----
<1> 使用 `@RequestBody`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/")
	fun handle(@RequestBody parts: MultiValueMap<String, Part>): String { // <1>
		// ...
	}
----
<1> 使用 `@RequestBody`.

要以流方式顺序访问多部分数据,可以将 `@RequestBody` 与 `Flux<Part>`(或 Kotlin 中的 `Flow<Part>`)一起使用,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/")
	public String handle(@RequestBody Flux<Part> parts) { <1>
		// ...
	}
----
<1> 使用 `@RequestBody`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/")
	fun handle(@RequestBody parts: Flow<Part>): String { // <1>
		// ...
	}
----
<1> 使用 `@RequestBody`.


[[webflux-ann-requestbody]]
==== `@RequestBody`
[.small]#<<web.adoc#mvc-ann-requestbody, Web MVC>>#

您可以使用 `@RequestBody` 注解通过 <<webflux-codecs,HttpMessageReader>> 将请求主体读取并反序列化为 `Object`.  以下示例使用 `@RequestBody` 参数:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(@RequestBody Account account) {
		// ...
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(@RequestBody account: Account) {
		// ...
	}
----

与 Spring MVC 不同,在 WebFlux 中,`@RequestBody` 方法的参数支持响应类型. 以及完全无阻塞的阅读和(客户端到服务器)流式传输.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(@RequestBody Mono<Account> account) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(@RequestBody accounts: Flow<Account>) {
		// ...
	}
----

您可以使用 <<webflux-config>> 的 HTTP <<webflux-config-message-codecs>> 选项来配置或自定义消息阅读器.

您可以将 `@RequestBody` 与 `javax.validation.Valid` 或 Spring 的 `@Validated` 注解结合使用,这两种注解都会导致应用标准 Bean 验证.
默认情况下,验证错误会导致 `WebExchangeBindException`,并将其转换为 400(BAD_REQUEST) 响应.  或者,您可以通过 `BindingResult` 参数在控制器内本地处理验证错误,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(@Valid @RequestBody Mono<Account> account) {
		// use one of the onError* operators...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(@Valid @RequestBody account: Mono<Account>) {
		// ...
	}
----


[[webflux-ann-httpentity]]
==== `HttpEntity`
[.small]#<<web.adoc#mvc-ann-httpentity, Web MVC>>#

`HttpEntity` 与使用 <<webflux-ann-requestbody>> 或多或少有些类似,但它基于一个暴露请求头和正文的容器对象.  以下清单显示了一个示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(HttpEntity<Account> entity) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(entity: HttpEntity<Account>) {
		// ...
	}
----


[[webflux-ann-responsebody]]
==== `@ResponseBody`
[.small]#<<web.adoc#mvc-ann-responsebody, Web MVC>>#

您可以在方法上使用 `@ResponseBody` 注解,以通过 <<webflux-codecs, HttpMessageWriter>> 将返回序列化到响应主体.  以下清单显示了一个示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/accounts/{id}")
	@ResponseBody
	public Account handle() {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/accounts/{id}")
	@ResponseBody
	fun handle(): Account {
		// ...
	}
----

类级别也支持 `@ResponseBody` ,在这种情况下,它由所有控制器方法继承.  例如 `@RestController` 的效果,它只不过是一个用 `@Controller` 和 `@ResponseBody` 标记的元注解.

您可以将 `@ResponseBody` 与 reactive 类型一起使用.  这意味着您可以返回 Reactor 或 RxJava 类型,并将它们产生的异步值呈现给响应.有关更多详细信息,请参阅<<webflux-codecs-streaming>> 和 <<webflux-codecs-jackson,JSON rendering>>.

您可以将 `@ResponseBody` 方法与 JSON 序列化视图结合使用.  有关详细信息,请参阅 <<webflux-ann-jackson>>  .

您可以使用 <<webflux-config>> 的 HTTP  <<webflux-config-message-codecs>> 选项来配置或自定义消息编写.

[[webflux-ann-responseentity]]
==== `ResponseEntity`
[.small]#<<web.adoc#mvc-ann-responseentity, Web MVC>>#

`ResponseEntity` 与 <<webflux-ann-responsebody>> 类似,但具有状态和响应头.  例如:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/something")
	public ResponseEntity<String> handle() {
		String body = ... ;
		String etag = ... ;
		return ResponseEntity.ok().eTag(etag).build(body);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/something")
	fun handle(): ResponseEntity<String> {
		val body: String = ...
		val etag: String = ...
		return ResponseEntity.ok().eTag(etag).build(body)
	}
----

WebFlux 支持使用单值<<webflux-reactive-libraries, reactive type>>异步生成 `ResponseEntity`,and/or 主体的单值和多值 reactive 类型.

这允许使用 `ResponseEntity` 进行各种异步响应， 如下所示:

* `ResponseEntity<Mono<T>>` 或 `ResponseEntity<Flux<T>>` 可以立即获得响应状态和响应头,而在稍后以异步方式提供正文时.
如果主体包含 0..1 个值, 请使用 `Mono`,如果主体可以产生多个值,请使用 `Flux`.
* `Mono<ResponseEntity<T>>` 在稍后的时间异步提供所有的 -- response status, headers, 和 body. 这允许响应状态和响应头根据异步请求处理的结果而变化.
* `Mono<ResponseEntity<Mono<T>>>` 或 `Mono<ResponseEntity<Flux<T>>>` 是另一种可能的方法， 但是不太常见. 它们首先异步地提供响应状态和响应头， 然后第二次异步地提供响应主体.

[[webflux-ann-jackson]]
==== Jackson JSON

Spring 为 Jackson JSON 库提供支持.

[[webflux-ann-jsonview]]
===== JSON 序列化视图
[.small]#<<web.adoc#mvc-ann-jackson, Web MVC>>#

Spring WebFlux 为 https://www.baeldung.com/jackson-json-view-annotation[Jackson的序列化视图]提供内置支持,允许仅渲染 Object 中所有字段的子集.  为了与 `@ResponseBody` 控制器方法或者返回 `ResponseEntity` 的控制器方法一起使用,可以简单地将 `@JsonView` 注解放在参数上,指定需要使用的视图类或接口即可. 如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RestController
	public class UserController {

		@GetMapping("/user")
		@JsonView(User.WithoutPasswordView.class)
		public User getUser() {
			return new User("eric", "7!jd#h23");
		}
	}

	public class User {

		public interface WithoutPasswordView {};
		public interface WithPasswordView extends WithoutPasswordView {};

		private String username;
		private String password;

		public User() {
		}

		public User(String username, String password) {
			this.username = username;
			this.password = password;
		}

		@JsonView(WithoutPasswordView.class)
		public String getUsername() {
			return this.username;
		}

		@JsonView(WithPasswordView.class)
		public String getPassword() {
			return this.password;
		}
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RestController
	class UserController {

		@GetMapping("/user")
		@JsonView(User.WithoutPasswordView::class)
		fun getUser(): User {
			return User("eric", "7!jd#h23")
		}
	}

	class User(
			@JsonView(WithoutPasswordView::class) val username: String,
			@JsonView(WithPasswordView::class) val password: String
	) {
		interface WithoutPasswordView
		interface WithPasswordView : WithoutPasswordView
	}
----

NOTE: `@JsonView` 允许一组视图类,但每个控制器方法只能指定一个.  如果需要激活多个视图,可以使用复合接口.

[[webflux-ann-modelattrib-methods]]
=== `Model`
[.small]#<<web.adoc#mvc-ann-modelattrib-methods, Web MVC>>#

您可以使用 `@ModelAttribute` 注解:

* 在 `@RequestMapping` 方法中的<<webflux-ann-modelattrib-method-args,方法参数>>,用于从 `model` 创建或访问 Object 并通过 `WebDataBinder` 将其绑定到请求.
* 作为 `@Controller` 或 `@ControllerAdvice` 类中的方法级注解,有助于在任何 `@RequestMapping` 方法调用之前初始化模型.
* 在 `@RequestMapping` 方法上标记其返回值是一个模型属性.

本节讨论 `@ModelAttribute` 注解可被应用在方法或方法参数上 - 前面列表中的第二项. 控制器可以包含任意数量的 `@ModelAttribute` 方法.
在同一控制器中的 `@RequestMapping` 方法之前调用所有这些方法.  `@ModelAttribute` 方法也可以通过 `@ControllerAdvice` 在控制器之间共享.  有关更多详细信息,请参阅 <<webflux-ann-controller-advice>> 部分.

`@ModelAttribute` 方法具有灵活的方法签名.  除了与 `@ModelAttribute` 本身或请求体相关的任何内容外,它们支持许多与 `@RequestMapping` 方法相同的参数.

以下示例显示了 `@ModelAttribute` 方法:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ModelAttribute
	public void populateModel(@RequestParam String number, Model model) {
		model.addAttribute(accountRepository.findAccount(number));
		// add more ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ModelAttribute
	fun populateModel(@RequestParam number: String, model: Model) {
		model.addAttribute(accountRepository.findAccount(number))
		// add more ...
	}
----

以下示例仅添加一个属性:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ModelAttribute
	public Account addAccount(@RequestParam String number) {
		return accountRepository.findAccount(number);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ModelAttribute
	fun addAccount(@RequestParam number: String): Account {
		return accountRepository.findAccount(number);
	}
----

NOTE: 如果未明确指定名称,框架将根据属性的类型给予一个默认名称,如 {api-spring-framework}/core/Conventions.html[`Conventions`] 的 javadoc 中所述.  你可以通过设置 `@ModelAttribute` 注解的值来改变默认值. 当向 `Model` 中直接添加属性时,请使用合适的重载方法 `addAttribute`.

与 Spring MVC 不同,Spring WebFlux 在模型中显式支持响应式类型(例如 `Mono<Account>` 或 `io.reactivex.Single<Account>`). 可以在 `@RequestMapping` 调用时将此类异步模型属性透明地解析(并更新模型)为其实际值,前提是声明了 `@ModelAttribute` 参数而没有包装,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ModelAttribute
	public void addAccount(@RequestParam String number) {
	    Mono<Account> accountMono = accountRepository.findAccount(number);
	    model.addAttribute("account", accountMono);
	}

	@PostMapping("/accounts")
	public String handle(@ModelAttribute Account account, BindingResult errors) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.ui.set

	@ModelAttribute
	fun addAccount(@RequestParam number: String) {
		val accountMono: Mono<Account> = accountRepository.findAccount(number)
		model["account"] = accountMono
	}

	@PostMapping("/accounts")
	fun handle(@ModelAttribute account: Account, errors: BindingResult): String {
		// ...
	}
----

另外,任何具有响应性类型包装器的模型属性都将在视图渲染之前解析为其实际值(并更新了模型).

`@ModelAttribute` 注解也可以被用在 `@RequestMapping` 方法上,这种情况下,`@RequestMapping` 方法的返回值将会被解释为 model 的一个属性,而非一个视图名.  此时视图名将以视图命名约定来方式来决议,与返回值为 `void` 的方法所采用的处理方法类似. `@ModelAttribute` 还可以自定义模型属性名称,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/accounts/{id}")
	@ModelAttribute("myAccount")
	public Account handle() {
		// ...
		return account;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/accounts/{id}")
	@ModelAttribute("myAccount")
	fun handle(): Account {
		// ...
		return account
	}
----



[[webflux-ann-initbinder]]
=== `DataBinder`
[.small]#<<web.adoc#mvc-ann-initbinder, Web MVC>>#


`@Controller` 或 `@ControllerAdvice` 类可以使用 `@InitBinder` 方法初始化 `WebDataBinder` 的实例,而这些方法又可以:


* 将请求参数(即表单或查询数据) 绑定到模型对象.
* 将基于字符串的请求值(例如请求参数,路径变量,请求头,cookie 等) 转换为目标类型的控制器方法参数.
* 在呈现HTML表单时将模型对象值格式化为 `String` 值.

`@InitBinder` 方法可以注册特定于控制器的 `java.beans.PropertyEditor` 或Spring `Converter` 和 `Formatter` 组件.  此外,您可以使用<<webflux-config-conversion,WebFlux Java configuration>> 在全局共享的 `FormattingConversionService` 中注册 `Converter` 和 `Formatter` 类型.

`@InitBinder` 方法支持许多与 `@RequestMapping` 方法相同的参数,但 `@ModelAttribute`(命令对象) 参数除外.  通常,它们使用 `WebDataBinder` 参数(用于注册) 和 `void` 返回值进行声明.  以下清单显示了一个示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class FormController {

		@InitBinder // <1>
		public void initBinder(WebDataBinder binder) {
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
			dateFormat.setLenient(false);
			binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
		}

		// ...
	}
----
<1> 使用 `@InitBinder` 注解.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class FormController {

		@InitBinder // <1>
		fun initBinder(binder: WebDataBinder) {
			val dateFormat = SimpleDateFormat("yyyy-MM-dd")
			dateFormat.isLenient = false
			binder.registerCustomEditor(Date::class.java, CustomDateEditor(dateFormat, false))
		}

		// ...
	}
----

或者,当使用基于 `Formatter` 的设置时,您可以通过共享的 `FormattingConversionService` 重复使用相同的方法并注册特定于控制器的 `Formatter` 实现,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class FormController {

		@InitBinder
		protected void initBinder(WebDataBinder binder) {
			binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd")); <1>
		}

		// ...
	}
----
<1> 添加一个自定义 formatter ( 本例中为 `DateFormatter`).

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class FormController {

		@InitBinder
		fun initBinder(binder: WebDataBinder) {
			binder.addCustomFormatter(DateFormatter("yyyy-MM-dd")) // <1>
		}

		// ...
	}
----
<1> 添加一个自定义 formatter ( 本例中为 `DateFormatter`).


[[webflux-ann-initbinder-model-design]]
==== Model Design
[.small]#<<web.adoc#mvc-ann-initbinder-model-design, Web MVC>>#

include::web-data-binding-model-design.adoc[]


[[webflux-ann-controller-exceptions]]
=== 异常
[.small]#<<web.adoc#mvc-ann-exceptionhandler, Web MVC>>#

`@Controller` 和 <<webflux-ann-controller-advice, @ControllerAdvice>> 可以使用 `@ExceptionHandler` 方法来处理来自控制器方法的异常,如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class SimpleController {

		// ...

		@ExceptionHandler // <1>
		public ResponseEntity<String> handle(IOException ex) {
			// ...
		}
	}
----
<1> 声明一个 `@ExceptionHandler`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class SimpleController {

		// ...

		@ExceptionHandler // <1>
		fun handle(ex: IOException): ResponseEntity<String> {
			// ...
		}
	}
----
<1> 声明一个 `@ExceptionHandler`.

该异常可能与顶级异常(即抛出直接 `IOException`) 或顶级包装器中的异常(例如,包含在 `IllegalStateException` 内的 `IOException`) 相匹配.

对于匹配的异常类型,最好将目标异常声明为方法参数,如前面的示例所示. 或者,注解声明可以缩小要匹配的异常类型. 我们通常建议在参数签名中尽可能具体,并在以相应顺序优先的 `@ControllerAdvice` 上声明您的 root 异常映射. 有关详细信息,请参见 <<web.adoc#mvc-ann-exceptionhandler, MVC 部分>> .

NOTE: WebFlux 中的 `@ExceptionHandler` 方法支持与 `@RequestMapping` 方法相同的方法参数和返回值,但与请求正文和 `@ModelAttribute` 相关的方法参数除外.

`HandlerAdapter` 为 `@RequestMapping` 方法提供了对 Spring WebFlux 中 `@ExceptionHandler` 方法的支持. 有关更多详细信息,请参见  <<webflux-dispatcher-handler>>

[[webflux-ann-rest-exceptions]]
==== REST API exceptions
[.small]#<<web.adoc#mvc-ann-rest-exceptions, Web MVC>>#

REST 服务的一个常见要求是在响应正文中包含错误详细信息.  Spring Framework 不会自动执行此操作,因为响应正文中的错误详细信息的表示是特定于应用程序的.  但是,`@RestController` 可以使用带有 `ResponseEntity` 返回值的 `@ExceptionHandler` 方法来设置响应的状态和正文.  这些方法也可以在 `@ControllerAdvice` 类中声明,以全局应用它们.

NOTE: 请注意,Spring WebFlux 与 Spring MVC `ResponseEntityExceptionHandler` 没有等效项,因为 WebFlux 仅引发 `ResponseStatusException`(或其子类),并且不需要将其转换为 HTTP 状态代码.

[[webflux-ann-controller-advice]]
=== Controller Advice
[.small]#<<web.adoc#mvc-ann-controller-advice, Web MVC>>#

通常,在 `@Controller` 类上声明 `@ExceptionHandler`, `@InitBinder`, 和 `@ModelAttribute` 注解.  如果您希望此类方法更全局地应用(跨控制器) ,则可以在标有 `@ControllerAdvice` 或 `@RestControllerAdvice` 的类中声明它们.

`@ControllerAdvice` `@Component` 注解,这意味着可以通过组件扫描将这些类注册为 Spring bean.  `@RestControllerAdvice` 也是一个用 `@ControllerAdvice` 和 `@ResponseBody` 标记的元注解,这实际上意味着 `@ExceptionHandler` 方法通过消息转换(与视图解析或模板渲染相对) 呈现给响应主体.

在启动时, `@RequestMapping` 和 `@ExceptionHandler` 方法的基础结构类检测 `@ControllerAdvice` 类型的 Spring bean,然后在运行时应用它们的方法.
全局 `@ExceptionHandler` 方法(来自 `@ControllerAdvice`) 在本地方法之后(来自 `@Controller`) 应用.  相比之下,全局 `@ModelAttribute` 和 `@InitBinder` 方法在本地方法之前应用.

默认情况下,`@ControllerAdvice` 方法适用于每个请求(即所有控制器) ,但您可以通过使用注解上的属性将其缩小到控制器的子集,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Target all Controllers annotated with @RestController
	@ControllerAdvice(annotations = RestController.class)
	public class ExampleAdvice1 {}

	// Target all Controllers within specific packages
	@ControllerAdvice("org.example.controllers")
	public class ExampleAdvice2 {}

	// Target all Controllers assignable to specific classes
	@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
	public class ExampleAdvice3 {}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Target all Controllers annotated with @RestController
	@ControllerAdvice(annotations = [RestController::class])
	public class ExampleAdvice1 {}

	// Target all Controllers within specific packages
	@ControllerAdvice("org.example.controllers")
	public class ExampleAdvice2 {}

	// Target all Controllers assignable to specific classes
	@ControllerAdvice(assignableTypes = [ControllerInterface::class, AbstractController::class])
	public class ExampleAdvice3 {}
----

前面示例中的选择器在运行时进行评估,如果广泛使用,可能会对性能产生负面影响. 有关更多详细信息,请参阅 {api-spring-framework}/web/bind/annotation/ControllerAdvice.html[`@ControllerAdvice`] javadoc .

include::webflux-functional.adoc[leveloffset=+1]

[[webflux-uri-building]]
== URI 链接
[.small]#<<web.adoc#mvc-uri-building, Web MVC>>#

本部分介绍了 Spring 框架中可用于 URI 的各种选项.

include::webflux/web-uris.adoc[leveloffset=+2]

include::webflux-cors.adoc[leveloffset=+1]

[[webflux-web-security]]
== Web Security
[.small]#<<web.adoc#mvc-web-security, Web MVC>>#

https://spring.io/projects/spring-security[Spring Security] 项目为保护 Web 应用程序免受恶意攻击提供支持.请参阅 Spring Security 参考文档,包括:

* {doc-spring-security}/reactive/configuration/webflux.html[WebFlux Security]
* {doc-spring-security}/reactive/test/index.html[WebFlux Testing Support]
* {doc-spring-security}/features/exploits/csrf.html#csrf-protection[CSRF protection]
* {doc-spring-security}/features/exploits/headers.html[Security Response Headers]

include::webflux-view.adoc[leveloffset=+1]

[[webflux-caching]]
== HTTP 缓存
[.small]#<<web.adoc#mvc-caching, Web MVC>>#

HTTP 缓存可以显着提高 Web 应用程序的性能. HTTP缓存围绕 `Cache-Control` 响应头,随后是条件请求头(例如 `Last-Modified` 和 `ETag`) .  HTTP的响应头 `Cache-Control` 主要帮助私有缓存(比如浏览器端缓存) 和公共缓存(比如代理端缓存) 了解它们应该如果缓存HTTP响应.
如果内容未更改,则 `ETag` 头用于生成条件请求, 该条件请求可能导致 304 (NOT_MODIFIED)  没有正文. 可以认为它是 `Last-Modified` 头的一个更精细的后续版本.

本节介绍 Spring WebFlux 中可用的与HTTP缓存相关的选项.

[[webflux-caching-cachecontrol]]
=== `CacheControl`
[.small]#<<web.adoc#mvc-caching-cachecontrol, Web MVC>>#

{api-spring-framework}/http/CacheControl.html[`CacheControl`] 支持配置与 `Cache-Control` 头相关的设置,并在许多地方被接受为参数:

* <<webflux-caching-etag-lastmodified>>
* <<webflux-caching-static-resources>>

虽然 https://tools.ietf.org/html/rfc7234#section-5.2.2[RFC 7234] 描述了 `Cache-Control` 响应头的所有可能的指令,但 `CacheControl` 类型采用面向用例的方法,该方法侧重于常见场景:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Cache for an hour - "Cache-Control: max-age=3600"
	CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);

	// Prevent caching - "Cache-Control: no-store"
	CacheControl ccNoStore = CacheControl.noStore();

	// Cache for ten days in public and private caches,
	// public caches should not transform the response
	// "Cache-Control: max-age=864000, public, no-transform"
	CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Cache for an hour - "Cache-Control: max-age=3600"
	val ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS)

	// Prevent caching - "Cache-Control: no-store"
	val ccNoStore = CacheControl.noStore()

	// Cache for ten days in public and private caches,
	// public caches should not transform the response
	// "Cache-Control: max-age=864000, public, no-transform"
	val ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic()

----

[[webflux-caching-etag-lastmodified]]
=== Controllers
[.small]#<<web.adoc#mvc-caching-etag-lastmodified, Web MVC>>#

控制器可以添加对 HTTP 缓存的显式支持.  我们建议这样做,因为资源的 `lastModified` 或 `ETag` 值需要先计算才能与条件请求头进行比较.  控制器可以向 `ResponseEntity` 添加 `ETag` 头和 `Cache-Control` 设置,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/book/{id}")
	public ResponseEntity<Book> showBook(@PathVariable Long id) {

		Book book = findBook(id);
		String version = book.getVersion();

		return ResponseEntity
				.ok()
				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
				.eTag(version) // lastModified is also available
				.body(book);
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/book/{id}")
	fun showBook(@PathVariable id: Long): ResponseEntity<Book> {

		val book = findBook(id)
		val version = book.getVersion()

		return ResponseEntity
				.ok()
				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
				.eTag(version) // lastModified is also available
				.body(book)
	}
----

如果与条件请求头的比较表明内容未更改,则前面的示例发送带有空响应体的 304 (NOT_MODIFIED) 响应.  否则,`ETag` 和 `Cache-Control` 头将添加到响应中.

您还可以对控制器中的条件请求头进行检查,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RequestMapping
	public String myHandleMethod(ServerWebExchange exchange, Model model) {

		long eTag = ... // <1>

		if (exchange.checkNotModified(eTag)) {
			return null; // <2>
		}

		model.addAttribute(...); // <3>
		return "myViewName";
	}
----
<1> 特定于应用的计算.
<2> 响应已设置为 304(NOT_MODIFIED)  - 无需进一步处理.
<3> 继续请求处理.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RequestMapping
	fun myHandleMethod(exchange: ServerWebExchange, model: Model): String? {

		val eTag: Long = ... // <1>

		if (exchange.checkNotModified(eTag)) {
			return null// <2>
		}

		model.addAttribute(...) // <3>
		return "myViewName"
	}
----
<1> 特定于应用的计算.
<2> 响应已设置为 304(NOT_MODIFIED)  - 无需进一步处理.
<3> 继续请求处理.

有三种变体可用于检查针对 `eTag` 值,`lastModified` 值或两者的条件请求.  对于条件 `GET` 和 `HEAD` 请求, 您可以将响应设置为 304 (NOT_MODIFIED) . 对于 `POST`, `PUT`, 和 `DELETE`,您可以将响应设置为 412 (PRECONDITION_FAILED) ,以防止并发修改.

[[webflux-caching-static-resources]]
=== 静态资源
[.small]#<<web.adoc#mvc-caching-static-resources, Web MVC>>#

您应该使用 `Cache-Control` 和条件响应头来提供静态资源,以获得最佳性能.  请参阅有关<<webflux-config-static-resources>>的部分.

[[webflux-config]]
== WebFlux 配置
[.small]#<<web.adoc#mvc-config, Web MVC>>#

WebFlux Java 配置提供了适用于大多数应用程序的默认配置以及配置 API 来对其进行自定义. 这意味您无需了解 Java 配置创建的基础 bean.
如果您想了解更多信息,请参阅 `WebFluxConfigurationSupport` 中查看它们,或者阅读有关<<webflux-special-bean-types>>中内容的更多信息.

有关配置API中没有的高级自定义设置请参阅 <<webflux-config-advanced-java>>.

[[webflux-config-enable]]
=== 启用 WebFlux 配置
[.small]#<<web.adoc#mvc-config-enable, Web MVC>>#

在 Java 配置中,您可以使用 `@EnableWebFlux` 注解启用 MVC 配置,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig {
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig
----

前面的示例注册了许多 Spring MVC <<webflux-special-bean-types, 基础结构的 beans>>,并适应类路径上可用的依赖(例如,JSON,XML 等的有效负载转换器) .

[[webflux-config-customize]]
=== WebFlux config API
[.small]#<<web.adoc#mvc-config-customize, Web MVC>>#

在 Java 配置中,您可以实现 `WebFluxConfigurer` 接口, 如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		// Implement configuration methods...
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Configuration
@EnableWebFlux
class WebConfig : WebFluxConfigurer {

	// Implement configuration methods...
}
----

[[webflux-config-conversion]]
=== 转换,格式化
[.small]#<<web.adoc#mvc-config-conversion, Web MVC>>#

默认情况下,将安装各种数字和日期类型的格式化程序以及支持通过字段上的 `@NumberFormat` 和 `@DateTimeFormat` 进行定制.

在 Java 配置中,您可以注册自定义格式化程序和转换器,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public void addFormatters(FormatterRegistry registry) {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun addFormatters(registry: FormatterRegistry) {
			// ...
		}
	}
----

默认情况下,Spring MVC 在解析和格式化日期值时会考虑请求区域设置.  这适用于使用  "input" 日期表示为字符串的表单.
但是,对于  "date" 和 "time" 表单字段,浏览器使用 HTML 规范中定义的固定格式.  在这种情况下,日期和时间格式可以按以下方式自定义:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public void addFormatters(FormatterRegistry registry) {
			DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
			registrar.setUseIsoFormat(true);
			registrar.registerFormatters(registry);
      	}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun addFormatters(registry: FormatterRegistry) {
			val registrar = DateTimeFormatterRegistrar()
			registrar.setUseIsoFormat(true)
			registrar.registerFormatters(registry)
		}
	}
----

NOTE: 有关何时使用<<core.adoc#format-FormatterRegistrar-SPI, `FormatterRegistrar` SPI>>实现的更多信息,请参阅 `FormatterRegistrar` SPI和 `FormattingConversionServiceFactoryBean`.

[[webflux-config-validation]]
=== 验证
[.small]#<<webmvc.adoc#mvc-config-validation, Web MVC>>#


默认情况下,如果类路径上存在<<core.adoc#validation-beanvalidation-overview, Bean Validation>> (例如Hibernate Validator) ,则 `LocalValidatorFactoryBean` 将注册为全局 <<core.adoc#validator,validator>> .  以便与 `@Valid` 和 `Validated` 一起使用并在控制器方法参数上进行验证.

在 Java 配置中,您可以自定义全局 `Validator` 实例,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public Validator getValidator() {
			// ...
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun getValidator(): Validator {
			// ...
		}

	}
----

请注意,您还可以在本地注册 `Validator` 实现,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class MyController {

		@InitBinder
		protected void initBinder(WebDataBinder binder) {
			binder.addValidators(new FooValidator());
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class MyController {

		@InitBinder
		protected fun initBinder(binder: WebDataBinder) {
			binder.addValidators(FooValidator())
		}
	}
----


TIP: 如果需要在某处注入 `LocalValidatorFactoryBean`,请创建一个 bean 并使用 `@Primary` 标记它,以避免与 MVC 配置中声明的那个冲突.

[[webflux-config-content-negotiation]]
=== 内容类型解析器
[.small]#<<web.adoc#mvc-config-content-negotiation, Web MVC>>#

您可以配置 Spring WebFlux 如何根据请求确定 `@Controller` 实例的请求媒体类型.(默认情况下,仅选中 `Accept` 头) .但您也可以启用基于查询参数的策略.

以下示例显示如何自定义请求的内容类型解析:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun configureContentTypeResolver(builder: RequestedContentTypeResolverBuilder) {
			// ...
		}
	}
----

[[webflux-config-message-codecs]]
=== HTTP 消息编解码器
[.small]#<<web.adoc#mvc-config-message-converters, Web MVC>>#

以下示例显示如何自定义读取和写入请求和响应主体的方式:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun configureHttpMessageCodecs(configurer: ServerCodecConfigurer) {
			// ...
		}
	}
----

`ServerCodecConfigurer` 提供了一组默认的读取器和写入器. 您可以使用它来添加更多读取器和写入器,自定义默认读取器或完全替换默认读取器和写入器.

对于 Jackson JSON 和 XML,请考虑使用 {api-spring-framework}/http/converter/json/Jackson2ObjectMapperBuilder.html[`Jackson2ObjectMapperBuilder`],该工具使用以下属性自定义 Jackson 的默认属性:

* https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES[`DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES`] 被禁用.
* https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION[`MapperFeature.DEFAULT_VIEW_INCLUSION`] 被禁用.

同时,如果检测到在 classpath 路径下存在这些模块,也会自动地注册它们.

* https://github.com/FasterXML/jackson-datatype-joda[jackson-datatype-joda]: 支持Joda-Time类型.
* https://github.com/FasterXML/jackson-datatype-jsr310[jackson-datatype-jsr310]: 支持Java 8日期和时间API类型.
* https://github.com/FasterXML/jackson-datatype-jdk8[jackson-datatype-jdk8]: 支持其他Java 8类型,例如 `Optional`.
* https://github.com/FasterXML/jackson-module-kotlin[`jackson-module-kotlin`]: 支持Kotlin类和数据类.



[[webflux-config-view-resolvers]]
=== 视图解析
[.small]#<<web.adoc#mvc-config-view-resolvers, Web MVC>>#

下面的示例显示如何配置视图解析:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			// ...
		}
	}
----

`ViewResolverRegistry` 具有与 Spring Framework 集成的视图技术的快捷方式. 以下示例使用 FreeMarker(这也需要配置基础 FreeMarker 视图技术):

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {


		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.freeMarker();
		}

		// Configure Freemarker...

		@Bean
		public FreeMarkerConfigurer freeMarkerConfigurer() {
			FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
			configurer.setTemplateLoaderPath("classpath:/templates");
			return configurer;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {
		
		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			registry.freeMarker()
		}

		// Configure Freemarker...

		@Bean
		fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply {
			setTemplateLoaderPath("classpath:/templates")
		}
	}
----

您还可以插入任何 `ViewResolver` 实现,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {


		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			ViewResolver resolver = ... ;
			registry.viewResolver(resolver);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			val resolver: ViewResolver = ...
			registry.viewResolver(resolver
		}
	}
----

为了支持 <<webflux-multiple-representations>> 并通过视图解析(除 HTML 之外)呈现其他格式,您可以基于 `HttpMessageWriterView` 实现配置一个或多个默认视图,该实现接受 `spring-web` 中任何可用的<<webflux-codecs>>. 以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {


		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.freeMarker();

			Jackson2JsonEncoder encoder = new Jackson2JsonEncoder();
			registry.defaultViews(new HttpMessageWriterView(encoder));
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {


		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			registry.freeMarker()

			val encoder = Jackson2JsonEncoder()
			registry.defaultViews(HttpMessageWriterView(encoder))
		}

		// ...
	}
----

有关与 Spring WebFlux 集成的视图技术的更多信息,请参见 <<webflux-view>> .

[[webflux-config-static-resources]]
=== 静态资源
[.small]#<<web.adoc#mvc-config-static-resources, Web MVC>>#

此选项提供了一种从 {api-spring-framework}/core/io/Resource.html[`Resource`] 库位置列表中使用静态资源的便捷方法

在下面的示例中,给定以 `/resources` 开头的请求,相对路径用于在 Web 应用程序根目录下或在或在 `/static` 下的类路径上查找静态资源.  资源的有效期为 1 年,以确保最大程度地使用浏览器缓存,并减少浏览器发出的 HTTP 请求. 如果返回 304 状态代码,`Last-Modified` 头也会计算到.

以下清单显示了如何使用 Java 配置执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public", "classpath:/static/")
					.setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS));
		}

	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public", "classpath:/static/")
					.setCacheControl(CacheControl.maxAge(365, TimeUnit.DAYS))
		}
	}
----

// TODO: See also <<webflux-caching-static-resources, HTTP caching support for static resources>>.

资源处理还支持一系列 {api-spring-framework}/web/servlet/resource/ResourceResolver.html[`ResourceResolver`]  实现 和 {api-spring-framework}/web/servlet/resource/ResourceTransformer.html[`ResourceTransformer`]  实现, 可用于创建用于使用优化资源的工具

`VersionResourceResolver` 可用于基于内容、固定应用程序版本或其他的 MD5 哈希计算的版本化资源url. `ContentVersionStrategy`(MD5 hash)方法是一个很好的选择, 有一些值得注意的例外,例如与模块加载器一起使用的 JavaScript 资源.

以下示例显示如何在Java配置中使用 `VersionResourceResolver`:

[source,java,indent=0,subs="verbatim",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public/")
					.resourceChain(true)
					.addResolver(new VersionResourceResolver().addContentVersionStrategy("/**"));
		}

	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public/")
					.resourceChain(true)
					.addResolver(VersionResourceResolver().addContentVersionStrategy("/**"))
		}

	}
----

您可以使用 `ResourceUrlProvider` 来重写 URL 并应用完整的解析器和转换器链,例如插入版本. MVC 配置提供了 `ResourceUrlProvider` bean,因此可以将其注入到其他用户.  您还可以使用 `ResourceUrlEncodingFilter` 的 Thymeleaf、jsp、FreeMarker 和其他依赖于 `HttpServletResponse#encodeURL` 的 URL 标记来做重写转换.

与 Spring MVC 不同，目前在 WebFlux 中，没有办法透明地重写静态资源 URL，因为没有视图技术可以解析和转换非阻塞链。仅提供本地资源时，解决方法是直接使用 `ResourceUrlProvider`（例如，通过自定义元素）并阻止。

请注意,当同时使用 `EncodedResourceResolver`(例如,用于提供 gzipped 或 brotli 编码的资源) 和 `VersionedResourceResolver` 时,必须按此顺序注册它们.  这可确保始终基于未编码的文件可靠地计算基于内容的版本.

https://www.webjars.org/documentation[WebJars] 也支持使用 `WebJarsResourceResolver` 和自动注册,当 `org.webjars:webjars-locator` 存在于类路径中时. 解析器可以重写 URL 来包含 jar 的版本,也可以与传入的 URL 匹配,而不需要版本 .  例如, `/jquery/jquery.min.js` 到 `/jquery/1.2.0/jquery.min.js`.

TIP: 基于 `ResourceHandlerRegistry` 的 Java 配置提供了更多选项用于细粒度控制，例如，最后修改的行为和优化的资源解析。


[[webflux-config-path-matching]]
=== 路径匹配
[.small]#<<web.adoc#mvc-config-path-matching, Web MVC>>#

您可以自定义与路径匹配和 URL 处理相关的选项.  有关各个选项的详细信息,请参阅 {api-spring-framework}/web/servlet/config/annotation/PathMatchConfigurer.html[`PathMatchConfigurer`]  javadoc.

以下示例显示如何在 Java 配置 `PathMatchConfigurer`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public void configurePathMatch(PathMatchConfigurer configurer) {
			configurer
				.setUseCaseSensitiveMatch(true)
				.setUseTrailingSlashMatch(false)
				.addPathPrefix("/api",
						HandlerTypePredicate.forAnnotation(RestController.class));
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		@Override
		fun configurePathMatch(configurer: PathMatchConfigurer) {
			configurer
				.setUseCaseSensitiveMatch(true)
				.setUseTrailingSlashMatch(false)
				.addPathPrefix("/api",
						HandlerTypePredicate.forAnnotation(RestController::class.java))
		}
	}
----

[TIP]
====
Spring WebFlux 依赖于请求路径的解析表示形式来访问解码的路径段值,该请求路径称为 `RequestPath`,并且去除了分号内容(即路径或矩阵变量). 这意味着,与 Spring MVC 不同,您无需指示是否解码请求路径,也无需指示是否出于路径匹配目的而删除分号内容.

Spring WebFlux 也不支持后缀模式匹配,这与 Spring MVC 不同,在 Spring MVC 中,我们也  <<web.adoc#mvc-ann-requestmapping-suffix-pattern-match, 建议>>不要依赖它.
====



[[webflux-config-websocket-service]]
=== WebSocketService

WebFlux Java 配置声明了一个 `WebSocketHandlerAdapter` bean， 它为调用 `WebSocket` 处理程序提供了支持.  这意味着要处理 `WebSocket` 握手请求， 剩下要做的就是通过 `SimpleUrlHandlerMapping` 将 `WebSocketHandler` 映射到 URL.

在某些情况下， 可能需要使用提供的 `WebSocketService` 服务创建 `WebSocketHandlerAdapter` bean， 该服务允许配置 `WebSocket` 服务器属性.  例如:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebFlux
	public class WebConfig implements WebFluxConfigurer {

		@Override
		public WebSocketService getWebSocketService() {
			TomcatRequestUpgradeStrategy strategy = new TomcatRequestUpgradeStrategy();
			strategy.setMaxSessionIdleTimeout(0L);
			return new HandshakeWebSocketService(strategy);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebFlux
	class WebConfig : WebFluxConfigurer {

		@Override
		fun webSocketService(): WebSocketService {
			val strategy = TomcatRequestUpgradeStrategy().apply {
				setMaxSessionIdleTimeout(0L)
			}
			return HandshakeWebSocketService(strategy)
		}
	}
----



[[webflux-config-advanced-java]]
=== 高级配置模式
[.small]#<<web.adoc#mvc-config-advanced-java, Web MVC>>#

`@EnableWebFlux` 导入 `DelegatingWebFluxConfiguration` 其中:

* 为 Spring WebFlux 应用程序提供了默认的 Spring 配置
* 检测到并委派到 `WebFluxConfigurer` 的自定义该配置

对于高级模式,请删除 `@EnableWebFlux` 并直接从 `DelegatingWebFluxConfiguration` 继承 ,而不是实现 `WebFluxConfigurer`,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class WebConfig extends DelegatingWebFluxConfiguration {

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class WebConfig : DelegatingWebFluxConfiguration {

		// ...
	}
----

可以在 `WebConfig` 中保留现有的方法,但现在也可以重写基类中的 bean 声明,并且在类路径上仍然可以有任意数量的其他 `WebMvcConfigurer` .

[[webflux-http2]]
== HTTP/2
[.small]#<<web.adoc#mvc-http2, Web MVC>>#

Servlet 4 容器需要支持 HTTP/2,Spring Framework 5 与 Servlet API 4 兼容. 从编程模型的角度来看,应用程序不需要特定的任何操作.  但是,存在与服务器配置相关的注意事项.  有关更多详细信息,请参阅 https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support[ HTTP/2 wiki 页面].