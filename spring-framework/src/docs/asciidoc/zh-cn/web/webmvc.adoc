[[mvc]]
= Spring Web MVC
:doc-spring-security: {doc-root}/spring-security/reference

Spring Web MVC 是构建在 Servlet API 上的原始 Web 框架,从一开始就包含在 Spring Framework 中.  正式名称  "`Spring Web MVC,`" 来自其源模块({spring-framework-main-code}/spring-webmvc[`spring-webmvc`])的名称,但它通常被称为 "`Spring MVC`"..

与 Spring Web MVC 一样,Spring Framework 5.0 引入了一个响应式栈 Web 框架,其名称 "`Spring WebFlux`", 也基于其源模块({spring-framework-main-code}/spring-webflux[`spring-webflux`]).  本节介绍 Spring Web MVC.  <<web-reactive.adoc#spring-web-reactive, 下一节>>将介绍 Spring WebFlux. .

有关基本信息以及与 Servlet 容器和 Java EE 版本范围的兼容性,请参阅 Spring Framework https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions[Wiki].


[[mvc-servlet]]
== DispatcherServlet
[.small]#<<web-reactive.adoc#webflux-dispatcher-handler, WebFlux>>#

Spring MVC 和许多其他 Web 框架一样,围绕前端控制器模式设计,其中核心  `DispatcherServlet` 为请求处理提供通用的操作,而实际工作由可配置委托组件执行.  该模型非常灵活,支持多种工作流程.

`DispatcherServlet` 与任何 `Servlet` 一样,需要使用 Java 或 `web.xml` 配置， 根据 `Servlet` 规范进行声明和映射.  反过来,`DispatcherServlet` 使用 Spring 配置来发现请求映射,视图解析,异常处理 <<mvc-servlet-special-bean-types, 等等>>所需的委托组件.

下面的 Java 配置示例注册并初始化 `DispatcherServlet`,它由 Servlet 容器自动检测(请参阅<<mvc-container-config>>) :

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyWebApplicationInitializer implements WebApplicationInitializer {

		@Override
		public void onStartup(ServletContext servletContext) {

			// Load Spring web application configuration
			AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();
			context.register(AppConfig.class);

			// Create and register the DispatcherServlet
			DispatcherServlet servlet = new DispatcherServlet(context);
			ServletRegistration.Dynamic registration = servletContext.addServlet("app", servlet);
			registration.setLoadOnStartup(1);
			registration.addMapping("/app/*");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyWebApplicationInitializer : WebApplicationInitializer {

		override fun onStartup(servletContext: ServletContext) {

			// Load Spring web application configuration
			val context = AnnotationConfigWebApplicationContext()
			context.register(AppConfig::class.java)

			// Create and register the DispatcherServlet
			val servlet = DispatcherServlet(context)
			val registration = servletContext.addServlet("app", servlet)
			registration.setLoadOnStartup(1)
			registration.addMapping("/app/*")
		}
	}
----

NOTE: 	除了直接使用 ServletContext API 之外,您还可以扩展 `AbstractAnnotationConfigDispatcherServletInitializer` 并覆盖特定方法(请参阅 <<mvc-servlet-context-hierarchy,上下文层次结构>>下的示例) .

NOTE: 注意：对于编程用例，`GenericWebApplicationContext` 可以替代 `AnnotationConfigWebApplicationContext`。 见
{api-spring-framework}/web/context/support/GenericWebApplicationContext.html[`GenericWebApplicationContext`]
javadoc 了解详细信息。

以下 `web.xml` 配置示例注册并初始化 `DispatcherServlet`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
<web-app>

	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>

	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/app-context.xml</param-value>
	</context-param>

	<servlet>
		<servlet-name>app</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value></param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>

	<servlet-mapping>
		<servlet-name>app</servlet-name>
		<url-pattern>/app/*</url-pattern>
	</servlet-mapping>

</web-app>
----

NOTE: Spring Boot 则有不同的初始化顺序.  Spring Boot 使用 Spring 配置来引导自身和嵌入式 `Servlet` 容器,而不是挂钩到 `Servlet` 容器的生命周期.  在 Spring 配置中检测 `Filter` 和 `Servlet` 声明,并在 Servlet 容器中注册.  有关更多详细信息,请参阅 https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-embedded-container[Spring Boot 文档] .

[[mvc-servlet-context-hierarchy]]
=== 上下文层次结构

`DispatcherServlet` 需要一个 `WebApplicationContext`(`ApplicationContext` 的扩展) 来配置自己.  `WebApplicationContext` 有一个指向 `ServletContext` 的链接以及与之关联的 `Servlet`.
它还绑定到 `ServletContext`,当需要访问它时,应用程序可以使用 `RequestContextUtils` 上的静态方法来查找 `WebApplicationContext`.

对于许多应用程序,拥有一个简单的 `WebApplicationContext` 已经足够了. 它也有一个上下文层次结构,其中根 `WebApplicationContext` 在多个 `DispatcherServlet`(或其他 `Servlet`) 实例之间共享, 每个实例都有自己的子 `WebApplicationContext` 配置.
有关上下文层次结构功能的更多信息,请参阅 <<core.adoc#context-introduction,`ApplicationContext` 的其他功能>>.

根 `WebApplicationContext` 通常包含 bean 基础结构,例如需要跨多个 `Servlet` 实例共享的数据存储库和业务服务.  这些 bean 被有效继承,可以在特定于 `Servlet` 的子 `WebApplicationContext` 中重写(即重新声明) ,它通常包含给定 `Servlet` 本地的 bean.  下图显示了这种关系:

image::{image-resource}/mvc-context-hierarchy.png[]

以下示例配置 `WebApplicationContext` 层次结构:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

		@Override
		protected Class<?>[] getRootConfigClasses() {
			return new Class<?>[] { RootConfig.class };
		}

		@Override
		protected Class<?>[] getServletConfigClasses() {
			return new Class<?>[] { App1Config.class };
		}

		@Override
		protected String[] getServletMappings() {
			return new String[] { "/app1/*" };
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyWebAppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

		override fun getRootConfigClasses(): Array<Class<*>> {
			return arrayOf(RootConfig::class.java)
		}

		override fun getServletConfigClasses(): Array<Class<*>> {
			return arrayOf(App1Config::class.java)
		}

		override fun getServletMappings(): Array<String> {
			return arrayOf("/app1/*")
		}
	}
----

TIP: 如果不需要应用程序上下文层次结构,则应用程序可以通过 `getRootConfigClasses()` 返回所有配置,并从 `getServletConfigClasses()` 返回 `null`.

以下示例显示了 `web.xml` 配置(和上面效果一样) :

[source,xml,indent=0,subs="verbatim,quotes"]
----
<web-app>

	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>

	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/root-context.xml</param-value>
	</context-param>

	<servlet>
		<servlet-name>app1</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/app1-context.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>

	<servlet-mapping>
		<servlet-name>app1</servlet-name>
		<url-pattern>/app1/*</url-pattern>
	</servlet-mapping>

</web-app>
----

TIP: 	如果不需要应用程序上下文层次结构,则应用程序可以仅配置 "`root`" 上下文,并将 `contextConfigLocation` Servlet 参数保留为空.


[[mvc-servlet-special-bean-types]]
=== 特殊的 Bean 类型
[.small]#<<web-reactive.adoc#webflux-special-bean-types, WebFlux>>#

`DispatcherServlet` 委托特殊 bean 处理请求并渲染视图.  "`special beans`" 是指实现 WebFlux 框架的 Spring 管理的 `Object` 实例.  这些通常带有内置联系,但您可以自定义其属性并扩展或替换它们.


下表列出了 `DispatcherHandler` 检测到的特殊 bean:

[[mvc-webappctx-special-beans-tbl]]
[cols="1,2", options="header"]
|===
| Bean 类型| 说明

| `HandlerMapping`
| 将请求映射到处理程序以及用于预处理和后处理的<<mvc-handlermapping-interceptor, 拦截器>>列表.  其映射规则基于某些标准,其细节因 `HandlerMapping` 实现而异.
    两个主要的 `HandlerMapping` 实现是 `RequestMappingHandlerMapping`(它支持 `@RequestMapping` 带注解的方法)  和 `SimpleUrlHandlerMapping` (它维护对处理程序的 URI 路径模式的显式注册) .

| `HandlerAdapter`
| 无论实际调用处理程序如何,都可以帮助 `DispatcherServlet` 调用映射到请求的处理程序.  例如,调用带有注解的控制器,需要从注解中解析一些信息.  `HandlerAdapter` 的主要目的是保护 `DispatcherServlet` 不受此类细节的影响.

| <<mvc-exceptionhandlers, `HandlerExceptionResolver`>>
| 解决异常的策略,他可以将捕获到的异常映射到处理程序,HTML 错误视图或其他目标.  请参阅<<mvc-exceptionhandlers,`HandlerExceptionResolver`>>.

| <<mvc-viewresolver, `ViewResolver`>>
| 将从处理程序返回的逻辑基于 `String` 的视图名称解析为用于呈现给响应的实际 `View`.  请参阅 <<mvc-viewresolver>> 和 <<mvc-view>>.

| <<mvc-localeresolver, `LocaleResolver`>>, <<mvc-timezone, LocaleContextResolver>>
| 解析客户端正在使用的. 以及可能的时区,以便能够提供国际化视图.  请参阅 <<mvc-localeresolver>>.

| <<mvc-themeresolver, `ThemeResolver`>>
| 解决 Web 应用程序可以使用的主题 - 例如,提供个性化布局.  见<<mvc-themeresolver>>.

| <<mvc-multipart, `MultipartResolver`>>
| 解析 multi-part 的请求(例如: 浏览器表单文件上载) . 请参阅<<mvc-multipart>>.

| <<mvc-flash-attributes, `FlashMapManager`>>
| 存储和检索 `"input"` 和 `"output"` `FlashMap`,可用于将属性从一个请求传递到另一个请求,通常是通过重定向.  请参阅<<mvc-flash-attributes>>.
|===


[[mvc-servlet-config]]
=== Web MVC 配置
[.small]#<<web-reactive.adoc#webflux-framework-config, WebFlux>>#

对于每种类型的 <<mvc-servlet-special-bean-types,特殊 bean>>, `DispatcherServlet` 首先会检查 `WebApplicationContext`. 如果没有匹配的 bean 类型,则会退回检查  {spring-framework-main-code}/spring-webmvc/src/main/resources/org/springframework/web/servlet/DispatcherServlet.properties[`DispatcherServlet.properties`].

在大多数情况下,<<mvc-config>>是最佳起点.  它以 Java 或 XML 声明所需的 bean,并提供更高级别的配置回调 API 来自定义它.

NOTE: Spring Boot 依赖于 MVC Java 配置来配置 Spring MVC 并提供许多额外的便捷选项.

[[mvc-container-config]]
=== Servlet 配置

在 Servlet 3.0+ 环境中,您可以选择以编程方式配置 Servlet 容器作为替代方法,也可以与 `web.xml` 文件结合使用.  以下示例注册 `DispatcherServlet`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.springframework.web.WebApplicationInitializer;

	public class MyWebApplicationInitializer implements WebApplicationInitializer {

		@Override
		public void onStartup(ServletContext container) {
			XmlWebApplicationContext appContext = new XmlWebApplicationContext();
			appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");

			ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet(appContext));
			registration.setLoadOnStartup(1);
			registration.addMapping("/");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.web.WebApplicationInitializer

	class MyWebApplicationInitializer : WebApplicationInitializer {

		override fun onStartup(container: ServletContext) {
			val appContext = XmlWebApplicationContext()
			appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml")

			val registration = container.addServlet("dispatcher", DispatcherServlet(appContext))
			registration.setLoadOnStartup(1)
			registration.addMapping("/")
		}
	}
----

`WebApplicationInitializer` 是 Spring MVC 提供的一个接口,实现此接口的任何 Servlet 3 容器都可被检测到并自动初始化.
`AbstractDispatcherServletInitializer` 抽象类实现了 `WebApplicationInitializer` 接口,通过重写方法来指定 `servlet` 映射和 `DispatcherServlet` 配置的地址, 从而更方便的注册 `DispatcherServlet`.

对于使用基于 Java 的 Spring 配置的应用程序,建议使用此方法,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

		@Override
		protected Class<?>[] getRootConfigClasses() {
			return null;
		}

		@Override
		protected Class<?>[] getServletConfigClasses() {
			return new Class<?>[] { MyWebConfig.class };
		}

		@Override
		protected String[] getServletMappings() {
			return new String[] { "/" };
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyWebAppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

		override fun getRootConfigClasses(): Array<Class<*>>? {
			return null
		}

		override fun getServletConfigClasses(): Array<Class<*>>? {
			return arrayOf(MyWebConfig::class.java)
		}

		override fun getServletMappings(): Array<String> {
			return arrayOf("/")
		}
	}
----

如果使用基于 XML 的 Spring 配置,则应直接从 `AbstractDispatcherServletInitializer` 扩展,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

		@Override
		protected WebApplicationContext createRootApplicationContext() {
			return null;
		}

		@Override
		protected WebApplicationContext createServletApplicationContext() {
			XmlWebApplicationContext cxt = new XmlWebApplicationContext();
			cxt.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");
			return cxt;
		}

		@Override
		protected String[] getServletMappings() {
			return new String[] { "/" };
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyWebAppInitializer : AbstractDispatcherServletInitializer() {

		override fun createRootApplicationContext(): WebApplicationContext? {
			return null
		}

		override fun createServletApplicationContext(): WebApplicationContext {
			return XmlWebApplicationContext().apply {
				setConfigLocation("/WEB-INF/spring/dispatcher-config.xml")
			}
		}

		override fun getServletMappings(): Array<String> {
			return arrayOf("/")
		}
	}
----

`AbstractDispatcherServletInitializer` 还提供了一种便捷的方法来添加 `Filter` 实例并将它们自动映射到 `DispatcherServlet`,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

		// ...

		@Override
		protected Filter[] getServletFilters() {
			return new Filter[] {
				new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyWebAppInitializer : AbstractDispatcherServletInitializer() {

		// ...

		override fun getServletFilters(): Array<Filter> {
			return arrayOf(HiddenHttpMethodFilter(), CharacterEncodingFilter())
		}
	}
----

每个过滤器都根据其具体类型添加默认名称,并自动映射到 `DispatcherServlet`.

`AbstractDispatcherServletInitializer` 的 protected 方法 `isAsyncSupported` 提供了一个单独的地址来启用 `DispatcherServlet` 上的异步支持以及映射到它的所有过滤器.  默认情况下,此标志设置为 `true`.

最后,如果您需要进一步自定义 `DispatcherServlet` 本身,则可以覆盖 `createDispatcherServlet` 方法.

[[mvc-servlet-sequence]]
=== Processing
[.small]#<<web-reactive.adoc#webflux-dispatcher-handler-sequence, WebFlux>>#

`DispatcherServlet` 按如下方式处理请求:

* 首先,搜索应用的上下文对象 `WebApplicationContext`,并把它作为一个属性(attribute)绑定到该请求上. 以便让控制器和其他组件能使用它.  属性的键名默认为 `DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE`.
* 将 locale resolver 绑定到请求上,并允许其他组件解析处理请求时使用的语言环境(渲染视图,准备数据等) .  如果您不需要区域解析,则不需要 locale resolver.
* 将 theme resolver 绑定到请求,以允许视图等组件确定要使用的 themes.  如果您不使用 themes,则可以忽略它.
* 如果指定 multipart 文件处理器,则会检查请求的文件是不是 multiparts 的, 如果是,请求将包装在 `MultipartHttpServletRequest` 中, 以便其他组件进一步处理.  有关 Multipart Resolver 的更多信息,请参见 <<mvc-multipart,Multipart Resolver>>.
* 为该请求查找一个合适的处理器.  如果找到处理程序,则与该处理器关联的整条执行链(前处理器、后处理器、控制器等) 都会被执行,以完成相应模型的准备或视图的渲染.  或者,对于带注解的控制器,可以显示响应(在 HandlerAdapter 中) 而不是返回视图.
* 如果处理器返回模型,则渲染视图.  如果没有返回模型(可能是由于前处理器或后处理器拦截请求,可能是出于安全原因) ,则不会渲染任何视图,因为该请求可能已经完成.

在 `WebApplicationContext` 中声明的 `HandlerExceptionResolver` 用于解决请求处理过程中引发的异常. 这些异常解析程序允许使用自定义的逻辑来解决,有关详细信息,请参阅 <<mvc-exceptionhandlers>>  .

对于 HTTP 缓存支持，可以使用 `WebRequest` 的 `checkNotModified` 方法，以及注解控制器的更多选项，如 <<mvc-caching-etag-lastmodified,控制器的 HTTP 缓存>>.

您可以自定义通过 `DispatcherServlet` 的配置. 可以在 `web.xml` 文件中,声明元素 Servlet 的上添加 Servlet 的初始化参数(`init-param` 元素) .  下表列出了支持的参数:

[[mvc-disp-servlet-init-params-tbl]]
.DispatcherServlet 初始化参数
|===
| 参数| 说明

| `contextClass`
| 实现 `ConfigurableWebApplicationContext` 的类,由此类通过本地配置来初始化 Servlet 实例.  默认情况下,使用 `XmlWebApplicationContext`.

| `contextConfigLocation`
|
一个指定了上下文配置文件路径的字符串,并传递给上下文实例(由 `contextClass` 指定)  . 该字符串可能包含多个字符串(使用逗号作为分隔符) 以支持多个上下文.  对于具有两次定义的 bean 的多个上下文位置,最新位置优先(即最后加载的为准) .

| `namespace`
| `WebApplicationContext` 的命名空间.  默认为 `[servlet-name]-servlet`.

| `throwExceptionIfNoHandlerFound`
| 当没有找到请求的处理程序时是否抛出 `NoHandlerFoundException`.  然后可以使用 `HandlerExceptionResolver` 捕获异常(例如,使用 `@ExceptionHandler` 控制器方法) 并像处理其他任何方法一样处理异常.

  默认情况下,此参数设置为 `false`,在这种情况下,`DispatcherServlet` 将响应状态设置为 `404(NOT_FOUND) `,而不会引发异常.

  请注意,如果配置了 默认 servlet 处理 ,则始终将未解析的请求转发到 <<mvc-default-servlet-handler, 默认 servlet>>,并且永远不会引发 404.
|===

[[mvc-handlermapping-path]]
=== 路径匹配

Servlet API 将完整的请求路径公开为  `requestURI` ，并进一步将其细分为 `contextPath`, `servletPath`, and `pathInfo`，其值根据 Servlet 的映射方式而有所不同。 根据这些输入，Spring MVC 需要确定查找路径用于处理程序映射，它是 `DispatcherServlet` 本身映射中的路径，不包括 `contextPath` 和任何 `servletMapping` 前缀（如果存在）。

`servletPath` 和 `pathInfo` 被解码，这使得它们无法直接与完整的 `requestURI` 进行比较导出 `lookupPath`，因此有必要对 `requestURI` 进行解码。 然而，这引入了它自己的问题，因为 path 可能包含编码的保留字符，例如 `"/"` 或 `";"`，这些字符在解码后又会改变路径的结构，这也可能导致安全问题。 此外，Servlet 容器可能会在不同程度上规范化 `servletPath`，这使得更不可能执行与 `requestURI` 的比较 `startsWith`。

这就是为什么最好避免依赖基于前缀的 `servletPath` 映射类型附带的 `servletPath`。 如果 `DispatcherServlet` 被映射为带有 `"/"` 的默认 Servlet 或者没有带有 `"/*"` 的前缀并且 Servlet 容器是 4.0+，那么 Spring MVC 能够检测到 Servlet 映射类型并避免完全使用 `servletPath` 和 `pathInfo`。 在 3.1 Servlet 容器上，假设相同的 Servlet 映射类型，可以通过在 MVC 配置中通过 <<mvc-config-path-matching>> 提供具有 `alwaysUseFullPath=true` 的 `UrlPathHelper` 来实现等效。

幸运的是，默认的 Servlet 映射 `"/"` 是一个不错的选择。 但是，仍然存在一个问题，即需要对 `requestURI` 进行解码，以便与控制器映射进行比较。 这也是不可取的，因为可能会解码改变路径结构的保留字符。 如果这些字符不是预期的，那么您可以拒绝它们（如 Spring Security HTTP 防火墙），或者您可以使用 `urlDecode=false` 配置 `UrlPathHelper`，但控制器映射需要与编码路径匹配，这可能并不总是有效 出色地。 此外，有时 `DispatcherServlet` 需要与另一个 Servlet 共享 URL 空间，并且可能需要通过前缀进行映射。

通过从 `PathMatcher` 切换到 5.3 或更高版本中可用的已解析 `PathPattern` 可以更全面地解决上述问题，请参阅 <<mvc-ann-requestmapping-pattern-comparison>>。 与需要解码查找路径或编码控制器映射的 `AntPathMatcher` 不同，解析的 `PathPattern`
匹配名为  `RequestPath` 的路径的解析表示，一次一个路径段。 这允许单独解码和清理路径段值，而不会有改变路径结构的风险。 解析后的 `PathPattern` 也支持使用 `servletPath` 前缀映射，只要前缀保持简单并且没有任何需要编码的字符即可。

[[mvc-handlermapping-interceptor]]
=== 拦截器

所有 `HandlerMapping` 实现都支持处理拦截器,这些拦截器在需要为特定类型的请求应用一些功能时可能很有用非常有用.
例如,检查用户身份等,`org.springframework.web.servlet` 包中的 `HandlerInterceptor` 实现了三种方法,提供足够的灵活性来执行各种预处理和后处理:

* `preHandle(..)`: 在执行实际处理程序之前
* `postHandle(..)`: 在执行实际处理程序之后
* `afterCompletion(..)`: 完成请求后

`preHandle(..)` 方法返回一个布尔值.  您可以使用此方法来中断或继续执行链的处理.  当此方法返回 `true` 时,处理程序执行链继续.
当它返回 `false` 时,`DispatcherServlet` 假定拦截器本身已处理请求(例如,呈现适当的视图) 并且不继续执行执行链中的其他拦截器和实际处理程序.

有关如何配置 <<mvc-config-interceptors,Interceptors>>  的示例,请参阅 MVC 配置一节中的拦截器.  您还可以使用各个 `HandlerMapping` 实现上的setter方法直接注册它们.

请注意,在 `HandlerAdapter` 和 `postHandle` 之前,响应被写入并提交.  `postHandle` 对于 `@ResponseBody` 和 `ResponseEntity` 方法不太有用, 这意味着对响应进行任何更改都为时已晚.
例如添加额外的 header.  对于此类方案,您可以实现 `ResponseBodyAdvice` 并将其声明为 <<mvc-ann-controller-advice,Controller Advice>> bean或直接在 `RequestMappingHandlerAdapter` 上进行配置.

[[mvc-exceptionhandlers]]
=== 异常
[.small]#<<web-reactive.adoc#webflux-dispatcher-exceptions, WebFlux>>#

如果在请求映射期间发生异常或从请求处理程序(例如 `@Controller`) 抛出异常, 则 `DispatcherServlet` 委托给 `HandlerExceptionResolver` bean 来处理并解决异常,这通常是错误响应.

下表列出了可用的 `HandlerExceptionResolver` 实现:

[cols="1,2", options="header"]
.HandlerExceptionResolver 实现
|===
| `HandlerExceptionResolver` | 描述

| `SimpleMappingExceptionResolver`
| 异常类名称和错误视图名称之间的映射.  用于在浏览器应用程序中呈现错误页面.

| {api-spring-framework}/web/servlet/mvc/support/DefaultHandlerExceptionResolver.html[`DefaultHandlerExceptionResolver`]
| 解决 Spring MVC 引发的异常并将它们映射到 HTTP 状态代码.  另请参阅备用 `ResponseEntityExceptionHandler` 和 <<mvc-ann-rest-exceptions,REST API exceptions>>异常.

| `ResponseStatusExceptionResolver`
| 使用 `@ResponseStatus` 注解解析异常,并根据注解中的值将它们映射到 HTTP 状态代码.

| `ExceptionHandlerExceptionResolver`
| 通过在 `@Controller` 或 `@ControllerAdvice` 类中调用 `@ExceptionHandler` 方法来解决异常.  请参阅 <<mvc-ann-exceptionhandler, @ExceptionHandler methods>>方法.
|===


[[mvc-excetionhandlers-handling]]
==== 解析链

您可以通过在 Spring 配置中声明多个 `HandlerExceptionResolver` bean 并根据需要设置其顺序属性来形成异常解析链.  `order` 属性越高,异常解析器定位的越晚.

`HandlerExceptionResolver` 的约定指定它可以返回:

* 一个指向错误视图的 `ModelAndView`.
* 如果在解析程序中处理异常,则为空的 `ModelAndView`.
* 如果异常仍未解析,则为 `null`,以供后续解析器尝试,如果异常保留在最后,则允许冒泡到 `Servlet` 容器. .

<<mvc-config,MVC Config>>自动声明内置的解析器,用于默认的 Spring MVC 异常,`@ResponseStatus` 带注解的异常,以及对 `@ExceptionHandler` 方法的支持.  您可以自定义该列表或替换它.

[[mvc-ann-customer-servlet-container-error-page]]
==== 容器错误页面

如果任何 `HandlerExceptionResolver` 仍未解析异常,并且因此将其传播给 servlet 容器或者如果响应状态设置为错误状态(即 4xx,5xx)  ,则 Servlet 容器可以呈现 HTML 中的默认错误页面.
要自定义容器的默认错误页面,可以在 `web.xml`.中声明错误页面映射.  以下示例显示了如何执行此操作:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<error-page>
		<location>/error</location>
	</error-page>
----

根据前面的示例,当异常冒泡或响应具有错误状态时,Servlet 容器会在容器内对配置的 URL 进行 ERROR 调度(例如,`/error`) .
然后由 `DispatcherServlet` 处理,可能将其映射到 `@Controller`,可以实现该控件以返回带有模型的错误视图名称或呈现 JSON 响应,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RestController
	public class ErrorController {

		@RequestMapping(path = "/error")
		public Map<String, Object> handle(HttpServletRequest request) {
			Map<String, Object> map = new HashMap<String, Object>();
			map.put("status", request.getAttribute("javax.servlet.error.status_code"));
			map.put("reason", request.getAttribute("javax.servlet.error.message"));
			return map;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RestController
	class ErrorController {

		@RequestMapping(path = ["/error"])
		fun handle(request: HttpServletRequest): Map<String, Any> {
			val map = HashMap<String, Any>()
			map["status"] = request.getAttribute("javax.servlet.error.status_code")
			map["reason"] = request.getAttribute("javax.servlet.error.message")
			return map
		}
	}
----

TIP: Servlet API 没有提供在 Java 中创建错误页面映射的方法.  但是,您可以同时使用 `WebApplicationInitializer` 和简写的 `web.xml`.

[[mvc-viewresolver]]
=== View Resolution
[.small]#<<web-reactive.adoc#webflux-viewresolution, WebFlux>>#

Spring MVC 定义了 `ViewResolver` 和 `View` 接口,使您可以在浏览器中呈现模型,而无需将您与特定的视图技术联系起来.  `ViewResolver` 提供视图名称和实际视图之间的映射.
`View` 接口负责准备请求,并将请求的渲染交给某种具体的视图技术实现.

下表提供了有关 `ViewResolver` 层次结构的更多详细信息:

[[mvc-view-resolvers-tbl]]
.ViewResolver 实现
|===
| ViewResolver| 描述

| `AbstractCachingViewResolver`
| `AbstractCachingViewResolver` 的子类缓存它们解析的视图实例.  缓存可提高某些视图技术的性能.  您可以通过将 `cache` 属性设置为 `false`.来关闭缓存.  此外,如果必须在运行时刷新某个视图(例如,修改 `FreeMarker` 模板时) ,则可以使用 `removeFromCache(String viewName, Locale loc)` 方法.

| `UrlBasedViewResolver`
| `ViewResolver` 接口的简单实现,它不需要其他任何显式的映射说明,而直接使用 URL 来解析到逻辑视图名.  如果您的逻辑名称与真正的视图资源的名称匹配,则不需要任何映射.

| `InternalResourceViewResolver`
| `UrlBasedViewResolver` 的便捷子类,支持 `InternalResourceView`(实际上是 Servlet 和 JSP) 和子类,如 `JstlView` 和 `TilesView`.  您可以使用 `setViewClass(..)` 为此解析程序生成的所有视图指定视图类.  有关详细信息,请参阅 {api-spring-framework}/web/reactive/result/view/UrlBasedViewResolver.html[`UrlBasedViewResolver`] javadoc.

| `FreeMarkerViewResolver`
| `UrlBasedViewResolver` 的便捷子类,支持 `FreeMarkerView` 其自定义子类.

| `ContentNegotiatingViewResolver`
| 实现 `ViewResolver` 接口,该接口根据请求文件名或 `Accept` 头解析视图.  请参阅  <<mvc-multiple-representations,内容协商>>.

| `BeanNameViewResolver`
| `ViewResolver` 接口的实现， 该接口将视图名称解释为当前应用程序上下文中的 bean 名称. 这是一个非常灵活的实现， 它允许根据不同的视图名称来混合和匹配不同的视图类型.  每个这样的 `View` 都可以定义为一个 bean， 例如 在 XML 或配置类中.
|===


[[mvc-viewresolver-handling]]
==== 处理
[.small]#<<web-reactive.adoc#webflux-viewresolution-handling, WebFlux>>#

您可以在视图解析器链中声明多个视图解析器,并在必要时通过设置 `order` 属性来指定排序.  请记住,`order` 属性越高,视图解析器在链中的位置越晚.  .

`ViewResolver` 可以返回 `null` 以指示无法找到该视图.  但是,对于 JSP 和 `InternalResourceViewResolver`, 确定 JSP 是否存在的唯一方法是通过 `RequestDispatcher` 执行调度.  因此,您必须始终将 `InternalResourceViewResolver` 配置为视图解析器的整体顺序中的最后一个.

配置视图解析就像将 `ViewResolver` bean 添加到 Spring 配置一样简单. <<mvc-config,MVC Config>>为<<mvc-config-view-resolvers,View 解析器>>提供专用配置 API,并添加无逻辑视图控制器(<<mvc-config-view-controller, View Controllers>> ) ,这些控制器对于没有控制器逻辑的 HTML 模板渲染非常有用.

[[mvc-redirecting-redirect-prefix]]
==== 重定向
[.small]#<<web-reactive.adoc#webflux-redirecting-redirect-prefix, WebFlux>>#

您可以在视图中使用 `redirect:` 前缀来执行重定向. `UrlBasedViewResolver`(及其子类) 将此识别为需要重定向的指令.  视图名称的其余部分是重定向 URL.

控制器本身可以根据逻辑视图名称进行操作.  逻辑视图名称(例如 `redirect:/myapp/some/resource`) 相对于当前 Servlet 上下文重定向,而名称如 `redirect:http://myhost.com/some/arbitrary/path`  重定向到绝对 URL.

请注意,如果使用 `@ResponseStatus` 注解控制器方法,则注解值优先于 `RedirectView` 设置的响应状态.

[[mvc-redirecting-forward-prefix]]
==== 转发

你也可以在视图名称中使用 `forward:` 前缀,来作为 `UrlBasedViewResolver` 和其子类最终解析的视图名称.  这将创建一个 `InternalResourceView`,它执行 `RequestDispatcher.forward()`.
因此,此前缀对于 `InternalResourceViewResolver` 和 `InternalResourceView`(对于 JSP) 没有用,但如果您使用其他视图技术时仍希望强制 Servlet/JSP 引擎处理资源的转发,则它可能会有所帮助.  请注意,您也可以链接多个视图解析器.


[[mvc-multiple-representations]]
==== 内容协商
[.small]#<<web-reactive.adoc#webflux-multiple-representations, WebFlux>>#

{api-spring-framework}/web/servlet/view/ContentNegotiatingViewResolver.html[`ContentNegotiatingViewResolver`] 本身不解析视图,而是委托给其他视图解析器,并选择类似于客户端请求的表示的视图.  可以从 `Accept` 头或查询参数(例如, `"/path?format=pdf"`) 确定表示.

`ContentNegotiatingViewResolver` 通过将请求的媒体类型与其每个 `ViewResolvers` 关联的 `View` 支持的媒体类型(也称为 `Content-Type`) 进行比较,选择适当的 `View` 来处理请求. 列表中具有兼容 `Content-Type` 的第一个 `View` 将表示返回给客户端.
如果 `ViewResolver` 链无法提供兼容视图,则会查询通过 `DefaultViews` 属性指定的视图列表.  后一个选项适用于单个视图,它可以呈现当前资源的适当表示,而不管逻辑视图名称如何.  `Accept` 头可以包含通配符(例如 `text/{asterisk}`) ,在这种情况下,`Content-Type` 为 `text/xml` 的 `View` 是兼容匹配.

有关配置详细信息,请参阅 <<mvc-config,MVC Config>> 下的<<mvc-config-view-resolvers,View 解析器>> .

[[mvc-localeresolver]]
=== 国际化

正如 Spring Web MVC 框架所做的那样,Spring 架构的大多数部分都支持国际化.  `DispatcherServlet` 允许您使用客户端的语言环境自动解析消息.  这是通过 `LocaleResolver` 对象完成的.

当请求进入时,`DispatcherServlet` 会查找当前语言环境解析器,如果找到,则会尝试使用它来设置语言环境.  您可以通过使用 `RequestContext.getLocale()` 方法,来获取由区域解析器解析到的结果.

除了自动解析语言环境之外,您还可以在处理程序时添加拦截器(有关拦截器的更多信息,请参阅<<mvc-handlermapping-interceptor,Interception>> ) ,以便于在特定情况下更改语言环境. 例如(通过请求中的参数来改变语言环境)

区域解析器和拦截器在 `org.springframework.web.servlet.i18n` 包中定义,并以正常方式在应用程序上下文中进行配置.  Spring 中包含以下选择的语言环境解析器.

* <<mvc-timezone>>
* <<mvc-localeresolver-acceptheader>>
* <<mvc-localeresolver-cookie>>
* <<mvc-localeresolver-session>>
* <<mvc-localeresolver-interceptor>>


[[mvc-timezone]]
==== Time Zone

除了获取客户端的区域设置外,了解其时区通常也很有用.  `LocaleContextResolver` 接口提供了 `LocaleResolver` 的扩展,它允许解析器提供更丰富的 `LocaleContext`,其中可能包含时区信息.

当此解析器可用时,可以使用 `RequestContext.getTimeZone()` 方法获取用户的 `TimeZone`.  时区信息由 Spring 的 `ConversionService` 注册的任何 Date/Time `Converter` 和 `Formatter` 对象自动使用.


[[mvc-localeresolver-acceptheader]]
==== Header 解析器

此区域解析器检查客户端(例如,Web 浏览器) 发送的请求头中的 `accept-language`.  通常,此字段包含客户端操作系统的区域设置.  请注意,此解析器不支持时区信息.


[[mvc-localeresolver-cookie]]
==== Cookie 解析器

此区域解析器检查客户端上可能存在的 `Cookie`,以查看是否指定了 `Locale` 或 `TimeZone`.  如果是,则使用指定的详细信息.  通过使用此区域解析器的属性,您可以指定 cookie 的名称以及失效时间.  以下示例定义 `CookieLocaleResolver`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver">

		<property name="cookieName" value="clientlanguage"/>

		<!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) -->
		<property name="cookieMaxAge" value="100000"/>

	</bean>
----

下表描述了 `CookieLocaleResolver` 的属性:

[[mvc-cookie-locale-resolver-props-tbl]]
.CookieLocaleResolver 属性
[cols="1,1,4"]
|===
| 属性 | 默认值 | 描述

| `cookieName`
| classname + LOCALE
| cookie 的名字

| `cookieMaxAge`
| Servlet container default
| Cookie 在客户端上持续存在的最长时间.  如果指定 `-1`,则不会保留 cookie.  它仅在客户端关闭浏览器之前可用.

| `cookiePath`
| /
| 限制 cookie 对您网站某个部分的可见性.  当指定了 `cookiePath` 时,cookie 仅对该路径及其下方的路径可见.
|===


[[mvc-localeresolver-session]]
==== Session 解析器

您可以使用 `SessionLocaleResolver` 从与用户请求关联的 `Session` 中获取 `Locale` 和 `TimeZone`.  与 `CookieLocaleResolver` 相比,此策略将本地选择的区域设置存储在 Servlet 容器的 `HttpSession` 中.  因此,这些设置对于每个会话都是临时的,这些设置在会话结束时会丢失.

请注意,与外部会话管理机制没有直接关系,例如 Spring Session 项目.  此 `SessionLocaleResolver` 根据当前的 `HttpServletRequest` 评估和修改相应的 `HttpSession` 属性.


[[mvc-localeresolver-interceptor]]
==== Locale 拦截器

您可以通过将 `LocaleChangeInterceptor` 添加到其中一个 `HandlerMapping` 定义来启用语言环境的更改.  它会检测请求中的参数并相应地更改语言环境,在程序的应用程序上下文中调用 `LocaleResolver` 上的 `setLocale` 方法.
下一个示例显示,当调用包含名为 `siteLanguage` 的参数的所有 `{asterisk}.view` 资源时更改了区域设置.  例如,对 URL 的请求 `http://www.sf.net/home.view?siteLanguage=nl` 将网站语言更改为荷兰语.  以下示例显示如何拦截区域设置:

[source,xml,indent=0,subs="verbatim"]
----
	<bean id="localeChangeInterceptor"
			class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">
		<property name="paramName" value="siteLanguage"/>
	</bean>

	<bean id="localeResolver"
			class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/>

	<bean id="urlMapping"
			class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
		<property name="interceptors">
			<list>
				<ref bean="localeChangeInterceptor"/>
			</list>
		</property>
		<property name="mappings">
			<value>/**/*.view=someController</value>
		</property>
	</bean>
----



[[mvc-themeresolver]]
=== 主题

您可以使用 Spring Web MVC 框架自带的主题来设置应用程序的整体外观,从而增强用户体验.  主题是静态资源的集合,通常是样式表和图片,它们会影响应用程序的视觉样式.


[[mvc-themeresolver-defining]]
==== 定义一个主题

要在 Web 应用程序中使用主题,必须设置 `org.springframework.ui.context.ThemeSource` 接口的实现.  `WebApplicationContext` 接口扩展了 `ThemeSource`, 但将其职责委托给专用实现.
默认情况下,委托是 `org.springframework.ui.context.support.ResourceBundleThemeSource` 的实现. 它从类路径的根目录加载属性文件.
要使用自定义 `ThemeSource` 实现或配置 `ResourceBundleThemeSource` 的名称前缀,可以在应用程序上下文中使用保留名称 `themeSource` 注册 bean.  Web 应用程序上下文自动检测具有该名称的 bean 并使用它.

使用 `ResourceBundleThemeSource` 时,主题在简单属性文件中定义.  属性文件列出构成主题的资源,如以下示例所示:

[literal,subs="verbatim,quotes"]
----
styleSheet=/themes/cool/style.css
background=/themes/cool/img/coolBg.jpg
----

属性的键是从视图代码引用主题元素的名称.  对于 JSP,通常使用 `spring:theme` 自定义标签执行此操作,该标记与 `spring:message` 标签非常相似.  以下 JSP 片段使用上一示例中定义的主题来自定义外观:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%>
	<html>
		<head>
			<link rel="stylesheet" href="<spring:theme code='styleSheet'/>" type="text/css"/>
		</head>
		<body style="background=<spring:theme code='background'/>">
			...
		</body>
	</html>
----

默认情况下,`ResourceBundleThemeSource` 使用空的名称前缀.  因此,从类路径的根加载属性文件.  因此,您可以将 `cool.properties` 主题定义放在类路径根目录的目录中(例如,在 `/WEB-INF/classes` 中) .
`ResourceBundleThemeSource` 使用标准的 Java 资源包加载机制,从而使主题也具有国际化.  例如,我们可以有一个 `/WEB-INF/classes/cool_nl.properties`,它引用一个带有荷兰文本的特殊背景图片.

[[mvc-themeresolver-resolving]]
==== 解析主题

定义主题后,如<<mvc-themeresolver-defining, 上一节所述>>,您可以决定使用哪个主题.  `DispatcherServlet` 查找名为 `themeResolver` 的 bean,以找出要使用的 `ThemeResolver` 实现.
主题解析器的工作方式与 `LocaleResolver` 的工作方式大致相同.  它检测用于特定请求的主题,还可以更改请求的主题.  下表描述了 Spring 提供的主题解析器:

[[mvc-theme-resolver-impls-tbl]]
.ThemeResolver 实现
[cols="1,4"]
|===
| Class | 描述

| `FixedThemeResolver`
| 选择使用 `defaultThemeName`

| `SessionThemeResolver`
| 主题在用户的 HTTP 会话中维护.  它只需要为每个会话设置一次,但不会在会话之间保留.

| `CookieThemeResolver`
| 所选主题存储在客户端的 cookie 中.
|===

Spring 还提供了一个 `ThemeChangeInterceptor`,它允许通过简单的请求参数对每个请求进行主题更改.


[[mvc-multipart]]
=== Multipart 解析器
[.small]#<<web-reactive.adoc#webflux-multipart, WebFlux>>#

`org.springframework.web.multipart` 包中的 `MultipartResolver` 是一种用于解析包括文件上传在内的多部分请求的策略.  他包含了一个 https://commons.apache.org/proper/commons-fileupload[Commons FileUpload] 的实现,另一个基于 Servlet 3.0 多部分请求解析.

要启用多部分处理,在 Spring 的配置文件中, 为 `DispatcherServlet` 配置名称为 `multipartResolver` 的 `MultipartResolver` bean.  `DispatcherServlet` 会自动检测并将其应用于请求中.
当收到内容类型为 `multipart/form-data` 的 POST 请求时,解析器会解析内容并将当前的 `HttpServletRequest` 包装为 `MultipartHttpServletRequest`,以提供对已解析部分的访问,并将其作为请求参数暴露.

[[mvc-multipart-resolver-commons]]
==== Apache Commons `FileUpload`

要使用 Apache Commons `FileUpload`,您可以配置名为 `multipartResolver` 的 `CommonsMultipartResolver` 类型的 bean.  您还需要添加 `commons-fileupload` 依赖.

此解析器变体委托给应用程序中的本地库，提供跨 Servlet 容器的最大可移植性。 作为替代方案，考虑通过容器自己的解析器进行标准 Servlet 多部分解析，如下所述。

[NOTE]
====
Commons FileUpload 传统上仅适用于 POST 请求，但接受任何 `multipart/` 内容类型。 见
{api-spring-framework}/web/multipart/commons/CommonsMultipartResolver.html[`CommonsMultipartResolver`]
javadoc 了解详细信息和配置选项。
====

[[mvc-multipart-resolver-standard]]
==== Servlet 3.0

需要通过 Servlet 容器配置启用 Servlet 3.0 多部分解析:

* 在 Java 中,在注册 Servlet 时设置 `MultipartConfigElement`.
* 在 `web.xml` 中,将 `"<multipart-config>"` 部分添加到 servlet 声明中.

以下示例显示如何在注册 Servlet 时设置 `MultipartConfigElement`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

		// ...

		@Override
		protected void customizeRegistration(ServletRegistration.Dynamic registration) {

			// Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold
			registration.setMultipartConfig(new MultipartConfigElement("/tmp"));
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class AppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

		// ...

		override fun customizeRegistration(registration: ServletRegistration.Dynamic) {

			// Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold
			registration.setMultipartConfig(MultipartConfigElement("/tmp"))
		}

	}
----

一旦您配置好 Servlet 3.0,您就可以添加名为 `multipartResolver` 的 `StandardServletMultipartResolver` 类型的 bean.

[NOTE]
====
此解析器按原样使用您的 Servlet 容器的多部分解析器，可能会将应用程序暴露给容器实现差异。 默认情况下，它将尝试使用任何 HTTP 方法解析任何 `multipart/` 内容类型，但这可能不受所有 Servlet 容器的支持。 见
{api-spring-framework}/web/multipart/support/StandardServletMultipartResolver.html[`StandardServletMultipartResolver`]
javadoc 了解详细信息和配置选项。
====

[[mvc-logging]]
=== 日志
[.small]#<<web-reactive.adoc#webflux-logging, WebFlux>>#

Spring MVC 中的 DEBUG 级别日志记录旨在实现紧凑,简约和人性化.  它侧重于那些一次又一次使用的高价值信息,其他的只有在调试特定问题时才有用.

TRACE 级日志记录通常遵循与 DEBUG 相同的原则(例如,不应该是 fire hose) ,但可以用于调试任何问题.  此外,一些日志消息可能在 TRACE 与 DEBUG 中显示不同的详细程度.

良好的日志记录来自使用日志的经验.  如果您发现任何不符合既定目标的事件,请告知我们.

[[mvc-logging-sensitive-data]]
==== 敏感数据
[.small]#<<web-reactive.adoc#webflux-logging-sensitive-data, WebFlux>>#

DEBUG 和 TRACE 日志记录可能会记录敏感信息.  这就是默认情况下屏蔽请求参数和请求头的原因,并且必须通过 `DispatcherServlet` 上的 `enableLoggingRequestDetails` 属性显式启用它们的完整日志记录.

以下示例说明如何使用 Java 配置执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public class MyInitializer
		extends AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class<?>[] getRootConfigClasses() {
		return ... ;
	}

	@Override
	protected Class<?>[] getServletConfigClasses() {
		return ... ;
	}

	@Override
	protected String[] getServletMappings() {
		return ... ;
	}

	@Override
	protected void customizeRegistration(ServletRegistration.Dynamic registration) {
		registration.setInitParameter("enableLoggingRequestDetails", "true");
	}

}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

		override fun getRootConfigClasses(): Array<Class<*>>? {
			return ...
		}

		override fun getServletConfigClasses(): Array<Class<*>>? {
			return ...
		}

		override fun getServletMappings(): Array<String> {
			return ...
		}

		override fun customizeRegistration(registration: ServletRegistration.Dynamic) {
			registration.setInitParameter("enableLoggingRequestDetails", "true")
		}
	}
----




[[filters]]
== 过滤器
[.small]#<<web-reactive.adoc#webflux-filters, WebFlux>>#

`spring-web` 模块提供了一些有用的过滤器:

* <<filters-http-put>>
* <<filters-forwarded-headers>>
* <<filters-shallow-etag>>
* <<filters-cors>>



[[filters-http-put]]
=== 表单数据

浏览器只能通过 HTTP GET 或 HTTP POST 提交表单数据,但非浏览器客户端也可以使用 HTTP PUT,PATCH 和 DELETE 提交表单数据.  Servlet API 要求 `ServletRequest.getParameter{asterisk}()` 方法仅支持 HTTP POST 的表单字段访问. .

`spring-web` 模块提供 `FormContentFilter` 过滤器来拦截 HTTP PUT,PATCH 和 DELETE 请求,请求类型为 `application/x-www-form-urlencoded`, `FormContentFilter` 从请求中读取表单数据, 并包装 `ServletRequest`,然后可以通过 `ServletRequest.getParameter{asterisk}()` 系列方法提供表单数据.

[[filters-forwarded-headers]]
=== 转发请求头
[.small]#<<web-reactive.adoc#webflux-forwarded-headers, WebFlux>>#

当通过代理主机或者端口或者其他方案请求时(例如,负载均衡) ,从客户端角度看,创建正确的主机,端口或者其他 Schema 成为一项挑战,

https://tools.ietf.org/html/rfc7239[RFC 7239] 定义了代理可以用来提供有关原始请求信息的转发 HTTP 头.  还有其他非标准头文件,包括 `X-Forwarded-Host`, `X-Forwarded-Port`, `X-Forwarded-Proto`, `X-Forwarded-Ssl`, 和 `X-Forwarded-Prefix`.

`ForwardedHeaderFilter` 是一个 Servlet 过滤器,它根据 `Forwarded` 头部信息修改请求的主机,端口和 Schema,然后删除请求头. 过滤器依赖于包装请求,并且 ,必须先于其他过滤器(例如 `RequestContextFilter`) 进行排序, 应该与修改后的请求而不是原始请求一起使用.

当转发请求头时需要注意的安全事项,因为应用程序无法知道请求头是代理按我们想的那样添加还是由客户端恶意添加,这就是为什么应该将信任边界的代理配置为删除来自外部的不受信任的转发请求头.  您还可以使用 `removeOnly=true` 配置 `ForwardedHeaderFilter`,在这种情况下,它会删除但不使用请求头.

为了支持<<mvc-ann-async,异步请求>>并且可以处理错误的情况, 过滤器应使用 `DispatcherType.ASYNC` 和 `DispatcherType.ERROR` 映射.
如果使用 Spring Framework 的 `AbstractAnnotationConfigDispatcherServletInitializer`(请参阅<<mvc-container-config,Servlet 配置>>) 所有过滤器都将自动注册 为 dispatch 类型.  但是,如果通过 `web.xml` 或在 Spring Boot 中 `FilterRegistrationBean` ,除了 `DispatcherType.REQUEST` 之外,还必须包含 `DispatcherType.ASYNC` 和 `DispatcherType.ERROR`.

[[filters-shallow-etag]]
=== Shallow ETag

`ShallowEtagHeaderFilter` 过滤器通过缓存写入响应的内容并从中计算 MD5 哈希来创建 "`shallow`" ETag.  客户端下次发送时, 它会执行相同操作,但它也会将计算值与 `If-None-Match` 请求头进行比较,如果两者相等,则返回 304(NOT_MODIFIED) .

此策略可以节省网络带宽,但不能节省 CPU,因为必须为每个请求计算完整响应.  前面描述的控制器级别的其他策略可以避免计算.  请参阅 <<mvc-caching,HTTP 缓存>>.

此过滤器具有 `writeWeakETag` 参数,该参数将过滤器配置为写入弱 ETag,类似于以下内容: `W/"02a2d595e6ed9a0b24f027f2b63b134d6"`(如 https://tools.ietf.org/html/rfc7232#section-2.3[RFC 7232 Section 2.3]) .

为了支持<< mvc-ann-async,异步请求>>,此过滤器必须与 `DispatcherType.ASYNC` 映射,以便过滤器可以延迟并成功生成 ETag 到最后一个异步调度的末尾.  如果使用 Spring Framework 的 `AbstractAnnotationConfigDispatcherServletInitializer`(请参阅 <<mvc-container-config>>) ,则会为所有调度类型自动注册所有过滤器.  但是,如果通过 `web.xml` 或在 Spring Boot 中通过 `FilterRegistrationBean` 注册过滤器,请确保包括
`DispatcherType.ASYNC`

[[filters-cors]]
=== CORS
[.small]#<<web-reactive.adoc#webflux-filters-cors, WebFlux>>#

Spring MVC 通过控制器上的注解为 CORS 配置提供细粒度的支持.  但是,当与 Spring Security 一起使用时,我们建议在 Spring Security 的过滤器链之前配置的内置 `CorsFilter`.

有关更多详细信息,请参阅  <<mvc-cors>> 和 <<mvc-cors-filter>> 过滤器部分.

[[mvc-controller]]
== 注解控制器
[.small]#<<web-reactive.adoc#webflux-controller, WebFlux>>#

Spring MVC 提供了基于注解的编程模型,其中 `@Controller` 和 `@RestController` 组件使用注解来表示请求映射、请求输入、异常处理等. 被注解的控制器拥有灵活的方法签名,并且无需扩展基类或实现特定的接口. 以下示例显示了由注解定义的控制器:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class HelloController {

		@GetMapping("/hello")
		public String handle(Model model) {
			model.addAttribute("message", "Hello World!");
			return "index";
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.ui.set

	@Controller
	class HelloController {

		@GetMapping("/hello")
		fun handle(model: Model): String {
			model["message"] = "Hello World!"
			return "index"
		}
	}
----

在前面的示例中,该方法接受 `Model` 并将视图名称作为 `String` 返回,但是存在许多其他选项,本章稍后将对其进行说明.

TIP: 有关 https://spring.io/guides[spring.io] 的指南和教程,请使用本节中介绍的基于注解的编程模型.



[[mvc-ann-controller]]
=== Declaration
[.small]#<<web-reactive.adoc#webflux-ann-controller, WebFlux>>#

您可以在 Servlet 的 `WebApplicationContext` 中使用标准的 Spring bean 定义来定义控制器 bean. `@Controller` 模板允许自动检测, 与 Spring 支持检测类路径中的 `@Component` 类一样,会自动注册 bean 定义. 它还充当注解类的模板,表示它充当的是 Web 组件的角色.

要启用 `@Controller` bean 的自动检测,您可以将组件扫描添加到 Java 配置中,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan("org.example.web")
	public class WebConfig {

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan("org.example.web")
	class WebConfig {

		// ...
	}
----

以下示例显示了与前面示例等效的 XML 配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:component-scan base-package="org.example.web"/>

		<!-- ... -->

	</beans>
----

`@RestController` 是一个<<core.adoc#beans-meta-annotations, 组合注解>>,它本身由 `@Controller` 和 `@ResponseBody` 元注解组成.  其每个方法都是类级别(type-level) 的 `@ResponseBody` 注解,因此,直接写入响应主体与视图渲染和使用 HTML 模板.

[[mvc-ann-requestmapping-proxying]]
==== AOP 代理

在某些情况下,您需要在运行时使用 AOP 代理装饰控制器.  例如,如果您想在控制器上直接使用 `@Transactional` 注解.  在这种情况下,对于控制器而言,我们建议使用基于类的代理.  这通常也是控制器的默认选择.  但是,如果控制器没有实现 Spring Context 回调的接口 (例如 `InitializingBean`, `*Aware` 等) , 则可能需要显式配置基于类的代理.
例如,使用 `<tx:annotation-driven/>`,您可以更改为 `<tx:annotation-driven proxy-target-class="true"/>`. 使用 `@EnableTransactionManagement` ,你可以更改为 `@EnableTransactionManagement(proxyTargetClass = true)`

[[mvc-ann-requestmapping]]
=== Request Mapping
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping, WebFlux>>#

`@RequestMapping` 注解用于将请求映射到控制器方法. 它具有各种属性,可以通过 URL、HTTP 方法、请求参数、请求头参数(headers) 和媒体类型进行匹配.  可以在类级别使用它来表示共享映射,或在方法级别上用于缩小到特定的端点映射范围.

还有 `@RequestMapping` 的 HTTP 方法特定的缩写变量:

* `@GetMapping`
* `@PostMapping`
* `@PutMapping`
* `@DeleteMapping`
* `@PatchMapping`

这些简洁的注解是 <<mvc-ann-requestmapping-composed>>,因为,大多数的控制器方法应该映射到 HTTP 方法而不是使用 `@RequestMapping`. 默认情况下, `@RequestMapping` 和所有 HTTP 方法匹配. 在类上定义的仍然需要 `@RequestMapping` 来表示共享映射.

以下示例具有类和方法级别映射:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RestController
	@RequestMapping("/persons")
	class PersonController {

		@GetMapping("/{id}")
		public Person getPerson(@PathVariable Long id) {
			// ...
		}

		@PostMapping
		@ResponseStatus(HttpStatus.CREATED)
		public void add(@RequestBody Person person) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RestController
	@RequestMapping("/persons")
	class PersonController {

		@GetMapping("/{id}")
		fun getPerson(@PathVariable id: Long): Person {
			// ...
		}

		@PostMapping
		@ResponseStatus(HttpStatus.CREATED)
		fun add(@RequestBody person: Person) {
			// ...
		}
	}
----



[[mvc-ann-requestmapping-uri-templates]]
==== URI 模式匹配
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-uri-templates, WebFlux>>#

`@RequestMapping` 可以使用 URL patterns 来映射. 这里有两种选择:

* `PathPattern` -- 与 URL 路径匹配的预解析模式 (也预定义为“ PathContainer”) .  专为 web 使用而设计， 该解决方案可有效处理编码和路径参数， 并有效匹配.
* `AntPathMatcher` -- 根据字符串路径匹配字符串模式.  这在 Spring 配置中还用于在类路径， 文件系统和其他位置上选择资源的原始解决方案.  它效率较低， 并且字符串路径输入对于有效处理 URL 的编码和其他问题是一个挑战.

`PathPattern` 是推荐用于 Web 应用程序的解决方案， 它是 Spring WebFlux 中的唯一选择.  在 5.3 版之前， `AntPathMatcher` 是Spring MVC 中的唯一选择， 并且是默认设置.  但是， 可以在 <<mvc-config-path-matching, MVC config>> 启用 `PathPattern`
.

`PathPattern` 与 `AntPathMatcher` 支持相同的语法. 此外， 它还支持 capturing pattern, 例如. `+{*spring}+`, 用于匹配路径末尾 0 个或多个路径. `PathPattern` 还限制了 `+**+` 的使用， 以匹配多个路径段， 因此仅在模式末尾才允许使用. 当为给定请求选择最佳匹配模式时， 这消除了许多歧义的情况.有关完整的语法， 请参阅 {api-spring-framework}/web/util/pattern/PathPattern.html[PathPattern] 和 {api-spring-framework}/util/AntPathMatcher.html[AntPathMatcher].

示例:

* `+"/resources/ima?e.png"+` - match one character in a path segment
* `+"/resources/*.png"+` - match zero or more characters in a path segment
* `+"/resources/**"+` - match multiple path segments
* `+"/projects/{project}/versions"+` - match a path segment and capture it as a variable
* `+"/projects/{project:[a-z]+}/versions"+` - match and capture a variable with a regex

您还可以使用 `@PathVariable` 声明 URI 变量并访问它们的值,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {
		// ...
	}
----


您可以在类和方法级别声明 URI 变量,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@RequestMapping("/owners/{ownerId}")
	public class OwnerController {

		@GetMapping("/pets/{petId}")
		public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	@RequestMapping("/owners/{ownerId}")
	class OwnerController {

		@GetMapping("/pets/{petId}")
		fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {
			// ...
		}
	}
----

URI 变量会自动转换为适当的类型,或者引发 `TypeMismatchException`.  默认情况下支持简单类型(`int`, `long`, `Date` 等) ,您也可以注册对任何其他数据类型的支持.  请参见 <<mvc-ann-typeconversion>> 和 <<mvc-ann-initbinder>>.

你可以显示命名 URI 变量(例如, `@PathVariable("customId")` ),但是如果名称是相同的,并且代码是使用调试信息编译的,或者在 Java 8 中使用 `-parameters` 编译器标记.  则可以保留该详细信息.

语法 `{varName:regex}` 声明一个具有正则表达式的 URI 变量,其语法为 `{varName:regex}`. 例如,给定 URL `"/spring-web-3.0.5.jar"`,以下方法提取名称,版本和文件扩展名:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
	public void handle(@PathVariable String name, @PathVariable String version, @PathVariable String ext) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
	fun handle(@PathVariable name: String, @PathVariable version: String, @PathVariable ext: String) {
		// ...
	}
----

URI 路径模式还可以嵌入  `${...}`,在启动时通过 `PropertySourcesPlaceholderConfigurer` 解析本地、系统、环境和其他属性源时解析的占位符. 例如,这种模式可以使用基于某些外部配置对基 URL 进行参数化


[[mvc-ann-requestmapping-pattern-comparison]]
==== 模式比较
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-pattern-comparison, WebFlux>>#

当多个模式与 URL 匹配时， 必须选择最佳匹配.  根据是否启用了已解析的 `PathPattern`， 使用以下方法之一完成此操作:

* {api-spring-framework}/web/util/pattern/PathPattern.html#SPECIFICITY_COMPARATOR[`PathPattern.SPECIFICITY_COMPARATOR`]
* {api-spring-framework}/util/AntPathMatcher.html#getPatternComparator-java.lang.String-[`AntPathMatcher.getPatternComparator(String path)`]

两者都有助于对模式进行排序， 并将最匹配的放在顶层.如果 URI 变量的数量较少且单个通配符计为 1 且双通配符计为 2,那么模式就不那么具体了. 如果模式得到的分数相等,那么会选择较长的模式匹配. 如果分数和长度都相同,则会选择拥有比通配符更多的 URI 变量的模式.

默认映射模式(`/{asterisk}{asterisk}`)从评分中排除,并始终排在最后.  此外,前缀模式(例如 `/public/{asterisk}{asterisk}`) 被认为比没有双通配符的其他模式更不具体.

有关完整的详细信息， 请单击上面的链接到模式比较.

[[mvc-ann-requestmapping-suffix-pattern-match]]
==== 后缀匹配

从 5.3 开始， 默认情况下 Spring MVC 不再执行 `.{asterisk}` 后缀模式匹配,以便映射到 `/person` 的控制器也隐式映射到 `/person.{asterisk}`. 路径扩展不再用于解释请求的响应内容类型  - 例如,`/person.pdf`,`/person.xml` 等.

当浏览器用于发送难以持续交互的 `Accept` 头时,必须以这种方式使用文件扩展名. 目前,这不再是必需的,判断 `Accept` 头应该是首选.

随着时间的推移,文件扩展名的使用已经证明有多种方式存在问题.  当使用 URI 变量,路径参数和 URI 编码进行覆盖时,它可能会导致歧义.  有关基于 URL 的授权和安全性的推理(有关更多详细信息,请参阅下一节) 也变得更加困难.

要完全禁用 5.3 之前的版本中的路径扩展， 请进行以下设置: :

* `useSuffixPatternMatching(false)`,  <<mvc-config-path-matching, PathMatchConfigurer>>
* `favorPathExtension(false)`,  <<mvc-config-content-negotiation, ContentNegotiationConfigurer>>

除了通过 `"Accept"` 头之外， 还有一种方法可以请求内容类型， (例如,在浏览器中输入 URL 时).  路径扩展的一种安全替代方法是使用查询参数策略. 如果必须使用文件扩展名,请考虑通过 <<mvc-config-content-negotiation,ContentNegotiationConfigurer>> 的 `mediaTypes` 属性将它们限制为只允许注册的扩展名列表.

[[mvc-ann-requestmapping-rfd]]
==== 后缀匹配和 RFD

反射文件下载(Reflected file download) 攻击与 XSS 类似,因为它依赖请求输入,例如查询参数、URI 变量,并且在响应中被反射. 但是,RFD 攻击不是将 JavaScript 插入 HTML,而是依赖浏览器切换来执行下载,进而在之后的双击时将响应作为可执行脚本处理.

在 Spring MVC 中,`@ResponseBody` 和 `ResponseEntity` 方法存在风险,因为它们可以呈现不同的内容类型,客户端可以通过 URL 路径扩展来请求.  禁用后缀模式匹配并使用路径扩展进行内容协商可降低风险,但不足以防止 RFD 攻击.

为了防止 RFD 攻击,在呈现响应主体之前,需要在 Spring MVC 添加 `Content-Disposition:inline;filename=f.txt` 头用于提供固定和安全的下载文件. 只有在 URL 路径包含的文件扩展名中既不包含白名单,也没有为内容协商显式注册以时,才需要这样做.  但是,在浏览器直接输入 URL 时,可能会产生副作用.

默认情况下,有许多常见的路径扩展白名单. 具有自定义 `HttpMessageConverter` 实现的应用程序可以显式注册内容协商的文件扩展名,以避免为这些扩展添加 `Content-Disposition` 头.  请参阅<<mvc-config-content-negotiation>>

有关 RFD 的其他建议,请参阅 https://pivotal.io/security/cve-2015-5211[CVE-2015-5211]


[[mvc-ann-requestmapping-consumes]]
==== 消费者媒体类型
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-consumes, WebFlux>>#

您可以根据请求的 `Content-Type` 缩小请求映射范围,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping(path = "/pets", consumes = "application/json") // <1>
	public void addPet(@RequestBody Pet pet) {
		// ...
	}
----
<1> 使用 `consumes` 属性来缩小内容类型的映射.


[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/pets", consumes = ["application/json"]) // <1>
	fun addPet(@RequestBody pet: Pet) {
		// ...
	}
----
<1> 使用 `consumes` 属性来缩小内容类型的映射.

`consumes` 属性还支持否定表达式 - 例如,`!text/plain` 表示除 `text/plain` 之外的任何内容类型.

您可以在类级别声明共享 `consumes` 属性.  但是,与大多数其他请求映射属性不同,在类级别使用时,方法级别会 `consumes` 属性覆盖而不是扩展类级别声明.

TIP: `MediaType` 为常用媒体类型提供常量,例如 `APPLICATION_JSON_VALUE` 和 `APPLICATION_XML_VALUE`.


[[mvc-ann-requestmapping-produces]]
==== 生产者媒体类型
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-produces, WebFlux>>#

您可以根据 `Accept` 请求头和控制器方法生成的内容类型列表来缩小请求映射,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path = "/pets/{petId}", produces = "application/json") // <1>
	@ResponseBody
	public Pet getPet(@PathVariable String petId) {
		// ...
	}
----
<1>  使用 `produces` 属性来缩小内容类型的映射.


[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/pets/{petId}", produces = ["application/json"]) // <1>
	@ResponseBody
	fun getPet(@PathVariable petId: String): Pet {
		// ...
	}
----
<1>  使用 `produces` 属性来缩小内容类型的映射.

媒体类型可以指定字符集.  支持否定表达式 - 例如, `!text/plain` 表示 "text/plain" 以外的任何内容类型.

您可以在类级别声明共享的 `produces` 属性.  但是,与大多数其他请求映射属性不同,在类级别使用时,方法级别会生成属性覆盖,而不是扩展类级别声明.

TIP: `MediaType` 为常用媒体类型提供常量,例如 `APPLICATION_JSON_UTF8_VALUE` 和 `APPLICATION_XML_VALUE`.


[[mvc-ann-requestmapping-params-and-headers]]
==== 参数, 请求头
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-params-and-headers, WebFlux>>#

您可以根据请求参数条件缩小请求映射.  您可以测试是否存在请求参数(`myParam`) ,缺少一个(`!myParam`) 或特定值(`myParam=myValue`) .  以下示例显示如何测试特定值:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") // <1>
	public void findPet(@PathVariable String petId) {
		// ...
	}
----
<1> 测试 `myParam` 是否等于 `myValue`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/pets/{petId}", params = ["myParam=myValue"]) // <1>
	fun findPet(@PathVariable petId: String) {
		// ...
	}
----
<1> 测试 `myParam` 是否等于 `myValue`.

您还可以将其与请求头条件一起使用,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path = "/pets", headers = "myHeader=myValue") // <1>
	public void findPet(@PathVariable String petId) {
		// ...
	}
----
<1> 测试 `myParam` 是否等于 `myValue`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/pets", headers = ["myHeader=myValue"]) // <1>
	fun findPet(@PathVariable petId: String) {
		// ...
	}
----

TIP: 您可以将 `Content-Type` 和 `Accept` 与 `headers` 条件匹配,但最好使用<<mvc-ann-requestmapping-consumes, consumes>> 和 <<mvc-ann-requestmapping-produces, produces>> 替代.


[[mvc-ann-requestmapping-head-options]]
==== HTTP HEAD, OPTIONS
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-head-options, WebFlux>>#

`@GetMapping` (和 `@RequestMapping(method=HttpMethod.GET)`)一样,为了请求映射的目的,透明地支持 HTTP HEAD 以进行请求映射. 控制器方法无需更改.  在 `javax.servlet.http.HttpServlet` 中应用的响应包确保有 `Content-Length` 头并且设置为写入的字节数,但实际上不会写入响应.

`@GetMapping` (和 `@RequestMapping(method=HttpMethod.GET)`)一样,为了请求映射的目的,被隐式映射到并支持 HTTP HEAD,处理 HTTP HEAD 请求就像它是 HTTP GET 一样,但不是写入正文,而是计算字节数并设置 `Content-Length` 头.

默认情况下,HTTP OPTIONS 通过设置 `Allow` 响应头来为所有具有匹配 URL 模式的 `@RequestMapping` 方法中列出的 HTTP 方法列表来处理 HTTP 选项.

对于没有 HTTP 方法声明的 `@RequestMapping`,`Allow` 请求头可以设置为 `GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS`.  控制器方法应始终声明支持的 HTTP 方法(例如,通过使用特定于 HTTP 方法的变体: `@GetMapping`, `@PostMapping` 等) .

您可以将 `@RequestMapping` 方法显式映射到 HTTP HEAD 和 HTTP OPTIONS,但在常见情况下这不是必需的.


[[mvc-ann-requestmapping-composed]]
==== 自定义注解
[.small]#<<web-reactive.adoc#mvc-ann-requestmapping-head-options, WebFlux>>#

Spring MVC 支持使用 <<core.adoc#beans-meta-annotations, 组合注解>>进行请求映射.  这些注解本身是使用 `@RequestMapping` 进行元注解的,并且用于重新声明具有更窄,更具体目的的 `@RequestMapping` 属性的子集(或全部) .

`@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`, 和 `@PatchMapping` 就是组合注解最好的示例, 提供它们是因为.
可以说,大多数控制器方法应该映射到特定的 HTTP 方法,而不是使用 `@RequestMapping`,默认情况下,它与所有 HTTP 方法匹配.  如果您需要组合注解的示例,请查看如何声明这些注解.

Spring MVC 还支持使用自定义请求匹配逻辑的自定义请求映射属性. 这是一个更高级的选项,需要继承 `RequestMappingHandlerMapping` 并覆盖 `getCustomMethodCondition` 方法, 您可以在其中检查自定义属性并返回自己的 `RequestCondition`.

[[mvc-ann-requestmapping-registration]]
==== 显式注册
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-registration, WebFlux>>#

您可以以编程方式注册处理程序方法,您可以将其用于动态注册或高级情况,例如不同 URL 下的同一处理程序的不同实例.  以下示例注册处理程序方法:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class MyConfig {

		@Autowired
		public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) // <1>
				throws NoSuchMethodException {

			RequestMappingInfo info = RequestMappingInfo
					.paths("/user/{id}").methods(RequestMethod.GET).build(); // <2>

			Method method = UserHandler.class.getMethod("getUser", Long.class); // <3>

			mapping.registerMapping(info, handler, method); // <4>
		}
	}
----
<1> 为控制器注入目标处理程序和处理程序映射
<2> 准备映射元数据的请求
<3> 获取处理程序方法
<4> 添加注册

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class MyConfig {

		@Autowired
		fun setHandlerMapping(mapping: RequestMappingHandlerMapping, handler: UserHandler) { // <1>
			val info = RequestMappingInfo.paths("/user/{id}").methods(RequestMethod.GET).build() // <2>
			val method = UserHandler::class.java.getMethod("getUser", Long::class.java) // <3>
			mapping.registerMapping(info, handler, method) // <4>
		}
	}
----
<1> 为控制器注入目标处理程序和处理程序映射
<2> 准备映射元数据的请求
<3> 获取处理程序方法
<4> 添加注册

[[mvc-ann-methods]]
=== 程序处理方法
[.small]#<<web-reactive.adoc#webflux-ann-methods, WebFlux>>#

`@RequestMapping` 处理程序方法具有灵活的签名,可以从一系列控制器方法参数和返回值中进行选择.


[[mvc-ann-arguments]]
==== 方法参数
[.small]#<<web-reactive.adoc#webflux-ann-arguments, WebFlux>>#

下表显示了控制器方法参数,任何参数都不支持响应式(Reactive)类型.

JDK 8  `java.util.Optional` 作为方法参数来支持的,它与具有 `required` 属性的注解(例如 `@RequestParam`, `@RequestHeader` 等相结合).  并且等同于 `required=false`.

[cols="1,2", options="header"]
|===
| 控制器方法参数 | 	描述

| `WebRequest`, `NativeWebRequest`
| 无需直接使用 Servlet API 即可访问请求参数以及 request 和 session 属性.

| `javax.servlet.ServletRequest`, `javax.servlet.ServletResponse`
| 选择任何特定的请求或响应类型 - 例如,`ServletRequest`, `HttpServletRequest` 或 Spring 的 `MultipartRequest`, `MultipartHttpServletRequest`.

| `javax.servlet.http.HttpSession`
| 强制进行会话.  因此,此类参数永远不可能为 `null`. 请注意,会话访问不是线程安全的.  如果允许多个请求同时访问会话,请考虑将 `RequestMappingHandlerAdapter` 实例的 `synchronizeOnSession` 标志设置为 `true`.

| `javax.servlet.http.PushBuilder`
| Spring4.0 push 生成器 API 用于编程 HTTP/2 资源推送, 请注意,根据 Servlet 规范,如果客户端不支持该 HTTP/2 功能,则注入的 `PushBuilder` 实例可以为 `null`.

| `java.security.Principal`
| 当前经过身份验证的用户 - 如果已知,可能是特定的 `Principal` 实现类.

请注意，不会立即解析此参数，如果它被注解了以允许自定义解析器解析它
在通过 `HttpServletRequest#getUserPrincipal` 恢复默认 resolution 之前。
例如，Spring Security `Authentication` 实现了 `Principal` 并且将通过这样的方式注入
`HttpServletRequest#getUserPrincipal`，除非它也用 `@AuthenticationPrincipal` 注解，在这种情况下它
由自定义 Spring Security 解析器通过 `Authentication#getPrincipal` 解析。

| `HttpMethod`
| 请求的 HTTP 方法.

| `java.util.Locale`
| 当前请求区域设置,由最可用的 `LocaleResolver`(实际上是已配置的 `LocaleResolver` 或 `LocaleContextResolver`) 确定.

| `java.util.TimeZone` + `java.time.ZoneId`
| 与当前请求关联的时区,由 `LocaleContextResolver` 确定

| `java.io.InputStream`, `java.io.Reader`
| 用于访问 Servlet API 暴露的原始请求主体.

| `java.io.OutputStream`, `java.io.Writer`
| 用于访问 Servlet API 暴露的原始响应主体.

| `@PathVariable`
| 用于访问 URI 模板变量.  请参阅<<mvc-ann-requestmapping-uri-templates>>.

| `@MatrixVariable`
| 用于访问 URI 路径段中的名称 - 值对.  请参见<<mvc-ann-matrix-variables>>.

| `@RequestParam`
| 用于访问 Servlet 请求参数,包括多部分文件.  参数值将转换为声明的方法参数类型.  请参阅 <<mvc-ann-requestparam>> 以及 <<mvc-multipart-forms>>.  请注意,对于简单的参数值,使用 `@RequestParam` 是可选的.  请参阅本表末尾的 "任何其他参数".


| `@RequestHeader`
| 用于访问请求头.  头的值将转换为声明的方法参数类型.  请参阅<<mvc-ann-requestheader>>.

| `@CookieValue`
| 用于访问 cookie.  Cookie 值将转换为声明的方法参数类型.  请参阅<<mvc-ann-cookievalue>>.

| `@RequestBody`
| 用于访问 HTTP 请求正文.  通过使用 `HttpMessageConverter` 实现将正文内容转换为声明的方法参数类型.  请参阅 <<mvc-ann-requestbody>>.

| `HttpEntity<B>`
| 用于访问请求头和正文.  使用 HttpMessageConverter 转换正文.  见<<mvc-ann-httpentity,HttpEntity>>.

| `@RequestPart`
| 要访问 `multipart/form-data` 请求中的部件,请使用 `HttpMessageConverter` 转换部件的主体.  见<<mvc-multipart-forms>>.

| `java.util.Map`, `org.springframework.ui.Model`, `org.springframework.ui.ModelMap`
| 用于访问 HTML 控制器中使用的模型,并将其作为视图呈现的一部分暴露给模板.

| `RedirectAttributes`
| 指定在重定向(即,要附加到查询字符串) 时使用的属性,以及临时存储的 flash 属性,直到重定向后的请求为止.  请参阅<<mvc-redirecting-passing-data>> 和<<mvc-flash-attributes>>.

| `@ModelAttribute`
| 用于访问模型中的现有属性(如果不存在则实例化) ,并应用数据绑定和验证.  请参阅<<mvc-ann-modelattrib-method-args>>以及  <<mvc-ann-modelattrib-methods>>和<<mvc-ann-initbinder>>.

    请注意,使用 `@ModelAttribute` 是可选的(例如,设置其属性) .  请参阅本表末尾的 "任何其他参数".

| `Errors`, `BindingResult`
| 用于访问来自命令对象的验证和数据绑定的错误(即 `@ModelAttribute` 参数) 或来自验证 `@RequestBody` 或 `@RequestPart` 参数的错误.  您必须在经过验证的方法参数后立即声明 `Errors` 或 `BindingResult` 参数.

| `SessionStatus` + class-level `@SessionAttributes`
| 用于标记表单处理完成,从而触发通过类级别 `@SessionAttributes` 注解声明的会话属性的清除.  有关更多详细信息,请参阅  <<mvc-ann-sessionattributes>>.

| `UriComponentsBuilder`
| 用于准备相对于当前请求的主机,端口,方案,上下文路径和 servlet 映射的文字部分的 URL.  请参阅<<mvc-uri-building>>.

| `@SessionAttribute`
| 用于访问任何会话属性,与由于类级别 `@SessionAttributes` 声明的结束形成对比.  有关更多详细信息,请参阅<<mvc-ann-sessionattribute>>.

| `@RequestAttribute`
| 用于访问请求属性.  有关更多详细信息,请参阅<<mvc-ann-requestattrib>>.

| Any other argument
| 如果方法参数与此表中的任何值不匹配,并且它是一个简单类型(由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty] 确定, 则它被解析为 `@RequestParam`. 否则,它将被解析为 `@ModelAttribute`.
|===


[[mvc-ann-return-types]]
==== 返回值
[.small]#<<web-reactive.adoc#webflux-ann-return-types, WebFlux>>#

下表描述了支持的控制器方法返回值.  所有返回值都支持响应式类型.

[cols="1,2", options="header"]
|===
| Controller method return value | Description

| `@ResponseBody`
|  返回值通过 `HttpMessageConverter` 实现转换并写入响应.  请参阅<<mvc-ann-responsebody>>.

| `HttpEntity<B>`, `ResponseEntity<B>`
| 指定完整响应(包括 HTTP 头和主体) 的返回值将通过 `HttpMessageConverter` 实现转换并写入响应.  请参阅 <<mvc-ann-responseentity>>.

| `HttpHeaders`
| 用于返回带头部信息且没有正文的响应.

| `String`
| 要使用 `ViewResolver` 实现解析的视图名称,并与隐式模型一起使用 - 通过命令对象和 `@ModelAttribute` 方法确定.  处理程序方法还可以通过声明 `Model` 参数以编程方式丰富模型(请参阅<<mvc-ann-requestmapping-registration>> ) .

| `View`
| 用于与隐式模型一起呈现的 `View` 实例 - 通过命令对象和 `@ModelAttribute` 方法确定.  处理程序方法还可以通过声明 `Model` 参数以编程方式丰富模型(请参阅<<mvc-ann-requestmapping-registration>>) .

| `java.util.Map`, `org.springframework.ui.Model`
| 要添加到隐式模型的属性,通过 `RequestToViewNameTranslator` 隐式确定视图名称.

| `@ModelAttribute`
| 要添加到模型的属性,通过 `RequestToViewNameTranslator` 隐式确定视图名称.

  请注意,`@ModelAttribute` 是可选的.  请参阅本表末尾的 "任何其他返回值".

| `ModelAndView` object
| 要使用的视图和模型属性,以及(可选) 响应状态.

| `void`
| 如果具有 `void` 返回类型(或返回值为 `null` ) 的方法,如果它还具有 `ServletResponse`,`OutputStream` 参数或 `@ResponseStatus` 注解, 则认为已完全处理该响应.  如果控制器已进行正 `ETag` 或 `lastModified` 时间戳检查,则也是如此(有关详细信息,请参阅 <<mvc-caching-etag-lastmodified>> ) .
    如果以上都不是真的,则 `void` 返回类型也可以指示REST控制器的 "无响应主体" 或HTML控制器的默认视图名称选择.

| `DeferredResult<V>`
| 从任何线程异步生成任何前面的返回值 - 例如,由于某些事件或回调.  请参阅 <<mvc-ann-async>> 和 <<mvc-ann-async-deferredresult>>.

| `Callable<V>`
| 在 Spring MVC 管理的线程中异步生成上述任何返回值.  请参阅 和 <<mvc-ann-async-callable,Callable>>.

| `ListenableFuture<V>`,
  `java.util.concurrent.CompletionStage<V>`,
  `java.util.concurrent.CompletableFuture<V>`
| 作为替代 `DeferredResult` 的便捷操作(例如,当底层服务返回其中一个时) .

| `ResponseBodyEmitter`, `SseEmitter`
| 使用 `HttpMessageConverter` 实现以异步方式发送对象流以写入响应.  还支持 `ResponseEntity` 的主体.  请参阅 <<mvc-ann-async>> 和 <<mvc-ann-async-http-streaming>>.

| `StreamingResponseBody`
| 异步写入响应 `OutputStream`.  还支持 `ResponseEntity` 的主体.  请参阅 <<mvc-ann-async>> 和 <<mvc-ann-async-http-streaming>>.

| Reactive types -- Reactor, RxJava, or others through `ReactiveAdapterRegistry`
| 使用 `multi-value` 流(例如,`Flux`, `Observable`) 替代 `DeferredResult` 收集到 `List` 中.

 对于流式场景(例如, `text/event-stream`, `application/json+stream`), `SseEmitter` 和 `ResponseBodyEmitter` 使用的是在 Spring MVC 管理的线程上执行 `ServletOutputStream` 阻塞I/O,这是 针对每一个 `Write` 的

请参阅 <<mvc-ann-async>> 和 <<mvc-ann-async-reactive-types>>.

| 其他任何返回值
| 任何与此表中任何早期值不匹配且返回值为 `String` 或 `void` 的返回值都被视为视图名称(通过 `RequestToViewNameTranslator` 应用默认视图名称选择) , 前提是它不是简单类型,由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty] 确定,简单类型的值仍未解决.
|===


[[mvc-ann-typeconversion]]
==== 类型转换
[.small]#<<web-reactive.adoc#webflux-ann-typeconversion, WebFlux>>#

如果参数声明为 `String` 以外的其他参数,则表示某些带注解的控制器方法参数(例如 `@RequestParam`, `@RequestHeader`, `@PathVariable`, `@MatrixVariable`, 和 `@CookieValue`) 可能需要进行类型转换.

对于此类情况,将根据配置的转换器自动应用类型转换.  默认情况下,支持简单类型(`int`, `long`, `Date` 和其他) .  您可以通过 `WebDataBinder`(请参阅<<mvc-ann-initbinder>>) 或使用 `FormattingConversionService` 注册 `Formatters` 来自定义类型转换.  请参见 <<core.adoc#format, Spring Field Formatting>>.

类型转换中的一个实际问题是处理空的 String 值. 如果该值由于类型转换而变为 `null`， 则将其视为丢失. `Long`, `UUID`, 和其他目标类型.  如果要允许注入 `null`， 则可以在参数注解中使用 `required` 标志， 或将参数声明为 `@Nullable`.

[NOTE]
====
从 5.3 开始， 即使在类型转换之后， 也将强制使用非 `null` 参数. 如果您的处理程序方法接受 `null` 值， 请在相应的 `@RequestParam` 等注解中将您的参数声明为 `@Nullable` 或将其标记为 `required=false`. 这是最佳实践， 也是针对 5.3 升级中遇到的回归问题的推荐解决方案.

另外， 您也可以专门处理在必需的 `@PathVariable` 的情况下， 生成的 `MissingPathVariableException`. 转换后的空值将被视为空的原始值， 因此将抛出相应的  `Missing...Exception`.
====


[[mvc-ann-matrix-variables]]
==== Matrix Variables
[.small]#<<web-reactive.adoc#webflux-ann-matrix-variables, WebFlux>>#

https://tools.ietf.org/html/rfc3986#section-3.3[RFC 3986] 讨论了路径段中的携带键值对.  在 Spring MVC 中,我们将那些基于 Tim Berners-Lee 的 https://www.w3.org/DesignIssues/MatrixURIs.html["`old post`"] 称为 "`matrix variables(矩阵变量) `" ,但它们也可以称为 URI 路径参数.

矩阵变量可以在任意路径段落中出现,每对矩阵变量之间使用分号隔开,多个值可以用逗号隔开(例如,`/cars;color=red,green;year=2012`) , 也可以通过重复的变量名称指定多个值(例如,`color=red;color=green;color=blue`) .

如果 URL 有可能会包含矩阵变量,那么在请求路径的映射配置上就需要使用 URI 模板来体现. 这样才能确保请求可以被正确地映射,而不管矩阵变量在 URI 中是否出现、出现的次序是怎样的等. 以下示例使用矩阵变量:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /pets/42;q=11;r=22

	@GetMapping("/pets/{petId}")
	public void findPet(@PathVariable String petId, @MatrixVariable int q) {

		// petId == 42
		// q == 11
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /pets/42;q=11;r=22

	@GetMapping("/pets/{petId}")
	fun findPet(@PathVariable petId: String, @MatrixVariable q: Int) {

		// petId == 42
		// q == 11
	}
----

由于任意路径段落中都可以含有矩阵变量,在某些场景下,开发者需要用更精确的信息来指定矩阵变量的位置. 以下示例说明如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /owners/42;q=11/pets/21;q=22

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public void findPet(
			@MatrixVariable(name="q", pathVar="ownerId") int q1,
			@MatrixVariable(name="q", pathVar="petId") int q2) {

		// q1 == 11
		// q2 == 22
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /owners/42;q=11/pets/21;q=22

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	fun findPet(
			@MatrixVariable(name = "q", pathVar = "ownerId") q1: Int,
			@MatrixVariable(name = "q", pathVar = "petId") q2: Int) {

		// q1 == 11
		// q2 == 22
	}
----

矩阵变量可以定义为可选,并指定默认值,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /pets/42

	@GetMapping("/pets/{petId}")
	public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {

		// q == 1
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /pets/42

	@GetMapping("/pets/{petId}")
	fun findPet(@MatrixVariable(required = false, defaultValue = "1") q: Int) {

		// q == 1
	}
----

要获取所有矩阵变量,可以使用 `MultiValueMap`,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public void findPet(
			@MatrixVariable MultiValueMap<String, String> matrixVars,
			@MatrixVariable(pathVar="petId") MultiValueMap<String, String> petMatrixVars) {

		// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
		// petMatrixVars: ["q" : 22, "s" : 23]
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	fun findPet(
			@MatrixVariable matrixVars: MultiValueMap<String, String>,
			@MatrixVariable(pathVar="petId") petMatrixVars: MultiValueMap<String, String>) {

		// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
		// petMatrixVars: ["q" : 22, "s" : 23]
	}
----

请注意,您需要启用矩阵变量的使用.  在 MVC Java 配置中,您需要通过 <<mvc-config-path-matching>> 将 `removeSemicolonContent=false` 设置为 `UrlPathHelper`.  在 MVC XML 命名空间中,您可以设置 `<mvc:annotation-driven enable-matrix-variables="true"/>`.


[[mvc-ann-requestparam]]
==== `@RequestParam`
[.small]#<<web-reactive.adoc#webflux-ann-requestparam, WebFlux>>#

您可以使用 `@RequestParam` 注解将 Servlet 请求参数(即查询参数或表单数据) 绑定到控制器中的方法参数.

以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@RequestMapping("/pets")
	public class EditPetForm {

		// ...

		@GetMapping
		public String setupForm(@RequestParam("petId") int petId, Model model) { <1>
			Pet pet = this.clinic.loadPet(petId);
			model.addAttribute("pet", pet);
			return "petForm";
		}

		// ...

	}
----
<1> 使用 `@RequestParam` 绑定 `petId`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.ui.set

	@Controller
	@RequestMapping("/pets")
	class EditPetForm {

		// ...

		@GetMapping
		fun setupForm(@RequestParam("petId") petId: Int, model: Model): String { // <1>
			val pet = this.clinic.loadPet(petId);
			model["pet"] = pet
			return "petForm"
		}

		// ...

	}
----
<1> 使用 `@RequestParam` 绑定 `petId`.

若参数使用了该注解,则该参数默认是必须提供的.但您可以通过将 `@RequestParam` 注解的 `required` 属性设置为 `false` 或通过使用 `java.util.Optional` 包装器声明参数来指定方法参数是可选的.

如果目标方法参数类型不是 `String`,则会自动应用类型转换.  请参阅<<mvc-ann-typeconversion>>.

将参数类型声明为数组或列表允许为同一参数名称解析多个参数值.

当 `@RequestParam` 注解声明为 `Map<String, String>` 或 `MultiValueMap<String, String>` 时, 如果注解中未指定参数名称,则会使用每个给定参数名称的请求参数值填充映射.

请注意,使用 `@RequestParam` 是可选的(例如,设置其属性) .  默认情况下, 任何属于简单值类型的参数(由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty] 确定) 并且未被任何其他参数解析器解析,都被视为使用 `@RequestParam` 进行注解.


[[mvc-ann-requestheader]]
==== `@RequestHeader`
[.small]#<<web-reactive.adoc#webflux-ann-requestheader, WebFlux>>#

您可以使用 `@RequestHeader` 注解将请求头绑定到控制器中的方法参数.

考虑以下请求,请求头为:

[literal]
[subs="verbatim,quotes"]
----
Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300
----

以下示例获取 `Accept-Encoding` 和 `Keep-Alive` 头的值:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/demo")
	public void handle(
			@RequestHeader("Accept-Encoding") String encoding, // <1>
			@RequestHeader("Keep-Alive") long keepAlive) { // <2>
		//...
	}
----
<1> 获取 `Accept-Encoding` 头部信息
<2> 获取 `Keep-Alive` 头部信息.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/demo")
	fun handle(
			@RequestHeader("Accept-Encoding") encoding: String, // <1>
			@RequestHeader("Keep-Alive") keepAlive: Long) { // <2>
		//...
	}
----
<1> 获取 `Accept-Encoding` 头部信息
<2> 获取 `Keep-Alive` 头部信息.

如果目标方法参数类型不是 String,则会自动应用类型转换.  请参阅<<mvc-ann-typeconversion>>.

在 `Map<String, String>,MultiValueMap<String, String>` 或 `HttpHeaders` 参数上使用 `@RequestHeader` 注解时,将使用所有请求头值填充映射.

TIP: 内置支持可用于将逗号分隔的字符串转换为字符串或字符串集或类型转换系统已知的其他类型.  例如,使用 `@RequestHeader("Accept")` 注解的方法参数可以是 `String` 类型,也可以是 `String[]` 或 `List<String>`.


[[mvc-ann-cookievalue]]
==== `@CookieValue`
[.small]#<<web-reactive.adoc#webflux-ann-cookievalue, WebFlux>>#

您可以使用 `@CookieValue` 注解将 HTTP cookie 的值绑定到控制器中的方法参数.

考虑使用以下 cookie 的请求:

[literal,subs="verbatim,quotes"]
----
JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84
----

以下示例显示了如何获取 cookie 值:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/demo")
	public void handle(@CookieValue("JSESSIONID") String cookie) { <1>
		//...
	}
----
<1> 获取 `JSESSIONID` cookie 的值


[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/demo")
	fun handle(@CookieValue("JSESSIONID") cookie: String) { // <1>
		//...
	}
----
<1> 获取 `JSESSIONID` cookie 的值

如果目标方法参数类型不是 String,则会自动应用类型转换.  请参阅<<mvc-ann-typeconversion>>.

[[mvc-ann-modelattrib-method-args]]
==== `@ModelAttribute`
[.small]#<<web-reactive.adoc#webflux-ann-modelattrib-method-args, WebFlux>>#

您可以在方法参数上使用 `@ModelAttribute` 注解来从模型访问属性,或者如果不存在则将其实例化.  model 属性还覆盖了名称与字段名称匹配的 HTTP Servlet 请求参数的值.  这称为数据绑定,它使您不必处理解析和转换单个查询参数和表单字段.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public String processSubmit(@ModelAttribute Pet pet) {
		// method logic...
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
fun processSubmit(@ModelAttribute pet: Pet): String {
	// method logic...
}
----

上面的 `Pet` 实例来源于以下方式之一：:

* 可能来自由 <<mvc-ann-modelattrib-methods,@ModelAttribute 方法>> 添加的模型中检索
* 如果出现模型属性，则从 HTTP 会话中检索类级别的 <<mvc-ann-sessionattributes>> 注解
* 通过 `Converter` 获得，其中模型属性名称与请求值的名称匹配，例如路径变量或请求参数（下面会详细讲解）。
* 它可能是调用了自身的默认构造器被实例化出来的
* 他可能从调用具有与 Servlet 请求参数匹配的参数的 `"primary constructor"`.  参数名称通过 JavaBeans `@ConstructorProperties` 或字节码中的运行时保留参数名称确定.

虽然通常使用 <<mvc-ann-modelattrib-methods,@ModelAttribute method>> 来使用属性填充模型,但另一种替代方法是依赖于 `Converter<String, T>` 和 URI 路径变量.  这适用于模型属性名称与请求值的名称（例如路径变量或请求参数）匹配，并且存在从 `String` 到模型属性类型的 `Converter` 。  在以下示例中, model 属性名称 `account` 匹配 URI 路径变量 `account`,并通过将 String 字符串传递到已注册的 `Converter<String, Account>` 转换器来加载 `Account` :

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PutMapping("/accounts/{account}")
	public String save(@ModelAttribute("account") Account account) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PutMapping("/accounts/{account}")
	fun save(@ModelAttribute("account") account: Account): String {
		// ...
	}
----

下一步就是数据的绑定,`WebDataBinder` 类能将请求参数,包括字符串的查询参数和表单字段等,通过名称匹配到 model 的属性上.
成功匹配的字段在需要的时候会进行一次类型转换(从 String 类型到目标字段的类型) ,然后被填充到 model 对应的属性中, 有关数据绑定(和验证) 的更多信息,请参阅<<core.adoc#validation, Validation>>.  有关自定义数据绑定的更多信息,请参阅<<mvc-ann-initbinder>>.

数据绑定可能导致错误.  默认情况下,会引发 `BindException` .  但是,要在控制器方法中检查此类错误,可以在 `@ModelAttribute` 旁边添加一个 `BindingResult` 参数,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) { // <1>
		if (result.hasErrors()) {
			return "petForm";
		}
		// ...
	}
----
<1> 在 `@ModelAttribute` 旁边添加 `BindingResult`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	fun processSubmit(@ModelAttribute("pet") pet: Pet, result: BindingResult): String { // <1>
		if (result.hasErrors()) {
			return "petForm"
		}
		// ...
	}
----
<1> 在 `@ModelAttribute` 旁边添加 `BindingResult`.

在某些情况下,您可能希望在没有数据绑定的情况下访问 `model` 属性. 对于这种情况,您可以将 model 注入控制器并直接访问它,或者设置 `@ModelAttribute(binding=false)`,如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ModelAttribute
	public AccountForm setUpForm() {
		return new AccountForm();
	}

	@ModelAttribute
	public Account findAccount(@PathVariable String accountId) {
		return accountRepository.findOne(accountId);
	}

	@PostMapping("update")
	public String update(@Valid AccountForm form, BindingResult result,
			@ModelAttribute(binding=false) Account account) { // <1>
		// ...
	}
----
<1> 设置 `@ModelAttribute(binding=false)`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ModelAttribute
	fun setUpForm(): AccountForm {
		return AccountForm()
	}

	@ModelAttribute
	fun findAccount(@PathVariable accountId: String): Account {
		return accountRepository.findOne(accountId)
	}

	@PostMapping("update")
	fun update(@Valid form: AccountForm, result: BindingResult,
			   @ModelAttribute(binding = false) account: Account): String { // <1>
		// ...
	}
----
<1> 设置 `@ModelAttribute(binding=false)`.

通过添加 `javax.validation.Valid` 注解或 Spring 的 `@Validated` 注解(<<core.adoc#validation-beanvalidation, Bean Validation>> 和<<core.adoc#validation, Spring validation>>) ,您可以在数据绑定后自动应用验证.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
		@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
		public String processSubmit(@Valid @ModelAttribute("pet") Pet pet, BindingResult result) { // <1>
			if (result.hasErrors()) {
				return "petForm";
			}
			// ...
		}
----
<1> 验证 `Pet` 实例.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	fun processSubmit(@Valid @ModelAttribute("pet") pet: Pet, result: BindingResult): String { // <1>
		if (result.hasErrors()) {
			return "petForm"
		}
		// ...
	}
----

请注意,使用 `@ModelAttribute` 是可选的(例如,设置其属性) .  默认情况下,任何非简单值类型的参数(由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty] 确定) 并且未被任何其他参数解析器解析,都被视为使用 `@ModelAttribute` 进行注解.

[[mvc-ann-sessionattributes]]
==== `@SessionAttributes`
[.small]#<<web-reactive.adoc#webflux-ann-sessionattributes, WebFlux>>#

`@SessionAttributes` 用于在请求之间的 HTTP Servlet 会话中存储 model 属性.  它是一个类型级别的注解,用于声明特定控制器使用的会话属性.  这通常列出 model 属性的名称或 model 属性的类型,这些属性应该透明地存储在会话中以供后续访问请求使用.

以下示例使用 `@SessionAttributes` 注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@SessionAttributes("pet") // <1>
	public class EditPetForm {
		// ...
	}
----
<1> 使用 `@SessionAttributes` 注解.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	@SessionAttributes("pet") // <1>
	class EditPetForm {
		// ...
	}
----
<1> 使用 `@SessionAttributes` 注解.

在第一个请求中,当名称为 `pet` 的 model 属性添加到模型中时,他会自动保存到 HTTP Servlet 会话中,并保持不变,直到另一个控制器方法使用 `SessionStatus` 方法参数来清除存储,如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@SessionAttributes("pet") // <1>
	public class EditPetForm {

		// ...

		@PostMapping("/pets/{id}")
		public String handle(Pet pet, BindingResult errors, SessionStatus status) {
			if (errors.hasErrors) {
				// ...
			}
			status.setComplete(); // <2>
			// ...
		}
	}
----
<1> 在Servlet会话中存储 `Pet` 值.
<2> 在Servlet会话中清除 `Pet` 值.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Controller
@SessionAttributes("pet") // <1>
class EditPetForm {

	// ...

	@PostMapping("/pets/{id}")
	fun handle(pet: Pet, errors: BindingResult, status: SessionStatus): String {
		if (errors.hasErrors()) {
			// ...
		}
		status.setComplete() // <2>
		// ...
	}
}
----
<1> 在Servlet会话中存储 `Pet` 值.
<2> 在Servlet会话中清除 `Pet` 值.


[[mvc-ann-sessionattribute]]
==== `@SessionAttribute`
[.small]#<<web-reactive.adoc#webflux-ann-sessionattribute, WebFlux>>#

如果需要访问已存在的被全局 session 属性,例如在控制器之外(如通过过滤器) 的(可有可无) ,请在方法参数上使用 `@SessionAttribute` 注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RequestMapping("/")
	public String handle(@SessionAttribute User user) { <1>
		// ...
	}
----
<1> 使用 `@SessionAttribute` 注解.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RequestMapping("/")
	fun handle(@SessionAttribute user: User): String { // <1>
		// ...
	}
----

对于需要添加或删除会话属性的用例,请考虑将 `org.springframework.web.context.request.WebRequest` 或 `javax.servlet.http.HttpSession` 注入控制器方法.

作为控制器工作流的一部分,在会话中临时存储模型属性的方法可以使用 `@SessionAttributes`,详情请参阅<<mvc-ann-sessionattributes>>.

[[mvc-ann-requestattrib]]
==== `@RequestAttribute`
[.small]#<<web-reactive.adoc#webflux-ann-requestattrib, WebFlux>>#

与 `@SessionAttribute` 类似,`@RequestAttribute` 注解可用于访问由过滤器(`Filter`) 或拦截器(`HandlerInterceptor`) 创建的已存在的请求属性:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/")
	public String handle(@RequestAttribute Client client) { // <1>
		// ...
	}
----
<1> 使用 `@RequestAttribute` 注解.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/")
	fun handle(@RequestAttribute client: Client): String { // <1>
		// ...
	}
----
<1> 使用 `@RequestAttribute` 注解.


[[mvc-redirecting-passing-data]]
==== 重定向属性

默认情况下,所有模型属性都被视为在重定向 URL 中暴露为 URI 模板变量.  在其余属性中,原始类型或集合或基本类型数组的属性将自动附加为查询参数.

如果专门为重定向准备了模型实例,期望的结果则是将原始类型属性作为查询参数.  但是,在带注解的控制器中,为了渲染目的,模型可以包含其他属性(例如,下拉字段值) .
为了避免在 URL 中出现此类属性的可能性,`@RequestMapping` 方法可以声明 `RedirectAttributes` 类型的参数, 并使用它来指定可供 `RedirectView` 使用的确切属性.  如果方法重定向,则使用 `RedirectAttributes` 的内容.  否则,使用模型的内容.

`RequestMappingHandlerAdapter` 提供了一个名为 `ignoreDefaultModelOnRedirect` 的标志,您可以使用该标志指示如果控制器方法重定向,则永远不应使用默认模型的内容.
相反,控制器方法应声明 `RedirectAttributes` 类型的属性,如果不这样做,则不应将任何属性传递给 `RedirectView`.  MVC 命名空间和 MVC Java 配置都将此标志设置为 `false`,以保持向后兼容性.  但是,对于新应用程序,我们建议将其设置为 `true`.

请注意,扩展重定向 URL 时,当前请求中的 URI 模板变量会自动可用,您需要通过 `Model` 或 `RedirectAttributes` 显式添加它们.  以下示例显示如何定义重定向:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/files/{path}")
	public String upload(...) {
		// ...
		return "redirect:files/{path}";
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/files/{path}")
	fun upload(...): String {
		// ...
		return "redirect:files/{path}"
	}
----

将数据传递到重定向目标的另一种方法是使用<<mvc-flash-attributes>>.  与其他重定向属性不同,Flash 属性保存在 HTTP 会话中(因此,不会出现在 URL 中) .  有关更多信息,请参阅 Flash 属性.


[[mvc-flash-attributes]]
==== Flash 属性

Flash 属性(flash attributes) 提供了一个请求为另一个请求存储有用属性的方法. 这在重定向的时候最常使用,比如常见的 POST/REDIRECT/GET 模式.  Flash 属性会在重定向前被暂时地保存起来(通常是保存在 session 中) ,重定向后会重新被下一个请求取用并立即从原保存地移除.

为支持 flash 属性,Spring MVC 提供了两个抽象.  `FlashMap` 被用来存储 flash 属性,而用 `FlashMapManager` 来存储、取回、管理 `FlashMap` 的实例.

对 flash 属性的支持默认是启用 "`on`" 的,并不需要显式声明,不过没用到它时它绝不会主动地去创建 HTTP 会话(session) . 对于每个请求,框架都会"`input`" 一个 `FlashMap`,里面存储了从上个请求(如果有) 保存下来的属性;
同时,每个请求也会 "`output`" `FlashMap`,里面保存了要给下个请求使用的属性.  两个 FlashMap 实例在 Spring MVC 应用中的任何地点都可以通过 `RequestContextUtils` 工具类的静态方法取得.

控制器通常不需要直接接触 FlashMap. 一般是通过 `@RequestMapping` 方法去接受 `RedirectAttributes` 类型的参数,然后直接地往其中添加 flash 属性.
通过 `RedirectAttributes` 对象添加进去的 flash 属性会自动被填充到请求的 "`output`" `FlashMap` 对象中去. 类似地,重定向后 "`input`" 的 `FlashMap` 属性也会自动被添加到服务重定向 URL 的控制器参数 `Model` 中去

.匹配请求所使用的 flash 属性
****
flash 属性的概念在其他许多的 Web 框架中也存在,并且实践证明有时可能会导致并发上的问题. 这是因为从定义上讲,flash 属性保存的时间是到下个请求接收到之前.  问题在于,`"next"` 请求不一定刚好就是需要重定向到的那个请求,它有可能是其他的异步请求(比如 polling 请求或者资源请求等) . 这会导致 flash 属性在到达真正的目标请求前就被移除了.

为了减少这个问题发生的可能性,重定向视图 `RedirectView` 会自动为一个 `FlashMap` 实例记录其目标重定向URL的路径和查询参数. 然后,默认的 `FlashMapManager` 会在为请求查找其该 "input" 的 `FlashMap` 时,匹配这些信息.

这并不能完全解决重定向的并发问题,但极大程度地减少了这种可能性,因为它可以从重定向 URL 已有的信息中来做匹配. 因此,一般只有在重定向的场景下,才推荐使用 flash 属性.
****


[[mvc-multipart-forms]]
==== Multipart
[.small]#<<web-reactive.adoc#webflux-multipart-forms, WebFlux>>#

<<mvc-multipart,启用>> `MultipartResolver` 后,将解析具有 `multipart/form-data` 的 POST 请求的内容,并将其作为常规请求参数进行访问.  以下示例访问一个常规表单字段和一个上载文件:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class FileUploadController {

		@PostMapping("/form")
		public String handleFormUpload(@RequestParam("name") String name,
				@RequestParam("file") MultipartFile file) {

			if (!file.isEmpty()) {
				byte[] bytes = file.getBytes();
				// store the bytes somewhere
				return "redirect:uploadSuccess";
			}
			return "redirect:uploadFailure";
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class FileUploadController {

		@PostMapping("/form")
		fun handleFormUpload(@RequestParam("name") name: String,
							@RequestParam("file") file: MultipartFile): String {

			if (!file.isEmpty) {
				val bytes = file.bytes
				// store the bytes somewhere
				return "redirect:uploadSuccess"
			}
			return "redirect:uploadFailure"
		}
	}
----

将参数类型声明为 `List<MultipartFile>` 允许为同一参数名称解析多个文件.

当 `@RequestParam` 注解声明为 `Map<String, MultipartFile>` 或 `MultiValueMap<String, MultipartFile>` 时,如果注解中未指定参数名称,则会使用每个给定参数名称的多部分文件填充 map.

NOTE: 使用 Servlet 3.0 多部分解析,您也可以将 `javax.servlet.http.Part` 而不是 Spring 的 `MultipartFile` 声明为方法参数或集合值类型.

您还可以将多部分内容用作绑定到<<mvc-ann-modelattrib-method-args, 命令对象>>的数据的一部分.  例如,前面示例中的表单字段和文件可以是表单对象上的字段,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	class MyForm {

		private String name;

		private MultipartFile file;

		// ...
	}

	@Controller
	public class FileUploadController {

		@PostMapping("/form")
		public String handleFormUpload(MyForm form, BindingResult errors) {
			if (!form.getFile().isEmpty()) {
				byte[] bytes = form.getFile().getBytes();
				// store the bytes somewhere
				return "redirect:uploadSuccess";
			}
			return "redirect:uploadFailure";
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyForm(val name: String, val file: MultipartFile, ...)

	@Controller
	class FileUploadController {

		@PostMapping("/form")
		fun handleFormUpload(form: MyForm, errors: BindingResult): String {
			if (!form.file.isEmpty) {
				val bytes = form.file.bytes
				// store the bytes somewhere
				return "redirect:uploadSuccess"
			}
			return "redirect:uploadFailure"
		}
	}
----

还可以在 RESTful 中从非浏览器客户端提交多部分请求.  以下示例显示了带有 JSON 的文件:

[literal,subs="verbatim,quotes"]
----
POST /someUrl
Content-Type: multipart/mixed

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="meta-data"
Content-Type: application/json; charset=UTF-8
Content-Transfer-Encoding: 8bit

{
	"name": "value"
}
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="file-data"; filename="file.properties"
Content-Type: text/xml
Content-Transfer-Encoding: 8bit
... File Data ...
----

对于名称为 "meta-data" 的部分,可以通过控制器方法上的 `@RequestParam` `String` metadata 参数来获得.
但对于那部分请求体中为 JSON 格式数据的请求, 可能更想通过接受一个对应的强类型对象,就像 `@RequestBody` 通过 <<integration.adoc#rest-message-conversion, HttpMessageConverter>> 将一般请求的请求体转换成一个对象一样. 使用 `@RequestPart` 注解访问多部分:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/")
	public String handle(@RequestPart("meta-data") MetaData metadata,
			@RequestPart("file-data") MultipartFile file) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/")
	fun handle(@RequestPart("meta-data") metadata: MetaData,
			@RequestPart("file-data") file: MultipartFile): String {
		// ...
	}
----

您可以将 `@RequestPart` 与 `javax.validation.Valid` 结合使用,或使用 Spring 的 `@Validated` 注解,这两种注解都会启用标准 Bean 验证.
默认情况下,验证错误会导致 `MethodArgumentNotValidException`, 并将其转换为 400(BAD_REQUEST) 响应.  或者,您可以通过 `Errors` 或 `BindingResult` 参数在控制器内本地处理验证错误,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/")
	public String handle(@Valid @RequestPart("meta-data") MetaData metadata,
			BindingResult result) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/")
	fun handle(@Valid @RequestPart("meta-data") metadata: MetaData,
			result: BindingResult): String {
		// ...
	}
----



[[mvc-ann-requestbody]]
==== `@RequestBody`
[.small]#<<web-reactive.adoc#webflux-ann-requestbody, WebFlux>>#

您可以使用 `@RequestBody` 注解通过 <<integration.adoc#rest-message-conversion, `HttpMessageConverter`>> 将请求主体读取并反序列化为 `Object`.  以下示例使用 `@RequestBody` 参数:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(@RequestBody Account account) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(@RequestBody account: Account) {
		// ...
	}
----

您可以使用<<mvc-config>> 的 <<mvc-config-message-converters>> 选项来配置或自定义消息转换.

您可以将 `@RequestBody` 与 `javax.validation.Valid` 或Spring的 `@Validated` 注解结合使用,这两种注解都会启用标准 Bean 验证.
默认情况下,验证错误会导致 `MethodArgumentNotValidException`,并将其转换为 400(BAD_REQUEST) 响应.  或者,您可以通过 `Errors` 或 `BindingResult` 参数在控制器内本地处理验证错误,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(@Valid @RequestBody Account account, BindingResult result) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(@Valid @RequestBody account: Account, result: BindingResult) {
		// ...
	}
----


[[mvc-ann-httpentity]]
==== HttpEntity
[.small]#<<web-reactive.adoc#webflux-ann-httpentity, WebFlux>>#

`HttpEntity` 与使用 <<mvc-ann-requestbody>> 或多或少有些类似,但它基于一个暴露请求头和正文的容器对象.  以下清单显示了一个示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(HttpEntity<Account> entity) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(entity: HttpEntity<Account>) {
		// ...
	}
----



[[mvc-ann-responsebody]]
==== `@ResponseBody`
[.small]#<<web-reactive.adoc#webflux-ann-responsebody, WebFlux>>#

您可以在方法上使用 `@ResponseBody` 注解,以通过<<integration.adoc#rest-message-conversion, HttpMessageConverter>>将返回序列化到响应主体.  以下清单显示了一个示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/accounts/{id}")
	@ResponseBody
	public Account handle() {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/accounts/{id}")
	@ResponseBody
	fun handle(): Account {
		// ...
	}
----

类级别也支持 `@ResponseBody` ,在这种情况下,它由所有控制器方法继承.  例如 `@RestController` 的效果,它只不过是一个用 `@Controller` 和 `@ResponseBody` 标记的元注解.

您可以将 `@ResponseBody` 与 reactive 类型一起使用.  有关更多详细信息,请参阅 <<mvc-ann-async>> 和 <<mvc-ann-async-reactive-types>>.

您可以使用 <<mvc-config>> 的 <<mvc-config-message-converters>> 选项来配置或自定义消息转换.

您可以将 `@ResponseBody` 方法与 JSON 序列化视图结合使用.  有关详细信息,请参阅<<mvc-ann-jackson>> .


[[mvc-ann-responseentity]]
==== ResponseEntity
[.small]#<<web-reactive.adoc#webflux-ann-responseentity, WebFlux>>#

`ResponseEntity` 与<<mvc-ann-responsebody>> 类似,但具有状态和响应头.  例如:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/something")
	public ResponseEntity<String> handle() {
		String body = ... ;
		String etag = ... ;
		return ResponseEntity.ok().eTag(etag).build(body);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/something")
	fun handle(): ResponseEntity<String> {
		val body = ...
		val etag = ...
		return ResponseEntity.ok().eTag(etag).build(body)
	}
----

Spring MVC 支持使用单值<<mvc-ann-async-reactive-types, reactive type>> 异步生成 `ResponseEntity`,and/or 主体的单值和多值 reactive 类型.这允许以下类型的异步响应:

* `ResponseEntity<Mono<T>>` 或 `ResponseEntity<Flux<T>>` 可以立即获得响应状态和响应头,而在稍后以异步方式提供正文时.
如果主体包含 0..1 个值, 请使用 `Mono`,如果主体可以产生多个值,请使用 `Flux`.
* `Mono<ResponseEntity<T>>` 在稍后的时间异步提供所有的 -- response status, headers, 和 body. 这允许响应状态和响应头根据异步请求处理的结果而变化.


[[mvc-ann-jackson]]
==== Jackson JSON

Spring 为 Jackson JSON 库提供支持.

[[mvc-ann-jsonview]]
===== JSON 序列化视图
[.small]#<<web-reactive.adoc#webflux-ann-jsonview, WebFlux>>#

Spring MVC 为 https://www.baeldung.com/jackson-json-view-annotation[Jackson 的序列化视图] 提供内置支持,允许仅渲染 Object 中所有字段的子集.  为了与 `@ResponseBody` 控制器方法或者返回 `ResponseEntity` 的控制器方法一起使用,可以简单地将 `@JsonView` 注解放在参数上,指定需要使用的视图类或接口即可. 如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RestController
	public class UserController {

		@GetMapping("/user")
		@JsonView(User.WithoutPasswordView.class)
		public User getUser() {
			return new User("eric", "7!jd#h23");
		}
	}

	public class User {

		public interface WithoutPasswordView {};
		public interface WithPasswordView extends WithoutPasswordView {};

		private String username;
		private String password;

		public User() {
		}

		public User(String username, String password) {
			this.username = username;
			this.password = password;
		}

		@JsonView(WithoutPasswordView.class)
		public String getUsername() {
			return this.username;
		}

		@JsonView(WithPasswordView.class)
		public String getPassword() {
			return this.password;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RestController
	class UserController {

		@GetMapping("/user")
		@JsonView(User.WithoutPasswordView::class)
		fun getUser() = User("eric", "7!jd#h23")
	}

	class User(
			@JsonView(WithoutPasswordView::class) val username: String,
			@JsonView(WithPasswordView::class) val password: String) {

		interface WithoutPasswordView
		interface WithPasswordView : WithoutPasswordView
	}
----

NOTE: `@JsonView` 允许一组视图类,但每个控制器方法只能指定一个.  如果需要激活多个视图,可以使用复合接口.

如果您要通过编程方式进行上述操作,而不是声明一个 `@JsonView` 注解, 用 `MappingJacksonValue` 包装返回值,并使用它提供序列化

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RestController
	public class UserController {

		@GetMapping("/user")
		public MappingJacksonValue getUser() {
			User user = new User("eric", "7!jd#h23");
			MappingJacksonValue value = new MappingJacksonValue(user);
			value.setSerializationView(User.WithoutPasswordView.class);
			return value;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RestController
	class UserController {

		@GetMapping("/user")
		fun getUser(): MappingJacksonValue {
			val value = MappingJacksonValue(User("eric", "7!jd#h23"))
			value.serializationView = User.WithoutPasswordView::class.java
			return value
		}
	}
----

对于依赖视图的控制器,只需将序列化视图类添加到 model 中即可. 如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class UserController extends AbstractController {

		@GetMapping("/user")
		public String getUser(Model model) {
			model.addAttribute("user", new User("eric", "7!jd#h23"));
			model.addAttribute(JsonView.class.getName(), User.WithoutPasswordView.class);
			return "userView";
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.ui.set

	@Controller
	class UserController : AbstractController() {

		@GetMapping("/user")
		fun getUser(model: Model): String {
			model["user"] = User("eric", "7!jd#h23")
			model[JsonView::class.qualifiedName] = User.WithoutPasswordView::class.java
			return "userView"
		}
	}
----



[[mvc-ann-modelattrib-methods]]
=== Model
[.small]#<<web-reactive.adoc#webflux-ann-modelattrib-methods, WebFlux>>#

您可以使用 `@ModelAttribute` 注解:

* 在 `@RequestMapping` 方法中的<<mvc-ann-modelattrib-method-args,方法参数>>,用于从 `model` 创建或访问 Object 并通过 `WebDataBinder` 将其绑定到请求.
* 作为 `@Controller` 或 `@ControllerAdvice` 类中的方法级注解,有助于在任何 `@RequestMapping` 方法调用之前初始化模型.
* 在 `@RequestMapping` 方法上标记其返回值是一个模型属性.

本节讨论 `@ModelAttribute` 注解可被应用在方法或方法参数上 - 前面列表中的第二项. 控制器可以包含任意数量的 `@ModelAttribute` 方法.
在同一控制器中的 `@RequestMapping` 方法之前调用所有这些方法.  `@ModelAttribute` 方法也可以通过 `@ControllerAdvice` 在控制器之间共享.  有关更多详细信息,请参阅 <<mvc-ann-controller-advice>>  部分.

`@ModelAttribute` 方法具有灵活的方法签名.  除了与 `@ModelAttribute` 本身或请求体相关的任何内容外,它们支持许多与 `@RequestMapping` 方法相同的参数.

以下示例显示了 `@ModelAttribute` 方法:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ModelAttribute
	public void populateModel(@RequestParam String number, Model model) {
		model.addAttribute(accountRepository.findAccount(number));
		// add more ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ModelAttribute
	fun populateModel(@RequestParam number: String, model: Model) {
		model.addAttribute(accountRepository.findAccount(number))
		// add more ...
	}
----

以下示例仅添加一个属性:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ModelAttribute
	public Account addAccount(@RequestParam String number) {
		return accountRepository.findAccount(number);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ModelAttribute
	fun addAccount(@RequestParam number: String): Account {
		return accountRepository.findAccount(number)
	}
----


NOTE: 如果未明确指定名称,框架将根据属性的类型给予一个默认名称,如 {api-spring-framework}/core/Conventions.html[`Conventions`] 的 javadoc 中所述.  你可以通过设置 `@ModelAttribute` 注解的值来改变默认值. 当向 `Model` 中直接添加属性时,请使用合适的重载方法 `addAttribute`.

`@ModelAttribute` 注解也可以被用在 `@RequestMapping` 方法上,这种情况下,`@RequestMapping` 方法的返回值将会被解释为 model 的一个属性,这通常不是必需的，因为它是 HTML 控制器中的默认行为，
除非返回值是一个 `String`，否则会被解释为视图名称. `@ModelAttribute` 还可以自定义模型属性名称,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/accounts/{id}")
	@ModelAttribute("myAccount")
	public Account handle() {
		// ...
		return account;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/accounts/{id}")
	@ModelAttribute("myAccount")
	fun handle(): Account {
		// ...
		return account
	}
----

[[mvc-ann-initbinder]]
=== `DataBinder`
[.small]#<<web-reactive.adoc#webflux-ann-initbinder, WebFlux>>#

`@Controller` 或 `@ControllerAdvice` 类可以使用 `@InitBinder` 方法初始化 `WebDataBinder` 的实例,而这些方法又可以:

* 将请求参数(即表单或查询数据) 绑定到模型对象.
* 将基于字符串的请求值(例如请求参数,路径变量,请求头,cookie 等) 转换为目标类型的控制器方法参数.
* 在呈现 HTML 表单时将模型对象值格式化为 `String` 值.

`@InitBinder` 方法可以注册特定于控制器的 `java.beans.PropertyEditor` 或 Spring `Converter` 和 `Formatter` 组件.  此外,您可以使用<<mvc-config-conversion,MVC config>> 在全局共享的 `FormattingConversionService` 中注册 `Converter` 和 `Formatter` 类型.

`@InitBinder` 方法支持许多与 `@RequestMapping` 方法相同的参数,但 `@ModelAttribute`(命令对象) 参数除外.  通常,它们使用 `WebDataBinder` 参数(用于注册) 和 `void` 返回值进行声明.  以下清单显示了一个示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class FormController {

		@InitBinder // <1>
		public void initBinder(WebDataBinder binder) {
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
			dateFormat.setLenient(false);
			binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
		}

		// ...
	}
----
<1> 使用 `@InitBinder` 注解.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class FormController {

		@InitBinder // <1>
		fun initBinder(binder: WebDataBinder) {
			val dateFormat = SimpleDateFormat("yyyy-MM-dd")
			dateFormat.isLenient = false
			binder.registerCustomEditor(Date::class.java, CustomDateEditor(dateFormat, false))
		}

		// ...
	}
----
<1> 使用 `@InitBinder` 注解.

或者,当使用基于 `Formatter` 的设置时,您可以通过共享的 `FormattingConversionService` 重复使用相同的方法并注册特定于控制器的 `Formatter` 实现,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class FormController {

		@InitBinder // <1>
		protected void initBinder(WebDataBinder binder) {
			binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd"));
		}

		// ...
	}
----
<1> 添加一个自定义 formatter ( 本例中为 `DateFormatter`).

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class FormController {

		@InitBinder // <1>
		protected fun initBinder(binder: WebDataBinder) {
			binder.addCustomFormatter(DateFormatter("yyyy-MM-dd"))
		}

		// ...
	}
----
<1> 添加一个自定义 formatter ( 本例中为 `DateFormatter`).

[[mvc-ann-initbinder-model-design]]
==== Model Design
[.small]#<<web-reactive.adoc#webflux-ann-initbinder-model-design, WebFlux>>#

include::web-data-binding-model-design.adoc[]

[[mvc-ann-exceptionhandler]]
=== 异常
[.small]#<<web-reactive.adoc#webflux-ann-controller-exceptions, WebFlux>>#

`@Controller` 和 <<mvc-ann-controller-advice, @ControllerAdvice>> 可以使用 `@ExceptionHandler` 方法来处理来自控制器方法的异常,如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class SimpleController {

		// ...

		@ExceptionHandler
		public ResponseEntity<String> handle(IOException ex) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class SimpleController {

		// ...

		@ExceptionHandler
		fun handle(ex: IOException): ResponseEntity<String> {
			// ...
		}
	}
----

该异常可能与顶级异常(即抛出直接 `IOException`) 或包装器中的异常(例如,包含在 `IllegalStateException` 内的 `IOException`) 相匹配.从 5.3 开始， 这可以在任意原因级别上匹配， 而以前只考虑了直接原因.

对于匹配的异常类型,最好将目标异常声明为方法参数,如前面的示例所示. 当多个异常方法匹配时,根( root )异常匹配通常优先于原因( cause )异常匹配.  更具体地说,`ExceptionDepthComparator` 用于根据抛出的异常类型的深度对异常进行排序.

注解声明可以缩小要匹配的异常类型,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExceptionHandler({FileSystemException.class, RemoteException.class})
	public ResponseEntity<String> handle(IOException ex) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExceptionHandler(FileSystemException::class, RemoteException::class)
	fun handle(ex: IOException): ResponseEntity<String> {
		// ...
	}
----

您甚至可以使用特定异常类型列表中的非常通用的参数签名,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExceptionHandler({FileSystemException.class, RemoteException.class})
	public ResponseEntity<String> handle(Exception ex) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExceptionHandler(FileSystemException::class, RemoteException::class)
	fun handle(ex: Exception): ResponseEntity<String> {
		// ...
	}
----

[NOTE]
====
root 和 cause 异常匹配之间的区别可能是令人惊讶的.

在前面显示的 `IOException` 变体中,通常使用实际的 `FileSystemException` 或 `RemoteException` 实例作为参数调用该方法,因为它们都是从 `IOException` 扩展的.  但是,如果任何此类异常在包装器内传播,而该异常本身就是 `IOException`,则传入的异常实例就是包装器异常.

在 `handle(Exception)` 变体中,行为更简单.  这总是在包装场景中使用包装器异常调用,在这种情况下可以通过 `ex.getCause()` 找到实际匹配的异常.  传入的异常仅在实际的 `FileSystemException` 或 `RemoteException` 实例被抛出为顶级异常时才会发生.
====

我们通常建议您在参数签名中尽可能具体,减少 root 和 cause 异常类型之间不匹配的可能性.  考虑将多匹配方法分解为单独的 `@ExceptionHandler` 方法,每个方法通过其签名匹配单个特定异常类型.

在具有多个 `@ControllerAdvice` 组成中,我们建议在 `@ControllerAdvice` 上声明根异常映射,并使用相应的顺序进行优先级排序.
虽然根异常匹配优先于某个原因,但这是在给定控制器或 `@ControllerAdvice` 类的方法中定义的.  这意味着优先级较高的 `@ControllerAdvice` bean上的原因匹配优先于较低优先级的 `@ControllerAdvice` bean上的任何匹配(例如,root) .

最后但同样重要的是, 可以通过 `@ExceptionHandler` 方法的实现,讲异常以原始的形式重新抛出,并提供给特定的异常实例.  这在您仅对根级别匹配或在特定上下文中无法静态确定的匹配中感兴趣的情况下非常有用.  重新抛出的异常通过后续的解析链传播,就好像给定的 `@ExceptionHandler` 方法首先不匹配一样.

Spring MVC中对 `@ExceptionHandler` 方法的支持是基于 `DispatcherServlet` 级别的<<mvc-exceptionhandlers, HandlerExceptionResolver>>机制构建的.


[[mvc-ann-exceptionhandler-args]]
==== 方法参数

`@ExceptionHandler`方法支持以下参数:

[cols="1,2", options="header"]
|===
| 方法参数 | 描述

| Exception type
| 用于访问引发的异常.

| `HandlerMethod`
| 访问控制器方法引发的异常

| `WebRequest`, `NativeWebRequest`
| 无需直接使用 Servlet API 即可访问请求参数以及请求和会话属性.

| `javax.servlet.ServletRequest`, `javax.servlet.ServletResponse`
| 选择任何特定的请求或响应类型(例如,`ServletRequest` 或 `HttpServletRequest` 或 Spring的 `MultipartRequest` or `MultipartHttpServletRequest`).

| `javax.servlet.http.HttpSession`
| 强制进行会话.  因此,这样的结果永远不会是 `null` 的. 请注意,会话访问不是线程安全的.  如果允许多个请求同时访问会话,请考虑将 `RequestMappingHandlerAdapter` 实例的 `synchronizeOnSession` 标志设置为 `true`.

| `java.security.Principal`
| 当前经过身份验证的用户 - 如果已知,可能是特定的 `Principal` 实现类.

| `HttpMethod`
| 请求的 HTTP 方法.

| `java.util.Locale`
| 当前请求区域设置,由最可用的 `LocaleResolver`(实际上是已配置的 `LocaleResolver` 或 `LocaleContextResolver`) 确定.

| `java.util.TimeZone`, `java.time.ZoneId`
| 与当前请求关联的时区,由 `LocaleContextResolver` 确定.

| `java.io.OutputStream`, `java.io.Writer`
| 用于访问 Servlet API 暴露的原始响应主体.

| `java.util.Map`, `org.springframework.ui.Model`, `org.springframework.ui.ModelMap`
| 用于访问模型以获取错误响应.  总是为空.

| `RedirectAttributes`
| 指定在重定向的情况下使用的属性 - (将附加到查询字符串) 和临时存储的 flash 属性,直到重定向后的请求为止.  请参阅  <<mvc-redirecting-passing-data>>和 <<mvc-flash-attributes>>.

| `@SessionAttribute`
| 用于访问任何会话属性,与由于类级别 `@SessionAttributes` 声明的结束形成对比.  有关更多详细信息,请参阅<<mvc-ann-sessionattribute>>.

| `@RequestAttribute`
| 用于访问请求属性.  有关更多详细信息,请参阅<<mvc-ann-requestattrib>>.

|===


[[mvc-ann-exceptionhandler-return-values]]
==== 返回值

`@ExceptionHandler` 方法支持以下返回值:

[cols="1,2", options="header"]
|===
| Return value | Description

| `@ResponseBody`
| 返回值通过 `HttpMessageConverter` 实现转换并写入响应.  请参阅<<mvc-ann-responsebody>>

| `HttpEntity<B>`, `ResponseEntity<B>`
| 指定完整响应(包括 HTTP 头和主体) 的返回值将通过 `HttpMessageConverter` 实现转换并写入响应.  请参阅<<mvc-ann-responseentity>>.

| `String`
| 要使用 `ViewResolver 实现解析的视图名称`,并与隐式模型一起使用 - 通过命令对象和 `@ModelAttribute` 方法确定.  处理程序方法还可以通过声明 `Model` 参数以编程方式丰富模型(请参阅 <<mvc-ann-requestmapping-registration,显式注册>>) .

| `View`
| 用于与隐式模型一起呈现的 `View` 实例 - 通过命令对象和 `@ModelAttribute` 方法确定.  处理程序方法还可以通过声明 `Model` 参数以编程方式丰富模型(请参阅 <<mvc-ann-requestmapping-registration,显式注册>>) .

| `java.util.Map`, `org.springframework.ui.Model`
| 要添加到隐式模型的属性,通过 `RequestToViewNameTranslator` 隐式确定视图名称.

| `@ModelAttribute`
| 要添加到模型的属性,通过隐式确定视图名称.

 请注意,`@ModelAttribute` 是可选的.  请参阅本表末尾的 "任何其他返回值".

| `ModelAndView` object
| 要使用的视图和模型属性,以及(可选) 响应状态.

| `void`
| 如果具有 `void` 返回类型(或返回值为 `null` ) 的方法,如果它还具有 `ServletResponse`,`OutputStream` 参数或 `@ResponseStatus` 注解, 则认为已完全处理该响应.  如果控制器已进行正 `ETag` 或 `lastModified` 时间戳检查,则也是如此(有关详细信息,请参阅<<mvc-caching-etag-lastmodified>>) .

  如果以上都不是真的,则 `void` 返回类型也可以指示 REST 控制器的 "无响应主体" 或 HTML 控制器的默认视图名称选择.

| Any other return value
| 任何与此表中任何早期值不匹配且返回值为 `String` 或 `void` 的返回值都被视为视图名称(通过 `RequestToViewNameTranslator` 应用默认视图名称选择) , 前提是它不是简单类型,由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty] 确定,简单类型的值仍未解决.
|===


[[mvc-ann-rest-exceptions]]
==== REST API 异常
[.small]#<<web-reactive.adoc#webflux-ann-rest-exceptions, WebFlux>>#

REST 服务的一个常见要求是在响应正文中包含错误详细信息.  Spring Framework 不会自动执行此操作,因为响应正文中的错误详细信息的表示是特定于应用程序的.  但是,`@RestController` 可以使用带有 `ResponseEntity` 返回值的 `@ExceptionHandler` 方法来设置响应的状态和正文.  这些方法也可以在 `@ControllerAdvice` 类中声明,以全局应用它们.

在响应主体中实现具有错误详细信息的全局异常处理的应用程序应考虑扩展 {api-spring-framework}/web/servlet/mvc/method/annotation/ResponseEntityExceptionHandler.html[`ResponseEntityExceptionHandler`], 它提供对 Spring MVC 引发的异常的处理,并提供钩子来定制响应主体. 要使用它,请创建 `ResponseEntityExceptionHandler` 的子类,使用 `@ControllerAdvice` 注解它,覆盖必要的方法,并将其声明为 Spring bean.

[[mvc-ann-controller-advice]]
=== Controller Advice
[.small]#<<web-reactive.adoc#webflux-ann-controller-advice, WebFlux>>#

`@ExceptionHandler`, `@InitBinder`, 和 `@ModelAttribute` 注解仅适用于 `@Controller` 类或类层次结构上声明 .相反，如果它们在 `@ControllerAdvice` 或 `@RestControllerAdvice` 类中声明，则它们适用于任何控制器。 此外，从 5.3 开始，`@ControllerAdvice` 中的 `@ExceptionHandler` 方法可用于处理来自任何 `@Controller` 或任何其他处理程序的异常。

`@ControllerAdvice` 使用 `@Component` 元注解,这意味着可以通过 <<core.adoc#beans-java-instantiating-container-scan,
组件扫描>> 将这些类注册为 Spring bean.  `@RestControllerAdvice` 也是一个用 `@ControllerAdvice` 和 `@ResponseBody` 标记的元注解,这实际上意味着 `@ExceptionHandler` 方法将通过响应正文消息转换而不是通过 HTML 视图呈现其返回值.

在启动时，`RequestMappingHandlerMapping` 和 `ExceptionHandlerExceptionResolver` 检测控制器通知 bean 并在运行时应用它们。 来自 `@ControllerAdvice` 的全局`@ExceptionHandler` 方法在 _after_ 来自`@Controller` 的本地方法之后应用。相比之下，全局 `@ModelAttribute` 和 `@InitBinder` 方法在 _before_ 本地方法之前应用。
全局 `@ExceptionHandler` 方法(来自 `@ControllerAdvice`) 在本地方法之后(来自 `@Controller`) 应用.  相比之下,全局 `@ModelAttribute` 和 `@InitBinder` 方法在本地方法之前应用.

默认情况下,`@ControllerAdvice` 可以通过使用注解上的属性将其缩小到控制器的子集,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Target all Controllers annotated with @RestController
	@ControllerAdvice(annotations = RestController.class)
	public class ExampleAdvice1 {}

	// Target all Controllers within specific packages
	@ControllerAdvice("org.example.controllers")
	public class ExampleAdvice2 {}

	// Target all Controllers assignable to specific classes
	@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
	public class ExampleAdvice3 {}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Target all Controllers annotated with @RestController
	@ControllerAdvice(annotations = [RestController::class])
	class ExampleAdvice1

	// Target all Controllers within specific packages
	@ControllerAdvice("org.example.controllers")
	class ExampleAdvice2

	// Target all Controllers assignable to specific classes
	@ControllerAdvice(assignableTypes = [ControllerInterface::class, AbstractController::class])
	class ExampleAdvice3
----

前面示例中的选择器在运行时进行评估,如果广泛使用,可能会对性能产生负面影响.  有关更多详细信息,请参阅 {api-spring-framework}/web/bind/annotation/ControllerAdvice.html[`@ControllerAdvice`] javadoc .

include::webmvc-functional.adoc[leveloffset=+1]

[[mvc-uri-building]]
== URI 链接
[.small]#<<web-reactive.adoc#webflux-uri-building, WebFlux>>#

本部分介绍了 Spring 框架中可用于 URI 的各种选项.

include::web-uris.adoc[leveloffset=+2]

[[mvc-servleturicomponentsbuilder]]
=== 相对请求

您可以使用 `ServletUriComponentsBuilder` 创建相对于当前请求的 URI,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	HttpServletRequest request = ...

	// Re-uses scheme, host, port, path, and query string...

	URI uri = ServletUriComponentsBuilder.fromRequest(request)
			.replaceQueryParam("accountId", "{id}")
			.build("123");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val request: HttpServletRequest = ...

	// Re-uses scheme, host, port, path, and query string...

	val uri = ServletUriComponentsBuilder.fromRequest(request)
			.replaceQueryParam("accountId", "{id}")
			.build("123")
----

您可以创建相对于上下文路径的 URI,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	HttpServletRequest request = ...

	// Re-uses scheme, host, port, and context path...

	URI uri = ServletUriComponentsBuilder.fromContextPath(request)
			.path("/accounts")
			.build()
			.toUri();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val request: HttpServletRequest = ...

	// Re-uses scheme, host, port, and context path...

	val uri = ServletUriComponentsBuilder.fromContextPath(request)
			.path("/accounts")
			.build()
			.toUri()
----

您可以创建相对于 Servlet 的 URI(例如 `/main/{asterisk}`) ,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	HttpServletRequest request = ...

	// Re-uses scheme, host, port, context path, and Servlet mapping prefix...

	URI uri = ServletUriComponentsBuilder.fromServletMapping(request)
			.path("/accounts")
			.build()
			.toUri();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val request: HttpServletRequest = ...

	// Re-uses scheme, host, port, context path, and Servlet mapping prefix...

	val uri = ServletUriComponentsBuilder.fromServletMapping(request)
			.path("/accounts")
			.build()
			.toUri()
----

NOTE: 从 5.1 开始,`ServletUriComponentsBuilder` 会忽略来自 `Forwarded` 和 `X-Forwarded-*` 头部的信息,这些头部信息指定了客户端发起的地址.  考虑使用<<filters-forwarded-headers, `ForwardedHeaderFilter`>>来提取和使用或丢弃此类请求头.

[[mvc-links-to-controllers]]
=== 控制器链接

Spring MVC 也提供了构造指定控制器方法链接的机制.  例如,以下 MVC 控制器允许创建链接:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@RequestMapping("/hotels/{hotel}")
	public class BookingController {

		@GetMapping("/bookings/{booking}")
		public ModelAndView getBooking(@PathVariable Long booking) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	@RequestMapping("/hotels/{hotel}")
	class BookingController {

		@GetMapping("/bookings/{booking}")
		fun getBooking(@PathVariable booking: Long): ModelAndView {
			// ...
		}
	}
----

您可以通过引用方法名字的办法来准备一个链接,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	UriComponents uriComponents = MvcUriComponentsBuilder
		.fromMethodName(BookingController.class, "getBooking", 21).buildAndExpand(42);

	URI uri = uriComponents.encode().toUri();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val uriComponents = MvcUriComponentsBuilder
		.fromMethodName(BookingController::class.java, "getBooking", 21).buildAndExpand(42)

	val uri = uriComponents.encode().toUri()
----

在前面的示例中,为方法参数准备了填充值(在本例中,long 值: `21`) ,以用于填充路径变量并插入到 URL 中. 此外,我们提供了值 `42`,来填充任何剩余的 URI 变量,比如从类层级的请求映射中继承来的 `hotel` 变量.  如果方法还有更多的参数,你可以为那些不需要参与 URL 构造的变量赋予 null 值. 通常,只有 `@PathVariable` 和 `@RequestParam` 参数与构造 URL 有关.

还有其他使用 `MvcUriComponentsBuilder` 的方法. 例如,例如可以通过类似 mock 测试对象的方法,用代理来避免直接通过名字引用一个控制,如以下示例所示(该示例假定静态导入 `MvcUriComponentsBuilder.on`) :

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	UriComponents uriComponents = MvcUriComponentsBuilder
		.fromMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);

	URI uri = uriComponents.encode().toUri();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val uriComponents = MvcUriComponentsBuilder
		.fromMethodCall(on(BookingController::class.java).getBooking(21)).buildAndExpand(42)

	val uri = uriComponents.encode().toUri()
----

NOTE: 当控制器方法签名可用于 `fromMethodCall` 的链接创建时,其设计受到限制.  除了需要适当的参数签名外,返回类型还存在技术限制(即,为链接生成器调用生成运行时代理) ,因此返回类型不得为最终值.  特别是,视图名称的通用 `String` 返回类型在这里不起作用.  您应该改用 `ModelAndView` 甚至普通对象(具有 `String` 返回值) .

较早的示例在 `MvcUriComponentsBuilder` 中使用静态方法.  在内部,它们依靠 `ServletUriComponentsBuilder` 从当前请求的方案,主机,端口,上下文路径和 Servlet 路径准备基本 URL.  在大多数情况下,此方法效果很好.  但是,有时可能不足.  例如,您可能不在请求的上下文之内(例如,准备链接的批处理过程) ,或者您可能需要插入路径前缀(例如,从请求路径中删除且需要重新设置的语言环境前缀) .  插入链接) .

在这种情况下,可以使用静态的 `fromXxx` 重载方法,这些方法接受 `UriComponentsBuilder` 以使用基本 URL.  或者,您可以使用基本URL创建 `MvcUriComponentsBuilder` 的实例,然后使用基于实例的 `withXxx` 方法.  例如,以下清单使用 `withMethodCall`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	UriComponentsBuilder base = ServletUriComponentsBuilder.fromCurrentContextPath().path("/en");
	MvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo(base);
	builder.withMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);

	URI uri = uriComponents.encode().toUri();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val base = ServletUriComponentsBuilder.fromCurrentContextPath().path("/en")
	val builder = MvcUriComponentsBuilder.relativeTo(base)
	builder.withMethodCall(on(BookingController::class.java).getBooking(21)).buildAndExpand(42)

	val uri = uriComponents.encode().toUri()
----

NOTE: 从 5.1 开始,`ServletUriComponentsBuilder` 会忽略来自 `Forwarded` 和 `X-Forwarded-*` 头部的信息,这些头部信息指定了客户端发起的地址.  考虑使用<<filters-forwarded-headers, `ForwardedHeaderFilter`>>来提取和使用或丢弃此类请求头.

[[mvc-links-to-controllers-from-views]]
=== 链接到视图

在 Thymeleaf,FreeMarker 或 JSP 之类的视图中,您可以通过引用每个请求映射的隐式或显式分配的名称来构建到带注解的控制器的链接.  考虑以下示例:


[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RequestMapping("/people/{id}/addresses")
	public class PersonAddressController {

		@RequestMapping("/{country}")
		public HttpEntity<PersonAddress> getAddress(@PathVariable String country) { ... }
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RequestMapping("/people/{id}/addresses")
	class PersonAddressController {

		@RequestMapping("/{country}")
		fun getAddress(@PathVariable country: String): HttpEntity<PersonAddress> { ... }
	}
----

给定前面的控制器,可以按照以下方式准备来自 JSP 的链接,如下所示:

[source,jsp,indent=0,subs="verbatim,quotes"]
----
<%@ taglib uri="http://www.springframework.org/tags" prefix="s" %>
...
<a href="${s:mvcUrl('PAC#getAddress').arg(0,'US').buildAndExpand('123')}">Get Address</a>
----

前面的示例依赖于 Spring 标签库中声明的 `mvcUrl` 函数(即 `META-INF/spring.tld`) ,但可以很容易地定义自定义函数或使用自定义标签文件.

这是如何工作的,在启动时,每个 `HandlerMethodMappingNamingStrategy`  都通过 `@RequestMapping` 分配一个默认名称,其默认实现使用类的大写字母和方法名称(例如,`ThingController` 中的 `getThing` 方法变为 "TC#getThing") .
如果名称冲突,则可以使 `用@RequestMapping(name ="..")` 分配显式名称或实现自己的 `HandlerMethodMappingNamingStrategy`.

[[mvc-ann-async]]
== 异步请求
[.small]#<<mvc-ann-async-vs-webflux, Compared to WebFlux>>#

Spring MVC 与 Servlet 3.0 异步请求 <<mvc-ann-async-processing,处理>> 具有广泛的集成:

* 在控制器方法中返回 <<mvc-ann-async-deferredresult, `DeferredResult`>> 和 <<mvc-ann-async-callable, `Callable`>>,并为单个异步返回值提供基本支持.
* 控制器可以 <<mvc-ann-async-http-streaming,stream>> 多个值,包括 <<mvc-ann-async-sse, SSE>> 和 <<mvc-ann-async-output-stream, 原始数据>>.
* 控制器可以使用 reactive clients 并返回 <<mvc-ann-async-reactive-types, reactive types>> 以进行响应处理.

[[mvc-ann-async-deferredresult]]
=== `DeferredResult`
[.small]#<<mvc-ann-async-vs-webflux, Compared to WebFlux>>#

一旦在 Servlet 容器中 <<mvc-ann-async-configuration, 启用>> 了异步请求处理功能,控制器方法就可以使用 `DeferredResult` 包装任何受支持的控制器方法返回值,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/quotes")
	@ResponseBody
	public DeferredResult<String> quotes() {
		DeferredResult<String> deferredResult = new DeferredResult<String>();
		// Save the deferredResult somewhere..
		return deferredResult;
	}

	// From some other thread...
	deferredResult.setResult(result);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/quotes")
	@ResponseBody
	fun quotes(): DeferredResult<String> {
		val deferredResult = DeferredResult<String>()
		// Save the deferredResult somewhere..
		return deferredResult
	}

	// From some other thread...
	deferredResult.setResult(result)
----

控制器可以从不同的线程异步生成返回值 - 例如,响应外部事件( JMS 消息) ,计划任务或其他事件.

[[mvc-ann-async-callable]]
=== `Callable`
[.small]#<<mvc-ann-async-vs-webflux, Compared to WebFlux>>#

控制器可以使用 `java.util.concurrent.Callable` 包装任何支持的返回值,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping
	public Callable<String> processUpload(final MultipartFile file) {

		return new Callable<String>() {
			public String call() throws Exception {
				// ...
				return "someView";
			}
		};
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping
	fun processUpload(file: MultipartFile) = Callable<String> {
		// ...
		"someView"
	}
----

然后可以通过配置的 <<mvc-ann-async-configuration-spring-mvc, configured>> `TaskExecutor` 运行给定任务来获取返回值.

[[mvc-ann-async-processing]]
=== Processing
[.small]#<<mvc-ann-async-vs-webflux, Compared to WebFlux>>#

以下是 Servlet 异步请求处理的简要概述:

* Servlet 请求 `ServletRequest` 可以通过调用 `request.startAsync()` 方法而进入异步模式. 这样做的主要结果就是该 Servlet 以及所有的过滤器都可以结束,但其响应(response) 会等待异步处理结束后再返回调用.
* `request.startAsync()` 方法会返回一个 `AsyncContext` 对象 ,可用它对异步处理进行进一步的控制和操作. 比如说它也提供了一个与转向(forward) 很相似的 `dispatch` 方法,只不过它允许应用恢复 Servlet 容器的请求处理进程.
* `ServletRequest` 提供了获取当前 `DispatcherType` 的方式,后者可以用来区别当前处理的是原始请求、异步分发请求、转向、或是其他类型的请求分发类型.

`DeferredResult` 处理的工作方式如下:

* 控制器先返回一个 `DeferredResult` 对象,并把它存取在内存(队列或列表等) 中以便存取.
* Spring MVC调用 `request.startAsync()` 方法,开始进行异步处理.
* `DispatcherServlet` 和所有过滤器都退出 Servlet 容器线程,但此时方法的响应对象仍未返回.
* 由处理该请求的线程对 `DeferredResult` 进行设值,然后 Spring MVC 会重新把请求分派回 Servlet 容器,恢复处理.
* `DispatcherServlet` 再次被调用, 恢复对该异步返回结果的处理.

`Callable` 处理的工作方式如下:

* 控制器先返回一个 `Callable` 对象.
* Spring MVC调用 `request.startAsync()` 方法,开始进行异步处理,并把该 `Callable` 对象提交给另一个独立线程的 Actuator  `TaskExecutor` 处理.
* `DispatcherServlet` 和所有过滤器都退出 Servlet 容器线程,但此时方法的响应对象仍未返回.
* `Callable` 对象最终产生一个返回结果,此时 Spring MVC 会重新把请求分派回 Servlet 容器,恢复处理.
* `DispatcherServlet` 再次被调用,恢复对 `Callable` 异步处理所返回结果的处理.

有关更多背景知识,您还可以阅读在 Spring MVC 3.2 中引入了异步请求处理支持的 https://spring.io/blog/2012/05/07/spring-mvc-3-2-preview-introducing-servlet-3-async-support[博客文章].

[[mvc-ann-async-exceptions]]
==== 异常处理

若方法返回的是一个 `DeferredResult` 对象,你可以选择调 Exception 实例的 `setResult` 方法还是 `setErrorResult` 方法. 在这两种情况下,Spring MVC 都会将请求发送回 Servlet 容器以完成处理.  然后将其视为控制器方法返回给定值或者就好像它产生了给定的异常一样.  然后异常通过常规异常处理机制(例如,调用 `@ExceptionHandler` 方法) . 更具体地说呢,当 `Callable` 抛出异常时,Spring MVC 会把一个 `Exception` 对象分派给 Servlet 容器进行处理,而不是正常返回方法的返回值,然后容器恢复对此异步请求异常的处理.

当您使用 `Callable` 时,会出现类似的处理逻辑,主要区别在于从 `Callable` 返回结果,或者由它引发异常.

[[mvc-ann-async-interception]]
==== 拦截

处理器拦截器 `HandlerInterceptor` 可以实现 `AsyncHandlerInterceptor` 接口拦截异步请求,因为在异步请求开始时,被调用的回调方法是该接口的 `afterConcurrentHandlingStarted` 方法,而非一般的 `postHandle` 和 `afterCompletion` 方法.

如果需要与异步请求处理的生命流程有更深入的集成,比如需要处理 timeout 的事件等. 则 `HandlerInterceptor` 需要注册 `CallableProcessingInterceptor` 或 `DeferredResultProcessingInterceptor` 拦截器, 具体的细节可以参考 {api-spring-framework}/web/servlet/AsyncHandlerInterceptor.html[`AsyncHandlerInterceptor`] 类的 Java 文档

`DeferredResult` 类还提供了 `onTimeout(Runnable)` 和 `onCompletion(Runnable)` 等回调, 具体的细节可以参考 {api-spring-framework}/web/context/request/async/DeferredResult.html[javadoc of `DeferredResult`] 类的 Java 文档 `Callable` 可以替代 `WebAsyncTask`,它暴露了超时和完成回调的其他方法.

[[mvc-ann-async-vs-webflux]]
==== 与 WebFlux 相比

Servlet API 最初是为通过 Filter-Servlet 链进行一次传递而构建的.  Servlet 3.0 中添加了异步请求处理,使应用程序可以退出 Filter-Servlet 链,但保留响应以进行进一步处理.  Spring MVC 异步支持围绕该机制构建.
当控制器返回 `DeferredResult` 时,退出 Filter-Servlet 链,并释放 Servlet 容器线程.  稍后,在设置 `DeferredResult` 时,将进行 `ASYNC` 调度(到相同的 URL) ,在此期间,控制器将再次映射,但不是调用它,而是使用 `DeferredResult` 值(就像控制器返回了它) 来恢复处理.

相比之下,Spring WebFlux 既不是基于 Servlet API 构建的,也不需要这种异步请求处理功能,因为它在设计上是异步的.  异步处理已内置在所有框架协定中,并在请求处理的所有阶段得到内在支持.

从编程模型的角度来看,Spring MVC 和 Spring WebFlux 都支持异步和 <<mvc-ann-async-reactive-types>> 作为控制器方法中的返回值.  Spring MVC 甚至支持流式传输,包括响应性背压.  但是,与 WebFlux 不同,WebFlux 依赖于非阻塞 I/O,并且每次写入都不需要额外的线程,
因此对响应的单个写入仍然处于阻塞状态(并在单独的线程上执行) .

另一个基本区别是,Spring MVC 在控制器方法参数中不支持异步或响应类型(例如,`@RequestBody`,`@RequestPart` 等) ,也没有对异步和响应类型作为模型属性的任何显式支持.  Spring WebFlux 确实支持所有这些.

[[mvc-ann-async-http-streaming]]
=== HTTP 流
[.small]#<<web-reactive.adoc#webflux-codecs-streaming, WebFlux>>#

您可以将 `DeferredResult` 和 `Callable` 用于单个异步返回值.  如果要生成多个异步值并将其写入响应,该怎么办?  本节介绍如何执行此操作.

[[mvc-ann-async-objects]]
==== Objects

您可以使用 `ResponseBodyEmitter` 返回值来生成对象流,其中每个对象都使用 <<integration.adoc#rest-message-conversion, `HttpMessageConverter`>>  进行序列化并写入响应,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/events")
	public ResponseBodyEmitter handle() {
		ResponseBodyEmitter emitter = new ResponseBodyEmitter();
		// Save the emitter somewhere..
		return emitter;
	}

	// In some other thread
	emitter.send("Hello once");

	// and again later on
	emitter.send("Hello again");

	// and done at some point
	emitter.complete();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/events")
	fun handle() = ResponseBodyEmitter().apply {
		// Save the emitter somewhere..
	}

	// In some other thread
	emitter.send("Hello once")

	// and again later on
	emitter.send("Hello again")

	// and done at some point
	emitter.complete()
----

`ResponseBodyEmitter` 也可以被放到 `ResponseEntity` 体里面使用,这可以对响应状态和响应头做一些定制.

当 `emitter` 抛出 `IOException` 时(例如,如果远程客户端消失) ,应用程序不负责清理连接,不应调用 `emitter.complete` 或 `emitter.completeWithError`.  相反,servlet 容器会自动启动 `AsyncListener` 错误通知,其中 Spring MVC 进行 `completeWithError` 调用.  反过来,此调用会对应用程序执行一次最终 `ASYNC` 调度,在此期间,Spring MVC 将调用已配置的异常解析程序并完成请求.

[[mvc-ann-async-sse]]
==== SSE

`SseEmitter` (`ResponseBodyEmitter` 的子类) 为 https://www.w3.org/TR/eventsource/[Server-Sent Events] 提供支持,其中从服务器发送的事件根据 W3C SSE 规范进行格式化.  要从控制器生成 SSE 流,请返回 `SseEmitter`,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path="/events", produces=MediaType.TEXT_EVENT_STREAM_VALUE)
	public SseEmitter handle() {
		SseEmitter emitter = new SseEmitter();
		// Save the emitter somewhere..
		return emitter;
	}

	// In some other thread
	emitter.send("Hello once");

	// and again later on
	emitter.send("Hello again");

	// and done at some point
	emitter.complete();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/events", produces = [MediaType.TEXT_EVENT_STREAM_VALUE])
	fun handle() = SseEmitter().apply {
		// Save the emitter somewhere..
	}

	// In some other thread
	emitter.send("Hello once")

	// and again later on
	emitter.send("Hello again")

	// and done at some point
	emitter.complete()
----

虽然 SSE 是流式传输到浏览器的主要选项,但请注意 Internet Explorer 不支持 Server-Sent Events.  考虑将 Spring 的 <<web.adoc#websocket, WebSocket messaging>> 传递与针对各种浏览器的 <<web.adoc#websocket-fallback, SockJS fallback>>传输(包括 SSE) 一起使用.

有关异常处理的说明,另请参见 <<mvc-ann-async-objects, 上一节>> .

[[mvc-ann-async-output-stream]]
==== Raw Data

有时,跳过消息转换的阶段,直接把数据写回响应的输出流 `OutputStream` 可能更有效,比如文件下载这样的场景,这可以通过返回一个 `StreamingResponseBody` 类型的对象来实现,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/download")
	public StreamingResponseBody handle() {
		return new StreamingResponseBody() {
			@Override
			public void writeTo(OutputStream outputStream) throws IOException {
				// write...
			}
		};
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/download")
	fun handle() = StreamingResponseBody {
		// write...
	}
----

`StreamingResponseBody` 也可以被放到 `ResponseEntity` 体里面使用,这可以对响应状态和响应头做一些定制.

[[mvc-ann-async-reactive-types]]
=== Reactive Types(响应式类型)
[.small]#<<web-reactive.adoc#webflux-codecs-streaming, WebFlux>>#

如果使用 `spring-webflux` 中的响应式 `WebClient`,或其他客户端(也可以阅读 WebFlux 部分中的<<web-reactive.adoc#webflux-reactive-libraries, Reactive Libraries>> ) ,又或者是带响应式支持的数据存储,开发者可以直接从 Spring MVC 控制器方法返回响应式类型.

Reactive 返回值的处理方式如下:

* 如果返回类型有 `single-value` 流的语义,如 `Mono`(Reactor) 或 `Single`(RxJava),那么它是适配并等效于 `DeferredResult`.
* 如果返回类型有 multi-value 流的语义,如 `Flux` (Reactor)或 `Observable` (RxJava),并且如果媒体类型也表示为流,(例如,`application/x-ndjson` 或 `text/event-stream`) .  则它是适配并等效于使用 `ResponseBodyEmitter` 或 `SseEmitter`. 还可以返回 `Flux<ServerSentEvent>` 或 `Observable<ServerSentEvent>`.
* 如果返回类型 multi-value 流的语义,但媒体类型并不表示为流. 例如 `application/json`,则它是适配并等效于使用 `DeferredResult<List<?>>`.

TIP: Spring MVC 对使用中的响应式库进行了适配 – 例如,预计有多少值,这是在 `spring-core` 包的 {api-spring-framework}/core/ReactiveAdapterRegistry.html[`ReactiveAdapterRegistry`]  的帮助下完成的.  它为响应式和异步类型提供可插拔的支持. 注册表内置了对 RxJava 的支持,但其他可以注册.

对于流式传输到响应,支持响应式响应,但是对响应的写入仍然是阻塞的,并且通过<<mvc-ann-async-configuration-spring-mvc, configured>> `TaskExecutor` 在单独的线程上执行, 以避免阻塞上游源(例如从 `WebClient` 返回的 `Flux`) .
默认情况下,`SimpleAsyncTaskExecutor` 用于阻塞写入,但在加载时不适用.  如果计划使用响应类型进行流式处理,则应使用<<mvc-ann-async-configuration-spring-mvc, MVC configuration>>来配置任务执行程序.

[[mvc-ann-async-disconnects]]
=== 断开
[.small]#<<web-reactive.adoc#webflux-codecs-streaming, WebFlux>>#

当远程客户端消失时,Servlet API 不提供任何通知.  因此,在通过 stream 传输到响应时,无论是通过<<mvc-ann-async-sse, SseEmitter>>还是 <<mvc-ann-async-reactive-types, reactive types>>,定期发送数据都很重要, 因为如果客户端断开连接,写入将失败.  发送可以采用空(仅限注解) SSE 事件或另一方必须解释为心跳并忽略的任何其他数据的形式.

或者,考虑使用具有内置心跳机制的 Web 消息传递解决方案(例如基于<<websocket-stomp,  WebSocket 的 STOMP>> 或具有<<websocket-fallback, SockJS>>的 WebSocket) .

[[mvc-ann-async-configuration]]
=== 配置
[.small]#<<mvc-ann-async-vs-webflux, Compared to WebFlux>>#

必须在 Servlet 容器级别启用异步请求处理功能.  MVC 配置还暴露了异步请求的几个选项.

[[mvc-ann-async-configuration-servlet3]]
==== Servlet  容器

Filter 和 Servlet 声明具有 `asyncSupported` 标志,需要将其设置为 `true` 以启用异步请求处理.  此外,应声明 `Filter` 映射以处理 `ASYNC` `javax.servlet.DispatchType`.

在 Java 配置中,当您使用 `AbstractAnnotationConfigDispatcherServletInitializer` 初始化 Servlet 容器时,这将自动完成.

在 `web.xml` 配置中,您可以将 `<async-supported>true</async-supported>` 添加到 `DispatcherServlet` 和 `Filter` 声明,并添加 `<dispatcher>ASYNC</dispatcher>` 以过滤映射.

[[mvc-ann-async-configuration-spring-mvc]]
==== Spring MVC

MVC 配置暴露以下与异步请求处理相关的选项:

* Java configuration: 在 `WebMvcConfigurer` 上使用 `configureAsyncSupport` 回调.
* XML namespace: 使用 `<mvc:annotation-driven>` 下的 `<async-support>` 元素.

您可以配置以下内容:

* 异步请求的默认超时值(如果未设置) 取决于底层Servlet容器.
* `AsyncTaskExecutor` 用于在使用<<mvc-ann-async-reactive-types,Reactive Types>> 进行流式处理时阻止写入,以及用于执行从控制器方法返回的 `Callable` 实例.  如果您使用 reactive types 进行流式传输或者具有返回 `Callable` 的控制器方法, 我们强烈建议您配置此属性,因为默认情况下,它是 `SimpleAsyncTaskExecutor`.
* `DeferredResultProcessingInterceptor` 实现和 `CallableProcessingInterceptor` 实现.

请注意,您还可以在 `DeferredResult`, `ResponseBodyEmitter` 和 `SseEmitter` 上设置默认超时值.  对于 `Callable`,您可以使用 `WebAsyncTask` 来提供超时值.

include::webmvc-cors.adoc[leveloffset=+1]

[[mvc-web-security]]
== Web 安全
[.small]#<<web-reactive.adoc#webflux-web-security, WebFlux>>#

https://projects.spring.io/spring-security/[Spring Security]项目为保护 Web 应用程序免受恶意攻击提供支持.  请参阅 Spring Security 参考文档,包括:

* {doc-spring-security}/servlet/integrations/mvc.html[Spring MVC Security]
* {doc-spring-security}/servlet/test/mockmvc/setup.html[Spring MVC Test Support]
* {doc-spring-security}/features/exploits/csrf.html#csrf-protection[CSRF protection]
* {doc-spring-security}/features/exploits/headers.html[Security Response Headers]

https://hdiv.org/[HDIV] 是另一个与 Spring MVC 集成的 Web 安全框架.

[[mvc-caching]]
== HTTP 缓存
[.small]#<<web-reactive.adoc#webflux-caching, WebFlux>>#

HTTP 缓存可以显着提高 Web 应用程序的性能. HTTP 缓存围绕 `Cache-Control` 响应头,随后是条件请求头(例如 `Last-Modified` 和 `ETag`) .  HTTP 的响应头 `Cache-Control` 主要帮助私有缓存(比如浏览器端缓存) 和公共缓存(比如代理端缓存) 了解它们应该如果缓存HTTP响应.
如果内容未更改,则 `ETag` 头用于生成条件请求, 该条件请求可能导致 304(NOT_MODIFIED) 没有正文. 可以认为它是 `Last-Modified` 头的一个更精细的后续版本.

本节介绍 Spring Web MVC 中可用的与 HTTP 缓存相关的选项.

[[mvc-caching-cachecontrol]]
=== `CacheControl`
[.small]#<<web-reactive.adoc#webflux-caching-cachecontrol, WebFlux>>#

{api-spring-framework}/http/CacheControl.html[`CacheControl`] 支持配置与 `Cache-Control` 头相关的设置,并在许多地方被接受为参数:

* {api-spring-framework}/web/servlet/mvc/WebContentInterceptor.html[`WebContentInterceptor`]
* {api-spring-framework}/web/servlet/support/WebContentGenerator.html[`WebContentGenerator`]
* <<mvc-caching-etag-lastmodified>>
* <<mvc-caching-static-resources>>

虽然 https://tools.ietf.org/html/rfc7234#section-5.2.2[RFC 7234] 描述了 `Cache-Control` 响应头的所有可能的指令,但 `CacheControl` 类型采用面向用例的方法,该方法侧重于常见场景:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Cache for an hour - "Cache-Control: max-age=3600"
	CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);

	// Prevent caching - "Cache-Control: no-store"
	CacheControl ccNoStore = CacheControl.noStore();

	// Cache for ten days in public and private caches,
	// public caches should not transform the response
	// "Cache-Control: max-age=864000, public, no-transform"
	CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Cache for an hour - "Cache-Control: max-age=3600"
	val ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS)

	// Prevent caching - "Cache-Control: no-store"
	val ccNoStore = CacheControl.noStore()

	// Cache for ten days in public and private caches,
	// public caches should not transform the response
	// "Cache-Control: max-age=864000, public, no-transform"
	val ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic()
----

`WebContentGenerator` 还接受一个更简单的 `cachePeriod` 属性(以秒为单位定义) ,其工作方式如下:

* A `-1` 值不会生成 `Cache-Control` 的响应头.
* A `0` 值将防止缓存使用 `'Cache-Control:no-store'` 指令.
* An `n > 0` 一个大于0的值将缓存给定的响应在 `n` 秒使用 `'Cache-Control:max-age=n'`

[[mvc-caching-etag-lastmodified]]
=== Controllers
[.small]#<<web-reactive.adoc#webflux-caching-etag-lastmodified, WebFlux>>#

控制器可以添加对 HTTP 缓存的显式支持.  我们建议这样做,因为资源的 `lastModified` 或 `ETag` 值需要先计算才能与条件请求头进行比较.  控制器可以向 `ResponseEntity` 添加 `ETag` 头和 `Cache-Control` 设置,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/book/{id}")
	public ResponseEntity<Book> showBook(@PathVariable Long id) {

		Book book = findBook(id);
		String version = book.getVersion();

		return ResponseEntity
				.ok()
				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
				.eTag(version) // lastModified is also available
				.body(book);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/book/{id}")
	fun showBook(@PathVariable id: Long): ResponseEntity<Book> {

		val book = findBook(id);
		val version = book.getVersion()

		return ResponseEntity
				.ok()
				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
				.eTag(version) // lastModified is also available
				.body(book)
	}
----

如果与条件请求头的比较表明内容未更改,则前面的示例发送带有空响应体的 304 (NOT_MODIFIED) 响应.  否则,`ETag` 和 `Cache-Control` 头将添加到响应中.

您还可以对控制器中的条件请求头进行检查,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RequestMapping
	public String myHandleMethod(WebRequest request, Model model) {

		long eTag = ... // <1>

		if (request.checkNotModified(eTag)) {
			return null; // <2>
		}

		model.addAttribute(...); // <3>
		return "myViewName";
	}
----
<1> 特定于应用的计算.
<2> 响应已设置为 304(NOT_MODIFIED)  - 无需进一步处理.
<3> 继续请求处理.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RequestMapping
	fun myHandleMethod(request: WebRequest, model: Model): String? {

		val eTag: Long = ... // <1>

		if (request.checkNotModified(eTag)) {
			return null // <2>
		}

		model[...] = ... // <3>
		return "myViewName"
	}
----
<1> 特定于应用的计算.
<2> 响应已设置为 304(NOT_MODIFIED)  - 无需进一步处理.
<3> 继续请求处理.

有三种变体可用于检查针对 `eTag` 值,`lastModified` 值或两者的条件请求.  对于条件 `GET` 和 `HEAD` 请求, 您可以将响应设置为 304(NOT_MODIFIED) . 对于 `POST`, `PUT`, 和 `DELETE`,您可以将响应设置为 412(PRECONDITION_FAILED) ,以防止并发修改.

[[mvc-caching-static-resources]]
=== 静态资源
[.small]#<<web-reactive.adoc#webflux-caching-static-resources, WebFlux>>#

您应该使用 `Cache-Control` 和条件响应头来提供静态资源,以获得最佳性能.  请参阅有关<<mvc-config-static-resources>>的部分.

[[mvc-httpcaching-shallowetag]]
=== `ETag` 过滤器

您可以使用 `ShallowEtagHeaderFilter` 添加从响应内容计算的 "`shallow`" `eTag` 值,从而节省带宽但不节省CPU时间.  见  <<filters-shallow-etag>>.

include::webmvc-view.adoc[leveloffset=+1]

[[mvc-config]]
== MVC 配置
[.small]#<<web-reactive.adoc#webflux-config, WebFlux>>#

MVC Java 配置和 MVC 命名空间提供了适用于大多数应用程序的默认配置以及配置 API 来对其进行自定义.

有关配置 API 中没有的高级自定义设置请参阅<<mvc-config-advanced-java>> 和 <<mvc-config-advanced-xml>>.

您无需了解 MVC Java 配置和 MVC 命名空间创建的基础 bean.  如果您想了解更多信息,请参阅<<mvc-servlet-special-bean-types>>和 <<mvc-servlet-config>>.


[[mvc-config-enable]]
=== 启用 MVC 配置
[.small]#<<web-reactive.adoc#webflux-config-enable, WebFlux>>#

在 Java 配置中,您可以使用 `@EnableWebMvc` 注解启用 MVC 配置,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig {
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig
----

在 XML 配置中,您可以使用 `<mvc:annotation-driven>` 元素来启用 MVC 配置,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:mvc="http://www.springframework.org/schema/mvc"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/mvc
			https://www.springframework.org/schema/mvc/spring-mvc.xsd">

		<mvc:annotation-driven/>

	</beans>
----

前面的示例注册了许多 Spring MVC <<mvc-servlet-special-bean-types, 基础结构 bean>>,并适应类路径上可用的依赖(例如,JSON,XML 等的有效负载转换器) .

[[mvc-config-customize]]
=== MVC 配置 API
[.small]#<<web-reactive.adoc#webflux-config-customize, WebFlux>>#

在 Java 配置中,您可以实现 `WebMvcConfigurer` 接口,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		// Implement configuration methods...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {
		// Implement configuration methods...
	}
----

在 XML 中,您可以检查 `<mvc:annotation-driven/>` 的属性和子元素.  您可以查看 https://schema.spring.io/mvc/spring-mvc.xsd[Spring MVC XML schema] 或使用 IDE 的代码完成功能来发现可用的属性和子元素.

[[mvc-config-conversion]]
=== 类型转换
[.small]#<<web-reactive.adoc#webflux-config-conversion, WebFlux>>#

默认情况下,将安装各种数字和日期类型的格式化程序以及支持通过字段上的 `@NumberFormat` 和 `@DateTimeFormat` 进行定制.

在 Java 配置中,您可以注册自定义格式化程序和转换器,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void addFormatters(FormatterRegistry registry) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun addFormatters(registry: FormatterRegistry) {
			// ...
		}
	}
----

以下示例显示如何在 XML 中实现相同的配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:mvc="http://www.springframework.org/schema/mvc"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/mvc
			https://www.springframework.org/schema/mvc/spring-mvc.xsd">

		<mvc:annotation-driven conversion-service="conversionService"/>

		<bean id="conversionService"
				class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
			<property name="converters">
				<set>
					<bean class="org.example.MyConverter"/>
				</set>
			</property>
			<property name="formatters">
				<set>
					<bean class="org.example.MyFormatter"/>
					<bean class="org.example.MyAnnotationFormatterFactory"/>
				</set>
			</property>
			<property name="formatterRegistrars">
				<set>
					<bean class="org.example.MyFormatterRegistrar"/>
				</set>
			</property>
		</bean>

	</beans>
----

默认情况下,Spring MVC 在解析和格式化日期值时会考虑请求区域设置.  这适用于使用  "input" 日期表示为字符串的表单.
但是,对于  "date" 和 "time" 表单字段,浏览器使用 HTML 规范中定义的固定格式.  在这种情况下,日期和时间格式可以按以下方式自定义:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void addFormatters(FormatterRegistry registry) {
			DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
			registrar.setUseIsoFormat(true);
			registrar.registerFormatters(registry);
      	}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun addFormatters(registry: FormatterRegistry) {
			val registrar = DateTimeFormatterRegistrar()
			registrar.setUseIsoFormat(true)
			registrar.registerFormatters(registry)
		}
	}
----

NOTE: 有关何时使用 <<core.adoc#format-FormatterRegistrar-SPI, the `FormatterRegistrar` SPI>> 实现的更多信息,请参阅 FormatterRegistrar SPI 和 `FormattingConversionServiceFactoryBean`.

[[mvc-config-validation]]
=== 验证
[.small]#<<web-reactive.adoc#webflux-config-validation, WebFlux>>#

默认情况下,如果类路径上存在<<core.adoc#validation-beanvalidation-overview, Bean Validation>> (例如 Hibernate Validator) ,则 `LocalValidatorFactoryBean` 将注册为全局 <<core.adoc#validator, Validator>> .  以便与 `@Valid` 和 `Validated` 一起使用并在控制器方法参数上进行验证.

在 Java 配置中,您可以自定义全局 Validator 实例,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public Validator getValidator() {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun getValidator(): Validator {
			// ...
		}
	}
----

以下示例显示如何在 XML 中实现相同的配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:mvc="http://www.springframework.org/schema/mvc"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/mvc
			https://www.springframework.org/schema/mvc/spring-mvc.xsd">

		<mvc:annotation-driven validator="globalValidator"/>

	</beans>
----

请注意,您还可以在本地注册 `Validator` 实现,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class MyController {

		@InitBinder
		protected void initBinder(WebDataBinder binder) {
			binder.addValidators(new FooValidator());
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class MyController {

		@InitBinder
		protected fun initBinder(binder: WebDataBinder) {
			binder.addValidators(FooValidator())
		}
	}
----

TIP: 如果需要在某处注入 `LocalValidatorFactoryBean`,请创建一个 bean 并使用 `@Primary` 标记它,以避免与 MVC 配置中声明的那个冲突.

[[mvc-config-interceptors]]
=== 拦截器

在 Java 配置中,注册拦截器应用于传入的请求. 如以下示例所示:

[source,java,indent=0,subs="verbatim",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void addInterceptors(InterceptorRegistry registry) {
			registry.addInterceptor(new LocaleChangeInterceptor());
			registry.addInterceptor(new ThemeChangeInterceptor()).addPathPatterns("/**").excludePathPatterns("/admin/**");
			registry.addInterceptor(new SecurityInterceptor()).addPathPatterns("/secure/*");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun addInterceptors(registry: InterceptorRegistry) {
			registry.addInterceptor(LocaleChangeInterceptor())
			registry.addInterceptor(ThemeChangeInterceptor()).addPathPatterns("/**").excludePathPatterns("/admin/**")
			registry.addInterceptor(SecurityInterceptor()).addPathPatterns("/secure/*")
		}
	}
----

以下示例显示如何在 XML 中实现相同的配置:

[source,xml,indent=0,subs="verbatim"]
----
	<mvc:interceptors>
		<bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"/>
		<mvc:interceptor>
			<mvc:mapping path="/**"/>
			<mvc:exclude-mapping path="/admin/**"/>
			<bean class="org.springframework.web.servlet.theme.ThemeChangeInterceptor"/>
		</mvc:interceptor>
		<mvc:interceptor>
			<mvc:mapping path="/secure/*"/>
			<bean class="org.example.SecurityInterceptor"/>
		</mvc:interceptor>
	</mvc:interceptors>
----



[[mvc-config-content-negotiation]]
=== 内容类型
[.small]#<<web-reactive.adoc#webflux-config-content-negotiation, WebFlux>>#

您可以配置 Spring MVC 如何根据请求确定所请求的媒体类型(例如,`Accept` 头,URL 路径扩展,查询参数等) .

默认情况下,只检查  `Accept` 头.

如果必须使用基于内容类型解析,请考虑路径扩展上的查询参数策略.  有关更多详细信息,请参阅 <<mvc-ann-requestmapping-suffix-pattern-match>> 和 <<mvc-ann-requestmapping-rfd>>.

在 Java 配置中,您可以自定义请求的内容类型解析,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
			configurer.mediaType("json", MediaType.APPLICATION_JSON);
			configurer.mediaType("xml", MediaType.APPLICATION_XML);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureContentNegotiation(configurer: ContentNegotiationConfigurer) {
			configurer.mediaType("json", MediaType.APPLICATION_JSON)
			configurer.mediaType("xml", MediaType.APPLICATION_XML)
		}
	}
----


以下示例显示如何在 XML 中实现相同的配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:annotation-driven content-negotiation-manager="contentNegotiationManager"/>

	<bean id="contentNegotiationManager" class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean">
		<property name="mediaTypes">
			<value>
				json=application/json
				xml=application/xml
			</value>
		</property>
	</bean>
----



[[mvc-config-message-converters]]
=== 消息编解码器
[.small]#<<web-reactive.adoc#webflux-config-message-codecs, WebFlux>>#

使用 MVC Java 编程配置方式时,如果想替换 Spring MVC 提供的默认转换器,完全定制自己的 `HttpMessageConverter` ,这可以通过覆写 {api-spring-framework}/web/servlet/config/annotation/WebMvcConfigurer.html#configureMessageConverters-java.util.List-[`configureMessageConverters()`] 方法来实现.
如果只是想自定义,或者想在默认转换器之外再添加其他的转换器,那么可以通过覆写 {api-spring-framework}/web/servlet/config/annotation/WebMvcConfigurer.html#extendMessageConverters-java.util.List-[`extendMessageConverters()`] 方法来实现.

以下示例使用自定义的 `ObjectMapper` 而不是默认的 `ObjectMapper` 添加 XML 和 Jackson JSON 转换器:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfiguration implements WebMvcConfigurer {

		@Override
		public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
			Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder()
					.indentOutput(true)
					.dateFormat(new SimpleDateFormat("yyyy-MM-dd"))
					.modulesToInstall(new ParameterNamesModule());
			converters.add(new MappingJackson2HttpMessageConverter(builder.build()));
			converters.add(new MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build()));
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfiguration : WebMvcConfigurer {

		override fun configureMessageConverters(converters: MutableList<HttpMessageConverter<*>>) {
			val builder = Jackson2ObjectMapperBuilder()
					.indentOutput(true)
					.dateFormat(SimpleDateFormat("yyyy-MM-dd"))
					.modulesToInstall(ParameterNamesModule())
			converters.add(MappingJackson2HttpMessageConverter(builder.build()))
			converters.add(MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build()))
----

在上面的例子中, {api-spring-framework}/http/converter/json/Jackson2ObjectMapperBuilder.html[`Jackson2ObjectMapperBuilder`] 用于为 `MappingJackson2HttpMessageConverter` 和 `MappingJackson2XmlHttpMessageConverter` 转换器创建公共的配置,比如启用 tab 缩进、
定制的日期格式,并注册了模块 https://github.com/FasterXML/jackson-module-parameter-names[`jackson-module-parameter-names`] 用于获取参数名(Java 8 新增的特性) .

该 builder 会使用以下的默认属性对 Jackson 进行配置

* https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES[`DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES`] 被禁用.
* https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION[`MapperFeature.DEFAULT_VIEW_INCLUSION`] 被禁用.

同时,如果检测到在 classpath 路径下存在这些模块,该 builder 也会自动地注册它们.

* https://github.com/FasterXML/jackson-datatype-joda[jackson-datatype-joda]: 支持 Joda-Time 类型.
* https://github.com/FasterXML/jackson-datatype-jsr310[jackson-datatype-jsr310]: 支持 Java 8 日期和时间 API 类型.
* https://github.com/FasterXML/jackson-datatype-jdk8[jackson-datatype-jdk8]: 支持其他 Java 8 类型,例如 `Optional`.
* https://github.com/FasterXML/jackson-module-kotlin[`jackson-module-kotlin`]: 支持 Kotlin 类和数据类.

NOTE: 除了 https://search.maven.org/#search%7Cga%7C1%7Ca%3A%22jackson-dataformat-xml%22[`jackson-dataformat-xml`] 之外,使用 Jackson XML 支持启用缩进还需要 https://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.codehaus.woodstox%22%20AND%20a%3A%22woodstox-core-asl%22[`woodstox-core-asl`]依赖性.


* https://github.com/zalando/jackson-datatype-money[jackson-datatype-money]: 支持 `javax.money` 类型(非官方模块) .
* https://github.com/FasterXML/jackson-datatype-hibernate[jackson-datatype-hibernate]: 支持特定于 Hibernate 的类型和属性(包括延迟加载方面) .

以下示例显示如何在 XML 中实现相同的配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:annotation-driven>
		<mvc:message-converters>
			<bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">
				<property name="objectMapper" ref="objectMapper"/>
			</bean>
			<bean class="org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter">
				<property name="objectMapper" ref="xmlMapper"/>
			</bean>
		</mvc:message-converters>
	</mvc:annotation-driven>

	<bean id="objectMapper" class="org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"
		  p:indentOutput="true"
		  p:simpleDateFormat="yyyy-MM-dd"
		  p:modulesToInstall="com.fasterxml.jackson.module.paramnames.ParameterNamesModule"/>

	<bean id="xmlMapper" parent="objectMapper" p:createXmlMapper="true"/>
----



[[mvc-config-view-controller]]
=== 视图控制器

以下的一段代码相当于定义 `ParameterizableViewController` 视图控制器的快捷方式,该控制器会立即将请求转发(forwards) 给视图. 请确保仅在以下情景下才使用这个类: 当控制器除了将视图渲染到响应中外不需要执行任何逻辑时.

以下 Java 配置示例将对 `/` 的请求转发给名为 `home` 的视图:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void addViewControllers(ViewControllerRegistry registry) {
			registry.addViewController("/").setViewName("home");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun addViewControllers(registry: ViewControllerRegistry) {
			registry.addViewController("/").setViewName("home")
		}
	}
----

以下示例与前面的示例实现相同的功能,但使用 XML,通过使用 `<mvc:view-controller>` 元素:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:view-controller path="/" view-name="home"/>
----

如果将 `@RequestMapping` 方法映射到任何 HTTP 方法的 URL,则使用视图 控制器不能用于处理相同的 URL.  这是因为通过 URL 匹配的带注解的控制器被视为端点所有权的足够有力的指示,因此 405(METHOD_NOT_ALLOWED) ,415(UNSUPPORTED_MEDIA_TYPE) 或类似的响应可以 发送给客户端以帮助调试.  因此,建议避免在带注解的控制器和视图控制器之间拆分 URL 处理.

[[mvc-config-view-resolvers]]
=== View 解析器
[.small]#<<web-reactive.adoc#webflux-config-view-resolvers, WebFlux>>#

MVC 提供的配置简化了视图解析器的注册工作

以下 Java 配置示例使用 JSP 和 Jackson 作为 JSON 呈现的默认视图来配置内容协商视图解析:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.enableContentNegotiation(new MappingJackson2JsonView());
			registry.jsp();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			registry.enableContentNegotiation(MappingJackson2JsonView())
			registry.jsp()
		}
	}
----

以下示例显示如何在 XML 中实现相同的配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:view-resolvers>
		<mvc:content-negotiation>
			<mvc:default-views>
				<bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/>
			</mvc:default-views>
		</mvc:content-negotiation>
		<mvc:jsp/>
	</mvc:view-resolvers>
----

但请注意,FreeMarker,Tiles,Groovy Markup 和脚本模板也需要配置底层视图技术.

MVC 命名空间提供专用的元素.  以下示例适用于 FreeMarker:

[source,xml,indent=0,subs="verbatim,quotes"]
----

	<mvc:view-resolvers>
		<mvc:content-negotiation>
			<mvc:default-views>
				<bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/>
			</mvc:default-views>
		</mvc:content-negotiation>
		<mvc:freemarker cache="false"/>
	</mvc:view-resolvers>

	<mvc:freemarker-configurer>
		<mvc:template-loader-path location="/freemarker"/>
	</mvc:freemarker-configurer>

----

在 Java 配置中,您可以添加相应的 `Configurer` bean,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.enableContentNegotiation(new MappingJackson2JsonView());
			registry.freeMarker().cache(false);
		}

		@Bean
		public FreeMarkerConfigurer freeMarkerConfigurer() {
			FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
			configurer.setTemplateLoaderPath("/freemarker");
			return configurer;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			registry.enableContentNegotiation(MappingJackson2JsonView())
			registry.freeMarker().cache(false)
		}

		@Bean
		fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply {
			setTemplateLoaderPath("/freemarker")
		}
	}
----



[[mvc-config-static-resources]]
=== 静态资源
[.small]#<<web-reactive.adoc#webflux-config-static-resources, WebFlux>>#

此选项提供了一种从 {api-spring-framework}/core/io/Resource.html[`Resource`] 库位置列表中使用静态资源的便捷方法

在下面的示例中,给定以 `/resources` 开头的请求,相对路径用于在 Web 应用程序根目录下或在或在 `/static` 下的类路径上查找和提供相对于 `/public` 的静态资源.  资源的有效期为 1 年,以确保最大程度地使用浏览器缓存,并减少浏览器发出的 HTTP 请求. `Last-Modified` 信息是从 `Resource#lastModified` 中推导出来的,以便 HTTP 条件请求带有 `"Last-Modified"` headers..

以下清单显示了如何使用 Java 配置执行此操作:

[source,java,indent=0,subs="verbatim",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/resources/**")
				.addResourceLocations("/public", "classpath:/static/")
				.setCacheControl(CacheControl.maxAge(Duration.ofDays(365)));
		}
	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public", "classpath:/static/")
					.setCacheControl(CacheControl.maxAge(Duration.ofDays(365)))
		}
	}
----

以下示例显示如何在 XML 中实现相同的配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:resources mapping="/resources/**"
		location="/public, classpath:/static/"
		cache-period="31556926" />
----

查看<<mvc-caching-static-resources, 静态资源的 HTTP 缓存支持>>.

资源处理还支持一系列 {api-spring-framework}/web/servlet/resource/ResourceResolver.html[`ResourceResolver`]  实现 和 {api-spring-framework}/web/servlet/resource/ResourceTransformer.html[`ResourceTransformer`]  实现, 可用于创建用于使用优化资源的工具

`VersionResourceResolver` 可用于基于内容、固定应用程序版本或其他的 MD5 哈希计算的版本化资源 url. `ContentVersionStrategy`(MD5 hash)方法是一个很好的选择, 有一些值得注意的例外,例如与模块加载器一起使用的 JavaScript 资源.

以下示例显示如何在 Java 配置中使用 `VersionResourceResolver`:

[source,java,indent=0,subs="verbatim",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public/")
					.resourceChain(true)
					.addResolver(new VersionResourceResolver().addContentVersionStrategy("/**"));
		}
	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public/")
					.resourceChain(true)
					.addResolver(VersionResourceResolver().addContentVersionStrategy("/**"))
		}
	}
----

以下示例显示如何在 XML 中实现相同的配置:

[source,xml,indent=0,subs="verbatim"]
----
<mvc:resources mapping="/resources/**" location="/public/">
	<mvc:resource-chain resource-cache="true">
		<mvc:resolvers>
			<mvc:version-resolver>
				<mvc:content-version-strategy patterns="/**"/>
			</mvc:version-resolver>
		</mvc:resolvers>
	</mvc:resource-chain>
</mvc:resources>
----

您可以使用 `ResourceUrlProvider` 来重写 URL 并应用完整的解析器和转换器链,例如插入版本. MVC 配置提供了 `ResourceUrlProvider` bean,因此可以将其注入到其他用户.  您还可以使用 `ResourceUrlEncodingFilter` 的 Thymeleaf、jsp、FreeMarker 和其他依赖于 `HttpServletResponse#encodeURL` 的URL标记来做重写转换.

请注意,当同时使用 `EncodedResourceResolver`(例如,用于提供gzipped或brotli编码的资源) 和 `VersionedResourceResolver` 时,必须按此顺序注册它们.  这可确保始终基于未编码的文件可靠地计算基于内容的版本.

https://www.webjars.org/documentation[WebJars] 也支持使用 `WebJarsResourceResolver` 和自动注册,当 `org.webjars:webjars-locator` 存在于类路径中时. 解析器可以重写 URL 来包含 jar 的版本,也可以与传入的 URL 匹配,而不需要版本 .  例如, `/jquery/jquery.min.js` 到 `/jquery/1.2.0/jquery.min.js`.

TIP: 基于 ResourceHandlerRegistry 的 Java 配置为细粒度控制提供了更多选项，例如 最后修改的行为和优化的资源解析。

[[mvc-default-servlet-handler]]
=== 默认 Servlet

这些配置允许将 `DispatcherServlet` 映射到 `/` 路径(也即覆盖了容器默认 Servlet 的映射) ,但依然保留容器默认的 Servlet 以处理静态资源的请求. 这可以通过配置一个URL映射到 `/**`  的处理器 `DefaultServletHttpRequestHandler` 来实现,并且该处理器在其他所有 URL 映射关系中优先级应该是最低的.

该处理器会将所有请求转发(forward) 到默认的 Servlet,因此需要保证它在所有 URL 处理器映射 `HandlerMappings` 的最后. 如果你是通过 `<mvc:annotation-driven>` 的方式进行配置, 或自定义 `HandlerMapping` 实例,那么需要确保该处理器 `order` 属性的值比 `DefaultServletHttpRequestHandler` 的次序值 `Integer.MAX_VALUE` 小.

以下示例显示如何使用默认设置启用该功能:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
			configurer.enable();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureDefaultServletHandling(configurer: DefaultServletHandlerConfigurer) {
			configurer.enable()
		}
	}
----

以下示例显示如何在 XML 中实现相同的配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:default-servlet-handler/>
----

不过需要注意,覆写了 `/` 的Servlet映射后,默认 Servlet 的 `RequestDispatcher` 就必须通过名字而非路径来取得了.  `DefaultServletHttpRequestHandler` 会尝试在容器初始化的时候自动检测默认 Servlet, 这里它使用的是一份主流 Servlet 容器(包括 Tomcat, Jetty, GlassFish, JBoss, Resin, WebLogic, and WebSphere) 已知的名称列表. 如果默认 Servlet 被配置了一个其他的名字,或者使用了一个列表里未提供默认 Servlet 名称的容器,那么默认 Servlet 的名称必须被显式指定,正如下面代码所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
			configurer.enable("myCustomDefaultServlet");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureDefaultServletHandling(configurer: DefaultServletHandlerConfigurer) {
			configurer.enable("myCustomDefaultServlet")
		}
	}
----


以下示例显示如何在 XML 中实现相同的配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:default-servlet-handler default-servlet-name="myCustomDefaultServlet"/>
----



[[mvc-config-path-matching]]
=== 路径匹配
[.small]#<<web-reactive.adoc#webflux-config-path-matching, WebFlux>>#

您可以自定义与路径匹配和 URL 处理相关的选项.  有关各个选项的详细信息,请参阅 {api-spring-framework}/web/servlet/config/annotation/PathMatchConfigurer.html[`PathMatchConfigurer`]  javadoc.

以下示例显示如何在 Java 配置中自定义路径匹配:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configurePathMatch(PathMatchConfigurer configurer) {
			configurer
				.setPatternParser(new PathPatternParser())
				.addPathPrefix("/api", HandlerTypePredicate.forAnnotation(RestController.class));
		}

		private PathPatternParser patternParser() {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configurePathMatch(configurer: PathMatchConfigurer) {
			configurer
				.setPatternParser(patternParser)
				.addPathPrefix("/api", HandlerTypePredicate.forAnnotation(RestController::class.java))
		}

		fun patternParser(): PathPatternParser {
			//...
		}
	}
----

以下示例显示如何在 XML 中实现相同的配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:annotation-driven>
		<mvc:path-matching
			trailing-slash="false"
			path-helper="pathHelper"
			path-matcher="pathMatcher"/>
	</mvc:annotation-driven>

	<bean id="pathHelper" class="org.example.app.MyPathHelper"/>
	<bean id="pathMatcher" class="org.example.app.MyPathMatcher"/>
----



[[mvc-config-advanced-java]]
=== 高级 Java 配置
[.small]#<<web-reactive.adoc#webflux-config-advanced-java, WebFlux>>#

`@EnableWebMvc` 导入 `DelegatingWebMvcConfiguration`, 其中

* 为 Spring MVC 应用程序提供了默认的 Spring 配置
* 检测到并委派到 `WebMvcConfigurer` 的自定义该配置

对于高级模式,请删除 `@EnableWebMvc` 并直接从 `DelegatingWebMvcConfiguration` 继承 ,而不是实现 `WebMvcConfigurer`,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class WebConfig extends DelegatingWebMvcConfiguration {

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class WebConfig : DelegatingWebMvcConfiguration() {

		// ...
	}
----

可以在 `WebConfig` 中保留现有的方法,但现在也可以重写基类中的 bean 声明,并且在类路径上仍然可以有任意数量的其他 `WebMvcConfigurer` .

[[mvc-config-advanced-xml]]
=== 高级 XML 配置

MVC 命名空间没有高级模式,如果需要自定义无法更改的 bean 上的属性,可以使用 `ApplicationContext` 的 `BeanPostProcessor` 生命周期挂钩,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Component
	public class MyPostProcessor implements BeanPostProcessor {

		public Object postProcessBeforeInitialization(Object bean, String name) throws BeansException {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class MyPostProcessor : BeanPostProcessor {
		
		override fun postProcessBeforeInitialization(bean: Any, name: String): Any {
			// ...
		}
	}
----

请注意,`MyPostProcessor` 需要用XML显式声明为 bean,或通过 `<component-scan/>` 声明检测.

[[mvc-http2]]
== HTTP/2
[.small]#<<web-reactive.adoc#webflux-http2, WebFlux>>#

Servlet 4 容器需要支持 HTTP/2,Spring Framework 5 与 Servlet API 4 兼容. 从编程模型的角度来看,应用程序不需要特定的任何操作.  但是,存在与服务器配置相关的注意事项.  有关更多详细信息,请参阅 https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support[ HTTP/2 wiki 页面].

Servlet API 确实暴露了一个与 HTTP/2 相关的构造.  您可以使用 `javax.servlet.http.PushBuilder` 主动将资源推送到客户端,并且它被支持作为 `@RequestMapping` 方法的<<mvc-ann-arguments, 方法参数>>.