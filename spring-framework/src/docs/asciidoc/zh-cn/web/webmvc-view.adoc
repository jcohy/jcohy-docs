[[mvc-view]]
=  视图技术
[.small]#<<web-reactive.adoc#webflux-view, WebFlux>>#

无论您决定使用 Thymeleaf,Groovy 标签模板,JSP 还是其他技术,Spring MVC 中视图技术的使用都是可配置的, 主要是配置更改的问题.  本章介绍了与 Spring MVC 集成的视图技术.  我们假设您已经熟悉 <<mvc-viewresolver>>.

WARNING: Spring MVC 应用程序的视图应用于内部可信的应用中. 因为视图可以访问应用程序上下文中的所有 bean. 因此,不建议在以下情况的应用程序中使用 Spring MVC 的模板支持:
模板可由外部源编辑,因为这可能会带来安全隐患.

[[mvc-view-thymeleaf]]
== Thymeleaf
[.small]#<<web-reactive.adoc#webflux-view-thymeleaf, WebFlux>>#

Thymeleaf 是一个现代服务器端 Java 模板引擎,它强调可以通过双击在浏览器中预览的自然 HTML 模板,这对于 UI 模板的独立工作(例如,由设计人员) 非常有用,而无需运行服务器.  如果您想要替换 JSP, https://www.thymeleaf.org/[Thymeleaf] 提供了一组最广泛的功能,使这种转换更容易.  Thymeleaf 积极开发和维护.  有关更完整的介绍,请参阅 Thymeleaf 项目主页.

Thymeleaf 与 Spring MVC 的集成由 Thymeleaf 项目管理.  配置涉及一些 bean 声明, 例如 `ServletContextTemplateResolver`, `SpringTemplateEngine`, 和 `ThymeleafViewResolver`.  有关详细信息,请参阅 https://www.thymeleaf.org/documentation.html[Thymeleaf+Spring].

[[mvc-view-freemarker]]
== FreeMarker
[.small]#<<web-reactive.adoc#webflux-view-freemarker, WebFlux>>#

https://freemarker.apache.org/[Apache FreeMarker] 是一个模板引擎,用于生成从 HTML 到电子邮件和其他的任何类型的文本输出.  Spring Framework 有一个内置的集成,可以将 Spring MVC 与 FreeMarker 模板结合使用.

[[mvc-view-freemarker-contextconfig]]
=== View 配置
[.small]#<<web-reactive.adoc#webflux-view-freemarker-contextconfig, WebFlux>>#

以下示例显示如何将 FreeMarker 配置为视图技术:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
		@Configuration
		@EnableWebMvc
		public class WebConfig implements WebMvcConfigurer {

			@Override
			public void configureViewResolvers(ViewResolverRegistry registry) {
				registry.freeMarker();
			}

			// Configure FreeMarker...

			@Bean
			public FreeMarkerConfigurer freeMarkerConfigurer() {
				FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
				configurer.setTemplateLoaderPath("/WEB-INF/freemarker");
				return configurer;
			}
		}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			registry.freeMarker()
		}

		// Configure FreeMarker...

		@Bean
		fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply {
			setTemplateLoaderPath("/WEB-INF/freemarker")
		}
	}
----

以下示例显示如何在 XML 中配置相同的内容:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:annotation-driven/>

	<mvc:view-resolvers>
		<mvc:freemarker/>
	</mvc:view-resolvers>

	<!-- Configure FreeMarker... -->
	<mvc:freemarker-configurer>
		<mvc:template-loader-path location="/WEB-INF/freemarker"/>
	</mvc:freemarker-configurer>
----

或者,您也可以声明 `FreeMarkerConfigurer` bean 以完全控制所有属性,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">
		<property name="templateLoaderPath" value="/WEB-INF/freemarker/"/>
	</bean>
----

模板需要存储在上面所示的 `FreeMarkerConfigurer` 指定的目录中,根据前面的配置,如果您的控制器返回 `welcome` 视图名称,解析器将查找 `/WEB-INF/freemarker/welcome.ftl` 模板.

[[mvc-views-freemarker]]
=== FreeMarker 配置
[.small]#<<web-reactive.adoc#webflux-views-freemarker, WebFlux>>#

通过设置 `FreeMarkerConfigurer` bean可以将 `FreeMarker` 的 'Settings' 和 'SharedVariables' 值直接传递 Spring 管理的 `FreeMarker` 对象.  `freemarkerSettings` 属性需要 `java.util.Properties` 对象.  而 `freemarkerVariables` 属性需要 `java.util.Map` . 以下示例显示了如何执行此操作:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">
		<property name="templateLoaderPath" value="/WEB-INF/freemarker/"/>
		<property name="freemarkerVariables">
			<map>
				<entry key="xml_escape" value-ref="fmXmlEscape"/>
			</map>
		</property>
	</bean>

	<bean id="fmXmlEscape" class="freemarker.template.utility.XmlEscape"/>
----

有关更多的 `Configuration` 内容的设置和变量可以查看 FreeMarker 文档

[[mvc-view-freemarker-forms]]
=== 表单处理

Spring 本身提供了用于 JSP 的标签库,其中包含(当然还有很多)  `<spring:bind/>` 标签,这个标签用来展示从 Web 上的 `Validator` 或业务层抛出的失败验证表单.  Spring 还支持 FreeMarker 中的相同功能,并提供了方便的宏来生成表单输入元素.

[[mvc-view-bind-macros]]
==== 绑定宏命令
[.small]#<<web-reactive.adoc#webflux-view-bind-macros, WebFlux>>#

`spring-webmvc.jar` 包文件包含 Velocity 和 FreeMarker 的一组标准宏,因此两者都适用.

Spring库中定义的某些宏被认为是内部的(私有的) ,但在宏定义中不存在这样的范围,其实所有宏都可以在调用代码和用户模板时看到. 以下各节仅集中于需要从模板中直接调用的宏, 如果希望直接查看宏代码, 那么可以看文件 `spring.ftl`, 定义在 `org.springframework.web.servlet.view.freemarker` 包中.


[[mvc-view-simple-binding]]
==== 简单的绑定

HTML 表单(vm 或 ftl 模板),充当了 Spring MVC 控制器的表单视图,可以使用类似下面的代码绑定字段值,也可以类似 JSP 那样在每个输入字段后面添加错误信息. 以下示例显示了之前配置的 `personForm` 视图:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- FreeMarker macros have to be imported into a namespace.
		We strongly recommend sticking to 'spring'. -->
	<#import "/spring.ftl" as spring/>
	<html>
		...
		<form action="" method="POST">
			Name:
			<@spring.bind "personForm.name"/>
			<input type="text"
				name="${spring.status.expression}"
				value="${spring.status.value?html}"/><br />
			<#list spring.status.errorMessages as error> <b>${error}</b> <br /> </#list>
			<br />
			...
			<input type="submit" value="submit"/>
		</form>
		...
	</html>
----

`<@spring.bind>` 需要一个包含命令对象的 'path' 参数(默认是 'command',除非在 FormController 属性中被改变了) ,后面跟着写需要绑定到命令对象上的字段名. 可以使用嵌套字段,例如 `command.address.street`,绑定宏可以在 `web.xml` 中设置 `ServletContext` 的参数 `defaultHtmlEscape`,用于定义 HTML 的转义行为.

`<@spring.bindEscaped>` 宏命令是可选的,它接收第二个参数并显式地指定是否应在状态错误消息或值中使用 HTML 转义. 按需设置为 `true` 或 `false`,还有很多其它的宏,它们将在下一节中介绍.

[[mvc-views-form-macros]]
==== 输入宏命令

Velocity 和 FreeMarker 都使用宏简化了绑定和表单的生成(包括验证错误的显示) ,没有必要使用这些宏来生成表单输入字段,实际上他们都可以直接绑定在简单的 HTML 中,并且可混合使用.

下表中的可用宏显示了 FTL 定义和每个参数列表:

[[views-macros-defs-tbl]]
.宏命令定义表
[cols="3,1"]
|===
| 宏命令 | FTL 定义表

| `message` (根据代码参数从资源包中输出字符串)
| <@spring.message code/>

| `messageText`(根据代码参数从资源包中输出一个字符串,失败则使用默认参数的值)
| <@spring.messageText code, text/>

| `url`(使用应用程序的上下文根作为相对URL的前缀)
| <@spring.url relativeUrl/>

| `formInput` (标准输入域用户收集用户信息)
| <@spring.formInput path, attributes, fieldType/>

| `formHiddenInput`  (用于提交肥输入域的隐藏字段)
| <@spring.formHiddenInput path, attributes/>

| `formPasswordInput` (用户收集密码的标准输入字段,请注意,此类型的字段中不会填充任何值)
| <@spring.formPasswordInput path, attributes/>

| `formTextarea` (大文本域,用于收集大而自由的文本输入)
| <@spring.formTextarea path, attributes/>

| `formSingleSelect` (下拉选项框,可以选择一个必需的值)
| <@spring.formSingleSelect path, options, attributes/>

| `formMultiSelect` (一个选项列表框,允许用户选择0或更多值)
| <@spring.formMultiSelect path, options, attributes/>

| `formRadioButtons` (单选按钮,可以从可用选项中进行单个选择)
| <@spring.formRadioButtons path, options separator, attributes/>

| `formCheckboxes`  (一组允许选择0或更多值的复选框)
| <@spring.formCheckboxes path, options, separator, attributes/>

| `formCheckbox` (单个复选框)
| <@spring.formCheckbox path, attributes/>

| `showErrors`  (简化绑定字段的验证错误显示)
| <@spring.showErrors separator, classOrStyle/>
|===

NOTE: 在FTL(FreeMarker) 中, `formHiddenInput` 和 `formPasswordInput` 这两个宏实际上并不需要,因为可以使用普通的 `formInput` 宏. 将 `hidden` 或 `password` 指定为 `fieldType` 参数的值

上述任何宏的参数都具有一致的含义

* `path`: 要绑定到的字段的名称(例如 "command.name")
* `options`: 可从输入字段中选择的所有可用值的映射,`map` 的键表示从表单 `POST` 后得到的对象的值(已绑定的) ,`Map` 对象保存这些键用于返回值后能在表单上显示出来.
通常这样 `map` 由控制器提供数据,任何map都可以实现按需使用,可以使用 `SortedMap`,例如 `TreeMap` 和适当的 `Comparator` 为所有的值排序,使用来自 `commons-collections` 包中的 `LinkedHashMap` 或 `LinkedMap` 也是相同的原理.
* `separator`: 多个选项可以作为元素(单选按钮或复选框) 可以使用标签对字符序列进行分隔(例如 `<br>`) .
* `attributes`: HTML标签本身中可以包含任意标签或文本的附加字符串. 字符串与上面的宏分别对应,例如,在一个文本字段提供属性 `'rows="5" cols="60"'` 字段, 也可以添加css,例如 `'style="border:1px solid silver"'`.
* `classOrStyle`: 对于 `showErrors` 宏, 可以使用 span 标签包装每个错误的 CSS 类的名称. 如果未提供任何信息 (或该值为空) ,则错误将包含在 `<b></b>` 标签中

以下部分概述了宏的示例(一些在 FTL 中,一些在 VTL 中) .  如果两种语言之间存在使用差异,则会在说明中对其进行说明.

[[mvc-views-form-macros-input]]
===== 输入域

`formInput` 宏采用 `path` 参数(`command.name`) 和附加 `attributes` 参数(在下一个示例中为空) . 宏与所有其他表单生成宏一起在 path 参数上执行隐式 Spring 绑定. 在出现新绑定之前, 前一个绑定仍然有效,因此 `showErrors` 宏不需要再次传递 `path` 参数,它只对上次为其创建绑定的任何字段进行操作.

`showErrors` 宏采用分隔符参数(将用于分隔给定字段上的多个错误的字符,同时还接受第二个参数: 类名或样式属性. 请注意,`FreeMarker` 能够为属性参数指定默认值,这与 `Velocity` 不同, 以下示例显示如何使用 `formInput` 和 `showErrors` 宏:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<@spring.formInput "command.name"/>
	<@spring.showErrors "<br>"/>
----

下一个示例显示表单片段的输出,生成名称字段并在提交表单后在字段中没有值时显示验证错误.  验证通过 Spring 的验证框架进行.

生成的 HTML 类似于以下示例:

[source,jsp,indent=0,subs="verbatim,quotes"]
----
	Name:
	<input type="text" name="name" value="">
	<br>
		<b>required</b>
	<br>
	<br>
----

`formTextarea` 宏类似于 `formInput` 宏,连接收的参数都是相同的. 通常,第二个参数(`attributes`) 将被使用用于传递格式信息或 `rows` 和 `cols` 的属性.

[[mvc-views-form-macros-select]]
===== 选择字段

有四个字段宏可以用于生产 HTML 表单中的公共 UI 值作为选择的输入:

* `formSingleSelect`
* `formMultiSelect`
* `formRadioButtons`
* `formCheckboxes`

这四个宏都可以从表单字段中接收 `Map`,其实需要的就是标签的值. 当然值和标签是可以取相同的名.

下一个例子是 FTL 中的单选按钮. 表单使用 'London' 作为这个字段的默认值,因此不需用进行验证. 当渲染表单时,要选择的整个城市列表都在 'cityMap' 中,`cityMap` 是数据模型. 以下清单显示了该示例:

[source,jsp,indent=0,subs="verbatim,quotes"]
----
	...
	Town:
	<@spring.formRadioButtons "command.address.town", cityMap, ""/><br><br>
----

前面的列表呈现一行单选按钮,一个用于 `cityMap` 中的每个值,并使用分隔符 `""`. 没有提供其他属性(缺少宏的最后一个参数) . `cityMap` 对Map中的每个键值对使用相同的 `String`.  映射的键是表单实际提交为 `POST` 请求参数的键.  map 值是用户看到的标签.  在前面的示例中,给定一个包含三个众所周知的城市的列表以及表单支持对象中的默认值,HTML 类似于以下内容:

[source,jsp,indent=0,subs="verbatim,quotes"]
----
	Town:
	<input type="radio" name="address.town" value="London">London</input>
	<input type="radio" name="address.town" value="Paris" checked="checked">Paris</input>
	<input type="radio" name="address.town" value="New York">New York</input>
----

如果您的应用程序希望通过内部代码来处理城市,可以写一个 name 为 cityMap 的 Map 传递给模板,如下面的例子:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	protected Map<String, ?> referenceData(HttpServletRequest request) throws Exception {
		Map<String, String> cityMap = new LinkedHashMap<>();
		cityMap.put("LDN", "London");
		cityMap.put("PRS", "Paris");
		cityMap.put("NYC", "New York");

		Map<String, Object> model = new HashMap<>();
		model.put("cityMap", cityMap);
		return model;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	protected fun referenceData(request: HttpServletRequest): Map<String, *> {
		val cityMap = linkedMapOf(
				"LDN" to "London",
				"PRS" to "Paris",
				"NYC" to "New York"
		)
		return hashMapOf("cityMap" to cityMap)
	}
----

代码将按你的设置输出,可以看到更多的城市名字.

[source,jsp,indent=0,subs="verbatim,quotes"]
----
	Town:
	<input type="radio" name="address.town" value="LDN">London</input>
	<input type="radio" name="address.town" value="PRS" checked="checked">Paris</input>
	<input type="radio" name="address.town" value="NYC">New York</input>
----


[[mvc-views-form-macros-html-escaping]]
==== HTML 转义

由于 HTML 的版本问题,上面的表单宏在 HTML 的 4.01 版本中需要使用到转义,转义可以在 `web.xml` 中通过 Spring 的绑定来定义. 为了使标签遵守 XHTML 的规定以及覆盖默认的 HTML 转义值, 可以在模板中定义两个变量(或者使你的模型设置为模板可见形式) . 在模板中指定的优点是: 它们可以在模板处理后更改为不同的值,以便为表单中的不同字段提供不同的行为.

要切换为标签的 XHTML 合规性,请为名为 `xhtmlCompliant` 的模型或上下文变量指定值 `true` ,如以下示例所示:

[source,jsp,indent=0,subs="verbatim,quotes"]
----
	<#-- for FreeMarker -->
	<#assign xhtmlCompliant = true>
----

处理完该指令后,Spring 宏生成的任何元素现在都符合 XHTML 标准.

以类似的方式,您可以指定每个字段的 HTML 转义,如以下示例所示:

[source,jsp,indent=0,subs="verbatim,quotes"]
----
	<#-- until this point, default HTML escaping is used -->

	<#assign htmlEscape = true>
	<#-- next field will use HTML escaping -->
	<@spring.formInput "command.name"/>

	<#assign htmlEscape = false in spring>
	<#-- all future fields will be bound with HTML escaping off -->
----

[[mvc-view-groovymarkup]]
== Groovy Markup

https://groovy-lang.org/templating.html#_the_markuptemplateengine[Groovy标签模板引擎]主要用于生成类似 XML 的标签(XML,XHTML,HTML5 等) ,但您可以使用它来生成任何基于文本的内容.  Spring Framework 有一个内置的集成,可以将 Spring MVC 与 Groovy Markup 结合使用.

NOTE: 目前要求使用 Groovy 2.3.1+ 的版本.

[[mvc-view-groovymarkup-configuration]]
=== 配置

以下示例显示如何配置 Groovy 标签模板引擎:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.groovy();
		}

		// Configure the Groovy Markup Template Engine...

		@Bean
		public GroovyMarkupConfigurer groovyMarkupConfigurer() {
			GroovyMarkupConfigurer configurer = new GroovyMarkupConfigurer();
			configurer.setResourceLoaderPath("/WEB-INF/");
			return configurer;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			registry.groovy()
		}

		// Configure the Groovy Markup Template Engine...

		@Bean
		fun groovyMarkupConfigurer() = GroovyMarkupConfigurer().apply {
			resourceLoaderPath = "/WEB-INF/"
		}
	}
----

以下示例显示如何在 XML 中配置相同的内容:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:annotation-driven/>

	<mvc:view-resolvers>
		<mvc:groovy/>
	</mvc:view-resolvers>

	<!-- Configure the Groovy Markup Template Engine... -->
	<mvc:groovy-configurer resource-loader-path="/WEB-INF/"/>
----



[[mvc-view-groovymarkup-example]]
=== 例子

与传统的模板引擎不同,Groovy 是依赖于使用生成器语法的 DSL.  以下示例显示了 HTML 页面的示例模板:

[source,groovy,indent=0,subs="verbatim,quotes"]
----
	yieldUnescaped '<!DOCTYPE html>'
	html(lang:'en') {
		head {
			meta('http-equiv':'"Content-Type" content="text/html; charset=utf-8"')
			title('My page')
		}
		body {
			p('This is an example of HTML contents')
		}
	}
----

[[mvc-view-script]]
== 脚本视图
[.small]#<<web-reactive.adoc#webflux-view-script, WebFlux>>#

Spring Framework 有一个内置的集成,可以将 Spring MVC 与任何可以在 https://www.jcp.org/en/jsr/detail?id=223[JSR-223] Java 脚本引擎之上运行的模板库一起使用.  我们在不同的脚本引擎上测试了以下模板库:

[%header]
|===
|Scripting Library |Scripting Engine
|https://handlebarsjs.com/[Handlebars] |https://openjdk.java.net/projects/nashorn/[Nashorn]
|https://mustache.github.io/[Mustache] |https://openjdk.java.net/projects/nashorn/[Nashorn]
|https://facebook.github.io/react/[React] |https://openjdk.java.net/projects/nashorn/[Nashorn]
|https://www.embeddedjs.com/[EJS] |https://openjdk.java.net/projects/nashorn/[Nashorn]
|https://www.stuartellis.name/articles/erb/[ERB] |https://www.jruby.org[JRuby]
|https://docs.python.org/2/library/string.html#template-strings[String templates] |https://www.jython.org/[Jython]
|https://github.com/sdeleuze/kotlin-script-templating[Kotlin Script templating] |https://kotlinlang.org/[Kotlin]
|===

TIP: 集成任何其他脚本引擎的基本规则是它必须实现 `ScriptEngine` 和 `Invocable` 接口.


[[mvc-view-script-dependencies]]
=== 要求
[.small]#<<web-reactive.adoc#webflux-view-script-dependencies, WebFlux>>#

您需要在类路径上安装脚本引擎,其详细信息因脚本引擎而异:

* https://openjdk.java.net/projects/nashorn/[Nashorn] Javascript 引擎提供了内置的 Java 8+. 强烈建议使用最新的可用更新版本.
* 为了获得 https://www.jruby.org[JRuby] 支持,应添加 JRuby 依赖性
* 为了获得 https://www.jython.org[Jython] 支持,应添加 Jython 依赖性.
* `org.jetbrains.kotlin:kotlin-script-util` 依赖和包含在 `META-INF/services/javax.script.ScriptEngineFactory` 文件里的 `org.jetbrains.kotlin.script.jsr223.KotlinJsr223JvmLocalScriptEngineFactory` 行应添加到 Kotlin 脚本支持中.  有关详细信息,请参阅此 https://github.com/sdeleuze/kotlin-script-templating[示例] .

还需要为基于脚本的模板引擎添加依赖. 例如,对于 JavaScript,可以使用 https://www.webjars.org/[WebJars].

[[mvc-view-script-integrate]]
=== 脚本模板
[.small]#<<web-reactive.adoc#webflux-view-script, WebFlux>>#

您可以声明 `ScriptTemplateConfigurer` bean 以指定要使用的脚本引擎,要加载的脚本文件,要调用以呈现模板的函数,等等.  以下示例使用 Mustache 模板和 Nashorn JavaScript 引擎:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.scriptTemplate();
		}

		@Bean
		public ScriptTemplateConfigurer configurer() {
			ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();
			configurer.setEngineName("nashorn");
			configurer.setScripts("mustache.js");
			configurer.setRenderObject("Mustache");
			configurer.setRenderFunction("render");
			return configurer;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			registry.scriptTemplate()
		}

		@Bean
		fun configurer() = ScriptTemplateConfigurer().apply {
			engineName = "nashorn"
			setScripts("mustache.js")
			renderObject = "Mustache"
			renderFunction = "render"
		}
	}
----

以下示例显示了 XML 中的相同排列:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:annotation-driven/>

	<mvc:view-resolvers>
		<mvc:script-template/>
	</mvc:view-resolvers>

	<mvc:script-template-configurer engine-name="nashorn" render-object="Mustache" render-function="render">
		<mvc:script location="mustache.js"/>
	</mvc:script-template-configurer>
----

对于 Java 和 XML 配置,控制器看起来没有什么不同,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class SampleController {

		@GetMapping("/sample")
		public String test(Model model) {
			model.addAttribute("title", "Sample title");
			model.addAttribute("body", "Sample body");
			return "template";
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class SampleController {

		@GetMapping("/sample")
		fun test(model: Model): String {
			model["title"] = "Sample title"
			model["body"] = "Sample body"
			return "template"
		}
	}
----

以下示例显示了 Mustache 模板:

[source,html,indent=0,subs="verbatim,quotes"]
----
	<html>
		<head>
			<title>{{title}}</title>
		</head>
		<body>
			<p>{{body}}</p>
		</body>
	</html>
----

使用以下参数调用 render 函数:

* `String template`: 模板内容
* `Map model`: 视图模型
* `RenderingContext renderingContext`:
  {api-spring-framework}/web/servlet/view/script/RenderingContext.html[`RenderingContext`]
提供对应用程序上下文,区域设置,模板加载器和 URL 的访问(自 5.0 起) .

`Mustache.render()` 方法会与本地兼容,因此可以直接调用.

如果模板化技术需要自定义,则可以提供实现自定义渲染函数的脚本. 例如, https://handlebarsjs.com[Handlerbars] 需要在使用模板之前进行编译,并且需要使用 https://en.wikipedia.org/wiki/Polyfill[polyfill] 以模拟服务器端脚本引擎中不可用的某些浏览器功能.

以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.scriptTemplate();
		}

		@Bean
		public ScriptTemplateConfigurer configurer() {
			ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();
			configurer.setEngineName("nashorn");
			configurer.setScripts("polyfill.js", "handlebars.js", "render.js");
			configurer.setRenderFunction("render");
			configurer.setSharedEngine(false);
			return configurer;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			registry.scriptTemplate()
		}

		@Bean
		fun configurer() = ScriptTemplateConfigurer().apply {
			engineName = "nashorn"
			setScripts("polyfill.js", "handlebars.js", "render.js")
			renderFunction = "render"
			isSharedEngine = false	
		}
	}
----

NOTE: 当要求非线程安全地使用脚本引擎时,需要将 `sharedEngine` 的属性设置为 `false` ,因为模板库不是为了并发而设计的,具体可以看运行在 Nashorn 上的 Handlerbars 或 react. 据此,需要 Java 8u60+ 的版本来修复这个 https://bugs.openjdk.java.net/browse/JDK-8076099[this bug].

`polyfill.js` 只需定义一个 `window` 对象,就可以被 Handlerbars 运行,如下所示:

[source,javascript,indent=0,subs="verbatim,quotes"]
----
	var window = {};
----

脚本 `render.js` 会在使用该模板之前被编译,一个好的产品应当保存和重用模板(使用缓存的方法) ,这样高效些. 这可以在脚本中完成,并且可以自定义它(例如管理模板引擎配置. 以下示例显示了如何执行此操作:

[source,javascript,indent=0,subs="verbatim,quotes"]
----
	function render(template, model) {
		var compiledTemplate = Handlebars.compile(template);
		return compiledTemplate(model);
	}
----

有关更多配置示例,请查看 Spring Framework 单元测试, {spring-framework-main-code}/spring-webmvc/src/test/java/org/springframework/web/servlet/view/script[Java] 和 {spring-framework-main-code}/spring-webmvc/src/test/resources/org/springframework/web/servlet/view/script[resources].

[[mvc-view-jsp]]
== JSP 和 JSTL

Spring 为 JSP 和 JSTL 视图提供了一些现成的解决方案

[[mvc-view-jsp-resolver]]
=== 视图解析

使用 JSP 进行开发时,可以声明 `InternalResourceViewResolver` bean.

`InternalResourceViewResolver` 可用于分发到任何 Servlet 资源， 尤其是 JSP.  作为最佳实践， 我们强烈建议您将 JSP 文件放在 `'WEB-INF'` 目录下的目录中， 以便客户端无法直接访问.

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/>
		<property name="prefix" value="/WEB-INF/jsp/"/>
		<property name="suffix" value=".jsp"/>
	</bean>
----



[[mvc-view-jsp-jstl]]
=== JSPs 和 JSTL

当使用 Java 标准标签库时,必须使用特殊的视图类 `JstlView`,因为 JSTL 需要一些准备工作,例如 I18N 功能.


[[mvc-view-jsp-tags]]
=== Spring 的 JSP 标签库

Spring 提供了请求参数与命令对象的数据绑定,如前面章节所述. 为了方便开发 JSP 页面,结合这些数据绑定功能,Spring 提供了一些使事情变得更容易的标签. 所有的 Spring 标签都 haveHTML 转义功能以启用或禁用字符转义.

`spring.tld` 标签库描述符(TLD) 在 `spring-webmvc.jar` 包中. 更多的信息,请浏览 {api-spring-framework}/web/servlet/tags/package-summary.html#package.description[API 参考] 或查看标签库说明.

[[mvc-view-jsp-formtaglib]]
=== Spring 的表单标签库

从 2.0 版本开始, Spring 在使用 JSP 和 Spring Web MVC 时为处理表单元素提供了一套完整的数据绑定识别标签. 每个标签都支持其相应的 HTML 标签对应的属性集,使标签熟悉和直观地使用,标签生成的 HTML 4.01/XHTML 1.0 兼容.

不同于其他的表单或输入标签库,Spring 的表单标签库是集成在 Spring Web MVC 中,标签可以使用控制器处理的命令对象和引用数据. 因此在下面的例子中将会看到,表单标签使得 JSP 更加方便开发、阅读和维护.

让我们浏览一下表单标签,看看如何使用每个标签的例子. 其中已经包括了生成的 HTML 片段,而某些标签需要进一步的讨论.


[[mvc-view-jsp-formtaglib-configuration]]
==== 配置

表单标签库捆绑在 `spring-webmvc.jar` 中. 库描述符名字为 `spring-form.tld`.

如果需要使用到这些标签,在 JSP 页面的头部必须添加对应的标签库

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
----
其中 `form` 是后面引用标签的前缀.


[[mvc-view-jsp-formtaglib-formtag]]
==== Form 标签

标签 'form' 绑定了引用库的内部标签,可以被 HTML 解析. 它将命令对象放在 `PageContext` 中,以便可以通过内部标签访问命令对象. 此库中的所有其他标签都是 form 标签的嵌套标签.

假设我们有一个名为 `User` 的域对象.  它是一个 JavaBean,具有 `firstName` 和 `lastName` 等属性. 我们将使用它作为表单控制器的形式支持对象,输出给 `form.jsp`. 以下示例显示了 `form.jsp` 的显示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<form:form>
		<table>
			<tr>
				<td>First Name:</td>
				<td><form:input path="firstName"/></td>
			</tr>
			<tr>
				<td>Last Name:</td>
				<td><form:input path="lastName"/></td>
			</tr>
			<tr>
				<td colspan="2">
					<input type="submit" value="Save Changes"/>
				</td>
			</tr>
		</table>
	</form:form>
----

`firstName` 和 `lastName` 值会从页面控制器放置在 `PageContext` 的命令对象中查找. 更多复杂的例子都是这样延伸的,重点就是内部标签是如何与 `form` 标签一起使用的.

以下清单显示了生成的 HTML,它看起来像标准格式:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<form method="POST">
		<table>
			<tr>
				<td>First Name:</td>
				<td><input name="firstName" type="text" value="Harry"/></td>
			</tr>
			<tr>
				<td>Last Name:</td>
				<td><input name="lastName" type="text" value="Potter"/></td>
			</tr>
			<tr>
				<td colspan="2">
					<input type="submit" value="Save Changes"/>
				</td>
			</tr>
		</table>
	</form>
----

之前的 JSP 假设表单的变量名是 `command`. 如果对象已经封装到另一个名称中了,表单也支持从自定义名称中绑定变量(这是最佳实践) . 如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<form:form modelAttribute="user">
		<table>
			<tr>
				<td>First Name:</td>
				<td><form:input path="firstName"/></td>
			</tr>
			<tr>
				<td>Last Name:</td>
				<td><form:input path="lastName"/></td>
			</tr>
			<tr>
				<td colspan="2">
					<input type="submit" value="Save Changes"/>
				</td>
			</tr>
		</table>
	</form:form>
----


[[mvc-view-jsp-formtaglib-inputtag]]
==== `input` 标签

这个标签其实就是 HTML 的 `input` 标签(当然是解析后的) ,此标签或默认绑定值和 `type='text'` 属性. 有关此的示例,请参阅<<mvc-view-jsp-formtaglib-formtag>>.  您还可以使用特定于 HTML5 的类型,例如 `email`, `tel`, `date` 等.

[[mvc-view-jsp-formtaglib-checkboxtag]]
==== `checkbox` 标签

 `checkbox` 也会解析成 HTML 的 `input` 标签.

假设 `User` 对象拥有新闻订阅和爱好列表属性,显示了 `Preferences` 类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class Preferences {

		private boolean receiveNewsletter;
		private String[] interests;
		private String favouriteWord;

		public boolean isReceiveNewsletter() {
			return receiveNewsletter;
		}

		public void setReceiveNewsletter(boolean receiveNewsletter) {
			this.receiveNewsletter = receiveNewsletter;
		}

		public String[] getInterests() {
			return interests;
		}

		public void setInterests(String[] interests) {
			this.interests = interests;
		}

		public String getFavouriteWord() {
			return favouriteWord;
		}

		public void setFavouriteWord(String favouriteWord) {
			this.favouriteWord = favouriteWord;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class Preferences(
			var receiveNewsletter: Boolean,
			var interests: StringArray,
			var favouriteWord: String
	)
----

相应的 `form.jsp` 可能类似于以下内容:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<form:form>
		<table>
			<tr>
				<td>Subscribe to newsletter?:</td>
				<%-- Approach 1: Property is of type java.lang.Boolean --%>
				<td><form:checkbox path="preferences.receiveNewsletter"/></td>
			</tr>

			<tr>
				<td>Interests:</td>
				<%-- Approach 2: Property is of an array or of type java.util.Collection --%>
				<td>
					Quidditch: <form:checkbox path="preferences.interests" value="Quidditch"/>
					Herbology: <form:checkbox path="preferences.interests" value="Herbology"/>
					Defence Against the Dark Arts: <form:checkbox path="preferences.interests" value="Defence Against the Dark Arts"/>
				</td>
			</tr>

			<tr>
				<td>Favourite Word:</td>
				<%-- Approach 3: Property is of type java.lang.Object --%>
				<td>
					Magic: <form:checkbox path="preferences.favouriteWord" value="Magic"/>
				</td>
			</tr>
		</table>
	</form:form>
----

`checkbox` 标签有三种方法,可满足您的所有复选框需求.

* 方法一: 当绑定值为 `java.lang.Boolean`, 如果绑定值为 `true`. 则 `input(checkbox)` 被标签为 `checked` . `value` 属性对应于 `setValue(Object)` 的值(当然是解析后的) .
* 方法二: 当绑定值是 `array` 或 `java.util.Collection`,如果绑定集合中存在已配置的 `setValue(Object)` 则输入(复选框) 将标签为已选中.
* 方法三: 对于任何其他绑定值类型, 如果配置的 `setValue(Object)` 等于绑定值,则 `input(checkbox)` 被标签为已选中.

请注意,无论采用何种方法,都会生成相同的 HTML 结构.  以下 HTML 代码段定义了一些复选框:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<tr>
		<td>Interests:</td>
		<td>
			Quidditch: <input name="preferences.interests" type="checkbox" value="Quidditch"/>
			<input type="hidden" value="1" name="_preferences.interests"/>
			Herbology: <input name="preferences.interests" type="checkbox" value="Herbology"/>
			<input type="hidden" value="1" name="_preferences.interests"/>
			Defence Against the Dark Arts: <input name="preferences.interests" type="checkbox" value="Defence Against the Dark Arts"/>
			<input type="hidden" value="1" name="_preferences.interests"/>
		</td>
	</tr>
----

可能不希望看到的是每个复选框后都附加隐藏域,如果 html 页中的复选框一个都没有选中,则在提交表单后,它的值将不会作为 HTTP 请求参数的一部分发送到服务器,因此为了使 Spring 表单数据绑定工作.
需要在 html 中使用此奇怪的变通方法. `checkbox` 标签遵循现有的 Spring 约定,其中包括每个复选框都以下划线 `_` 为前缀的隐藏参数. 通过这样做,可以有效地告诉 Spring"该复选框在表单中是可见的,并且希望将表单数据绑定到其上的对象能够反映复选框的状态".

[[mvc-view-jsp-formtaglib-checkboxestag]]
==== `checkboxes` 标签

`checkbox` 标签相当于多个HTML的 `input` 标签

上一个例子展示了复选框标签的生成. 有时候,不希望在 JSP 页面中列出 `User` 的所有爱好. 你更希望在运行提供可选的列表,并传递给复选框标签. 这是复选框标签的用途.
可以传入一个 `Array`、 一个 `List` 或一个包含 `items` 属性中的可用选项的 `Map`. 绑定属性通常是一个集合,因此它可以保存用户选择的多个值. 下面是使用此标签的 JSP 示例

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<form:form>
		<table>
			<tr>
				<td>Interests:</td>
				<td>
					<%-- Property is of an array or of type java.util.Collection --%>
					<form:checkboxes path="preferences.interests" items="${interestList}"/>
				</td>
			</tr>
		</table>
	</form:form>
----

本实例假定 `interestList` 是一个模型的属性 `List`,包含需要的字符串值. 在使用 MAP 的情况下,`Map` 的 key 将用作值,map 的 value 将用作要显示的标签. 还可以使用自定义对象,可以使用 `itemValue` 和使用 `itemLabel` 的标签作为该值提供属性名称.

[[mvc-view-jsp-formtaglib-radiobuttontag]]
==== `radiobutton` 标签

还有一个可以解析成 HTML `input` 标签的是 `radio` 标签

radio 很简单,提供多个值,但是一次只能选其中一个. 如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<tr>
		<td>Sex:</td>
		<td>
			Male: <form:radiobutton path="sex" value="M"/> <br/>
			Female: <form:radiobutton path="sex" value="F"/>
		</td>
	</tr>
----


[[mvc-view-jsp-formtaglib-radiobuttonstag]]
==== `radiobuttons` 标签

这个形式的 `radio` 也可以解析成 HTML 的 `input` 标签,只是它是多个单选.

就像上面的<<mvc-view-jsp-formtaglib-checkboxestag, `checkboxes` tag>>一样,可能希望将可用选项作为运行时变量传入. 对于此用法,可以使用单选标签. 可以传入一个数组、一个列表或一个包含 `items` 属性的 `Map`.
如果使用 map,map 的 key 将使用作为值并且 map 的值将使用作为标签来显示. 还可以使用自定义对象,可以使用 `itemValue` 和使用 `itemLabel` 的标签作为该值提供属性名称.

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<tr>
		<td>Sex:</td>
		<td><form:radiobuttons path="sex" items="${sexOptions}"/></td>
	</tr>
----


[[mvc-view-jsp-formtaglib-passwordtag]]
==== `password` 标签

`password` 标签页会解析成 HTML 的 `input` 标签 只是它有自己的特性.

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<tr>
		<td>Password:</td>
		<td>
			<form:password path="password"/>
		</td>
	</tr>
----

请注意,密码值是不可见的. 如果希望密码值可见,需要设置 `showPassword` 属性为 `true`,如下所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<tr>
		<td>Password:</td>
		<td>
			<form:password path="password" value="^76525bvHGq" showPassword="true"/>
		</td>
	</tr>
----


[[mvc-view-jsp-formtaglib-selecttag]]
==== `select` 标签

这个标签就是 HTML 的 `select` 元素. 支持单层选项或嵌套选项的选择,数据利用项来绑定.

让我们假设 `User`,他有一个技能列表如下:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<tr>
		<td>Skills:</td>
		<td><form:select path="skills" items="${skills}"/></td>
	</tr>
----

如果User选中的技能是Herbology,那么这个Skills的HTML源代码是这样的:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<tr>
		<td>Skills:</td>
		<td>
			<select name="skills" multiple="true">
				<option value="Potions">Potions</option>
				<option value="Herbology" selected="selected">Herbology</option>
				<option value="Quidditch">Quidditch</option>
			</select>
		</td>
	</tr>
----


[[mvc-view-jsp-formtaglib-optiontag]]
==== `option` 标签

这个标签就是 HTML 的 `option`(配合 `select` 中) 元素. 它会对被绑定的值设置属性为 `selected`,以下 HTML 显示了它的典型输出:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<tr>
		<td>House:</td>
		<td>
			<form:select path="house">
				<form:option value="Gryffindor"/>
				<form:option value="Hufflepuff"/>
				<form:option value="Ravenclaw"/>
				<form:option value="Slytherin"/>
			</form:select>
		</td>
	</tr>
----

如果 User 的家是在 Gryffindor,那么 House 的 HTML 源代码长这样:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<tr>
		<td>House:</td>
		<td>
			<select name="house">
				<option value="Gryffindor" selected="selected">Gryffindor</option> <1>
				<option value="Hufflepuff">Hufflepuff</option>
				<option value="Ravenclaw">Ravenclaw</option>
				<option value="Slytherin">Slytherin</option>
			</select>
		</td>
	</tr>
----
<1> 注意增加了一个 `selected` 属性.


[[mvc-view-jsp-formtaglib-optionstag]]
==== `options` 标签

这个标签就是 HTML 的 `option`(配合 `select` 中)元素,但是它处理的是一个列表,它会对被绑定的值设置属性为 `selected`,如下所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<tr>
		<td>Country:</td>
		<td>
			<form:select path="country">
				<form:option value="-" label="--Please Select"/>
				<form:options items="${countryList}" itemValue="code" itemLabel="name"/>
			</form:select>
		</td>
	</tr>
----

如果 `User` 住在 UK,那么 Country 的 HTML 源代码长这这样:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<tr>
		<td>Country:</td>
		<td>
			<select name="country">
				<option value="-">--Please Select</option>
				<option value="AT">Austria</option>
				<option value="UK" selected="selected">United Kingdom</option> <1>
				<option value="US">United States</option>
			</select>
		</td>
	</tr>
----
<1> 注意增加了一个 `selected` 属性.

看上面的两个例子, `option` 和 `options` 标签都生成了相同的标准的 HTML,但允许你在 JSP 中显式地按需显示属性值,例如默认的字符串在例子中是"-- Please Select"(就是默认的,选择为空的那个,这个很有用) .

`items` 属性通常使用项对象的集合或数组填充, `itemValue` 和 `itemLabel` 就是对应指定 bean 对象的属性,如果没有指定,对象将被转成字符串. 或者, 可以定义一个 `Map` 的 `items`,Map 的 key 对应选项值,value 对应选项标签. 如果如果 `itemValue` 和 `itemLabel` 都被指定了,那么 item 值属性对应 key,item 标签属性对应 value.

[[mvc-view-jsp-formtaglib-textareatag]]
==== `textarea` 标签

这个标签解析成 HTML 中的 `textarea` 标签:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<tr>
		<td>Notes:</td>
		<td><form:textarea path="notes" rows="3" cols="20"/></td>
		<td><form:errors path="notes"/></td>
	</tr>
----


[[mvc-view-jsp-formtaglib-hiddeninputtag]]
==== The `hidden` 标签

`hidden` 标签解析为 HTML 的 hidden,用在 `input` 标签中用于 `hidden` 绑定值,目的很明显就是 `hidden` ,如下

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<form:hidden path="house"/>
----

如果我们选择 `house` 值作为隐藏 domain 提交, HTML 长这样:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<input name="house" type="hidden" value="Gryffindor"/>

----


[[mvc-view-jsp-formtaglib-errorstag]]
==== `errors` 标签

这个标签会在 HTML 的 `span` 标签中展示错误,它提供对在控制器中创建的错误的访问,或对与控制器关联的任何验证程序创建的出错信息进行显示.

假设我们希望在提交表单后显示 `firstName` 和 `lastName` 字段的所有错误信息,我们有一个验证器的实例的 `User` 类称为 `UserValidator`. 如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class UserValidator implements Validator {

		public boolean supports(Class candidate) {
			return User.class.isAssignableFrom(candidate);
		}

		public void validate(Object obj, Errors errors) {
			ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "required", "Field is required.");
			ValidationUtils.rejectIfEmptyOrWhitespace(errors, "lastName", "required", "Field is required.");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class UserValidator : Validator {

		override fun supports(candidate: Class<*>): Boolean {
			return User::class.java.isAssignableFrom(candidate)
		}

		override fun validate(obj: Any, errors: Errors) {
			ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "required", "Field is required.")
			ValidationUtils.rejectIfEmptyOrWhitespace(errors, "lastName", "required", "Field is required.")
		}
	}
----

这个 `form.jsp` 看起来是这样的:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<form:form>
		<table>
			<tr>
				<td>First Name:</td>
				<td><form:input path="firstName"/></td>
				<%-- Show errors for firstName field --%>
				<td><form:errors path="firstName"/></td>
			</tr>

			<tr>
				<td>Last Name:</td>
				<td><form:input path="lastName"/></td>
				<%-- Show errors for lastName field --%>
				<td><form:errors path="lastName"/></td>
			</tr>
			<tr>
				<td colspan="3">
					<input type="submit" value="Save Changes"/>
				</td>
			</tr>
		</table>
	</form:form>
----

如果我们将 `firstName` 和 `lastName` 的域设置空值并提交,则 html 看起来是这样的:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<form method="POST">
		<table>
			<tr>
				<td>First Name:</td>
				<td><input name="firstName" type="text" value=""/></td>
				<%-- Associated errors to firstName field displayed --%>
				<td><span name="firstName.errors">Field is required.</span></td>
			</tr>

			<tr>
				<td>Last Name:</td>
				<td><input name="lastName" type="text" value=""/></td>
				<%-- Associated errors to lastName field displayed --%>
				<td><span name="lastName.errors">Field is required.</span></td>
			</tr>
			<tr>
				<td colspan="3">
					<input type="submit" value="Save Changes"/>
				</td>
			</tr>
		</table>
	</form>
----

如果我们要显示给定页面的整个错误列表,该怎么办? 下面的示例显示了 `errors` 标签还支持一些基本的通用功能

* `path="{asterisk}"`: 展示所有的错误.
* `path="lastName"`: 展示 `lastName` 域的所有错误
* 如果 `path` 被省略,只会显示当前对象的错误.

下面的示例将显示页面顶部的错误列表,后跟字段旁边的特定于字段的错误:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<form:form>
		<form:errors path="*" cssClass="errorBox"/>
		<table>
			<tr>
				<td>First Name:</td>
				<td><form:input path="firstName"/></td>
				<td><form:errors path="firstName"/></td>
			</tr>
			<tr>
				<td>Last Name:</td>
				<td><form:input path="lastName"/></td>
				<td><form:errors path="lastName"/></td>
			</tr>
			<tr>
				<td colspan="3">
					<input type="submit" value="Save Changes"/>
				</td>
			</tr>
		</table>
	</form:form>
----

html 看起来是这样的:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<form method="POST">
		<span name="*.errors" class="errorBox">Field is required.<br/>Field is required.</span>
		<table>
			<tr>
				<td>First Name:</td>
				<td><input name="firstName" type="text" value=""/></td>
				<td><span name="firstName.errors">Field is required.</span></td>
			</tr>

			<tr>
				<td>Last Name:</td>
				<td><input name="lastName" type="text" value=""/></td>
				<td><span name="lastName.errors">Field is required.</span></td>
			</tr>
			<tr>
				<td colspan="3">
					<input type="submit" value="Save Changes"/>
				</td>
			</tr>
		</table>
	</form>
----

`spring-webmvc.jar` 中包含 `spring-form.tld` 标签库描述符(TLD) . 有关单个标签的全面参考,请浏览 {api-spring-framework}/web/servlet/tags/form/package-summary.html#package.description[API 参考] 或查看标签库说明.

[[mvc-rest-method-conversion]]
==== HTTP 方法转换

REST 的一个关键原则是使用统一的接口. 这意味着所有资源(URL)都可以使用相同的四种 HTTP 方法进行操作 GET, PUT, POST,和 DELETE. 对于每个方法,HTTP 规范都定义了精确的语义.
例如, GET 应该始终是一个安全的操作,这意味着它对服务器的数据没有任何影响. 而 PUT 或 DELETE 应该是幂等的,这意味着可以反复重复这些操作,其最终结果应该是相同的. 虽然 HTTP 定义了这四种方法,但是 HTML 只支持两个: GET 和 POST.
幸运的是,有两种可能的解决方法: 1,可以使用 JavaScript 来执行 PUT 或 DELETE. 2,简单地用 "real" 的方式作为附加参数(作为 HTML 表单中的隐藏输入字段)进行 POST. 后者是使用 Spring 的 `HiddenHttpMethodFilter` 做的.
这个过滤器是一个简单的 Servlet 过滤器,因此它可以与任何 Web 框架(不仅仅是 Spring MVC)结合使用,只需将此过滤器添加到  web.xml,并将具有隐藏域 `method` 参数转换为相应的 HTTP 方法请求.


为了支持 HTTP 方法转换,Spring MVC 表单标签已更新为支持设置 HTTP 方法.  例如,以下代码片段来自 "宠物诊所" 示例:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<form:form method="delete">
		<p class="submit"><input type="submit" value="Delete Pet"/></p>
	</form:form>
----

实际上它就是一个 HTTP POST,DELETE 方法只是隐藏在请求参数中的假正经方法而已,这个 DELETE 将被定义在 web.xml 的 `HiddenHttpMethodFilter` 来处理,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<filter>
		<filter-name>httpMethodFilter</filter-name>
		<filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
	</filter>

	<filter-mapping>
		<filter-name>httpMethodFilter</filter-name>
		<servlet-name>petclinic</servlet-name>
	</filter-mapping>
----

以下示例显示了相应的 `@Controller` 方法:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RequestMapping(method = RequestMethod.DELETE)
	public String deletePet(@PathVariable int ownerId, @PathVariable int petId) {
		this.clinic.deletePet(petId);
		return "redirect:/owners/" + ownerId;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RequestMapping(method = [RequestMethod.DELETE])
	fun deletePet(@PathVariable ownerId: Int, @PathVariable petId: Int): String {
		clinic.deletePet(petId)
		return "redirect:/owners/$ownerId"
	}
----

[[mvc-view-jsp-formtaglib-html5]]
==== HTML5 标签

表单标签库允许输入动态属性,这意味着您可以输入任何 HTML5 的特定属性.

表单 `input` 标签支持输入文本以外的类型属性.  他允许 HTML5 定义输入类型,例如 `email`, `date`,`range` 等.  请注意,因为 `text` 是默认类型,因此不需要输入 `type='text'`

[[mvc-view-tiles]]
== Tiles

Spring Web 应用还可以集成 Tiles,就像其它视图技术一样. 下面将描述怎样集成.

NOTE: 本节重点介绍 Spring 在 `org.springframework.web.servlet.view.tiles3` 包中对 Tiles 版本 3 的支持.

[[mvc-view-tiles-dependencies]]
=== 依赖

为了能够使用 Tiles,您必须在 Tiles 3.0.1 或更高版本上添加依赖及其对项目的 https://tiles.apache.org/framework/dependency-management.html[依赖传递].


[[mvc-view-tiles-integrate]]
=== 配置

为了能够使用 Tiles,您必须使用包含定义的文件对其进行配置(有关定义和其他 Tiles 概念的基本信息,请参阅 https://tiles.apache.org[]) .  在 Spring 中,这是通过使用 `TilesConfigurer` 完成的.  以下示例 `ApplicationContext` 配置显示了如何执行此操作:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles3.TilesConfigurer">
		<property name="definitions">
			<list>
				<value>/WEB-INF/defs/general.xml</value>
				<value>/WEB-INF/defs/widgets.xml</value>
				<value>/WEB-INF/defs/administrator.xml</value>
				<value>/WEB-INF/defs/customer.xml</value>
				<value>/WEB-INF/defs/templates.xml</value>
			</list>
		</property>
	</bean>
----

这里的 Tiles 定义了五个文件,都位于 `WEB-INF/defs` 文件夹中. 在初始化 `WebApplicationContext` 时 ,文件将被加载,定义工厂将被初始化. 完成此操作之后,在 Spring Web 应用程序中,定义文件中包含的 Tiles 可以用作视图.  之后 Spring 使用 Tiles 与使用其他视图是一样的: 通常是一个便捷的 `TilesViewResolver`..

您可以通过添加下划线然后添加区域设置来指定特定于区域设置的 Tiles 定义,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles3.TilesConfigurer">
		<property name="definitions">
			<list>
				<value>/WEB-INF/defs/tiles.xml</value>
				<value>/WEB-INF/defs/tiles_fr_FR.xml</value>
			</list>
		</property>
	</bean>
----

使用上述配置,`tiles_fr_FR.xml` 用于具有 `fr_FR` 语言环境的请求,默认情况下使用 `tiles.xml`.

NOTE: 由于下划线用于表示区域设置,因此我们建议不要在 Tiles 定义的文件名中使用它们.

[[mvc-view-tiles-url]]
==== `UrlBasedViewResolver`

`UrlBasedViewResolver` 对给定的 `viewClass` 进行实例化,即会解析所有的视图.  以下 bean 定义了 `UrlBasedViewResolver`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="viewResolver" class="org.springframework.web.servlet.view.UrlBasedViewResolver">
		<property name="viewClass" value="org.springframework.web.servlet.view.tiles3.TilesView"/>
	</bean>
----

[[mvc-view-tiles-preparer]]
==== `SimpleSpringPreparerFactory` 和 `SpringBeanPreparerFactory`

作为一个高级功能,Spring 还支持两个特殊的 Tiles `PreparerFactory` 实现,有关如何在 Tiles 定义文件中使用 `ViewPreparer` 引用的详细信息,请参阅 Tiles 文档.

您可以指定 `SimpleSpringPreparerFactory` 以基于以下条件自动装配 `ViewPreparer` 实例指定的准备器类,应用 Spring 的容器回调以及应用配置的 Spring `BeanPostProcessors`.  如果 Spring 的上下文范围注解配置具有激活后,将自动检测 "ViewPreparer" 类中的注解并 应用.  请注意,这需要 Tiles 定义文件中的 preparer 类,如下所示: 默认的 "PreparerFactory" 会这么做.

您可以指定 `SpringBeanPreparerFactory` 来操作指定的 preparer 名称(而不是类) ,从 DispatcherServlet 的应用程序上下文中获取相应的 Spring bean. 在这种情况下,完整的 bean 创建过程控制着 Spring 应用程序上下文,允许使用显式依赖注入配置,作用域 bean 等.
请注意,您需要为每个 preparer 名称定义一个 Spring bean 定义(在 Tiles 定义中使用) .  以下示例显示如何在 `TilesConfigurer` 上定义一个 `SpringBeanPreparerFactory` 属性集:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles3.TilesConfigurer">
		<property name="definitions">
			<list>
				<value>/WEB-INF/defs/general.xml</value>
				<value>/WEB-INF/defs/widgets.xml</value>
				<value>/WEB-INF/defs/administrator.xml</value>
				<value>/WEB-INF/defs/customer.xml</value>
				<value>/WEB-INF/defs/templates.xml</value>
			</list>
		</property>

		<!-- resolving preparer names as Spring bean definition names -->
		<property name="preparerFactoryClass"
				value="org.springframework.web.servlet.view.tiles3.SpringBeanPreparerFactory"/>

	</bean>
----


[[mvc-view-feeds]]
== RSS 和 Atom

`AbstractAtomFeedView` 和 `AbstractRssFeedView` 都继承自 `AbstractFeedView` 基类,分别用于提供 Atom 和 RSS Feed 视图.  它们基于java.net的 https://rometools.github.io/rome/[ROME] 项目,位于 `org.springframework.web.servlet.view.feed` 包中.

`AbstractAtomFeedView` 要求实现 `buildFeedEntries()` 方法,并可选择重写 `buildFeedMetadata()` 方法(默认实现为空).以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SampleContentAtomView extends AbstractAtomFeedView {

		@Override
		protected void buildFeedMetadata(Map<String, Object> model,
				Feed feed, HttpServletRequest request) {
			// implementation omitted
		}

		@Override
		protected List<Entry> buildFeedEntries(Map<String, Object> model,
				HttpServletRequest request, HttpServletResponse response) throws Exception {
			// implementation omitted
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SampleContentAtomView : AbstractAtomFeedView() {
		
		override fun buildFeedMetadata(model: Map<String, Any>,
				feed: Feed, request: HttpServletRequest) {
			// implementation omitted
		}

		override fun buildFeedEntries(model: Map<String, Any>,
				request: HttpServletRequest, response: HttpServletResponse): List<Entry> {
			// implementation omitted
		}
	}
----

类似的要求适用于实现 `AbstractRssFeedView`,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SampleContentRssView extends AbstractRssFeedView {

		@Override
		protected void buildFeedMetadata(Map<String, Object> model,
				Channel feed, HttpServletRequest request) {
			// implementation omitted
		}

		@Override
		protected List<Item> buildFeedItems(Map<String, Object> model,
				HttpServletRequest request, HttpServletResponse response) throws Exception {
			// implementation omitted
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SampleContentRssView : AbstractRssFeedView() {

		override fun buildFeedMetadata(model: Map<String, Any>,
									feed: Channel, request: HttpServletRequest) {
			// implementation omitted
		}

		override fun buildFeedItems(model: Map<String, Any>,
				request: HttpServletRequest, response: HttpServletResponse): List<Item> {
			// implementation omitted
		}
	}
----


`buildFeedItems()` 和 `buildFeedEntries()` 方法在 HTTP 请求中传递,以防需要访问区域设置. 仅为 cookie 或其他 http 头的设置传递 http 响应. 该 feed 将在方法返回后自动写入响应对象.

有关创建 Atom 视图的示例,请参阅 Alef Arendsen 的 Spring Team Blog https://spring.io/blog/2009/03/16/adding-an-atom-view-to-an-application-using-spring-s-rest-support[entry].

[[mvc-view-document]]
== PDF 和 Excel

Spring 提供了返回 HTML 以外的输出的方法,包括 PDF 和 Excel 电子表格.  本节介绍如何使用这些功能.

[[mvc-view-document-intro]]
=== 文档视图简介

返回 HTML 页并不总是用户查看模型输出的最佳方式,Spring 让开发者可以从模型数据动态生成 PDF 文档或 Excel 电子表格. 该文档是视图,将从具有正确内容类型的服务器流式传输到 HTML,使客户端 PC 能够运行其电子表格或 PDF 查看器应用程序以进行响应.

要使用 Excel 视图,需要将 Apache POI 库添加到类路径中. 对于 PDF 生成,您需要添加(最好) OpenPDF 库.

NOTE: 如果可能,您应该使用最新版本的基础文档生成库.  特别是,我们强烈建议使用 OpenPDF(例如,OpenPDF 1.0.5) 而不是过时的原始 iText 2.1.7,因为 OpenPDF 是主动维护的,并修复了不受信任的 PDF 内容的重要漏洞.


[[mvc-view-document-pdf]]
=== PDF 视图

单词列表的简单 PDF 视图可以扩展 `org.springframework.web.servlet.view.document.AbstractPdfView` 并实现 `buildPdfDocument()` 方法,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class PdfWordList extends AbstractPdfView {

		protected void buildPdfDocument(Map<String, Object> model, Document doc, PdfWriter writer,
				HttpServletRequest request, HttpServletResponse response) throws Exception {

			List<String> words = (List<String>) model.get("wordList");
			for (String word : words) {
				doc.add(new Paragraph(word));
			}
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class PdfWordList : AbstractPdfView() {

		override fun buildPdfDocument(model: Map<String, Any>, doc: Document, writer: PdfWriter,
				request: HttpServletRequest, response: HttpServletResponse) {

			val words = model["wordList"] as List<String>
			for (word in words) {
				doc.add(Paragraph(word))
			}
		}
	}
----

控制器可以从外部视图定义(通过名称引用它) 返回这样的视图,也可以从处理程序方法返回 `View` 实例.

[[mvc-view-document-excel]]
=== Excel 视图

从 Spring Framework 4.2 开始,`org.springframework.web.servlet.view.document.AbstractXlsView` 作为 Excel 视图的基类提供.  它基于 Apache POI,具有专门的子类(`AbstractXlsxStreamingView` 和 `AbstractExcelView`) ,取代了过时的 `AbstractXlsxView` 类.

编程模型类似于 `AbstractPdfView`,`buildExcelDocument()` 作为核心模板方法,控制器能够从外部定义(通过名称) 返回这样的视图,或者从处理程序方法返回 `View` 实例.

[[mvc-view-jackson]]
== Jackson
[.small]#<<web-reactive.adoc#webflux-view-httpmessagewriter, WebFlux>>#

Spring 为 Jackson JSON 库提供支持.

[[mvc-view-json-mapping]]
=== 基于 Jackson 的 JSON 视图
[.small]#<<web-reactive.adoc#webflux-view-httpmessagewriter, WebFlux>>#

`MappingJackson2JsonView` 使用 Jackson 库的 `ObjectMapper` 将响应内容呈现为 JSON.  默认情况下,模型映射的全部内容(特定于框架的类除外) 都编码为 JSON.  对于需要过滤 Map 内容的情况,您可以使用 `modelKeys` 属性指定要编码的特定模型属性集.  您还可以使用 `extractValueFromSingleKeyModel` 属性将 `single-key` 模型中的值直接提取和序列化,而不是作为模型属性的映射.

您可以使用 Jackson 提供的注解根据需要自定义 JSON 映射.  当您需要进一步控制时,可以通过 `ObjectMapper` 属性注入自定义 `ObjectMapper`,以用于需要为特定类型提供自定义 JSON 序列化程序和反序列化程序的情况.

[[mvc-view-xml-mapping]]
=== 基于 Jackson 的 XML 视图
[.small]#<<web-reactive.adoc#webflux-view-httpmessagewriter, WebFlux>>#

`MappingJackson2XmlView` 使用 https://github.com/FasterXML/jackson-dataformat-xml[Jackson XML 扩展]的 `XmlMapper` 将响应内容呈现为 XML.  如果模型包含多个条目,则应使用 `modelKeybean` 属性显式设置要序列化的对象.  如果模型包含单个条目,则会自动序列化.

您可以使用 JAXB 或 Jackson 提供的注解根据需要自定义 XML 映射.  当您需要进一步控制时,可以通过 `ObjectMapper` 属性注入自定义 `XmlMapper`,以便自定义 XML 需要为特定类型提供序列化程序和反序列化程序.


[[mvc-view-xml-marshalling]]
== XML编 组

`MarshallingView` 使用 XML `Marshaller`(在 `org.springframework.oxm` 包中定义) 将响应内容呈现为 XML.  您可以使用 `MarshallingView` 实例的 `modelKey` bean属性显式设置要编组的对象.  或者,视图会迭代所有模型属性,并封送 `Marshaller` 支持的第一种类型.
有关 `org.springframework.oxm` 包中功能的更多信息,请参阅使用 <<data-access.adoc#oxm,Marshalling XML using O/X Mappers>>.

[[mvc-view-xslt]]
== XSLT 视图

XSLT 是一个用于转换 XML 的语言,能够在 web 的视图技术中使用.如果应用需要处理 XML(或者将模型转换为 XML) ,那么 XSLT 是一个很适合的视图技术. 以下部分显示如何将 XML 文档生成为模型数据,并在 Spring Web MVC 应用程序中使用 XSLT 进行转换.

这个例子是一个简单的 Spring 应用程序,它在 `Controller` 中创建一个单词列表并将它们添加到模型映射中. 该映射与使用的 XSLT 视图名称一起返回. 有关 Spring Web MVC 控制器接口的详细信息, 请参阅<<mvc-controller>>.  XSLT 控制器将单词列表转换为准备转换的简单 XML 文档.

[[mvc-view-xslt-beandefs]]
=== Beans

Configuration 配置是 Spring 应用程序的标配,MVC 配置必须定义 `XsltViewResolver` bean 和常规 MVC 注解配置,以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@EnableWebMvc
	@ComponentScan
	@Configuration
	public class WebConfig implements WebMvcConfigurer {

		@Bean
		public XsltViewResolver xsltViewResolver() {
			XsltViewResolver viewResolver = new XsltViewResolver();
			viewResolver.setPrefix("/WEB-INF/xsl/");
			viewResolver.setSuffix(".xslt");
			return viewResolver;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@EnableWebMvc
	@ComponentScan
	@Configuration
	class WebConfig : WebMvcConfigurer {

		@Bean
		fun xsltViewResolver() = XsltViewResolver().apply {
			setPrefix("/WEB-INF/xsl/")
			setSuffix(".xslt")	
		}
	}
----


[[mvc-view-xslt-controllercode]]
=== Controller

并且我们需要一个控制器,用来处理单词的生成逻辑.

控制器逻辑封装在 `@Controller` 类中,处理程序方法定义如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class XsltController {

		@RequestMapping("/")
		public String home(Model model) throws Exception {
			Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
			Element root = document.createElement("wordList");

			List<String> words = Arrays.asList("Hello", "Spring", "Framework");
			for (String word : words) {
				Element wordNode = document.createElement("word");
				Text textNode = document.createTextNode(word);
				wordNode.appendChild(textNode);
				root.appendChild(wordNode);
			}

			model.addAttribute("wordList", root);
			return "home";
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.ui.set

	@Controller
	class XsltController {

		@RequestMapping("/")
		fun home(model: Model): String {
			val document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument()
			val root = document.createElement("wordList")

			val words = listOf("Hello", "Spring", "Framework")
			for (word in words) {
				val wordNode = document.createElement("word")
				val textNode = document.createTextNode(word)
				wordNode.appendChild(textNode)
				root.appendChild(wordNode)
			}

			model["wordList"] = root
			return "home"
		}
	}
----

到目前为止,我们只创建了一个 DOM 文档并将其添加到模型映射中.  请注意,您还可以将 XML 文件作为 `Resource` 加载,并使用它而不是自定义 DOM 文档.

当然,有软件包可以自动 'domify' 对象图,在 Spring 中,您可以完全灵活地以您选择的任何方式从模型中创建 DOM. 这可以防止 XML 在模型数据的结构中扮演太大的角色,这在使用工具管理 DOM 化过程时是一种危险.

[[mvc-view-xslt-transforming]]
=== 转换

最后, `XsltViewResolver` 将解析 "`home`"  XSLT 模板文件,并将 DOM 文档合并到其中以生成所需视图. 例如 `XsltViewResolver` 配置所示,XSLT 模板在 `WEB-INF/xsl` 目录中的 `war` 文件中, 并以 `xslt` 文件扩展名结束.

以下示例显示了 XSLT 转换:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="utf-8"?>
	<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">

		<xsl:output method="html" omit-xml-declaration="yes"/>

		<xsl:template match="/">
			<html>
				<head><title>Hello!</title></head>
				<body>
					<h1>My First Words</h1>
					<ul>
						<xsl:apply-templates/>
					</ul>
				</body>
			</html>
		</xsl:template>

		<xsl:template match="word">
			<li><xsl:value-of select="."/></li>
		</xsl:template>

	</xsl:stylesheet>
----

上述转换呈现为以下 HTML:

[source,html,indent=0,subs="verbatim,quotes"]
----
<html>
	<head>
		<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>Hello!</title>
	</head>
	<body>
		<h1>My First Words</h1>
		<ul>
			<li>Hello</li>
			<li>Spring</li>
			<li>Framework</li>
		</ul>
	</body>
</html>
----
