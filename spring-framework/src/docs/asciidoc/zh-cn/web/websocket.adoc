[[websocket]]
= WebSockets
:doc-spring-security: {doc-root}/spring-security/site/docs/current/reference
[.small]#<<web-reactive.adoc#webflux-websocket, WebFlux>>#

这一部分介绍 Spring 框架在 Web 应用程序中对 WebSocket 消息传递的支持,通过 SockJS 的 WebSocket 仿真,包括使用 STOMP 作为应用程序级 WebSocket 的子协议的发布 - 订阅消息传递.

include::webmvc/websocket-intro.adoc[leveloffset=+1]

[[websocket-server]]
== WebSocket API
[.small]#<<web-reactive.adoc#webflux-websocket-server, WebFlux>>#

Spring Framework 提供了一个 WebSocket API,您可以使用它来编写处理 WebSocket 消息的客户端和服务器端应用程序.

[[websocket-server-handler]]
=== `WebSocketHandler`
[.small]#<<web-reactive.adoc#webflux-websocket-server-handler, WebFlux>>#

创建 WebSocket 服务器与实现 `WebSocketHandler` 或继承 `TextWebSocketHandler` 或 `BinaryWebSocketHandler` 一样简单以下示例使用 `TextWebSocketHandler`:

[source,java,indent=0,subs="verbatim,quotes"]
----
	import org.springframework.web.socket.WebSocketHandler;
	import org.springframework.web.socket.WebSocketSession;
	import org.springframework.web.socket.TextMessage;

	public class MyHandler extends TextWebSocketHandler {

		@Override
		public void handleTextMessage(WebSocketSession session, TextMessage message) {
			// ...
		}

	}
----

有专门的 WebSocket Java 配置和 XML 命名空间支持,用于将上述 WebSocket 处理程序映射到特定的 URL. 如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	import org.springframework.web.socket.config.annotation.EnableWebSocket;
	import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
	import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Override
		public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
			registry.addHandler(myHandler(), "/myHandler");
		}

		@Bean
		public WebSocketHandler myHandler() {
			return new MyHandler();
		}

	}
----

以下示例显示了与前面示例等效的 XML 配置:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:handlers>
			<websocket:mapping path="/myHandler" handler="myHandler"/>
		</websocket:handlers>

		<bean id="myHandler" class="org.springframework.samples.MyHandler"/>

	</beans>
----

以上是在 Spring MVC 应用程序中使用的,应包含在 <<mvc-servlet, `DispatcherServlet`>> 的配置中. 但是,Spring 的 WebSocket 支持不依赖于 Spring MVC, 在 {api-spring-framework}/web/socket/server/support/WebSocketHttpRequestHandler.html[`WebSocketHttpRequestHandler`] 的帮助下,将 `WebSocketHandler` 集成到其他 HTTP 服务环境中是相对简单的.

当直接或间接使用 `WebSocketHandler` API 时,例如 通过 <<websocket-stomp>> 消息传递,由于基础标准 WebSocket 会话 (JSR-356) 不允许并发发送,因此应用程序必须同步消息的发送.  一种选择是用 {api-spring-framework}/web/socket/handler/ConcurrentWebSocketSessionDecorator.html[`ConcurrentWebSocketSessionDecorator`] 包装 `WebSocketSession`.

[[websocket-server-handshake]]
=== WebSocket 握手
[.small]#<<web-reactive.adoc#webflux-websocket-server-handshake, WebFlux>>#

自定义初始 `HTTPWebSocket` 握手请求的最简单的方法是通过 `HandshakeInterceptor`,它暴露 "`before`" 和 "`after`" 的握手方法.  此类拦截器可用于阻止握手或使任何属性用于 `WebSocketSession`. 例如,有一个内置的拦截器用于将 HTTP 会话属性传递给 `WebSocket` 会话:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Override
		public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
			registry.addHandler(new MyHandler(), "/myHandler")
				.addInterceptors(new HttpSessionHandshakeInterceptor());
		}

	}
----

以下示例显示了与前面示例等效的 XML 配置:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:handlers>
			<websocket:mapping path="/myHandler" handler="myHandler"/>
			<websocket:handshake-interceptors>
				<bean class="org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"/>
			</websocket:handshake-interceptors>
		</websocket:handlers>

		<bean id="myHandler" class="org.springframework.samples.MyHandler"/>

	</beans>
----

更高级的选项是继承执行 WebSocket 握手步骤的 `DefaultHandshakeHandler`,包括验证客户端来源、协商协议和其他操作. 如果应用程序需要配置自定义 `RequestUpgradeStrategy`,以便适应 WebSocket 服务器引擎和尚未受支持的版本(有关此主题的更多信息,请参阅<<websocket-server-deployment>>) , 则可能还需要使用此选项. Java 配置和 XML 命名空间都可以配置自定义的 `HandshakeHandler`.

TIP: Spring 提供了 `WebSocketHandlerDecorator` 基类,可用于用附加行为装饰 `WebSocketHandler`. 在使用 WebSocket 的 Java 配置或 XML 命名空间时,默认情况下提供和添加日志记录和异常处理实现.  `ExceptionWebSocketHandlerDecorator` 捕获所有 `WebSocketHandler` 方法产生异常,并关闭具有指示服务器错误状态为 `1011` 的 WebSocket 会话.

[[websocket-server-deployment]]
=== 部署

Spring WebSocket API 很容易集成到 Spring MVC 应用程序中,`DispatcherServlet` 既服务于 HTTP WebSocket 握手,也提供其他 HTTP 请求. 通过调用 `WebSocketHttpRequestHandler` 也很容易集成到其他 HTTP 处理方案中.  这很方便易懂.  但是,在J SR-356 运行时,需要特别注意.

Java WebSocket API(JSR-356)提供了两种部署机制. 第一种是在启动时包含 Servlet 容器类路径扫描(Servlet 3 功能),另一个是在 Servlet 容器初始化时使用注册 API. 这两种机制都不能为所有 http 处理使用单一的 "前端控制器", 包括 WebSocket 握手和所有其他 HTTP 请求,例如 Spring MVC 的 `DispatcherServlet`.

这是 JSR-356 的一个重要限制,Spring 的 WebSocket 支持解决了服务器特定的 `RequestUpgradeStrategy` 实现,即使在 JSR-356 运行时运行也是如此.  目前,Tomcat,Jetty,GlassFish,WebLogic,WebSphere 和 Undertow (以及 WildFly) 都有这样的策略.

NOTE: 	在 Java WebSocket API 中已经有解决上面限制的方法,并且遵循 https://github.com/eclipse-ee4j/websocket-api/issues/211[eclipse-ee4j/websocket-api#211] 中的规定.  还要注意的是,Tomcat 和 Jetty 已经提供了本地的 API 替代品,可以实现这一点,Jetty 也是如此.  我们希望更多服务器能够做到这一点.

第二个考虑因素是,具有 JSR-356 支持的 Servlet 容器将执行 `ServletContainerInitializer` (SCI)扫描,从而在某些情况下大大降低应用程序启动速度. 如果在升级到带有 JSR-356 支持的 Servlet 容器版本后观察到了显著的影响, 则应该可以通过在 `web.xml` 中使用 `<absolute-ordering />` 元素来有选择地启用或禁用 web 片段(和 SCI 扫描).

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<web-app xmlns="http://java.sun.com/xml/ns/javaee"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://java.sun.com/xml/ns/javaee
			https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
		version="3.0">

		<absolute-ordering/>

	</web-app>
----

然后,可以按名称有选择地启用 web 片段,例如 Spring 自定义的 `SpringServletContainerInitializer`,它为 Servlet 3 Java 初始化 API 提供支持.  以下示例显示了如何执行此操作:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<web-app xmlns="http://java.sun.com/xml/ns/javaee"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://java.sun.com/xml/ns/javaee
			https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
		version="3.0">

		<absolute-ordering>
			<name>spring_web</name>
		</absolute-ordering>

	</web-app>
----



[[websocket-server-runtime-configuration]]
=== 服务器配置
[.small]#<<web-reactive.adoc#webflux-websocket-server-config, WebFlux>>#

每个底层的 WebSocket 引擎都暴露了控制运行时特性的配置属性,如消息缓冲区大小、空闲超时和其他设置.

对于 Tomcat Tomcat, WildFly, 和 GlassFish,可以将 `ServletServerContainerFactoryBean` 添加到 WebSocket Java 配置中. 如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Bean
		public ServletServerContainerFactoryBean createWebSocketContainer() {
			ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();
			container.setMaxTextMessageBufferSize(8192);
			container.setMaxBinaryMessageBufferSize(8192);
			return container;
		}

	}
----

以下示例显示了与前面示例等效的 XML 配置:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<bean class="org.springframework...ServletServerContainerFactoryBean">
			<property name="maxTextMessageBufferSize" value="8192"/>
			<property name="maxBinaryMessageBufferSize" value="8192"/>
		</bean>

	</beans>
----

NOTE: 对于客户端 WebSocket 配置,您应该使用 `WebSocketContainerFactoryBean` (XML) 或 `ContainerProvider.getWebSocketContainer()`  (Java 配置) .

对于 Jetty,您需要提供预配置的 Jetty `WebSocketServerFactory` 并通过 WebSocket Java 配置将其插入 Spring 的 `DefaultHandshakeHandler`.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Override
		public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
			registry.addHandler(echoWebSocketHandler(),
				"/echo").setHandshakeHandler(handshakeHandler());
		}

		@Bean
		public DefaultHandshakeHandler handshakeHandler() {

			WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);
			policy.setInputBufferSize(8192);
			policy.setIdleTimeout(600000);

			return new DefaultHandshakeHandler(
					new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));
		}

	}
----

以下示例显示了与前面示例等效的 XML 配置:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:handlers>
			<websocket:mapping path="/echo" handler="echoHandler"/>
			<websocket:handshake-handler ref="handshakeHandler"/>
		</websocket:handlers>

		<bean id="handshakeHandler" class="org.springframework...DefaultHandshakeHandler">
			<constructor-arg ref="upgradeStrategy"/>
		</bean>

		<bean id="upgradeStrategy" class="org.springframework...JettyRequestUpgradeStrategy">
			<constructor-arg ref="serverFactory"/>
		</bean>

		<bean id="serverFactory" class="org.eclipse.jetty...WebSocketServerFactory">
			<constructor-arg>
				<bean class="org.eclipse.jetty...WebSocketPolicy">
					<constructor-arg value="SERVER"/>
					<property name="inputBufferSize" value="8092"/>
					<property name="idleTimeout" value="600000"/>
				</bean>
			</constructor-arg>
		</bean>

	</beans>
----

[[websocket-server-allowed-origins]]
=== Allowed Origins (允许来源)
[.small]#<<web-reactive.adoc#webflux-websocket-server-cors, WebFlux>>#

在 Spring 4.1.55 版本之后,WebSocket 和 SockJS 的默认行为是仅接受同源请求. 也可以允许所有或指定的来源列表. 此检查主要是为浏览器客户端设计的. 没有什么能阻止其他类型的客户端修改 `Origin` 头值 (有关更多详细信息,请参阅 https://tools.ietf.org/html/rfc6454[RFC 6454: The Web Origin Concept] ) .

三种可能的行为是:

 * 仅允许同源请求 (默认) : 在此模式下,启用 SockJS 时,Iframe HTTP 响应头 `X-Frame-Options` 设置为 `SAMEORIGIN`,并禁用 JSONP 传输,因为它不允许检查源的的请求.  因此,启用此模式时不支持 IE6 和 IE7.
 * 允许指定的来源列表: 每个允许的来源必须以 `http://` 或 `https://` 开头.  在此模式下,启用 SockJS 时,将禁用 IFrame 传输.  因此,启用此模式时,不支持 IE6 到 IE9.
 * 允许所有来源: 要启用此模式,您应提供 `{asterisk}` 作为允许的原始值.  在此模式下,所有传输都可用.

您可以配置 WebSocket 和 SockJS 允许的源,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	import org.springframework.web.socket.config.annotation.EnableWebSocket;
	import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
	import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Override
		public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
			registry.addHandler(myHandler(), "/myHandler").setAllowedOrigins("https://mydomain.com");
		}

		@Bean
		public WebSocketHandler myHandler() {
			return new MyHandler();
		}

	}
----

以下示例显示了与前面示例等效的 XML 配置:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:handlers all owed-origins="https://mydomain.com">
			<websocket:mapping path="/myHandler" handler="myHandler" />
		</websocket:handlers>

		<bean id="myHandler" class="org.springframework.samples.MyHandler"/>

	</beans>
----

[[websocket-fallback]]
== SockJS 回调选项

在公共 Internet 上,受控制之外的限制性代理可能会阻止 WebSocket 交互,因为它们未配置为传递 `Upgrade` 头,或者因为它们关闭看似空闲的长期连接.

此问题的解决方案是 WebSocket 仿真 - 即,首先尝试使用 WebSocket,然后依靠基于 HTTP 的技术来模拟 WebSocket 交互并暴露相同的应用程序级 API.

在 Servlet 技术栈上,Spring Framework 为 SockJS 协议提供服务器 (以及客户端) 支持.

[[websocket-fallback-sockjs-overview]]
=== 简介

SockJS 的目标是让应用程序使用 WebSocket 的 API,但在运行时需要回退到非 WebSocket 的替代方案,即无需更改应用程序代码.

SockJS 包括:

* https://github.com/sockjs/sockjs-protocol[SockJS 协议] 定义了 https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html[测试的执行形式]
* https://github.com/sockjs/sockjs-client/[SockJS JavaScript 客户端] -- 一个用于浏览器的客户端库
* SockJS 服务器实现是 Spring 框架中的 `spring-websocket` 模块.
* spring-websocket4.1 之后的版本还提供了一个 SockJS 的 Java 客户端

SockJS 是为在浏览器中使用而设计的. 使用各种技术来支持广泛的浏览器版本会有很大的不同. 有关 SockJS 传输类型和浏览器的完整列表,请参阅 https://github.com/sockjs/sockjs-client/[SockJS client] 页面.  传输分为三大类: WebSocket,HTTP Streaming 和 HTTP Long Polling.  有关这些类别的概述,请参阅此 https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/[this blog post].

SockJS 客户端首先发送 `GET/info` 以从服务器获取基本信息.  之后,它必须决定使用什么传输.  如果可能,使用 WebSocket.  如果没有,在大多数浏览器中,至少有一个 HTTP 流选项.  如果不是,则使用 HTTP (长) 轮询.

所有传输请求都具有以下 URL 结构:


----
https://host:port/myApp/myEndpoint/{server-id}/{session-id}/{transport}
----

where:

* pass:q[`{server-id}`]  用于集群中的路由请求并且不在其他地方使用
* pass:q[`{session-id}`] 将属于 SockJS 会话的 HTTP 请求关联起来
* pass:q[`{transport}`] 指定传输的类型(例如,`websocket`, `xhr-streaming` 等等).

WebSocket 传输只需要 HTTP 请求来执行 WebSocket 握手,此后所有消息都在该套接字上交换.

HTTP 传输需要更多请求, Ajax/XHR streaming 依赖于一个长时间运行的服务器消息请求和对客户机到服务器消息的其他 HTTP POST 请求. 长轮询也是类似的,只是它在每次服务器发送后结束当前请求.

SockJS 添加最小的消息帧,例如服务器最初发送字母 `o`("`open`" 帧),消息的格式会是 `a["message1","message2"]` (JSON 编码的数组) ,字母 `h`("`heartbeat`"  帧), 如果在默认的 25 秒内没有消息流,将发送字母 `c` ("`close`"  帧) 用于关闭会话.

要了解更多信息,请在浏览器中运行示例并观察 HTTP 请求. SockJS 客户端允许修复传输列表,因此可以一次查看每个传输. SockJS 客户端还提供了一个调试标志,它在浏览器控制台中启用有用的消息.  在服务器端启用 `org.springframework.web.socket` 的 `TRACE` 日志记录. 有关更多详细信息,请参阅 SockJS 协议 https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html[narrated test].

[[websocket-fallback-sockjs-enable]]
=== 开启 SockJS

您可以通过 Java 配置启用 SockJS,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Override
		public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
			registry.addHandler(myHandler(), "/myHandler").withSockJS();
		}

		@Bean
		public WebSocketHandler myHandler() {
			return new MyHandler();
		}

	}
----

以下示例显示了与前面示例等效的 XML 配置:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:handlers>
			<websocket:mapping path="/myHandler" handler="myHandler"/>
			<websocket:sockjs/>
		</websocket:handlers>

		<bean id="myHandler" class="org.springframework.samples.MyHandler"/>

	</beans>
----

前面的示例用于 Spring MVC 应用程序,应该包含在 <<mvc-servlet, `DispatcherServlet`>> 的配置中.  但是,Spring 的 WebSocket 和 SockJS 支持并不依赖于 Spring MVC.  在 {api-spring-framework}/web/socket/sockjs/support/SockJsHttpRequestHandler.html[`SockJsHttpRequestHandler`] 的帮助下,将其集成到其他 HTTP 服务环境中相对简单.

在浏览器端,应用程序可以使用 https://github.com/sockjs/sockjs-client/[`sockjs-client`] (版本 1.0.x) 来模拟 W3C WebSocket API,并与服务器进行通信,根据它所运行的浏览器选择最佳传输选项.  查看 https://github.com/sockjs/sockjs-client/[sockjs-client] 页和浏览器支持的传输类型列表. 客户端还提供了几个配置选项,例如指定要包含哪些传输.

[[websocket-fallback-xhr-vs-iframe]]
=== IE 8 和 9

Internet Explorer 8 和 9 仍在使用中.  他们是拥有 SockJS 的关键原因.  本节介绍在这些浏览器中运行的重要注意事项.

SockJS 客户端通过使用 Microsoft 的 https://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx[`XDomainRequest`]. 在 IE 8 和 9 中支持 Ajax/XHR 流.  能够做到跨域工作,但不支持发送 cookie. 对于 Java 应用程序来说,cookie 通常是必不可少的. 但是,由于 SockJS 客户端可以与许多服务器类型一起使用(不仅仅是 Java) ,所以需要知道 cookie 是否重要.  如果是这样,SockJS 客户端更喜欢 Ajax/XHR 流,否则它依赖于 iframe-based 技术.

来自 SockJS 客户端的第一个 `/info` 请求是对可能影响客户选择传输的信息的请求. 其中一个细节是服务器应用程序是否依赖于 cookie,例如用于身份验证或使用粘性会话进行群集.  Spring的SockJS支持包括一个称为 `sessionCookieNeeded` 的属性.
默认情况下,它是启用的,因为大多数Java应用程序都依赖 `JSESSIONID` cookie. 如果应用程序不需要它,可以关闭此选项,SockJS 客户端应在 IE 8 和 9 中选择 `xdr-streaming`.

如果您确实使用基于 iframe 的传输,请记住,可以通过将 HTTP 响应头 `X-Frame-Options` 设置为 `DENY`,`SAMEORIGIN` 或 `ALLOW-FROM <origin>` 来指示浏览器阻止在给定页面上使用 IFrames.  这用于防止 https://www.owasp.org/index.php/Clickjacking[点击劫持].

[NOTE]
====

Spring Security 3.2+ 版本为每个响应提供 `X-Frame-Options` 的设置. 默认情况下,Spring Security Java 配置将其设置为 `DENY`.  在 3.2 中,Spring Security XML 命名空间默认情况下不设置该头,但可以配置为执行此操作.  将来,它可以默认设置它.

有关如何配置 `X-Frame-Options` 头设置的详细信息,请参阅 Spring Security 文档的 {doc-spring-security}/features/exploits/headers.html#headers-default[默认的安全头].  您还可以查看 https://github.com/spring-projects/spring-security/issues/2718[gh-2718] 的其他背景信息.
====

如果您的应用程序添加了 `X-Frame-Options` 响应头 (其实应该这样做) ,并且是依赖 iframe-based 传输的,则需要将 header 设置为 `SAMEORIGIN` 或 `ALLOW-FROM <origin>`.  随着 Spring SockJS 的支持也需要知道 SockJS 客户端的位置,因为它是从 iframe 加载的. 默认情况下,iframe 被设置为从 CDN 位置下载 SockJS 客户端. 最好将此选项配置为来自应用程序相同的 URL 源.

以下示例显示了如何在 Java 配置中执行此操作:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/portfolio").withSockJS()
					.setClientLibraryUrl("http://localhost:8080/myapp/js/sockjs-client.js");
		}

		// ...

	}
----

XML 命名空间通过 `<websocket:sockjs>` 元素提供了类似的选项.

NOTE: 在初始开发期间,请启用 SockJS 客户端 `devel` 模式,以防止浏览器缓存否则将被缓存的 SockJS 请求 (如iframe) .  有关如何启用它的详细信息,请参阅 https://github.com/sockjs/sockjs-client/[SockJS client] 页面.

[[websocket-fallback-sockjs-heartbeat]]
=== 心跳

SockJS 协议要求服务器发送心跳消息以防止代理结束了连接. Spring SockJS 配置有一个称为 `heartbeatTime` 的属性,可用于自定义频率. 默认情况下,如果没有在该连接上发送其他消息,它会在 25 秒后发送心跳. 这 25 秒的值符合以下 https://tools.ietf.org/html/rfc6202[IETF 推荐]  公共互联网应用程序的设置.

NOTE: 在 WebSocket/SockJS 中使用 STOMP 时,如果 STOMP 的客户端和服务器忽略心跳的交互,SockJS 的心跳可以被关闭.

Spring SockJS 还允许配置 `TaskScheduler` 用于设置计划心跳任务. 任务计划程序由具有默认设置的线程池支持,该线程池基于可用处理器的数量. 应用程序应考虑根据特定需要而自定义设置.

[[websocket-fallback-sockjs-servlet3-async]]
=== 客户端断开连接

HTTP 流和 HTTP 长轮询 SockJS 传输要求连接保持比通常更长时间的停留,有关这些技术的概述,请参阅此 https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/[博客文章].

在 Servlet 容器中,这个功能是通过 Servlet 3 异步支持完成的,它允许退出 Servlet 容器线程处理请求并继续从另一个线程写入响应.

一个特殊的问题是,Servlet API 不会为已断开的客户端发送通知. 请参看 https://github.com/eclipse-ee4j/servlet-api/issues/44[eclipse-ee4j/servlet-api#44].  但是,Servlet 容器在随后尝试写入响应时引发异常. 由于 Spring 的 SockJS 服务支持服务器发送的心跳(默认情况下是每隔25秒就发一次),这意味着在该时间段内或更早地发送消息时,通常会检测到客户端断开.

NOTE: 有时候客户端的断开连接会导致服务端发生网络 IO 故障,从而记录了不必要的堆栈跟踪日志. Spring 尽最大努力识别出代表客户端断开连接(特定于每台服务器)的网络故障, 并使用 `AbstractSockJsSession` 中定义的专用日志类别 `DISCONNECTED_CLIENT_LOG_CATEGORY` 记录最少的消息. 如果需要查看堆栈跟踪,请将该日志类别设置为 `TRACE`.


[[websocket-fallback-cors]]
=== SockJS 和 CORS

如果允许 cross-origin 请求(请参阅第 <<websocket-server-allowed-origins>>), 则 SockJS 协议使用 CORS 在 XHR 流和轮询传输中进行跨域支持. 因此,除非检测到响应中存在 CORS 头, 否则会自动添加 CORS 头. 因此,如果应用程序已经配置为提供 CORS 支持,例如通过 Servlet 过滤器,Spring 的 `SockJsService` 将跳过此部分.

也可以通过在 Spring 的 SockJsService 中设置 `suppressCors` 属性来禁用这些 CORS 头的添加.

以下是 SockJS 的默认头信息列表和默认值:

* `Access-Control-Allow-Origin`: 初始化来自请求头中 `Origin` 的值
* `Access-Control-Allow-Credentials`: 始终设置为 `true`
* `Access-Control-Request-Headers`: 初始化值来自相同的请求头
* `Access-Control-Allow-Methods`: HTTP方法传输支持(见 `TransportType` 的枚举).
* `Access-Control-Max-Age`: 设置为31536000 (1 年).

对于实现可以看 `AbstractSockJsService` 中的 `addCorsHeaders` 方法,也可以看 `TransportType` 枚举类的源代码.

或者, 如果 CORS 配置允许它考虑排除 URL 与 SockJS 终端前缀,从而让 Spring 的 `SockJsService` 处理它.


[[websocket-fallback-sockjs-client]]
=== `SockJsClient`

提供 SockJS 的 Java 客户端版本,方便在不使用浏览器的情况下连接到远程 SockJS 端点. 当需要通过公用网络(即网络代理可能不使用 WebSocket 协议)在两个服务器之间进行双向通信时,这一点尤其有用.  SockJS Java 客户端对于测试目的也非常有用,例如模拟大量并发用户.

SockJS 的 Java 客户端支持 `websocket`, `xhr-streaming`, 和 `xhr-polling` 传输.,其余的部分只在浏览器中使用才有意义.

`WebSocketTransport` 可以配置为:


* JSR-356 运行时中的 `StandardWebSocketClient`.
* `JettyWebSocketClient` 使用 Jetty9 本地的 WebSocket 的 API
* Spring `WebSocketClient` 的任何实现.

根据定义,`XhrTransport` 支持 `xhr-streaming` 和 `xhr-polling`,因为从客户端的角度来看,除了用于连接服务器的 URL 之外没有其他区别.  目前有两种实现方式:


* `RestTemplateXhrTransport` 使用 Spring 的 `RestTemplate` 进行 HTTP 请求.
* `JettyXhrTransport` 使用 Jetty 的 `HttpClient` 进行HTTP请求.

以下示例显示如何创建 SockJS 客户端并连接到 SockJS 端点:

[source,java,indent=0,subs="verbatim,quotes"]
----
  List<Transport> transports = new ArrayList<>(2);
  transports.add(new WebSocketTransport(new StandardWebSocketClient()));
  transports.add(new RestTemplateXhrTransport());

  SockJsClient sockJsClient = new SockJsClient(transports);
  sockJsClient.doHandshake(new MyWebSocketHandler(), "ws://example.com:8080/sockjs");
----

NOTE: SockJS 使用 JSON 格式的数组进行消息传递.  默认情况下,使用 Jackson 2 并且需要在类路径上.  或者,您可以配置 `SockJsMessageCodec` 的自定义实现并在 `SockJsClient` 上配置它.

要使用 `SockJsClient` 模拟大量并发用户,您需要配置底层 HTTP 客户端 (用于 XHR 传输) 以允许足够数量的连接和线程.  以下示例显示了如何使用 Jetty 执行此操作:


[source,java,indent=0,subs="verbatim,quotes"]
----
HttpClient jettyHttpClient = new HttpClient();
jettyHttpClient.setMaxConnectionsPerDestination(1000);
jettyHttpClient.setExecutor(new QueuedThreadPool(1000));
----

以下示例显示了您应该考虑自定义的服务器端 SockJS 相关属性 (请参阅 javadoc 以获取详细信息) :

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Configuration
	public class WebSocketConfig extends WebSocketMessageBrokerConfigurationSupport {

		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/sockjs").withSockJS()
				.setStreamBytesLimit(512 * 1024) <1>
				.setHttpMessageCacheSize(1000) <2>
				.setDisconnectDelay(30 * 1000); <3>
		}

		// ...
	}
----
<1> 将 `streamBytesLimit` 属性设置为 512KB (默认值为 128KB- `128 * 1024`) .
<2> 将 `httpMessageCacheSize` 属性设置为 1000 (默认值为 `100`) .
<3> 将断开连接延迟属性设置为 `30` 秒 (默认值为 5 秒- `5 * 1000`) .

[[websocket-stomp]]
== STOMP

WebSocket 协议定义了两种类型的消息,即文本和二进制,但它们的内容是未定义的. 预计客户端和服务器可能会同意使用协议(即更高级别的消息传递协议) . 虽然使用协议与 WebSocket 是完全分离的, 无论哪种方式客户端和服务器将需要协商好用某种协议,以帮助解析消息.

[[websocket-stomp-overview]]
=== 概述

https://stomp.github.io/stomp-specification-1.2.html#Abstract[STOMP] (是一种简单的面向文本的消息传递协议) ,最初是为 Ruby、Python 和 Perl 等脚本语言创建的,用于连接企业消息代理.  它旨在解决常用的消息传递模式的一个子集. STOMP 可以用于任何可靠的双工流网络协议,如 TCP 和 WebSocket. 虽然 STOMP 是一种面向文本的协议,但消息的类型可以是文本或二进制.

STOMP 基于 HTTP 帧模型协议的,STOMP 的帧结构如下

----
COMMAND
header1:value1
header2:value2

Body^@
----

客户端可以使用 `SEND` 或 `SUBSCRIBE` 命令来发送或订阅消息,并且通过 `destination` 的头部信息描述消息的内容将由谁来接收. 这是一个简单的发布/订阅策略,可用于通过代理向其他连接的客户端发送消息,或向服务器发送消息以请求执行某些工作.

当使用 Spring 来支持的 STOMP 时,Spring WebSocket 的应用在客户端中扮演着 STOMP 代理的角色. 消息被路由到 `@Controller` 的消息处理方法或一个简单的内存代理,它跟踪订阅并向订阅用户广播消息.  还可以配置 Spring 与专门的 STOMP 代理(如 RabbitMQ,ActiveMQ 等)的实际广播的消息. 在这种情况下,Spring 维护到代理的 TCP 连接,将消息中继到它,并将消息从它传递到连接的 WebSocket 客户端. 因此,Spring Web 应用程序可以依赖统一的 HTTP 安全性、通用验证和熟悉的编程模型消息处理工作.

下面是一个客户端订阅接收股票报价的示例,服务器可能会周期性地发出此消息,例如通过 `SimpMessagingTemplate` 向代理发送邮件的计划任务:

----
SUBSCRIBE
id:sub-1
destination:/topic/price.stock.*

^@
----

下面是一个客户端发送贸易请求的示例,服务器可以通过 `@MessageMapping` 方法处理该交易请求:

----
SEND
destination:/queue/trade
content-type:application/json
content-length:44

{"action":"BUY","ticker":"MMM","shares",44}^@
----

执行后,服务器可以向客户端广播交易确认消息和详细信息.

在 STOMP 规范中故意将目的地的含义保持不透明.  它可以是任何字符串,完全取决于 STOMP 服务器来定义它们支持的目标的语义和语法.  然而,很常见的是,但是目的地是类似路径的字符串,其中 `/topic/..` 意味着发布 - 订阅 (一对多) 和 `/queue/` 意味着点对点 (一对一) 消息交流.

STOMP 服务器可以使用 `MESSAGE` 命令向所有订户广播消息. 以下是向已订阅的客户端发送股票报价的服务器示例:

----
MESSAGE
message-id:nxahklf6-1
subscription:sub-1
destination:/topic/price.stock.MMM

{"ticker":"MMM","price":129.45}^@
----

服务器无法发送未经请求的消息.  来自服务器的所有消息必须响应特定的客户端订阅,并且服务器消息的 `subscription-id` 头必须与客户端订阅的 `id` 头匹配.

上面的概述目的是对 STOMP 协议有一个基本的理解.  我们建议查看完整的 https://stomp.github.io/stomp-specification-1.2.html[协议规范] .

[[websocket-stomp-benefits]]
=== 优点

使用 STOMP 作为子协议,Spring Framework 和 Spring Security 提供了比使用原始 WebSocket 更丰富的编程模型. 关于 HTTP 与原始 TCP 以及它如何让 Spring MVC 和其他 Web 框架提供丰富的功能,可以做出同样的观点.  以下是一系列好处:

* 无需自定义消息的格式
* 可以使用 STOMP 客户端,包括 Spring Framework 中的 <<websocket-stomp-client, Java client>>
* 您可以 (可选) 使用消息代理 (例如 RabbitMQ,ActiveMQ 等) 来管理订阅和广播消息.
* 可以在任意数量的 `@Controller` 实例中组织应用程序逻辑,并且可以基于 STOMP 目 header 将消息路由到它们,而不是使用给定连接的单个 `WebSocketHandler` 处理原始 WebSocket 消息.
* 您可以使用 Spring Security 根据 STOMP 目标和消息类型保护消息.



[[websocket-stomp-enable]]
===  启用 STOMP

`spring-messaging` 和 `spring-websocket` 模块提供 STOMP over WebSocket 支持.  一旦有了这些依赖,就可以通过带有 <<websocket-fallback>> 的 WebSocket 暴露 STOMP 端点,如下例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
	import org.springframework.web.socket.config.annotation.StompEndpointRegistry;

	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/portfolio").withSockJS();  // <1>
		}

		@Override
		public void configureMessageBroker(MessageBrokerRegistry config) {
			config.setApplicationDestinationPrefixes("/app"); // <2>
			config.enableSimpleBroker("/topic", "/queue"); // <3>
		}
	}
----

<1> `/portfolio` 是 WebSocket (或SockJS) 客户端为 WebSocket 握手需要连接的端点的 HTTP URL.
<2> 目 header 以 `/app` 开头的 STOMP 消息将路由到 `@Controller` 类中的 `@MessageMapping` 方法.
<3> 使用内置消息代理进行订阅和广播,并将目 header 以 `/topic` or `/queue` 开头的消息路由到代理.

以下示例显示了与前面示例等效的 XML 配置:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:message-broker application-destination-prefix="/app">
			<websocket:stomp-endpoint path="/portfolio">
				<websocket:sockjs/>
			</websocket:stomp-endpoint>
			<websocket:simple-broker prefix="/topic, /queue"/>
		</websocket:message-broker>

	</beans>
----

NOTE: 对于内置的简单代理,`/topic` 和 `/queue` 前缀没有任何特殊含义.  它们仅仅是区分 pub-sub 和点对点消息传递的惯例 (即,许多订阅者与一个消费者) .  使用外部代理时,请检查代理的 STOMP 页面,以了解它支持的 STOMP 目标和前缀类型.

要从浏览器连接,对于SockJS,您可以使用 https://github.com/sockjs/sockjs-client[`sockjs-client`]. 对于 STOMP,许多应用程序使用了 https://github.com/jmesnil/stomp-websocket[jmesnil/stomp-websocket]库 (也称为 stomp.js) ,它是功能完备的,已经在生产中使用多年但不再维护.  目前, https://github.com/JSteunou/webstomp-client[JSteunou/webstomp-client] 是该库中最积极维护和不断发展的继任者.  以下示例代码基于它:

[source,javascript,indent=0]
[subs="verbatim,quotes"]
----
	var socket = new SockJS("/spring-websocket-portfolio/portfolio");
	var stompClient = webstomp.over(socket);

	stompClient.connect({}, function(frame) {
	}
----

或者,如果通过 WebSocket 连接 (没有 SockJS) ,则可以使用以下代码:

[source,javascript,indent=0]
[subs="verbatim,quotes"]
----
	var socket = new WebSocket("/spring-websocket-portfolio/portfolio");
	var stompClient = Stomp.over(socket);

	stompClient.connect({}, function(frame) {
	}
----

注意上面的 `stompClient` 不需要指定 `login` 和 `passcode` 的头信息. 即使是这样,它们也会在服务器端被忽略,或者被重写. 有关身份验证的详细信息,请参阅 <<websocket-stomp-handle-broker-relay-configure>> 和 <<websocket-stomp-authentication>>.

有关更多示例代码,请参阅

* https://spring.io/guides/gs/messaging-stomp-websocket/[Using WebSocket to build an
interactive web application] -- 入门指南.
* https://github.com/rstoyanchev/spring-websocket-portfolio[Stock Portfolio] -- 一个示例应用程序.

[[websocket-stomp-server-config]]
=== WebSocket 服务器

要配置基础 WebSocket 服务器,应用<<websocket-server-runtime-configuration>> 中的信息. 但是对于 Jetty,您需要通过 `StompEndpointRegistry` 设置 `HandshakeHandler` 和 `WebSocketPolicy`:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/portfolio").setHandshakeHandler(handshakeHandler());
		}

		@Bean
		public DefaultHandshakeHandler handshakeHandler() {

			WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);
			policy.setInputBufferSize(8192);
			policy.setIdleTimeout(600000);

			return new DefaultHandshakeHandler(
					new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));
		}
	}
----



[[websocket-stomp-message-flow]]
=== 消息流

一旦暴露了 STOMP 端点,Spring 应用程序就成为连接客户端的 STOMP 代理.  本节介绍服务器端的消息流.

`spring-messaging` 模块包含对源自 https://spring.io/spring-integration[Spring Integration] 的消息传递应用程序的基础支持,后来被提取并整合到 Spring Framework 中,以便在许多 https://spring.io/projects[Spring projects]和应用程序场景中得到更广泛的使用.  以下列表简要介绍了一些可用的消息传递抽象:


* {api-spring-framework}/messaging/Message.html[Message]: 携带有头和负载的消息
* {api-spring-framework}/messaging/MessageHandler.html[MessageHandler]: 消息处理协议
* {api-spring-framework}/messaging/MessageChannel.html[MessageChannel]: 发送消息的协议,使发件人和接收方弱耦合
* {api-spring-framework}/messaging/SubscribableChannel.html[SubscribableChannel]: 继承自 `MessageChannel` 并且发送消息给注册的 `MessageHandler` 订阅者
* {api-spring-framework}/messaging/support/ExecutorSubscribableChannel.html[ExecutorSubscribableChannel]: 使用 `Executor` 传递消息的 `SubscribableChannel`.

Java 配置 (即 `@EnableWebSocketMessageBroker`) 和 XML 命名空间配置 (即 `<websocket:message-broker>`) 都使用前面的组件来组装消息工作流.  下图显示了启用简单内置消息代理时使用的组件:

image::{image-resource}/message-flow-simple-broker.png[]

上图显示了三个消息通道:

* `clientInboundChannel`: 用于传递来自 WebSocket 客户端的消息
* `clientOutboundChannel`: 用于传递给 WebSocket 客户端的消息
* `brokerChannel`: 用于从应用程序中向代理发送消息

下图显示了配置外部代理 (例如 RabbitMQ) 以管理订阅和广播消息时使用的组件:

image::{image-resource}/message-flow-broker-relay.png[]

这两个图之间的主要区别在于使用 "`broker relay`" 通过 TCP 将消息传递到外部 STOMP 代理,以及将消息从代理传递到订阅的客户端.

当从 WebSocket 连接接收消息时,它们被解码为 STOMP 帧,变为 Spring 消息表示,并发送到 `clientInboundChannel` 以进行进一步处理.  例如, 目标 header 以 `/app` 开头的 STOMP 消息可以路由到带注解的控制器中的 `@MessageMapping` 方法,而 `/topic` 和 `/queue` 消息可以直接路由到消息代理.

带注解的 `@Controller` 可以处理由客户端通过 `brokerChannel` 发送到服务端的消息,并且通过 `clientOutboundChannel` 将消息广播给匹配的订阅者.  同一个控制器也可以响应 HTTP 请求执行相同操作,因此客户端可以执行 HTTP POST,然后 `@PostMapping` 方法可以向消息代理发送消息以向订阅的客户端广播.

我们可以通过一个简单的例子来追踪流程.  请考虑以下示例,该示例设置服务器:


[source,java,indent=0,subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/portfolio");
		}

		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.setApplicationDestinationPrefixes("/app");
			registry.enableSimpleBroker("/topic");
		}
	}

	@Controller
	public class GreetingController {

		@MessageMapping("/greeting")
		public String handle(String greeting) {
			return "[" + getTimestamp() + ": " + greeting;
		}
	}
----

上面的示例支持以下流程:

. 客户端需要连接到 `http://localhost:8080/portfolio`,一旦建立了WebSocket连接,STOMP帧就开始在其上流动.
. 客户端发送 SUBSCRIBE 帧,其目 header 为 `/topic/greeting`.  收到并解码后,消息将发送到 `clientInboundChannel` ,然后路由到存储客户端订阅的消息代理.
. 客户端向 `/app/greeting` 发送aSEND帧.  `/app` 前缀有助于将其路由到带注解的控制器.  除去 `/app` 前缀后,目标的剩余 `/greeting` 部分将映射到 `GreetingController` 中的 `@MessageMapping` 方法.
. 从 `GreetingController` 返回的值变为Spring消息,其中有效负载基于返回值和 `/topic/greeting` 的默认目 header  (从 `/app` 替换为 `/topic` ) . 生成的消息将发送到 `brokerChannel` 并由消息代理处理.
. 消息代理找到所有匹配的订阅者,并通过 `clientOutboundChannel` 向每个订阅者发送一个 MESSAGE 帧,消息被编码为 STOMP 帧并在 WebSocket 连接上发送.

下一节提供了有关注解方法的更多详细信息,包括支持的参数类型和返回值.

[[websocket-stomp-handle-annotations]]
=== 注解控制器

应用程序可以使用带注解的 `@Controller` 类来处理来自客户端的消息.  这些类可以声明 `@MessageMapping`, `@SubscribeMapping`, 和 `@ExceptionHandler` 方法,如以下主题中所述:

* <<websocket-stomp-message-mapping>>
* <<websocket-stomp-subscribe-mapping>>
* <<websocket-stomp-exception-handler>>


[[websocket-stomp-message-mapping]]
==== `@MessageMapping`

您可以使用 `@MessageMapping` 注解将方法映射到消息目标.  它在方法级别和类型级别受支持.  在类型级别,`@MessageMapping` 用于表示控制器中所有方法的共享映射.

默认目的地的匹配是 Ant 风格的使用斜线分隔(例如, `/thing*`, `/thing/**`),他们可以包含模板变量(例如, `/thing/{id}`). 可以通过 `@DestinationVariable` 的注解方法参数引用.  应用程序还可以切换到以点为分隔符的映射目标约定,如 <<websocket-stomp-destination-separator>> 中所述.

===== 支持以下方法参数

下表描述了方法参数:

[cols="1,2", options="header"]
|===
| 方法参数 | 描述

| `Message`
| 用于访问完整的消息.

| `MessageHeaders`
| 用于访问Message中的头部信息.

| `MessageHeaderAccessor`, `SimpMessageHeaderAccessor`, and `StompHeaderAccessor`
| 通过类型化方法访问头部信息

| `@Payload`
| 用于访问消息的负载,,由已配置的 `MessageConverter` 转换 (例如,从JSON) .

由于默认情况下是假定的,因此不需要注解的存在.

您可以使用 `@javax.validation.Valid` 或 Spring 的 `@Validated` 注解有效负载参数,以自动验证Payload参数.

| `@Header`
| 用于访问特定header值 - 以及使用 -- `org.springframework.core.convert.converter.Converter` 进行类型转换 (如有必要) .

| `@Headers`
| 用于访问消息中的所有 header .  此参数必须可分配给 `java.util.Map`.

| `@DestinationVariable`
| 用于访问从消息目标提取的模板变量. 根据需要将值转换为声明的方法参数类型.

| `java.security.Principal`
| 反射在 WebSocket HTTP 握手时登录的用户

|===

===== 返回值

默认的情况下,`@MessageMapping` 方法的返回值是用 `MessageConverter` 转换的,并作为新消息的正文. 默认情况下将其发送到与客户端消息具有相同目标的 `brokerChannel`, 但默认情况下使用前缀 `/topic`.

您可以使用 `@SendTo` 和 `@SendToUser` 注解来自定义输出消息的目标.  `@SendTo` 用于自定义目标目的地或指定多个目的地. `@SendToUser` 用于将输出消息定向到仅与输入消息关联的用户.  请参阅<<websocket-stomp-user-destination>>.

您可以在同一方法上同时使用 `@SendTo` 和 `@SendToUser`,并且在类级别都支持它们,在这种情况下,它们充当类中方法的默认值.  但是,请记住,任何方法级别的 `@SendTo` 或 `@SendToUser` 注解都会覆盖类级别的任何此类注解.

消息可以异步处理,`@MessageMapping` 方法可以返回 `ListenableFuture`, `CompletableFuture`, 或 `CompletionStage`.

请注意,`@SendTo` 和 `@SendToUser` 仅仅是一种便利,相当于使用 `SimpMessagingTemplate` 发送消息.  如有必要,对于更高级的方案, `@MessageMapping` 方法可以直接使用 `SimpMessagingTemplate`.  这可以代替返回值,或者可能另外返回值.  请参阅<<websocket-stomp-handle-send>>.

[[websocket-stomp-subscribe-mapping]]
==== `@SubscribeMapping`

`@SubscribeMapping` 类似于 `@MessageMapping`,但仅将映射缩小为订阅消息. 它支持与 `@MessageMapping` 相同的<<websocket-stomp-message-mapping, 方法参数>> .  但是对于返回值,默认情况下,消息将直接发送到客户端 (通过 `clientOutboundChannel`,以响应订阅) 而不是发送到代理 (通过 `brokerChannel`,作为匹配订阅的广播) .  添加 `@SendTo` 或 `@SendToUser` 会覆盖此行为并发送给代理.

什么时候有用? 假设代理映射到 `/topic` 和 `/queue`,而应用程序控制器映射到 `/app`.  在此设置中,代理将所有订阅存储到 `/topic` 和 `/queue`,用于重复广播,并且不需要应用程序参与.
客户端还可以订阅某个 `/app` 目的地,并且控制器可以返回响应于该订阅的值而不涉及代理而不再存储或使用订阅 (实际上是一次性请求 - 回复交换) .  一个用例是在启动时使用初始数据填充 UI.

什么时候这没用? 不要尝试将代理和控制器映射到相同的目标前缀,除非您由于某种原因希望两者都独立处理消息 (包括订阅) .  入站消息是并行处理的.  无法保证代理或控制器是否首先处理给定的消息.
如果在存储订阅并准备好广播时通知目标,则客户端应该在服务器支持时询问收据 (简单代理不支持) .  例如,使用 Java <<websocket-stomp-client, STOMP client>>,您可以执行以下操作来添加收据:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Autowired
	private TaskScheduler messageBrokerTaskScheduler;

	// During initialization..
	stompClient.setTaskScheduler(this.messageBrokerTaskScheduler);

	// When subscribing..
	StompHeaders headers = new StompHeaders();
	headers.setDestination("/topic/...");
	headers.setReceipt("r1");
	FrameHandler handler = ...;
	stompSession.subscribe(headers, handler).addReceiptTask(() -> {
		// Subscription ready...
	});
----

服务器端选项是在 `brokerChannel` 上 <<websocket-stomp-interceptors, 注册>> `ExecutorChannelInterceptor` ,并在处理完消息 (包括订阅) 后实现调用的 `afterMessageHandled` 方法.


[[websocket-stomp-exception-handler]]
==== `@MessageExceptionHandler`

应用程序可以使用 `@MessageExceptionHandler` 方法来处理来自 `@MessageMapping` 方法的异常.  如果要访问异常实例,可以在注解本身或通过方法参数声明异常.  以下示例通过方法参数声明异常:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Controller
	public class MyController {

		// ...

		@MessageExceptionHandler
		public ApplicationError handleException(MyException exception) {
			// ...
			return appError;
		}
	}
----

`@MessageExceptionHandler` 方法支持灵活的方法签名,并支持与<<websocket-stomp-message-mapping, `@MessageMapping`>> 方法相同的方法参数类型和返回值.

通常,`@MessageExceptionHandler` 方法适用于声明它们的 `@Controller` 类 (或类层次结构) .  如果您希望此类方法更全局地应用 (跨控制器) , 则可以在标有 `@ControllerAdvice` 的类中声明它们.  这与 Spring MVC 中提供的<<web.adoc#mvc-ann-controller-advice, 类似支持>>相当.

[[websocket-stomp-handle-send]]
=== 发送消息

如果要将消息从应用程序的任何组件发送到已连接的客户端,该怎么办? 任何应用程序的组件都可以向 `brokerChannel` 发送消息. 最简单的方法是 `SimpMessagingTemplate` 注入,并使用它来发送消息. 通常,它使用类型注入是如此方便的. 如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Controller
	public class GreetingController {

		private SimpMessagingTemplate template;

		@Autowired
		public GreetingController(SimpMessagingTemplate template) {
			this.template = template;
		}

		@RequestMapping(path="/greetings", method=POST)
		public void greet(String greeting) {
			String text = "[" + getTimestamp() + "]:" + greeting;
			this.template.convertAndSend("/topic/greetings", text);
		}

	}
----

但是,如果存在相同类型的另一个 bean,您还可以通过其名称 (`brokerMessagingTemplate`) 对其进行限定.

[[websocket-stomp-handle-simple-broker]]
=== 简单的消息代理

内置的简单消息代理处理来自客户端的订阅请求,首先会将它们存储在内存中,然后将消息广播到具有匹配目的地的已连接客户端. 代理支持类似路径的目的地,包括对 Ant 样式的目的地模式的订阅.

NOTE: 应用程序还可以使用点分隔 (而不是斜线分隔) 目标.  请查阅<<websocket-stomp-destination-separator>>.

如果配置了任务调度程序,则简单代理支持 https://stomp.github.io/stomp-specification-1.2.html#Heart-beating[STOMP 心跳].  要配置调度程序，您可以声明自己的 `TaskScheduler` bean 并通过 `MessageBrokerRegistry` 进行设置。 或者，您可以使用内置 `WebSocket` 配置中自动声明的那个，但是，您需要 `@Lazy` 来避免
内置 WebSocket 配置和您的 `WebSocketMessageBrokerConfigurer` 之间的循环。 例如：

[source,java,indent=0,subs="verbatim,quotes"]
----
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

	private TaskScheduler messageBrokerTaskScheduler;

	@Autowired
	public void setMessageBrokerTaskScheduler(@Lazy TaskScheduler taskScheduler) {
		this.messageBrokerTaskScheduler = taskScheduler;
	}

	@Override
	public void configureMessageBroker(MessageBrokerRegistry registry) {
		registry.enableSimpleBroker("/queue/", "/topic/")
				.setHeartbeatValue(new long[] {10000, 20000})
				.setTaskScheduler(this.messageBrokerTaskScheduler);

		// ...
	}
}
----

[[websocket-stomp-handle-broker-relay]]
=== 全功能的消息代理

简单的代理作为入门级别功能强大,但只是 STOMP 命令支持的一个子集(如没有 ack,接收者等),依赖于一个简单的消息循环发送,这不适合集群. 作为一种替代方法,应用程序可以升级到使用功能完备的消息代理.

请参阅 STOMP 文档以了解您选择的消息代理 (例如 https://www.rabbitmq.com/stomp.html[RabbitMQ], https://activemq.apache.org/stomp.html[ActiveMQ] 等) ,安装代理,并在启用 STOMP 支持的情况下运行它.  然后,您可以在 Spring 配置中启用 STOMP 代理中继 (而不是简单代理) .

以下示例配置启用功能齐全的代理:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/portfolio").withSockJS();
		}

		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.enableStompBrokerRelay("/topic", "/queue");
			registry.setApplicationDestinationPrefixes("/app");
		}

	}
----

以下示例显示了与前面示例等效的 XML 配置:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:message-broker application-destination-prefix="/app">
			<websocket:stomp-endpoint path="/portfolio" />
				<websocket:sockjs/>
			</websocket:stomp-endpoint>
			<websocket:stomp-broker-relay prefix="/topic,/queue" />
		</websocket:message-broker>

	</beans>
----

上面配置中的 STOMP broker relay 在spring的 {api-spring-framework}/messaging/MessageHandler.html[`MessageHandler`] 处理请求通过转发他们给外部的消息代理. 为了这么做需要建立 TCP 连接到消息代理,,转发所有的消息给代理并且转发所有的接收到的来自消息代理发送给客户端的内容(通过她们的 WebSocket 会话). 本质上对于传递消息在两个目的地之间,它扮演 "relay" 角色


NOTE: 将 `io.projectreactor.netty:reactor-netty` 和 `io.netty:netty-all` 依赖添加到项目中以进行TCP连接管理.

此外,应用组件 (例如 HTTP 请求处理方法、业务服务等) 也可以发送消息给消息代理. 如<<websocket-stomp-handle-send>>中所述,以向订阅的 WebSocket 客户端广播消息.

实际上,代理中继实现了强健且可伸缩的消息广播

[[websocket-stomp-handle-broker-relay-configure]]
=== 连接到消息代理

STOMP 代理中继会对代理维持单一的 "`system`" 级 TCP 连接. 此连接仅用于来自服务器端应用程序的消息,而不用于接收消息. 可以配置此连接的 STOMP 证书,即 STOMP 帧的 `login` 和 `passcode` 头, 这在 XML 命名空间和 Java 配置中都作为 `systemLogin` 和 `systemPasscode` 属性暴露,默认值是 `guest` 和 `guest`.

STOMP 代理中继还为每个连接的 WebSocket 客户端创建一个单独的 TCP 连接,可以将 STOMP 证书配置为代表客户端创建的所有 TCP 连接使用. 这在 XML 命名空间和 Java配 置中都作为 `clientLogin` 和 `clientPasscode` 属性暴露,默认值是 `guest` 和 `guest`.


NOTE: STOMP 代理中继总是在每个连接帧前设置 `login` 和 `passcode` 头,它转发给代理客户端. 因此,WebSocket 客户端无需设置这些 header ,它们也将被忽略.  正如<<websocket-stomp-authentication>> 部分所述,WebSocket 客户端应依赖 HTTP 身份验证来保护 WebSocket 端点并建立客户端标识.

STOMP 代理也能与消息代理在 "`system`" 级的 TCP 连接上发送和接收心跳,可以配置发送和接收心跳的间隔 (默认是每 10 秒) ,如果与代理的连接丢失,代理中继将继续每 5 秒尝试重新连接,直到成功.

当与代理的 "system" 级连接丢失并重新建立时,Spring bean 可以实现 `ApplicationListener<BrokerAvailabilityEvent>` 以接收通知. 例如,当没有 active 的 "`system`" 级连接时,股票报价服务广播股票行情可以停止尝试发送消息.

默认情况下,STOMP 代理中继始终连接,并在连接丢失时根据需要重新连接到同一主机和端口.  如果您希望提供多个地址,则在每次尝试连接时,您都可以配置地址供应商,而不是固定的主机和端口.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes"]
----
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {

	// ...

	@Override
	public void configureMessageBroker(MessageBrokerRegistry registry) {
		registry.enableStompBrokerRelay("/queue/", "/topic/").setTcpClient(createTcpClient());
		registry.setApplicationDestinationPrefixes("/app");
	}

	private ReactorNettyTcpClient<byte[]> createTcpClient() {
		return new ReactorNettyTcpClient<>(
				client -> client.addressSupplier(() -> ... ),
				new StompReactorNettyCodec());
	}
}
----

您还可以使用 `virtualHost` 属性配置 STOMP 代理中继. 这个属性的值将被设置为每个 CONNECT 帧的 `host` 头信息,并且在云环境中是可能很有用,尤其是建立 TCP 连接的实际主机与提供基于云的 STOMP 服务的主机不同的时候.

[[websocket-stomp-destination-separator]]
=== 点作为分隔符

当消息路由到 `@MessageMapping` 方法时,它们与 `AntPathMatcher` 匹配.  默认情况下,模式应使用斜杠 (`/`) 作为分隔符.  这是 Web 应用程序中的一个很好的约定,类似于 HTTP URL.  但是,如果您更习惯于消息传递约定,则可以切换到使用点 (`.`) 作为分隔符.

以下示例显示了如何在Java配置中执行此操作:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		// ...

		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.setPathMatcher(new AntPathMatcher("."));
			registry.enableStompBrokerRelay("/queue", "/topic");
			registry.setApplicationDestinationPrefixes("/app");
		}
	}
----

以下示例显示了与前面示例等效的 XML 配置:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:websocket="http://www.springframework.org/schema/websocket"
			xsi:schemaLocation="
					http://www.springframework.org/schema/beans
					https://www.springframework.org/schema/beans/spring-beans.xsd
					http://www.springframework.org/schema/websocket
					https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:message-broker application-destination-prefix="/app" path-matcher="pathMatcher">
			<websocket:stomp-endpoint path="/stomp"/>
			<websocket:stomp-broker-relay prefix="/topic,/queue" />
		</websocket:message-broker>

		<bean id="pathMatcher" class="org.springframework.util.AntPathMatcher">
			<constructor-arg index="0" value="."/>
		</bean>

	</beans>
----

之后,控制器可以使用点 (`.)` 作为 `@MessageMapping` 方法中的分隔符,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Controller
	@MessageMapping("red")
	public class RedController {

		@MessageMapping("blue.{green}")
		public void handleGreen(@DestinationVariable String green) {
			// ...
		}
	}
----

客户现在可以向 `/app/red.blue.green123` 发送消息. .

在前面的示例中,我们没有更改 "`broker relay`" 上的前缀,因为它们完全依赖于外部消息代理.  请参阅您使用的代理的 STOMP 文档页面,以查看它为目标 header 支持的约定.

另一方面,"简单代理"确实依赖于配置的 `PathMatcher`,因此,如果切换分隔符,则该更改也适用于代理以及代理将目标从消息与预订中的模式匹配的方式.


[[websocket-stomp-authentication]]
=== 身份验证

WebSocket 每一次 STOMP 的消息传递会话都是从 HTTP 请求开始的,可以是升级版的 WebSockets (即 WebSocket 握手)的请求,或者是 SockJS 回调的一系列 SockJS HTTP 传输请求的情况.

许多 Web 应用程序已经有身份验证和授权来保护 HTTP 请求. 通常,用户通过 Spring 安全性(如登录页、HTTP 基本身份验证或其他机制)进行身份验证. 经过身份验证的用户的安全上下文保存在 HTTP 会话中,并与同一 cookie 会话中的后续请求相关联.

因此,对于 WebSocket 握手或 SockJS HTTP 传输请求,通常会有通过 `HttpServletRequest#getUserPrincipal()` 访问的经过身份验证的用户. Spring 会自动将该用户与为其创建的 WebSocket 或 SockJS 会话关联,随后用在该用户的所有 STOMP 消息的会话传输过程的头部.

简而言之,典型的 Web 应用程序除了已经为安全性做的事情之外,不需要做任何事情. 用户在 HTTP 请求级别进行身份验证,通过基于 cookie 的 HTTP 会话维护的安全上下文,然后与为该用户创建的 WebSocket 或 SockJS 会话关联,并通过应用程序在每个消息流中标记用户的头信息.

请注意,STOMP 协议在 `CONNECT` 帧上有 `login` 和 `passcode` 头. 这些都是最初的设计并且仍然现在有些还是需要的. 然而,对于 WebSocket 上的 STOMP 在默认情况下,Spring 会忽略 STOMP 协议级别的授权头,并假定用户已经在 HTTP 传输级别进行了身份验证,并希望 WebSocket 或 SockJS 会话包含经过身份验证的用户.

[[websocket-stomp-authentication-token-based]]
=== 基于 token 的验证

https://github.com/spring-projects/spring-security-oauth[Spring Security OAuth]为基于令牌的安全性(包括 JSON Web Token(JWT))提供支持. 您可以将其用作 Web 应用程序中的身份验证机制,包括 STOMP over WebSocket 交互,如上一节所述 (即通过基于 cookie 的会话维护身份) .

同时,cookie 会话并不总是最适合的,例如在不希望维护服务器端会话的应用程序中,或者在移动应用程序中,通常使用报头进行身份验证.

WebSocket 协议, https://tools.ietf.org/html/rfc6455#section-10.5[WebSocket protocol, RFC 6455] 没有规定服务器在 WebSocket 握手期间可以对客户端进行身份验证的任何特定方式. 但是在实践中, 浏览器客户端只能使用标准的身份验证报头(即基本的 HTTP 身份验证)或 cookie,例如不能提供自定义的 header . 同样,SockJS JavaScript 客户端不提供使用 SockJS 传输请求发送 HTTP 头的方法.  请参阅 sockjs-client issue 196. 相反,它确实允许发送可用于发送令牌的查询参数,但这有其自身的缺点 (例如,令牌可能无意中使用服务器日志中的 URL 记录) .

NOTE: 上述限制适用于基于浏览器的客户端,并且不适用于支持使用 WebSocket 和 SockJS 请求发送报头的 Spring Java 的 STOMP 客户端.

因此,希望避免使用了 cookie 的应用程序在 HTTP 协议级别可能没有任何适合的身份验证供选择. 与其使用 cookie,他们可能更愿意在 STOMP 消息协议级别对头信息进行身份验证,两个简单的步骤可完成这个工作:

. 使 STMOP 客户端在连接时传递身份验证头
. 使用 `ChannelInterceptor` 方法处理身份验证头

下一个示例使用服务器端配置来注册自定义身份验证拦截器. 请注意,拦截器只需要在连接消息上进行身份验证并设置用户头. Spring 将注意到并保存经过身份验证的用户,并将其与同一会话中的后续 STOMP 消息相关联. 以下示例显示如何注册自定义身份验证拦截器:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class MyConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void configureClientInboundChannel(ChannelRegistration registration) {
			registration.interceptors(new ChannelInterceptor() {
				@Override
				public Message<?> preSend(Message<?> message, MessageChannel channel) {
					StompHeaderAccessor accessor =
							MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);
					if (StompCommand.CONNECT.equals(accessor.getCommand())) {
						Authentication user = ... ; // access authentication header(s)
						accessor.setUser(user);
					}
					return message;
				}
			});
		}
	}
----

还要注意,在使用 Spring Security 对消息的授权时,目前需要确保在 Spring 安全之前做好了身份验证的 `ChannelInterceptor` 配置,最好通过在自己的 `WebSocketMessageBrokerConfigurer` 实现中声明自定义拦截器来实现,该实现使用 `@Order(Ordered.HIGHEST_PRECEDENCE + 99)` 进行标记.

[[websocket-stomp-authorization]]
=== Authorization

Spring Security 提供 https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#websocket[WebSocket 子协议授权],该授权使用 `ChannelInterceptor` 根据其中的用户头来授权消息.  此外,Spring Session 提供了 https://docs.spring.io/spring-session/docs/current/reference/html5/#websocket[WebSocket 集成],可确保在 WebSocket 会话仍处于 active 状态时用户 HTTP 会话不会过期.

[[websocket-stomp-user-destination]]
=== 用户的目的地

应用程序可以发送针对特定用户的消息,Spring 的 STOMP 支持可识别以 `/user/` 为前缀的目标.  例如,客户端可能订阅 `/user/queue/position-updates` 目的地.  此目标由 `UserDestinationMessageHandler` 处理,并转换为用户会话唯一的目标 (例如 `/queue/position-updates-user123`) .  这为订阅通用命名的目的地提供了方便,同时确保与订阅同一目的地的其他用户没有冲突,以便每个用户都能接收到唯一的库存位置更新.

TIP: 使用用户目的地时，配置代理和应用程序目的地前缀很重要，如 <<websocket-stomp-enable>> 中所示，否则代理将处理仅应由 `UserDestinationMessageHandler` 处理的 "/user" 前缀消息 .

在发送方,可以将消息发送到目的地,例如 `/user/{username}/queue/position-updates`,,然后由 `UserDestinationMessageHandler` 将其转换为一个或多个目的地,每个目的地对应于与用户相关联的每个会话.  这允许应用程序中的任何组件发送针对特定用户的消息,而不必知道比其名称和通用目的地更重要的内容. 也可以通过注解和消息传递模板来支持这一点.

消息处理方法可以向与通过 `@SendToUser` 注解处理的消息相关的用户发送消息(也支持在类级别上共享一个公共目的地). 如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Controller
	public class PortfolioController {

		@MessageMapping("/trade")
		@SendToUser("/queue/position-updates")
		public TradeResult executeTrade(Trade trade, Principal principal) {
			// ...
			return tradeResult;
		}
	}
----

如果用户有多个会话,默认情况下,所有会话都已预订 到给定目标的目标. . 但是,有时可能需要只针对发送所处理消息的会话. 您可以通过将 `broadcast` 属性设置为 `false` 来执行此操作,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Controller
	public class MyController {

		@MessageMapping("/action")
		public void handleAction() throws Exception{
			// raise MyBusinessException here
		}

		@MessageExceptionHandler
		@SendToUser(destinations="/queue/errors", broadcast=false)
		public ApplicationError handleException(MyBusinessException exception) {
			// ...
			return appError;
		}
	}
----

NOTE: 虽然用户目的地通常意味着是一个经过身份验证的用户,但这不需要严格执行. 未与经过身份验证的用户关联的 WebSocket 会话也可以订阅用户目的地. 在这种情况下, `@SendToUser` 注解的行为将与 `broadcast=false` 效果完全相同,即只针对发送所处理消息的会话.

您可以从任何应用程序组件向用户目标发送消息,例如,注入由 Java 配置或 XML 命名空间创建的 `SimpMessagingTemplate`.   (如果需要使用 `@Qualifier` 进行限定,则 bean 名称为 `"brokerMessagingTemplate"`. ) 以下示例说明了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes"]
----
@Service
public class TradeServiceImpl implements TradeService {

	private final SimpMessagingTemplate messagingTemplate;

	@Autowired
	public TradeServiceImpl(SimpMessagingTemplate messagingTemplate) {
		this.messagingTemplate = messagingTemplate;
	}

	// ...

	public void afterTradeExecuted(Trade trade) {
		this.messagingTemplate.convertAndSendToUser(
				trade.getUserName(), "/queue/position-updates", trade.getResult());
	}
}
----

NOTE: 在使用具有外部消息代理的用户目的地时,请查看有关如何管理非 active 队列的代理文档,以便在用户会话结束时删除所有唯一的用户队列. 例如,当您使用目的地 (例如 `/exchange/amq.direct/position-updates`) 时,RabbitMQ 会创建自动删除队列.
因此,在这种情况下,客户端可以订阅 `/user/exchange/amq.direct/position-updates`.  同样,ActiveMQ 具有用于清除非 active 目的地的 https://activemq.apache.org/delete-inactive-destinations.html[配置选项].


在多服务器方案中,用户目标可能仍未解决,因为用户已连接到其他服务器. 在这种情况下,您可以将目的地配置为广播未解析的消息,以便让其他服务器有机会尝试.  这可以通过 Java 配置中的 `MessageBrokerRegistry` 的 `userDestinationBroadcast` 属性和XML中 `message-broker` 元素的 `user-destination-broadcast` 属性来完成.

[[websocket-stomp-ordered-messages]]
===  消息顺序

来自代理的消息将发布到 `clientOutboundChannel`,从那里将它们写入 WebSocket 会话.  由于通道由 `ThreadPoolExecutor` 支持,因此消息在不同的线程中处理,并且客户端接收的结果顺序可能与发布的确切顺序不匹配.

如果这是一个问题,请启用 `setPreservePublishOrder` 标志,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class MyConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		protected void configureMessageBroker(MessageBrokerRegistry registry) {
			// ...
			registry.setPreservePublishOrder(true);
		}

	}
----

以下示例显示了与前面示例等效的 XML 配置:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:message-broker preserve-publish-order="true">
			<!-- ... -->
		</websocket:message-broker>

	</beans>
----

设置标志后,同一客户端会话中的消息将一次发布到 `clientOutboundChannel`,以便保证发布顺序.  请注意,这会导致较小的性能开销,因此只有在需要时才应启用它.

[[websocket-stomp-application-context-events]]
=== 事件

发布了几个 `ApplicationContext` 事件,可以通过实现 Spring 的 `ApplicationListener` 接口来接收它们:

* `BrokerAvailabilityEvent`: 表明代理何时可用/不可用. 当 "`simple`" 的代理在启动时立即可用,并且在应用程序运行时保持不变. STOMP "broker relay" 可能会失去与完整功能代理的连接 (例如代理重新启动) . 代理中继会启动重新连接逻辑,并将在重新连接后重建与代理的 "`system`" 级连接.  因此,只要状态从连接变为断开连接,就会发布此事件,反之亦然.
使用 `SimpMessagingTemplate` 的组件应订阅此事件,并避免在代理不可用时发送消息. 在任何情况下,它们应该准备在发送消息时处理 `MessageDeliveryException`.
* `SessionConnectEvent`: 在收到新的 STOMP CONNECT 时发布,表示新客户端会话的开始. 该事件包含表示连接的消息,包括会话 ID,用户信息 (如果有) 以及客户端发送的任何自定义 header .  这对于跟踪客户端会话很有用.  订阅此事件的组件可以使用 `SimpMessageHeaderAccessor` 或 `StompMessageHeaderAccessor` 包装所包含的消息.
* `SessionConnectedEvent`: 在 `SessionConnectEvent` 之后不久发布,当代理已发送 STOMP CONNECTED 帧以响应 CONNECT 时.  此时,可以认为 STOMP 会话已完全建立.
* `SessionSubscribeEvent`:  在收到新的 STOMP SUBSCRIBE 时发布.
* `SessionUnsubscribeEvent`: 在收到新的 STOMP UNSUBSCRIBE 时发布.
* `SessionDisconnectEvent`: 当 STOMP 会话结束后被发布. DISCONNECT 是客户端发送的,也可能是在关闭 WebSocket 会话时自动生成的. 在某些情况下,此事件可能会在每个会话中发布一次以上. 对于多个断开事件,组件功能应该是幂等的.

NOTE: 当您使用功能齐全的代理时,如果代理暂时不可用,STOMP "代理中继" 会自动重新连接 "`system`"  连接.  但是,客户端连接不会自动重新连接.  假设启用了心跳,客户端通常会注意到代理在 10 秒内没有响应.  客户端需要实现自己的重新连接逻辑.

[[websocket-stomp-interceptors]]
=== 拦截

<<websocket-stomp-application-context-events>> 为 STOMP 连接的生命周期提供通知,但不为每个客户端消息提供通知.  应用程序还可以注册 `ChannelInterceptor` 来拦截任何消息以及处理链的任何部分.  以下示例显示如何拦截来自客户端的入站邮件:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void configureClientInboundChannel(ChannelRegistration registration) {
			registration.interceptors(new MyChannelInterceptor());
		}
	}
----

自定义 `ChannelInterceptor` 可以使用 `StompHeaderAccessor` 或 `SimpMessageHeaderAccessor` 来访问有关消息的信息,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public class MyChannelInterceptor implements ChannelInterceptor {

		@Override
		public Message<?> preSend(Message<?> message, MessageChannel channel) {
			StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);
			StompCommand command = accessor.getStompCommand();
			// ...
			return message;
		}
	}
----

应用程序还可以实现 `ExecutorChannelInterceptor`,它是 `ChannelInterceptor` 的子接口,在处理消息的线程中具有回调.  虽然为发送到通道的每个消息调用一次 `ChannelInterceptor`,但 `ExecutorChannelInterceptor` 在订阅来自通道的消息的每个 `MessageHandler` 的线程中提供挂钩.

请注意,与前面描述的 `SesionDisconnectEvent` 一样,DISCONNECT 消息可以来自客户端,也可以在 WebSocket 会话关闭时自动生成.  在某些情况下,拦截器可能会为每个会话多次拦截此消息.  对于多个断开连接事件,组件应该是幂等的.

[[websocket-stomp-client]]
=== STOMP 客户端

Spring 在 WebSocket 客户端和 TCP 客户端上分别提供了 STOMP

开始创建和配置 `WebSocketStompClient`, 如下所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	WebSocketClient webSocketClient = new StandardWebSocketClient();
	WebSocketStompClient stompClient = new WebSocketStompClient(webSocketClient);
	stompClient.setMessageConverter(new StringMessageConverter());
	stompClient.setTaskScheduler(taskScheduler); // for heartbeats
----

在前面的示例中,您可以将 `StandardWebSocketClient` 替换为 `SockJsClient`,因为它也是 `WebSocketClient` 的实现.  `SockJsClient` 可以使用 WebSocket 或基于 HTTP 的传输作为后备.  有关更多详细信息,请参阅 <<websocket-fallback-sockjs-client,SockJsClient>>.

接下来,您可以建立连接并为 STOMP 会话提供处理程序,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	String url = "ws://127.0.0.1:8080/endpoint";
	StompSessionHandler sessionHandler = new MyStompSessionHandler();
	stompClient.connect(url, sessionHandler);
----

当会话准备好使用时,将通知处理程序,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
public class MyStompSessionHandler extends StompSessionHandlerAdapter {

	@Override
	public void afterConnected(StompSession session, StompHeaders connectedHeaders) {
		// ...
	}
}
----

建立会话后,可以发送任何有效负载并使用配置的 `MessageConverter` 进行序列化,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
session.send("/topic/something", "payload");
----

也可以订阅目的地,. `subscribe` 方法需要处理订阅消息的处理程序,并返回可用于取消订阅的 `Subscription` 句柄.  对于每个收到的消息,处理程序可以指定要对其进行反序列化的目标对象类型,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
session.subscribe("/topic/something", new StompFrameHandler() {

	@Override
	public Type getPayloadType(StompHeaders headers) {
		return String.class;
	}

	@Override
	public void handleFrame(StompHeaders headers, Object payload) {
		// ...
	}

});
----

启用 STOMP 的心跳,需配置 `WebSocketStompClient` 与 `TaskScheduler`,并可选择自定义心跳间隔,10 秒的写不 active 会导致心跳发送和 10 秒的读取不 active 将会关闭连接.

`WebSocketStompClient` 仅在不活动的情况下 (即未发送其他消息时) 发送心跳.  当使用外部代理时， 这可能会有些困难， 因为发送具有非代理目标的消息时， 实际上并未转发给代理.  在这种情况下， 您可以在初始化 <<websocket-stomp-handle-broker-relay>> 时配置 `TaskScheduler`， 以确保即使仅发送具有非代理目标的消息， 也可以将心跳转发给代理.

NOTE: 	当使用 `WebSocketStompClient` 进行性能测试以模拟来自同一台计算机的数千个客户端时,请考虑关闭心跳,因为每个连接都计划自己的心跳任务,而对于在同一台计算机上运行的大量客户端来说,这不是最优化的.

STOMP 协议还支持回执,在处理发送或订阅后,客户端必须添加一个 `receipt` 头,服务器在该报头中响应回执帧. 为了支持这一点, `StompSession` 提供了 `setAutoReceipt(boolean)`,会在每个后续发送或订阅中添加 `receipt` 头.
另外,也可以手动向 `StompHeaders` 添加 `receipt` 头. 发送和订阅返回 `Receiptable` 的实例,可用于注册回执成功和失败回调. 对于此功能,客户端必须配置 `TaskScheduler`,并且设置为回执到期前的时间(默认情况下为 15 秒).


请注意, `StompSessionHandler` 本身是一个 `StompFrameHandler`,它允许它在处理消息的 `handleException` 回调之外处理 ERROR 帧,以及 `handleTransportError` 传输级别错误(包括 `ConnectionLostException`)

[[websocket-stomp-websocket-scope]]
=== WebSocket 作用域

每个 WebSocket 会话都有一个属性映射表. 这个表被附加为传入客户端消息的 header ,并且可以从控制器方法访问,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
@Controller
public class MyController {

	@MessageMapping("/action")
	public void handle(SimpMessageHeaderAccessor headerAccessor) {
		Map<String, Object> attrs = headerAccessor.getSessionAttributes();
		// ...
	}
}
----

也可以在 `websocket` 作用域内声明 Spring 管理的 bean. WebSocket 作用域的 bean 可以被注入到控制器和任何在 `clientInboundChannel` 上注册的通道拦截器. 这些都是典型的单例和比任何单个 WebSocket 会话的存活时间都要长. 因此,将需要对 WebSocket 作用域的 bean 使用作用作用域代理模式. 如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Component
	@Scope(scopeName = "websocket", proxyMode = ScopedProxyMode.TARGET_CLASS)
	public class MyBean {

		@PostConstruct
		public void init() {
			// Invoked after dependencies injected
		}

		// ...

		@PreDestroy
		public void destroy() {
			// Invoked when the WebSocket session ends
		}
	}

	@Controller
	public class MyController {

		private final MyBean myBean;

		@Autowired
		public MyController(MyBean myBean) {
			this.myBean = myBean;
		}

		@MessageMapping("/action")
		public void handle() {
			// this.myBean from the current WebSocket session
		}
	}
----

与任何自定义作用域一样,Spring 在第一次从控制器访问时初始化一个新的 `MyBean` 实例,并将该实例存储在 WebSocket 会话属性中. 随后返回同一实例,直到会话结束. WebSocket 作用域的 bean 将具有所有的 Spring 生命周期方法调用,如上面的示例所示.

[[websocket-stomp-configuration-performance]]
=== 性能

在性能方面没有一个办法是可以解决任何问题的. 许多因素都会影响性能,包括消息的大小、分卷、应用方法执行以及是否阻塞,外部因素例如网络速度等等. 本节的目标是提供可用配置选项的概述,以及有关如何推理、缩放的一些想法.

在消息传递应用程序消息中,通过通道来传递由线程池支持的异步执行. 配置此类应用程序需要对通道和消息流有很好的了解. 因此,建议查看<<websocket-stomp-message-flow>>.

一个明显需要重点配置的是两个线程池,`clientInboundChannel` 和 `clientOutboundChannel`. 默认情况下,两者都配置为可用处理器数量的两倍.

如果注解方法处理消息是绑定主 CPU 的话,那么 `clientInboundChannel` 的线程数应该与处理器数量保持接近. 如果他们所做的工作是更多的 IO 绑定,需要阻塞或等待数据库或其他外部系统,那么线程池的大小将需要增加.

[NOTE]
====

`ThreadPoolExecutor` 有三个重要的属性: 核心的线程大小,最大的线程大小和阻塞队列 (可用于执行任务的容量)

一个常见的混淆点是,配置核心池大小(如 10)和最大池大小(例如 20)会导致线程池中有 10 个至 20 个的线程. 实际上,如果容量是保留在其默认值为 `Integer.MAX_VALUE` 后,线程池将永远不会增加超过核心池大小,因为所有其他任务都在排队了.

请参阅 `ThreadPoolExecutor` 的 javadoc 以了解这些属性如何工作并理解各种排队策略.
====

在 `clientOutboundChannel` 方面, 这是所有关于向 WebSocket 客户端发送消息的内容. 如果客户端处于快速网络中,则线程数应保持在可用处理器数量附近. 如果它们速度慢或带宽低,则会花费更长的时间来消耗消息并给线程池带来负担. 因此,增加线程池的大小将是必要的.

虽然 `clientInboundChannel` 的工作负载可以预测 - 毕竟,它基于应用程序的工作 - 如何配置"clientOutboundChannel" 更难,因为它基于应用程序无法控制的因素. 因此,有两个与发送消息相关的附加属性:  `sendTimeLimit` 和 `sendBufferSizeLimit`. 这些用于配置在向客户端发送消息时允许发送的时间以及可以缓冲多少数据.

一般的想法是,在任何给定的时间,只有一个线程可以用来发送到客户端. 同时,所有附加消息都得到缓冲,可以使用这些属性来决定允许发送消息的时间长度以及在平均时间内可以缓冲多少数据. 有关重要的其他详细信息,请参阅 XML 架构的 javadoc 和文档.

以下示例显示了可能的配置:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void configureWebSocketTransport(WebSocketTransportRegistration registration) {
			registration.setSendTimeLimit(15 * 1000).setSendBufferSizeLimit(512 * 1024);
		}

		// ...

	}
----

以下示例显示了与前面示例等效的 XML 配置:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:message-broker>
			<websocket:transport send-timeout="15000" send-buffer-size="524288" />
			<!-- ... -->
		</websocket:message-broker>

	</beans>
----

上面显示的 WebSocket 传输配置也可用于配置传入的 STOMP 消息的允许的最大大小配置. 虽然理论上 WebSocket 的消息可以是几乎无限大,但在实践中 WebSocket 服务器通常会强加限制.  例如,在 Tomcat 是 8k、在 Jetty 中是 64k. 因为这个原因,STOMP 客户端 (例如JavaScript https://github.com/JSteunou/webstomp-client[webstomp-client]等) 可以将更大的 STOMP 信息分割为 16k 一个片,并将它们作为多个 WebSocket 消息发送,从而要求服务器进行缓冲和组装.

Spring 的 STOMP-over-WebSocket 支持实现了这一点,因此应用程序可以配置 STOMP 消息的最大大小,而不管 WebSocket 服务器特定的消息大小.  请记住,必要时会自动调整 WebSocket 消息大小,以确保它们至少可以携带 16K WebSocket 消息.

以下示例显示了一种可能的配置:

[source,java,indent=0,subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void configureWebSocketTransport(WebSocketTransportRegistration registration) {
			registration.setMessageSizeLimit(128 * 1024);
		}

		// ...

	}
----

以下示例显示了与前面示例等效的 XML 配置:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:message-broker>
			<websocket:transport message-size="131072" />
			<!-- ... -->
		</websocket:message-broker>

	</beans>
----

关于伸缩性的一个重要问题是使用多个应用程序实例. 目前,简单的代理是不可能做到的. 但是,当使用功能完备的代理(如 RabbitMQ)时,每个应用程序实例连接到代理,并且从一个应用程序实例广播的消息可以通过代理广播到通过任何其他应用程序实例连接的 WebSocket 客户端.

[[websocket-stomp-stats]]
=== 监控

当使用 `@EnableWebSocketMessageBroker` 或 `<websocket:message-broker>` 关键架构组件时,将自动收集统计信息和计数器,以便对应用程序的内部状态提供重要的参考.  该配置还声明了一个类型为 `WebSocketMessageBrokerStats` 的 bean,它在一个位置收集所有可用信息. 默认情况下,会每隔 `30` 分钟记录一次日志到 `INFO`. 可以通过Spring的 `MBeanExporter` 将此 bean 导出到 JMX,以便在运行时查看,例如通过 JDK 的 `jconsole`. 下面是可用信息的摘要

Client WebSocket Sessions (客户端WebSocket会话) ::
	Current (当前) ::: 当前有多少客户端会话已通过 WebSocketvsHTTPstreaming 和 pollingSockJS 会话
	Total (总共) ::: 已建立的总会话数
	Abnormally Closed (非正常关闭) :::
		Connect Failures (连接失败) :::: 这些会话已经建立,但在 60 秒内没有收到任何消息后被关闭. 这通常是代理或网络的问题.
		Send Limit Exceeded (发送限制) :::: 在超过配置的发送超时或可能与慢速客户端发生的发送缓冲区限制后,会话关闭(请参阅上一节)
		Transport Errors (传输错误) :::: 在传输错误(如无法读取或写入 WebSocket 连接或 HTTP 请求/响应)后关闭会话.
	STOMP Frames (STOMP帧) ::: CONNECT、CONNECTED 和 DISCONNECT 帧的总数目表明有多少客户端在 STOMP 级别上连接. 请注意,当会话异常关闭或客户端关闭而不发送断开连接帧时,断开连接计数可能会较低.
STOMP Broker Relay (STOMP消息代理回复) ::
	TCP Connections (TCP连接数) ::: 指示将代表客户端 WebSocket 会话的 TCP 连接设置为代理的数量. 这应该等于客户端 WebSocket 会话数+额外的共享的"系统"级连接,用于从应用程序内发送消息.
	STOMP Frames (STOMP帧) ::: 代表客户端转发到或从代理接收的 CONNECT、CONNECTED 和 DISCONNECT 的帧总数. 请注意,无论客户端 WebSocket 会话是如何关闭的,断开连接帧都将发送到代理. 因此,较低的断开连接帧计数是指代理正在主动关闭连接,可能是由于没有及时到达的心跳、无效的输入帧或其他.
Client Inbound Channel (客户端输入channel) :: 线程池的统计数据支持 `clientInboundChannel` 提供对传入消息处理的健康的检测. 在这里排队的任务是指应用程序可能太慢,无法处理消息. 如果有 i/o 绑定任务(如慢速数据库查询、对第三方 RESTAPI 的 HTTP 请求等) ,请考虑增加线程池大小.
Client Outbound Channel (客户端输出 channel) :: 线程池的统计数据支持 `clientOutboundChannel` 提供对向客户端广播消息的健康状况的检测. 在这里排队的任务的问题可能是客户端太慢,无法使用消息. 解决这一问题的一种方法是增加线程池的大小,以适应预期的并发慢速客户端的数量. 另一个选项是减少发送超时和发送缓冲区大小限制(请参阅上一节).
SockJS Task Scheduler (SockJS的任务计划) :: 用于发送心跳的 SockJS 任务计划程序的线程池的统计信息. 请注意,当心跳在 STOMP 级别上协商时,SockJS 心跳将被禁用.



[[websocket-stomp-testing]]
=== 测试

使用 Spring 的 WebSocket 支持来测试应用程序有两种主要方法. 第一种是编写服务器端测试,以验证控制器的功能及其注解的消息处理方法. 第二个是编写涉及运行客户端和服务器的完整的端到终端测试.

这两种方法不是互斥的. 相反,它们在总体测试策略中有一席之地. 服务器端测试更加集中,更易于编写和维护. 另一方面,端对点的集成测试更完整,更多,但它们也更多地涉及编写和维护

最简单的服务器端测试形式是编写控制器单元测试. 但是,这是不用够的,因为控制器的大部分内容取决于它的注解. 纯单元测试根本无法测试.

理想中的控制器应该在运行时调用,就像测试控制器使用 Spring MVC 测试框架处理 HTTP 请求的方法一样. 即不运行 Servlet 容器,而是依赖于 Spring 框架来调用带注解的控制器. 就像 Spring MVC 测试这里有两种可能的选择,要么使用 "基于上下文" 或 "单独" 设置.

* 在 SpringTestContext 框架的帮助下加载实际的 Spring 配置,将 `clientInboundChannel` 作为测试字段,并使用它发送要由控制器方法处理的消息.

* 手动设置调用控制器(即 `SimpAnnotationMethodMessageHandler`)所需的最低 Spring 框架基础结构,并直接向控制器传递消息.

这两种设置方案都在 https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web[股票投资组合]示例应用程序的测试中演示

第二种方法是创建端到端的集成测试. 为此,需要在嵌入式模式下运行 WebSocket 服务器,并将其作为 WebSocket 客户端发送包含 STOMP 帧的 WebSocket 消息.  https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web[股票投资组合]的应用程序的测试还演示了这种方法,它使用 Tomcat 作为嵌入式 WebSocket 服务器和简单的 STOMP 客户端进行测试.