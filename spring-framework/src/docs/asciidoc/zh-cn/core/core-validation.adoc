[[validation]]
= 验证, 数据绑定和类型转换

在业务逻辑中添加数据验证利弊参半,Spring 提供的验证(和数据绑定) 方案也未必能解决这个问题. 具体来说,验证不应该与 Web 层绑定,并且应该易于本地化,并且应该可以插入任何可用的验证器.
考虑到这些问题,Spring 提出了一个基本的,非常有用的 `Validator` 联系,它在应用程序的每一层都可用.

Spring 为开发者提供了一个称作 `DataBinder` 的对象来处理数据绑定,所谓的数据绑定就是将用户输入自动地绑定到相应的领域模型(或者说用来处理用户所输入的任何对象) . Spring 的 `Validator` 和 `DataBinder` 构成了验证包,这个包主要用在 web 层使用,但绝不限于此.

`BeanWrapper` 是 Spring 框架中的一个基本概念,并且在很多地方使用. 但是,在使用过程中可能从未碰过它. 鉴于这是一份参考文档,那么对 `BeanWrapper` 的解释很有必要. 我们将在本章中解释 `BeanWrapper`,在开发者尝试将数据绑定到对象的时候一定会使用到它.

Spring的 `DataBinder` 和底层的 `BeanWrapper` 都使用 `PropertyEditorSupport` 实现来解析和格式化属性值.  `PropertyEditor` `和PropertyEditorSupport` 接口是 JavaBeans 规范的一部分,本章也对其进行了解释. Spring 3 引入了一个 `core.convert` 包，它提供了一个
通用类型转换工具，以及更高级别的 "`format`" 包格式化 UI 字段值。 您可以将这些包用作更简单的替代方案 `PropertyEditorSupport` 实现。 本章还将讨论它们。

Spring 可以通过一些基础设置来支持 Java Bean 的验证. 也可以统一个适配器来兼容 Spring 的 `Validator` 验证接口
应用程序既可以一次性开启控制全局的 Bean Validation,如 Spring <<validation-beanvalidation,Validation>>中所述,并专门用于所有验证需求.
应用程序还可以为每个 `DataBinder` 实例注册其他 Spring `Validator` 实例,如配置<<validation-binder,配置 `DataBinder`>>中所述.

[[validator]]
== 使用 Spring 的 Validator 接口来进行数据验证

Spring 提供了 `Validator` 接口用来进行对象的数据验证. `Validator` 接口在进行数据验证的时候会要求传入一个 `Errors` 对象,当有错误产生时会将错误信息放入该对象.

考虑以下对象的示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class Person {

		private String name;
		private int age;

		// the usual getters and setters...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class Person(val name: String, val age: Int)
----

下一个示例通过实现 `org.springframework.validation.Validator` 接口的以下两个方法为 `Person` 类提供验证行为:

* `supports(Class)`: 判断该 `Validator` 是否能验证提供的 `Class` 的实例?
* `validate(Object, org.springframework.validation.Errors)`: 验证给定的对象,如果有验证失败信息,则将其放入 `Errors` 对象.

实现一个 `Validator` 相当简单,尤其是使用 Spring 提供的 `ValidationUtils` 工具类时. 以下示例为 `Person` 实例实现 `Validator`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class PersonValidator implements Validator {

		/**
		 * This Validator validates only Person instances
		 */
		public boolean supports(Class clazz) {
			return Person.class.equals(clazz);
		}

		public void validate(Object obj, Errors e) {
			ValidationUtils.rejectIfEmpty(e, "name", "name.empty");
			Person p = (Person) obj;
			if (p.getAge() < 0) {
				e.rejectValue("age", "negativevalue");
			} else if (p.getAge() > 110) {
				e.rejectValue("age", "too.darn.old");
			}
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class PersonValidator : Validator {

		/**
		 * This Validator validates only Person instances
		 */
		override fun supports(clazz: Class<*>): Boolean {
			return Person::class.java == clazz
		}

		override fun validate(obj: Any, e: Errors) {
			ValidationUtils.rejectIfEmpty(e, "name", "name.empty")
			val p = obj as Person
			if (p.age < 0) {
				e.rejectValue("age", "negativevalue")
			} else if (p.age > 110) {
				e.rejectValue("age", "too.darn.old")
			}
		}
	}
----

`ValidationUtils` 中的静态方法 `rejectIfEmpty(..)` 方法用于拒绝 `name` 属性(如果它为 `null` 或空字符串) . 更多信息可以参考 {api-spring-framework}/validation/ValidationUtils.html[`ValidationUtils`]  的javadocs.

虽然可以实现一个 `Validator` 类来验证富对象中的每个嵌套对象,但最好将每个嵌套对象类的验证逻辑封装在自己的 `Validator` 实现中.  例如,有一个名为 `Customer` 的复杂对象,它有两个 `String` 类型的属性(first name和second name) ,另外还有一个 `Address` 对象. 它与 `Customer` 毫无关系,
它还实现了名为 `AddressValidator` 的验证器. 如果考虑在 `CustomerValidator` 验证器类中重用 `AddressValidator` 验证器的功能(这种重用不是通过简单的代码拷贝) , 那么可以将 `AddressValidator` 验证器的实例通过依赖注入的方式注入到 `CustomerValidator` 验证器中. 如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class CustomerValidator implements Validator {

		private final Validator addressValidator;

		public CustomerValidator(Validator addressValidator) {
			if (addressValidator == null) {
				throw new IllegalArgumentException("The supplied [Validator] is " +
					"required and must not be null.");
			}
			if (!addressValidator.supports(Address.class)) {
				throw new IllegalArgumentException("The supplied [Validator] must " +
					"support the validation of [Address] instances.");
			}
			this.addressValidator = addressValidator;
		}

		/**
		 * This Validator validates Customer instances, and any subclasses of Customer too
		 */
		public boolean supports(Class clazz) {
			return Customer.class.isAssignableFrom(clazz);
		}

		public void validate(Object target, Errors errors) {
			ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required");
			ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required");
			Customer customer = (Customer) target;
			try {
				errors.pushNestedPath("address");
				ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);
			} finally {
				errors.popNestedPath();
			}
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class CustomerValidator(private val addressValidator: Validator) : Validator {

		init {
			if (addressValidator == null) {
				throw IllegalArgumentException("The supplied [Validator] is required and must not be null.")
			}
			if (!addressValidator.supports(Address::class.java)) {
				throw IllegalArgumentException("The supplied [Validator] must support the validation of [Address] instances.")
			}
		}

		/**
		* This Validator validates Customer instances, and any subclasses of Customer too
		*/
		override fun supports(clazz: Class<*>): Boolean {
			return Customer::class.java.isAssignableFrom(clazz)
		}

		override fun validate(target: Any, errors: Errors) {
			ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required")
			ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required")
			val customer = target as Customer
			try {
				errors.pushNestedPath("address")
				ValidationUtils.invokeValidator(this.addressValidator, customer.address, errors)
			} finally {
				errors.popNestedPath()
			}
		}
	}
----

验证错误信息会上报给作为参数传入的 `Errors` 对象,如果使用 Spring Web MVC. 您可以使用 `<spring:bind/>` 标记来检查错误消息,但您也可以自己检查 `Errors` 对象.  有关它提供的方法的更多信息可以在 {api-spring-framework}/validation/Errors.html[javadoc] javadoc 中找到.


[[validation-conversion]]
== 通过错误编码得到错误信息

<<validator, 上一节>>介绍了数据绑定和数据验证,如何拿到验证错误信息是最后需要讨论的问题. 在上一个的例子中,验证器拒绝了 `name` 和 `age` 属性. 如果我们想通过使用 `MessageSource` 输出错误消息, 可以在验证失败时设置错误编码(本例中就是 `name` 和 `age` ) .
当调用(直接或间接地,通过使用 `ValidationUtils` 类) `Errors` 接口中的 `rejectValue` 方法或者它的任意一个方法时,它的实现不仅仅注册传入的错误编码参数, 还会注册一些遵循一定规则的错误编码.
注册哪些规则的错误编码取决于开发者使用的 `MessageCodesResolver`. 当使用默认的 `DefaultMessageCodesResolver` 时, 除了会将错误信息注册到指定的错误编码上,这些错误信息还会注册到包含属性名的错误编码上. 假如调用 `rejectValue("age", "too.darn.old")` 方法,
Spring 除了会注册 `too.darn.old` 错误编码外, 还会注册 `too.darn.old.age` 和 `too.darn.old.age.int` 这两个错误编码(即一个是包含属性名,另外一个既包含属性名还包含类型的) . 在 Spring 中这种注册称为注册约定,这样所有的开发者都能按照这种约定来定位错误信息.

有关 `MessageCodesResolver` 和默认策略的更多信息可分别在 {api-spring-framework}/validation/MessageCodesResolver.html[`MessageCodesResolver`] 和 {api-spring-framework}/validation/DefaultMessageCodesResolver.html[`DefaultMessageCodesResolver`], 的 javadoc 中找到.

[[beans-beans]]
== 操作 bean 和 `BeanWrapper`

`org.springframework.beans` 包遵循 Oracle 提供的 JavaBeans 标准,JavaBean 只是一个包含默认无参构造器的类,
它遵循命名约定(举例来说)  名为 `bingoMadness` 属性将拥有设置方法 `setBingoMadness(..)` 和获取方法 `getBingoMadness()`. 有关 JavaBeans 和规范的更多信息,请参考 Oracle 的网站( https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html[javabeans]) .

beans 包里一个非常重要的类是 `BeanWrapper` 接口和它的相应实现(`BeanWrapperImpl`). 引自 javadoc: `BeanWrapper` 提供了设置和获取属性值(单个或批量) 、 获取属性描述符以及查询属性以确定它们是可读还是可写的功能.
`BeanWrapper` 还提供对嵌套属性的支持,能够不受嵌套深度的限制启用子属性的属性设置. `BeanWrapper` 还提供了无需目标类代码的支持就能够添加标准 JavaBeans 的 `PropertyChangeListeners` 和 `VetoableChangeListeners` 的能力.
最后但同样重要的是, `BeanWrapper` 支持设置索引属性. 应用程序代码通常不会直接使用 `BeanWrapper`,而是提供给 `DataBinder` 和 `BeanFactory` 使用.

`BeanWrapper` 顾名思义,它包装了 bean 并对其执行操作. 例如设置和获取属性.

[[beans-beans-conventions]]
=== 设置并获取基本和嵌套的属性

设置和获取属性是通过使用 `setPropertyValue`,  和 `getPropertyValues` 方法完成的,这些方法重载了 `BeanWrapper`.  Springs javadoc 更详细地描述了它们.  JavaBeans 规范具有指示对象属性的约定.  下表显示了这些约定的一些示例:

[[beans-beans-conventions-properties-tbl]]
.Examples of properties
|===
| Expression| Explanation

| `name`
| 表示属性 `name` 与 `getName()` 或 `isName()` 和 `setName(..)` 方法相对应

| `account.name`
| 表示 `account` 属性的嵌套属性 `name` 与 `getAccount().setName()` 或 `getAccount().getName()` 相对应.

| `account[2]`
| 表示索引属性 `account` 的第_3_个属性. 索引属性可以是 `array`, `list`, 其他自然排序的集合.

| `account[COMPANYNAME]`
| 表示映射属性 `account` 是键为 `COMPANYNAME` 的值.
|===

(如果您不打算直接使用 BeanWrapper ,那么下一节对您来说并不重要. 如果您只使用 `DataBinder` 和 `BeanFactory` 及其默认实现,那么您应该跳到有关<<beans-beans-conversion,  `PropertyEditors`>>的部分. )

以下两个示例类使用 `BeanWrapper` 来获取和设置属性:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class Company {

		private String name;
		private Employee managingDirector;

		public String getName() {
			return this.name;
		}

		public void setName(String name) {
			this.name = name;
		}

		public Employee getManagingDirector() {
			return this.managingDirector;
		}

		public void setManagingDirector(Employee managingDirector) {
			this.managingDirector = managingDirector;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class Company {
		var name: String? = null
		var managingDirector: Employee? = null
	}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class Employee {

		private String name;

		private float salary;

		public String getName() {
			return this.name;
		}

		public void setName(String name) {
			this.name = name;
		}

		public float getSalary() {
			return salary;
		}

		public void setSalary(float salary) {
			this.salary = salary;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class Employee {
		var name: String? = null
		var salary: Float? = null
	}
----

以下代码段显示了如何检索和操作实例化 `Companies` 和 `Employees` 的某些属性的一些示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	BeanWrapper company = new BeanWrapperImpl(new Company());
	// setting the company name..
	company.setPropertyValue("name", "Some Company Inc.");
	// ... can also be done like this:
	PropertyValue value = new PropertyValue("name", "Some Company Inc.");
	company.setPropertyValue(value);

	// ok, let's create the director and tie it to the company:
	BeanWrapper jim = new BeanWrapperImpl(new Employee());
	jim.setPropertyValue("name", "Jim Stravinsky");
	company.setPropertyValue("managingDirector", jim.getWrappedInstance());

	// retrieving the salary of the managingDirector through the company
	Float salary = (Float) company.getPropertyValue("managingDirector.salary");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val company = BeanWrapperImpl(Company())
	// setting the company name..
	company.setPropertyValue("name", "Some Company Inc.")
	// ... can also be done like this:
	val value = PropertyValue("name", "Some Company Inc.")
	company.setPropertyValue(value)

	// ok, let's create the director and tie it to the company:
	val jim = BeanWrapperImpl(Employee())
	jim.setPropertyValue("name", "Jim Stravinsky")
	company.setPropertyValue("managingDirector", jim.wrappedInstance)

	// retrieving the salary of the managingDirector through the company
	val salary = company.getPropertyValue("managingDirector.salary") as Float?
----



[[beans-beans-conversion]]
=== 内置 `PropertyEditor` 实现

Spring 使用 `PropertyEditor` 的概念来实现 `Object` 和 `String` 之间的转换,有时使用不同于对象本身的方式来表示属性显得更方便. 例如,`Date` 可以使用易于阅读的方式(如 `String : '2007-14-09'`).
还能将易于阅读的形式转换回原来的 `Date` (甚至做得更好: 转换任何以易于阅读形式输入的日期,然后返回日期对象) . 可以通过注册 `java.beans.PropertyEditor` 类型的自定义编辑器来实现此行为.
在 `BeanWrapper` 上注册自定义编辑器,或者在特定的 IoC 容器中注册自定义编辑器(如前一章所述) ,使其了解如何将属性转换为所需类型.  有关 `PropertyEditor` 的更多信息,请参阅 https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html[Oracle的java.beans包]的 javadoc

在 Spring 中使用属性编辑的几个示例:

* 通过使用 `PropertyEditor` 实现来设置 bean 的属性.  当您使用 `java.lang.String` 作为您在 XML 文件中声明的某个 bean 的属性的值时, Spring 将(如果相应属性的 setter 具有类参数) 使用 `ClassEditor` 尝试将参数解析为类对象.
* 在 Spring 的 MVC 框架中解析 HTTP 请求参数是通过使用各种 `PropertyEditor` 实现来完成的,您可以在 `CommandController` 的所有子类中手动绑定它们.

Spring 内置了许多 `PropertyEditor` 用于简化处理. 它们都位于 `org.springframework.beans.propertyeditors` 包中.
大多数(但不是全部,如下表所示) 默认情况下由 `BeanWrapperImpl` 注册.  当属性编辑器以某种方式进行配置时,开发者仍可以注册自定义的变体用于覆盖默认的变量. 下表描述了 Spring 提供的各种 `PropertyEditor` 实现:

[[beans-beans-property-editors-tbl]]
.内置 `PropertyEditor` 实现
[cols="30%,70%"]
|===
| 类| 说明

| `ByteArrayPropertyEditor`
| 字节数组的编辑器.  将字符串转换为其对应的字节表示形式. `BeanWrapperImpl` 默认注册.

| `ClassEditor`
| 将表示类的字符串解析为实际的类,反之亦然.  找不到类时,抛出 `IllegalArgumentException`.  默认情况下,由 `BeanWrapperImpl` 注册.

| `CustomBooleanEditor`
| `Boolean` 属性的可自定义属性编辑器.  默认情况下,由 `BeanWrapperImpl` 注册,但可以通过将其自定义实例注册为自定义编辑器来覆盖.

| `CustomCollectionEditor`
| `Collection` 的属性编辑器,将任何源 `Collection` 转换为给定的目标 `Collection` 类型.

| `CustomDateEditor`
| `java.util.Date` 的可自定义属性编辑器,支持自定义 `DateFormat`.  默认未注册.  必须根据需要使用适当的格式进行用户注册.

| `CustomNumberEditor`
| 任何 `Number` 子类的可自定义属性编辑器,例如 `Integer`, `Long`, `Float` 或 `Double`.  默认情况下,由 `BeanWrapperImpl` 注册,但可以通过将其自定义实例注册为自定义编辑器来覆盖.

| `FileEditor`
| 将字符串解析为 `java.io.File` 对象.  默认情况下,由 `BeanWrapperImpl` 注册.

| `InputStreamEditor`
| 单向属性编辑器,可以获取字符串并生成(通过中间 `ResourceEditor` 和 `Resource`) `InputStream`,以便 `InputStream` 属性可以直接设置为字符串.  请注意,默认用法不会为您关闭 `InputStream`.  默认情况下,由 `BeanWrapperImpl` 注册.

| `LocaleEditor`
| 可以将字符串解析为 `Locale` 对象,反之亦然(字符串格式为 `[language]\_[country]_[variant]`,与 `Locale` 的 `toString()` 方法相同) .也接受空格作为分隔符，作为下划线的替代。  默认情况下,由 `BeanWrapperImpl` 注册.

| `PatternEditor`
| 可以将字符串解析为 `java.util.regex.Pattern` 对象,反之亦然.

| `PropertiesEditor`
| 可以将字符串(使用 `java.util.Properties` 类的 javadoc 中定义的格式进行格式化) 转换为 `Properties` 对象.  默认情况下,由 `BeanWrapperImpl` 注册.

| `StringTrimmerEditor`
| 修剪字符串的属性编辑器.  (可选) 允许将空字符串转换为 `null`.  默认情况下未注册 - 必须是用户注册的.

| `URLEditor`
| 可以将URL的字符串表示形式解析为实际的 `URL` 对象.  默认情况下,由 `BeanWrapperImpl` 注册.
|===

Spring 使用 `java.beans.PropertyEditorManager` 设置属性编辑器(可能需要) 的搜索路径. 搜索路径还包括 `sun.bean.editors`,其中包括 `Font`, `Color` 和大多数基本类型等类型的 `PropertyEditor` 实现.
注意,标准的 JavaBeans 架构可以自动发现 `PropertyEditor` 类(无需显式注册) ,前提是此类与需处理的类位于同一个包,并且与该类具有相同的名称. 并以 `Editor` 单词结尾.  可以使用以下类和包结构,这足以使 `SomethingEditor` 类被识别并用作 `Something`  类型属性的 `PropertyEditor`.

[literal,subs="verbatim,quotes"]
----
com
  chank
    pop
      Something
      SomethingEditor // the PropertyEditor for the Something class
----
请注意,您也可以在此处使用标准 `BeanInfo` JavaBeans机制(https://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html[这里描述的是无关紧要的细节]) .  以下示例使用 `BeanInfo` 机制使用关联类的属性显式注册一个或多个 `PropertyEditor` 实例:

[literal,subs="verbatim,quotes"]
----
com
  chank
    pop
      Something
      SomethingBeanInfo // the BeanInfo for the Something class
----

以下引用的 `SomethingBeanInfo` 类的 Java 源代码将 `CustomNumberEditor` 与 `Something` 类的 `age` 属性相关联:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SomethingBeanInfo extends SimpleBeanInfo {

		public PropertyDescriptor[] getPropertyDescriptors() {
			try {
				final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true);
				PropertyDescriptor ageDescriptor = new PropertyDescriptor("age", Something.class) {
                    @Override
					public PropertyEditor createPropertyEditor(Object bean) {
						return numberPE;
					}
				};
				return new PropertyDescriptor[] { ageDescriptor };
			}
			catch (IntrospectionException ex) {
				throw new Error(ex.toString());
			}
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SomethingBeanInfo : SimpleBeanInfo() {

		override fun getPropertyDescriptors(): Array<PropertyDescriptor> {
			try {
				val numberPE = CustomNumberEditor(Int::class.java, true)
				val ageDescriptor = object : PropertyDescriptor("age", Something::class.java) {
					override fun createPropertyEditor(bean: Any): PropertyEditor {
						return numberPE
					}
				}
				return arrayOf(ageDescriptor)
			} catch (ex: IntrospectionException) {
				throw Error(ex.toString())
			}

		}
	}
----


[[beans-beans-conversion-customeditor-registration]]
==== 注册额外的自定义 `PropertyEditor`

将 bean 属性设置为字符串值时,Spring IoC 容器最终使用标准 JavaBeans `PropertyEditor` 实现将这些字符串转换为属性的复杂类型.  Spring 预先注册了许多自定义 `PropertyEditor` 实现(例如,将表示为字符串的类名转换为 `Class` 对象) .
此外,Java 的标准 JavaBeans `PropertyEditor` 查找机制允许对类的 `PropertyEditor` 进行适当的命名,并将其放置在与其提供支持的类相同的包中,以便可以自动找到它.

如果需要注册其他自定义 `PropertyEditors`,可以使用多种机制. 通常最麻烦也不推荐的策略是手动、简单的使用 `ConfigurableBeanFactory` 接口的 `registerCustomEditor()` 方法,
假设有一个 `BeanFactory` 引用,另一种(稍微更方便) 机制是使用一个名为 `CustomEditorConfigurer` 的特殊 bean 工厂后置处理器. 尽管您可以将 bean 工厂后置处理器与 `BeanFactory` 实现一起使用,但  `CustomEditorConfigurer` 具有嵌套属性设置,
因此我们强烈建议您将它与 `ApplicationContext` 一起使用,您可以在其中以类似的方式将其部署到任何其他 bean 以及它可以在哪里 自动检测并应用.

请注意,所有的 bean 工厂和应用程序上下文都自动使用了许多内置属性编辑器,在其内部都是使用 `BeanWrapper` 来进行属性转换的.  `BeanWrapper` 注册的标准属性编辑器列在<<beans-beans-conversion, 上一节>>中 此外,`ApplicationContexts` 还会覆盖或添加其他编辑器,以适合特定应用程序上下文类型的方式处理资源查找.

标准的 `PropertyEditor` JavaBeans 实例用于将以字符串表示的属性值转换为属性的实际复杂类型.  `CustomEditorConfigurer` 是一个 bean 后置处理工厂,可用于方便地在 `ApplicationContext` 中添加额外的 `PropertyEditor` 实例.

请考虑以下示例,该示例定义名为 `ExoticType` 的用户类和另一个名为 `DependsOnExoticType` 的类,该类需要将 `ExoticType` 设置为属性:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package example;

	public class ExoticType {

		private String name;

		public ExoticType(String name) {
			this.name = name;
		}
	}

	public class DependsOnExoticType {

		private ExoticType type;

		public void setType(ExoticType type) {
			this.type = type;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package example

	class ExoticType(val name: String)

	class DependsOnExoticType {

		var type: ExoticType? = null
	}
----

当创建好后,希望将 `type` 属性指定为一个字符串,`PropertyEditor` 会在幕后将其转换成实际的 `ExoticType` 实例. 以下 bean 定义显示了如何设置此关系:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="sample" class="example.DependsOnExoticType">
		<property name="type" value="aNameForExoticType"/>
	</bean>
----

`PropertyEditor` 实现如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// converts string representation to ExoticType object
	package example;

	public class ExoticTypeEditor extends PropertyEditorSupport {

		public void setAsText(String text) {
			setValue(new ExoticType(text.toUpperCase()));
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// converts string representation to ExoticType object
	package example

	import java.beans.PropertyEditorSupport

	class ExoticTypeEditor : PropertyEditorSupport() {

		override fun setAsText(text: String) {
			value = ExoticType(text.toUpperCase())
		}
	}
----

最后,以下示例显示如何使用 `CustomEditorConfigurer` 向 `ApplicationContext` 注册新的 `PropertyEditor`,然后可以根据需要使用它:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
		<property name="customEditors">
			<map>
				<entry key="example.ExoticType" value="example.ExoticTypeEditor"/>
			</map>
		</property>
	</bean>
----

[[beans-beans-conversion-customeditor-registration-per]]
===== 使用  `PropertyEditorRegistrar`

使用 Spring 容器注册属性编辑器的另一个策略是创建和使用 `PropertyEditorRegistrar`. 当需要在多种不同的情况下使用相同的属性编辑器集时,这个接口特别有用,编写相应的注册器并在每个案例中重用.
`PropertyEditorRegistrar` 与另外一个称为 `PropertyEditorRegistry` 的接口一起工作. 它使用 Spring `BeanWrapper`(`和DataBinder`)实现. `PropertyEditorRegistrar` 在与 `CustomEditorConfigurer` (<<beans-beans-conversion-customeditor-registration, 本节介绍的>>)一起使用时特别方便,
它暴露 `setPropertyEditorRegistrars(..)` 的属性. `PropertyEditorRegistrar` 和 `CustomEditorConfigurer` 结合使用可以简单的在 `DataBinder` 和 Spring MVC 控制之间共享.  它避免了在自定义编辑器上进行同步的需要: `PropertyEditorRegistrar需要为每个bean创建尝试创建新的` `PropertyEditor` 实例.

以下示例显示如何创建自己的 `PropertyEditorRegistrar` 实现:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package com.foo.editors.spring;

	public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {

		public void registerCustomEditors(PropertyEditorRegistry registry) {

			// it is expected that new PropertyEditor instances are created
			registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());

			// you could register as many custom property editors as are required here...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package com.foo.editors.spring

	import org.springframework.beans.PropertyEditorRegistrar
	import org.springframework.beans.PropertyEditorRegistry

	class CustomPropertyEditorRegistrar : PropertyEditorRegistrar {

		override fun registerCustomEditors(registry: PropertyEditorRegistry) {

			// it is expected that new PropertyEditor instances are created
			registry.registerCustomEditor(ExoticType::class.java, ExoticTypeEditor())

			// you could register as many custom property editors as are required here...
		}
	}
----

有关 `PropertyEditorRegistrar` 实现的示例,另请参见 `org.springframework.beans.support.ResourceEditorRegistrar`.  请注意,在实现 `registerCustomEditors(..)` 方法时,它会创建每个属性编辑器的新实例.

下一个示例显示如何配置 `CustomEditorConfigurer` 并将 `CustomPropertyEditorRegistrar` 的实例注入其中:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
		<property name="propertyEditorRegistrars">
			<list>
				<ref bean="customPropertyEditorRegistrar"/>
			</list>
		</property>
	</bean>

	<bean id="customPropertyEditorRegistrar"
		class="com.foo.editors.spring.CustomPropertyEditorRegistrar"/>
----

最后(与本章的重点有所不同,对于那些使用<<web.adoc#mvc, Spring's MVC web framework>>框架的人来说) ,使用 `PropertyEditorRegistrars` 和数据绑定控制器(`SimpleFormController`) 可以非常方便.  以下示例在 `@InitBinder` 方法的实现中使用 `PropertyEditorRegistrar`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class RegisterUserController {

		private final PropertyEditorRegistrar customPropertyEditorRegistrar;

		RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {
			this.customPropertyEditorRegistrar = propertyEditorRegistrar;
		}

		@InitBinder
		void initBinder(WebDataBinder binder) {
			this.customPropertyEditorRegistrar.registerCustomEditors(binder);
		}

		// other methods related to registering a User
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class RegisterUserController(
		private val customPropertyEditorRegistrar: PropertyEditorRegistrar) {

		@InitBinder
		fun initBinder(binder: WebDataBinder) {
			this.customPropertyEditorRegistrar.registerCustomEditors(binder)
		}

		// other methods related to registering a User
	}
----

这种类型的 `PropertyEditor` 注册方式可以让代码更加简洁(`@InitBinder` 的实现只有一行) ,并允许将通用 `PropertyEditor` 注册代码封装在一个类中,然后根据需要在尽可能多的 `Controllers` 之间共享.


[[core-convert]]
== Spring 类型转换

Spring 3 引入了一个 `core.convert` 包,它提供了一个通用的类型转换系统. 系统定义了一个用于实现类型转换逻辑的 SPI 和一个用于在运行时执行类型转换的 API.
在 Spring 的容器中,此系统可以用作 `PropertyEditor` 的替代方法,它将外部 bean 属性值字符串转换为所需的属性类型. 您还可以在需要进行类型转换的应用程序中的任何位置使用公共 API.

[[core-convert-Converter-API]]
=== SPI 转换器

实现类型转换逻辑的 SPI 是简易的,而且是强类型的. 如以下接口定义所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	package org.springframework.core.convert.converter;

	public interface Converter<S, T> {

		T convert(S source);
	}
----

创建自定义转换器都需要实现 `Converter` 接口,参数 `S` 是需要转换的类型,`T` 是转换后的类型. 这个转换器也可以应用在集合或数组上将 `S` 参数转换为 `T` 参数. 前提是已经注册了委托数组或集合转换器(`DefaultConversionService` 默认情况下也是如此) .

对于要 `convert(S)` 的每个调用,`source` 参数需保证不为 `null`. 转换失败时,`Converter`  可能会引发任意的 unchecked 异常. 具体来说,它应抛出 `IllegalArgumentException` 以报告无效的 `source` 值.  请注意确保您的 `Converter` 实现是线程安全的.

为方便起见,`core.convert.support` 包中提供了几个转换器实现.  这些包括从字符串到数字和其他常见类型的转换器.  以下清单显示了 `StringToInteger` 类,它是典型的 `Converter` 实现:

[source,java,indent=0,subs="verbatim,quotes"]
----
	package org.springframework.core.convert.support;

	final class StringToInteger implements Converter<String, Integer> {

		public Integer convert(String source) {
			return Integer.valueOf(source);
		}
	}
----

[[core-convert-ConverterFactory-SPI]]
=== 使用 `ConverterFactory`

当需要集中整个类层次结构的转换逻辑时(例如,从 `String` 转换为 `Enum` 对象时) ,您可以实现 `ConverterFactory`,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	package org.springframework.core.convert.converter;

	public interface ConverterFactory<S, R> {

		<T extends R> Converter<S, T> getConverter(Class<T> targetType);
	}
----

参数化 `S` 为您要转换的类型,`R` 是需要转换后的类型的基类.  然后实现 `getConverter(Class)`,其中 `T` 是 `R` 的子类.

以 `StringToEnumConverterFactory` 为例:

[source,java,indent=0,subs="verbatim,quotes"]
----
	package org.springframework.core.convert.support;

	final class StringToEnumConverterFactory implements ConverterFactory<String, Enum> {

		public <T extends Enum> Converter<String, T> getConverter(Class<T> targetType) {
			return new StringToEnumConverter(targetType);
		}

		private final class StringToEnumConverter<T extends Enum> implements Converter<String, T> {

			private Class<T> enumType;

			public StringToEnumConverter(Class<T> enumType) {
				this.enumType = enumType;
			}

			public T convert(String source) {
				return (T) Enum.valueOf(this.enumType, source.trim());
			}
		}
	}
----


[[core-convert-GenericConverter-SPI]]
=== 使用  `GenericConverter`

当您需要复杂的 `Converter` 实现时,请考虑使用 `GenericConverter` 接口. `GenericConverter` 具有比 `Converter` 更灵活但不太强类型的签名,支持在多种源和目标类型之间进行转换.
此外,`GenericConverter` 可以在实现转换逻辑时使用可用的源和目标字段上下文.  此上下文类允许通过字段注解或在字段签名上声明的一般信息来驱动类型转换.  以下清单显示了 `GenericConverter` 的接口定义:

[source,java,indent=0,subs="verbatim,quotes"]
----
	package org.springframework.core.convert.converter;

	public interface GenericConverter {

		public Set<ConvertiblePair> getConvertibleTypes();

		Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
	}
----

要实现 `GenericConverter`,请使用 `getConvertibleTypes()` 返回支持的 source→target 类型对,然后实现 `convert(Object, TypeDescriptor, TypeDescriptor)` 方法并编写转换逻辑. 源 `TypeDescriptor` 提供对保存要转换的值的源字段的访问,目标 `TypeDescriptor` 提供对要设置转换值的目标字段的访问.

Java 数组和集合之间转换的转换器是 `GenericConverter` 应用的例子. 其中 `ArrayToCollectionConverter` 内部声明目标集合类型用于解析集合元素类型的字段.  它允许在目标字段上设置集合之前,将源数组中的每个元素转换为集合元素类型.

NOTE: 因为 `GenericConverter` 是一个更复杂的SPI接口,所以只有在需要时才应该使用它.  一般使用 `Converter` 或 `ConverterFactory` 足以满足基本的类型转换需求.


[[core-convert-ConditionalGenericConverter-SPI]]
==== 使用 `ConditionalGenericConverter`

有时可能只想在特定条件为真时才执行 `Converter`,例如,在特定注解的目标上使用 `Converter`,或者,在一个特定的目标类方法(例如 `static valueOf` 方法) 中执行 `Converter`.  `ConditionalGenericConverter` 是 `GenericConverter` 和 `ConditionalConverter` 接口的组合. 允许自定义匹配条件

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface ConditionalConverter {

		boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);
	}

	public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {
	}
----

用于持久实体标识符和实体引用之间转换的 `IdToEntityConverter` 是 `ConditionalGenericConverter` 应用的例子.
如果目标实体类型声明静态查找器方法(如 `findAccount(Long)`), 那么 `IdToEntityConverter` 只对匹配的生效. 开发者可以实现 `matches(TypeDescriptor, TypeDescriptor)` 以执行 `finder` 方法来检查是否匹配.

[[core-convert-ConversionService-API]]
=== `ConversionService` API

`ConversionService` 定义了一个统一的 API,用于在运行时执行类型转换逻辑.  转换器通常在以下 Facade 接口后面执行:

[source,java,indent=0,subs="verbatim,quotes"]
----
	package org.springframework.core.convert;

	public interface ConversionService {

		boolean canConvert(Class<?> sourceType, Class<?> targetType);

		<T> T convert(Object source, Class<T> targetType);

		boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

		Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
	}
----

大多数 `ConversionService` 实现还实现了 `ConverterRegistry`,它提供了一个用于注册转换器的SPI.  在内部,`ConversionService` 实现委托其注册的转换器执行类型转换逻辑.

`core.convert.support` 包中提供了强大的 `ConversionService` 实现.  `GenericConversionService` 是适用于大多数环境的通用实现.  `ConversionServiceFactory` 提供了一个方便的工厂,用于创建常见的 `ConversionService` 配置.


[[core-convert-Spring-config]]
=== 配置 `ConversionService`

`ConversionService` 是一个无状态对象,在应用程序启动时就会实例化,可以被多个线程共享.
在 Spring 应用程序中,通常每个 Spring 容器(或 `ApplicationContext` ) 配置一个 `ConversionService` 实例. 该 `ConversionService` 将被 Spring 获取,然后在框架需要执行类型转换时使用. 也可以将 `ConversionService` 插入任意 bean 并直接调用它.

NOTE: 如果没有向 Spring 注册 `ConversionService`,则使用基于 `PropertyEditor` 的原始系统.

要使用 Spring 注册默认的 `ConversionService`,请添加以下 bean 定义,其 `id` 为 `conversionService`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="conversionService"
		class="org.springframework.context.support.ConversionServiceFactoryBean"/>
----

默认的 `ConversionService` 可以在字符串,数字,枚举,集合,映射和其他常见类型之间进行转换.  要使用您自己的自定义转换器补充或覆盖默认转换器,请设置 `converters` 属性.  属性值可以任何实现了 `Converter`, `ConverterFactory`, 或 `GenericConverter` 接口的类.

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="conversionService"
			class="org.springframework.context.support.ConversionServiceFactoryBean">
		<property name="converters">
			<set>
				<bean class="example.MyCustomConverter"/>
			</set>
		</property>
	</bean>
----

在 Spring MVC 应用程序中使用 `ConversionService` 也很常见.  请参阅Spring MVC章节中的<<web.adoc#mvc-config-conversion, 转换和格式化>> .

在某些情况下,您可能希望在转换期间应用格式.  有关使用 `FormattingConversionServiceFactoryBean` 的详细信息,请参阅 <<format-FormatterRegistry-SPI>>.

[[core-convert-programmatic-usage]]
=== 使用 `ConversionService` 编程

要以编程方式使用 `ConversionService` 实例,您可以像对任何其他 bean 一样注入对它的引用.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Service
	public class MyService {

		public MyService(ConversionService conversionService) {
			this.conversionService = conversionService;
		}

		public void doIt() {
			this.conversionService.convert(...)
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Service
	class MyService(private val conversionService: ConversionService) {
		
		fun doIt() {
			conversionService.convert(...)
		}
	}
----

对于大多数用例,您可以使用指定 `targetType` 的 `convert` 方法,但它不适用于更复杂的类型,例如参数化元素的集合.  例如,如果想使用编程的方式将整数列表转换为字符串列表,则需要提供源和目标类型的正规定义.

幸运的是,`TypeDescriptor` 提供了各种选项,使得这样做非常简单,如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	DefaultConversionService cs = new DefaultConversionService();

	List<Integer> input = ...
	cs.convert(input,
		TypeDescriptor.forObject(input), // List<Integer> type descriptor
		TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val cs = DefaultConversionService()

	val input: List<Integer> = ...
	cs.convert(input,
			TypeDescriptor.forObject(input), // List<Integer> type descriptor
			TypeDescriptor.collection(List::class.java, TypeDescriptor.valueOf(String::class.java)))
----

请注意, `DefaultConversionService` 会自动注册适合大多数环境的转换器.  这包括集合转换器,基本类型转换器和基本的对象到字符串转换器.  您可以使用 `DefaultConversionService` 类上的静态 `addDefaultConverters` 方法向任何 `ConverterRegistry` 注册相同的转换器.

值类型的转换器可以重用于数组和集合,因此无需创建特定的转换器即可将 `S` 的 `Collection` 转换为 `T` 的 `Collection`,前提是标准集合处理是合适的.

[[format]]
== Spring 字段格式化

如前一节所述, <<core-convert, `core.convert`>> 是一种通用类型转换系统.  它提供统一的 `ConversionService` API 以及强类型转换器 SPI,用于实现从一种类型到另一种类型的转换逻辑.
Spring 容器使用此系统绑定 bean 属性值.  此外,Spring Expression Language(SpEL) 和 `DataBinder` 都使用此系统绑定字段值. 此外,当 SpEL 需要将 Short 类型强转为 Long 类型, 用于试图完成 `expression.setValue(Object bean, Object value)` 时,那么 `core.convert` 系统也可以提供这种功能.

现在考虑典型客户端环境(例如 Web 或桌面应用程序) 的类型转换要求. 在这种环境中,在这种环境中,还包括转换成为 `String` 用于支持视图呈现程序. 此外,还通常需要本地化字符串值.
普通的转化器 SPI 没有提供按照直接进行格式转换的功能. 更通用的 `core.convert` `Converter` SPI不能解决此类要求. 为了实现这个功能,Spring 3 添加了方便的 `Formatter` SPI,它提供了简单强健的的 `PropertyEditor` 专供客户端环境.

通常, 当需要使用通用类型转换时可以用 `Converter` SPI. 例如,在 `java.util.Date` 和 `java.lang.Long` 之间进行转换.  在客户端环境(例如Web应用程序) 中工作时,可以使用 `Formatter` SPI, 并且需要解析和打印本地化的字段值. `ConversionService` 为两个 SPI 提供统一的类型转换 API.

[[format-Formatter-SPI]]
===  `Formatter` SPI

`Formatter` SPI 实现字段格式化逻辑是简单的,强类型的.  以下清单显示了 `Formatter` 接口定义:

[source,java,indent=0,subs="verbatim,quotes"]
----
	package org.springframework.format;

	public interface Formatter<T> extends Printer<T>, Parser<T> {
	}
----

`Formatter` 继承了内置的 `Printer` 和 `Parser` 接口. 以下清单显示了这两个接口的定义:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface Printer<T> {

		String print(T fieldValue, Locale locale);
	}
----

[source,java,indent=0,subs="verbatim,quotes"]
----
	import java.text.ParseException;

	public interface Parser<T> {

		T parse(String clientValue, Locale locale) throws ParseException;
	}
----

如果需要创建自定义的 `Formatter`,需要实现 `Formatter` 接口. 参数 `T` 类型是你需要格式化的类型.  例如,`java.util.Date`. 实现 `print()` 操作在客户端本地设置中打印显示的 `T` 实例.
实现 `parse()` 操作以从客户端本地设置返回的格式化表示形式分析T的实例. 如果尝试分析失败,`Formatter` 会抛出 `ParseException` 或 `IllegalArgumentException` 异常. 注意确保自定义的 `Formatter` 是线程安全的.

`format` 子包提供了多种 `Formatter` 实现方便使用.  `number` 子包中提供了 `NumberStyleFormatter`, `CurrencyStyleFormatter`, 和 `PercentStyleFormatter` 用于格式化 `java.lang.Number`(使用 `java.text.NumberFormat`) .
`datetime` 子包中提供了 `DateFormatter` 用于格式化 `java.util.Date`(使用 `java.text.DateFormat`) .

以下 `DateFormatter` 是 `Formatter` 实现的示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package org.springframework.format.datetime;

	public final class DateFormatter implements Formatter<Date> {

		private String pattern;

		public DateFormatter(String pattern) {
			this.pattern = pattern;
		}

		public String print(Date date, Locale locale) {
			if (date == null) {
				return "";
			}
			return getDateFormat(locale).format(date);
		}

		public Date parse(String formatted, Locale locale) throws ParseException {
			if (formatted.length() == 0) {
				return null;
			}
			return getDateFormat(locale).parse(formatted);
		}

		protected DateFormat getDateFormat(Locale locale) {
			DateFormat dateFormat = new SimpleDateFormat(this.pattern, locale);
			dateFormat.setLenient(false);
			return dateFormat;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class DateFormatter(private val pattern: String) : Formatter<Date> {

		override fun print(date: Date, locale: Locale)
				= getDateFormat(locale).format(date)

		@Throws(ParseException::class)
		override fun parse(formatted: String, locale: Locale)
				= getDateFormat(locale).parse(formatted)

		protected fun getDateFormat(locale: Locale): DateFormat {
			val dateFormat = SimpleDateFormat(this.pattern, locale)
			dateFormat.isLenient = false
			return dateFormat
		}
	}
----

更多内容上 Spring 社区查看 `Formatter` 的版本信息,请参阅 https://github.com/spring-projects/spring-framework/issues[GitHub Issues] 进行贡献.


[[format-CustomFormatAnnotations]]
=== 基于注解的格式化

字段格式也可以通过字段类型或注解进行配置. 如果要将注解绑定到 `Formatter`,请实现 `AnnotationFormatterFactory`. 以下清单显示了 `AnnotationFormatterFactory` 接口的定义:

[source,java,indent=0,subs="verbatim,quotes"]
----
	package org.springframework.format;

	public interface AnnotationFormatterFactory<A extends Annotation> {

		Set<Class<?>> getFieldTypes();

		Printer<?> getPrinter(A annotation, Class<?> fieldType);

		Parser<?> getParser(A annotation, Class<?> fieldType);
	}
----

创建一个实现:
. 参数 `A` 是要与之关联的字段 `annotationType` 逻辑格式(例如: `org.springframework.format.annotation.DateTimeFormat`)
. Have `getFieldTypes()` 返回可以在其上使用注解的字段的类型.
. Have `getPrinter()` 返回 `Printer` 以打印带注解的字段的值.
. Have `getParser()` 返回 `Parser` 解析注解字段的 `clientValue`

参数化 A 是将格式逻辑与(例如 `org.springframework.format.annotation.DateTimeFormat` 关联到字段 `annotationType`.  `getFieldTypes()` 返回注解可用的字段类型.  使 `getPrinter()` 返回 `Printer` 以打印注解字段值. `getParser()` 返回一个 Parser 以分析注解字段的 `clientValue`.

下面的示例 `AnnotationFormatterFactory` 实现,将 `@NumberFormat` 注解绑定到格式化程序. 此注解允许指定数字样式或模式

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public final class NumberFormatAnnotationFormatterFactory
			implements AnnotationFormatterFactory<NumberFormat> {

		public Set<Class<?>> getFieldTypes() {
			return new HashSet<Class<?>>(asList(new Class<?>[] {
				Short.class, Integer.class, Long.class, Float.class,
				Double.class, BigDecimal.class, BigInteger.class }));
		}

		public Printer<Number> getPrinter(NumberFormat annotation, Class<?> fieldType) {
			return configureFormatterFrom(annotation, fieldType);
		}

		public Parser<Number> getParser(NumberFormat annotation, Class<?> fieldType) {
			return configureFormatterFrom(annotation, fieldType);
		}

		private Formatter<Number> configureFormatterFrom(NumberFormat annotation, Class<?> fieldType) {
			if (!annotation.pattern().isEmpty()) {
				return new NumberStyleFormatter(annotation.pattern());
			} else {
				Style style = annotation.style();
				if (style == Style.PERCENT) {
					return new PercentStyleFormatter();
				} else if (style == Style.CURRENCY) {
					return new CurrencyStyleFormatter();
				} else {
					return new NumberStyleFormatter();
				}
			}
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class NumberFormatAnnotationFormatterFactory : AnnotationFormatterFactory<NumberFormat> {

		override fun getFieldTypes(): Set<Class<*>> {
			return setOf(Short::class.java, Int::class.java, Long::class.java, Float::class.java, Double::class.java, BigDecimal::class.java, BigInteger::class.java)
		}

		override fun getPrinter(annotation: NumberFormat, fieldType: Class<*>): Printer<Number> {
			return configureFormatterFrom(annotation, fieldType)
		}

		override fun getParser(annotation: NumberFormat, fieldType: Class<*>): Parser<Number> {
			return configureFormatterFrom(annotation, fieldType)
		}

		private fun configureFormatterFrom(annotation: NumberFormat, fieldType: Class<*>): Formatter<Number> {
			return if (annotation.pattern.isNotEmpty()) {
				NumberStyleFormatter(annotation.pattern)
			} else {
				val style = annotation.style
				when {
					style === NumberFormat.Style.PERCENT -> PercentStyleFormatter()
					style === NumberFormat.Style.CURRENCY -> CurrencyStyleFormatter()
					else -> NumberStyleFormatter()
				}
			}
		}
	}
----

想要触发格式化,只需在在字段上添加 `@NumberFormat` 注解即可.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyModel {

		@NumberFormat(style=Style.CURRENCY)
		private BigDecimal decimal;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyModel(
		@field:NumberFormat(style = Style.CURRENCY) private val decimal: BigDecimal
	)
----


[[format-annotations-api]]
==== 格式注解 API

`org.springframework.format.annotation` 包中存在可移植格式注解 API.  您可以使用 `@NumberFormat` 格式化 `java.lang.Number` 字段,例如  `Double` and
`Long` . 使用 `@DateTimeFormat` 格式化 `java.util.Date`, `java.util.Calendar`,`java.util.Long` JSR-310 `java.time`  字段.

下面的示例使用 `@DateTimeFormat` 将 `java.util.Date` 化为 `ISO Date(yyyy-MM-dd)`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyModel {

		@DateTimeFormat(iso=ISO.DATE)
		private Date date;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyModel(
		@DateTimeFormat(iso= ISO.DATE) private val date: Date
	)
----


[[format-FormatterRegistry-SPI]]
=== `FormatterRegistry` SPI

`FormatterRegistry` 是一个用于注册格式化程序和转换器的 SPI.  `FormattingConversionService` 适用于大多数环境的 `FormatterRegistry` 实现. 此实现可以通过编程或以声明的方式配置为可用 `FormattingConversionServiceFactoryBean` 的 Spring bean.
由于它也实现了 `ConversionService`,因此可以直接配置用于 Spring 的 `DataBinder` 和 Spring 的表达式语言(SpEL) .

以下清单显示了 `FormatterRegistry`:

[source,java,indent=0,subs="verbatim,quotes"]
----
	package org.springframework.format;

	public interface FormatterRegistry extends ConverterRegistry {

		void addPrinter(Printer<?> printer);

		void addParser(Parser<?> parser);

		void addFormatter(Formatter<?> formatter);

		void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter);

		void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser);

		void addFormatterForFieldAnnotation(AnnotationFormatterFactory<? extends Annotation> annotationFormatterFactory);
	}
----

如上所示, `Formatters` 通过 `fieldType` 或注解进行注册.

`FormatterRegistry` SPI 可以集中配置格式规则,避免跨控制器的重复配置. 例如,想要强制所有日期字段都以特定方式格式化,或者具有特定注解的字段以某种方式格式化.  使用共享的 `FormatterRegistry`,开发者只需一次定义这些规则,即可到处使用.

[[format-FormatterRegistrar-SPI]]
=== `FormatterRegistrar` SPI

`FormatterRegistrar` 是用于注册格式化器和通过 FormatterRegistry 转换的 SPI:

[source,java,indent=0,subs="verbatim,quotes"]
----
	package org.springframework.format;

	public interface FormatterRegistrar {

		void registerFormatters(FormatterRegistry registry);
	}
----

`FormatterRegistrar` 用于注册多个相关的转换器或格式化器(根据给定的格式化目录注册,例如 Date 格式化) . 在直接注册不能实现时 `FormatterRegistrar` 就派上用场了,
例如,当格式化程序需要在不同于其自身 `<T>` 的特定字段类型下进行索引时,或者在注册 `Printer/Parser` 对时. 下一节提供了有关转换器和格式化器注册的更多信息.

[[format-configuring-formatting-mvc]]
=== 在Spring MVC中配置格式化

请参阅 Spring MVC 章节中的<<web.adoc#mvc-config-conversion, 转换和格式化>>.

[[format-configuring-formatting-globaldatetimeformat]]
== 配置全局日期和时间格式

默认情况下,不带 `@DateTimeFormat` 注解的日期和时间字段使用 `DateFormat.SHORT`(短日期) 的格式转换字符串. 开发者也可以使用自定义的全局格式覆盖默认格式.

此时需要确保 Spring 不注册默认格式化器,而应该手动注册所有格式化器,可以借助以下方法手动注册格式器:

* `org.springframework.format.datetime.standard.DateTimeFormatterRegistrar`
* `org.springframework.format.datetime.DateFormatterRegistrar`.

例如,以下 Java 配置注册全局 `yyyyMMdd` 格式(此示例不依赖于 Joda-Time 库) :

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		public FormattingConversionService conversionService() {

			// Use the DefaultFormattingConversionService but do not register defaults
			DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false);

			// Ensure @NumberFormat is still supported
			conversionService.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory());

			// Register date conversion with a specific global format
			DateFormatterRegistrar registrar = new DateFormatterRegistrar();
			registrar.setFormatter(new DateFormatter("yyyyMMdd"));
			registrar.registerFormatters(conversionService);

			return conversionService;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun conversionService(): FormattingConversionService {
			// Use the DefaultFormattingConversionService but do not register defaults
			return DefaultFormattingConversionService(false).apply {
				// Ensure @NumberFormat is still supported
				addFormatterForFieldAnnotation(NumberFormatAnnotationFormatterFactory())
				// Register date conversion with a specific global format
				val registrar = DateFormatterRegistrar()
				registrar.setFormatter(DateFormatter("yyyyMMdd"))
				registrar.registerFormatters(this)
			}
		}
	}
----

如果您更喜欢基于 XML 的配置,则可以使用 `FormattingConversionServiceFactoryBean`.  以下示例显示了如何执行此操作:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
			<property name="registerDefaultFormatters" value="false" />
			<property name="formatters">
				<set>
					<bean class="org.springframework.format.number.NumberFormatAnnotationFormatterFactory" />
				</set>
			</property>
			<property name="formatterRegistrars">
				<set>
					<bean class="org.springframework.format.datetime.standard.DateTimeFormatterRegistrar">
						<property name="dateFormatter">
							<bean class="org.springframework.format.datetime.standard.DateTimeFormatterFactoryBean">
								<property name="pattern" value="yyyyMMdd"/>
							</bean>
						</property>
					</bean>
				</set>
			</property>
		</bean>
	</beans>
----

请注意,在 Web 中配置日期和时间格式时需要考虑其他一些注意事项
应用程序.  请参阅 <<web.adoc#mvc-config-conversion, WebMVC 格式转换>> 或 <<web-reactive.adoc#webflux-config-conversion, WebFlux 格式转换>>

[[validation-beanvalidation]]
== Java Bean 验证

Spring 框架提供了 https://beanvalidation.org/[Java Bean验证] API.

[[validation-beanvalidation-overview]]
=== Bean验证概述

Bean 验证为 Java 应用程序提供了通过约束声明和元数据进行验证的通用方法.  要使用它,您需要使用声明性验证约束对 domain 模型属性进行注解,然后由运行时强制实施.  有内置的约束,您也可以定义自己的自定义约束.

请考虑以下示例,该示例显示了具有两个属性的简单 `PersonForm` 模型:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class PersonForm {
		private String name;
		private int age;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class PersonForm(
			private val name: String,
			private val age: Int
	)
----

Bean 允许您为这些属性定义声明性验证约束,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class PersonForm {

		@NotNull
		@Size(max=64)
		private String name;

		@Min(0)
		private int age;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class PersonForm(
		@get:NotNull @get:Size(max=64)
		private val name: String,
		@get:Min(0)
		private val age: Int
	)
----

然后,Bean 验证验证器根据声明的约束来验证此类的实例.

有关 API 的常规信息,请参阅 https://beanvalidation.org/[Bean Validation]  网站. 有关默认引用实现的特定功能的信息,请参阅 https://www.hibernate.org/412.html[Hibernate Validator]  文档. 要了解如何将 bean 验证提供程序设置为 Spring bean,请继续阅读以下内容.



[[validation-beanvalidation-spring]]
=== 配置 bean Validation 提供者

Spring 提供了对 Bean 验证 API 的全面支持,包括将 Bean 验证提供程序作为 Spring Bean 进行引导.  这样,您就可以在应用程序需要验证的任何地方注入 `jakarta.validation.ValidatorFactory` 或 `jakarta.validation.Validator`.

您可以使用 `LocalValidatorFactoryBean` 将默认 `Validator` 配置为 Spring bean,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;

	@Configuration

	public class AppConfig {

		@Bean
		public LocalValidatorFactoryBean validator() {
			return new LocalValidatorFactoryBean();
		}
	}
----
[source,xml,indent=0,subs="verbatim,quotes",role="secondary"]
.XML
----
	<bean id="validator"
		class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"/>
----


上面的基本配置将触发 Bean 验证以使用其默认的引导机制进行初始化,Bean Validation 提供程序(例如 Hibernate Validator) 应该存在于类路径中并自动检测.


[[validation-beanvalidation-spring-inject]]
==== 注入Validator

`LocalValidatorFactoryBean` 实现了 `jakarta.validation.ValidatorFactory` 和 `jakarta.validation.Validator`, 以及 Spring 的 `org.springframework.validation.Validator`. 您可以将这些接口中的任何一个引用注入到需要调用验证逻辑的 bean 中.

如果您希望直接使用 Bean Validation API,则可以注入对 `jakarta.validation.Validator` 的引用,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import jakarta.validation.Validator;

	@Service
	public class MyService {

		@Autowired
		private Validator validator;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import jakarta.validation.Validator;

	@Service
	class MyService(@Autowired private val validator: Validator)
----

如果您的 bean 需要 Spring Validation API,则可以注入对 `org.springframework.validation.Validator` 的引用,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.springframework.validation.Validator;

	@Service
	public class MyService {

		@Autowired
		private Validator validator;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.validation.Validator

	@Service
	class MyService(@Autowired private val validator: Validator)
----


[[validation-beanvalidation-spring-constraints]]
==== 配置自定义约束

每个 bean 验证约束由两部分组成:

*  首先是声明约束及其可配置属性的 `@Constraint` 注解
*  实现约束行为的 `jakarta.validation.ConstraintValidator` 接口实现.

如果要将声明与实现关联,每个 `@Constraint` 注解都会引用相应的 `ConstraintValidator` 实现类. 在运行中,当在 domain 模型中遇到约束注解时,`ConstraintValidatorFactory` 会将引用的实现实例化.

默认情况下,`LocalValidatorFactoryBean` 会配置 `SpringConstraintValidatorFactory`,它会使用 Spring 去创建 `ConstraintValidator` 实例. 这允许自定义 `ConstraintValidators`, 就像任何其他 Spring bean 一样,从依赖注入中获益.

下面是自定义 `@Constraint` 声明的例子,使用 Spring 的依赖注入来管理 `ConstraintValidator` 的实现:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target({ElementType.METHOD, ElementType.FIELD})
	@Retention(RetentionPolicy.RUNTIME)
	@Constraint(validatedBy=MyConstraintValidator.class)
	public @interface MyConstraint {
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.FUNCTION, AnnotationTarget.FIELD)
	@Retention(AnnotationRetention.RUNTIME)
	@Constraint(validatedBy = MyConstraintValidator::class)
	annotation class MyConstraint
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import jakarta.validation.ConstraintValidator;

	public class MyConstraintValidator implements ConstraintValidator {

		@Autowired;
		private Foo aDependency;

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import jakarta.validation.ConstraintValidator

	class MyConstraintValidator(private val aDependency: Foo) : ConstraintValidator {

		// ...
	}
----


如前面的示例所示,`ConstraintValidator` 实现可以将其依赖 `@Autowired` 与任何其他 Spring bean 一样.


[[validation-beanvalidation-spring-method]]
==== Spring驱动的方法验证

Bean Validation 1.1 支持的方法验证,Hibernate Validator 4.3 支持的自定义扩展都可以通过 `MethodValidationPostProcessor` 定义集成到 Spring 上下文中. 如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;

	@Configuration

	public class AppConfig {

		@Bean
		public MethodValidationPostProcessor validationPostProcessor() {
			return new MethodValidationPostProcessor();
		}
	}

----
[source,xml,indent=0,subs="verbatim,quotes",role="secondary"]
.XML
----
	<bean class="org.springframework.validation.beanvalidation.MethodValidationPostProcessor"/>
----

为了符合 Spring 驱动方法验证的条件,所有目标类都需要使用 Spring 的 `@Validated` 进行注解,还可以选择声明要使用的验证组.  使用 Hibernate Validator 和 Bean Validation 1.1 提供验证的步骤可以查看 {api-spring-framework}/validation/beanvalidation/MethodValidationPostProcessor.html[`MethodValidationPostProcessor`]的 javadocs

[TIP]
====
方法验证依赖于 <<core.adoc#aop-introduction-proxies,AOP Proxies>> 目标类，接口上的方法的 JDK 动态代理或 CGLIB 代理。
使用代理有一定的限制，其中一些在 <<core.adoc#aop-understanding-aop-proxies,了解 AOP 代理>>。 另外记得
始终在代理类上使用方法和访问器； 直接访问字段将不起作用。
====

[[validation-beanvalidation-spring-other]]
==== 额外的配置选项

对于大多数情况,默认的 `LocalValidatorFactoryBean` 配置就足够了. 从消息插入到遍历解析,各种 Bean Validation 构造有许多配置选项.  有关这些选项的更多信息,请参阅 {api-spring-framework}/validation/beanvalidation/LocalValidatorFactoryBean.html[`LocalValidatorFactoryBean`] javadoc.

[[validation-binder]]
=== 配置  `DataBinder`

从 Spring 3 开始,您可以使用 `Validator` 配置 `DataBinder` 实例.  配置完成后,您可以通过调用 `binder.validate()` 来调用 `Validator`.  任何验证 `Errors` 都会自动添加到 binder 的 `BindingResult` 中.

以下示例说明如何在绑定到目标对象后以编程方式使用 `DataBinder` 来调用验证逻辑:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Foo target = new Foo();
	DataBinder binder = new DataBinder(target);
	binder.setValidator(new FooValidator());

	// bind to the target object
	binder.bind(propertyValues);

	// validate the target object
	binder.validate();

	// get BindingResult that includes any validation errors
	BindingResult results = binder.getBindingResult();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val target = Foo()
	val binder = DataBinder(target)
	binder.validator = FooValidator()

	// bind to the target object
	binder.bind(propertyValues)

	// validate the target object
	binder.validate()

	// get BindingResult that includes any validation errors
	val results = binder.bindingResult
----

`DataBinder` 还可以通过 `dataBinder.addValidators` 和 `dataBinder.replaceValidators` 来配置多个 `Validator` 实例.  将全局配置的 Bean `Validation` 与本地在 `DataBinder` 实例上配置的Spring `Validator` 相结合,这非常有用.  请参阅 <<webmvc.adoc#mvc-config-validation>>.


[[validation-mvc]]
===  Spring MVC 3 验证

请在 Spring MVC 章节 查看 <<webmvc.adoc#mvc-config-validation, 验证>>.
