[[aop]]
= 使用 Spring 面向切面编程

面向切面编程(Aspect-oriented Programming 简称 AOP) ,是相对面向对象编程(Object-oriented Programming 简称 OOP )的框架,作为 OOP 的一种功能补充. OOP 主要的模块单元是类(class). 而 AOP 则是切面(aspect) . 切面会将诸如事务管理这样跨越多个类型和对象的关注点模块化(在 AOP 的语义中,这类关注点被称为横切关注点(crosscutting) ) .

AOP 是 Spring 框架重要的组件,虽然 Spring IoC 容器没有依赖 AOP,因此 Spring 不会强迫开发者使用 AOP. 但 AOP 提供了非常棒的功能,用做对 Spring IoC 的补充.

.Spring AOP 具有 AspectJ 切点aop-pointcuts-designators
****
Spring 引入了一种更简单、更强大的方式用来自定义切面,开发者可以选择使用基于模式 <<aop-schema, schema-based approach>> 的方式或使用<<aop-ataspectj, @AspectJ >>注解风格方式来定义.
这两种方式都完全支持通知(Advice) 类型和 AspectJ 的切点语义,虽然实际上仍然是使用 Spring AOP 织入(weaving) 的.

本章主要讨论 Spring 框架对基于模式和基于 `@AspectJ` 的 AOP 支持. <<aop-api, 下一章>>,将讨论底层的 AOP 支持.
****

AOP 在 Spring Framework 中用于:

* 提供声明式企业服务,特别是用于替代 EJB 的声明式服务. 最重要的服务是<<data-access.adoc#transaction-declarative, 声明式事务管理>>,这个服务建立在 Spring 的抽象事务管理之上.
* 允许开发者实现自定义切面,使用 AOP 来完善 OOP 的功能.

NOTE: 如果只打算使用通用的声明式服务或者已有的声明式中间件服务,例如缓冲池(pooling) 那么可以不直接使用 AOP,也可以忽略本章大部分内容.

[[aop-introduction-defn]]
== AOP 概念

让我们从定义一些核心 AOP 概念和术语开始.  这些术语不是特定于 Spring 的.  不幸的是,AOP 术语不是特别直观.  但是,如果 Spring 使用自己的术语,那将更加令人困惑.

* Aspect(切面): 指关注点模块化,这个关注点可能会横切多个对象. 事务管理是企业级 Java 应用中有关横切关注点的例子.  在 Spring AOP 中,切面可以使用通用类 <<aop-schema, 基于 schema 的方式>>的方式或者在普通类中以<<aop-ataspectj, `@AspectJ`>>注解来实现.
* Join point(连接点):在程序执行过程中某个特定的点,例如某个方法调用的时间点或者处理异常的时间点. 在 Spring AOP 中,一个连接点总是代表一个方法的执行.
* Advice(通知): 在切面的某个特定的连接点上执行的动作. 通知有多种类型,包括 "`around`", "`before`" 和 "`after`" 等等. 通知的类型将在后面的章节进行讨论.  许多 AOP 框架,包括 Spring 在内,都是以拦截器做通知模型的,并维护着一个以连接点为中心的拦截器链.
* Pointcut(切点): 匹配连接点的断言. 通知和切点表达式相关联,并在满足这个切点的连接点上运行(例如,当执行某个特定名称的方法时) . 切点表达式如何和连接点匹配是 AOP 的核心: Spring 默认使用 AspectJ 切点语义.
* Introduction(引入): 声明额外的方法或者某个类型的字段. Spring 允许引入新的接口(以及一个对应的实现) 到任何被通知的对象上. 例如,可以使用引入来使 bean 实现 `IsModified` 接口, 以便简化缓存机制(在 AspectJ 社区,引入也被称为内部类型声明(inter) ) .
* Target object(目标对象): 被一个或者多个切面所通知的对象. 也被称作被通知(advised) 对象. 既然 Spring AOP 是通过运行时代理实现的,那么这个对象永远是一个被代理(proxied) 的对象.
* AOP proxy(AOP代理): AOP 框架创建的对象,用来实现切面契约(aspect contract) (包括通知方法执行等功能) . 在 Spring 中,AOP 代理可以是 JDK 动态代理或 CGLIB 代理.
* Weaving(织入): 把切面连接到其它的应用程序类型或者对象上,并创建一个被被通知的对象的过程. 这个过程可以在编译时(例如使用 AspectJ 编译器) 、类加载时或运行时中完成.  Spring 和其他纯 Java AOP 框架一样,是在运行时完成织入的.

Spring AOP 包含以下类型的通知:

* Before advice(前置通知): 在连接点之前运行但无法阻止执行流程进入连接点的通知(除非它引发异常) .
* After returning advice(后置返回通知): 在连接点正常完成后执行的通知(例如,当方法没有抛出任何异常并正常返回时) .
* After throwing advice(后置异常通知): 在方法抛出异常退出时执行的通知.
* After (finally) advice(后置通知(总会执行) ):  当连接点退出的时候执行的通知(无论是正常返回还是异常退出) .
* Around advice(环绕通知): 环绕连接点的通知,例如方法调用. 这是最强大的一种通知类型,. 环绕通知可以在方法调用前后完成自定义的行为. 它可以选择是否继续执行连接点或直接返回自定义的返回值又或抛出异常将执行结束.

环绕通知是最常用的一种通知类型. 与 AspectJ 一样,在选择 Spring 提供的通知类型时,团队推荐开发者尽量使用简单的通知类型来实现需要的功能. 例如, 如果只是需要使用方法的返回值来作缓存更新,虽然使用环绕通知也能完成同样的事情,但是仍然推荐使用后置返回通知来代替.
使用最合适的通知类型可以让编程模型变得简单, 还能避免很多潜在的错误. 例如,开发者无需调用于环绕通知(用 `JoinPoint`) 的 `proceed()` 方法,也就不会产生调用的问题.

所有通知参数都是静态类型的,因此您可以使用相应类型的通知参数(例如,方法执行的返回值的类型) 而不是 `Object` 数组.

切点和连接点匹配是 AOP 的关键概念,这个概念让 AOP 不同于其它仅仅提供拦截功能的旧技术. 切入点使得通知可以独立于面向对象的层次结构进行定向.  例如,您可以将一个提供声明式事务管理的通知应用于跨多个对象(例如服务层中的所有业务操作) 的一组方法.

[[aop-introduction-spring-defn]]
== Spring AOP 的功能和目标

Spring AOP 是用纯 Java 实现的.  不需要特殊的编译过程.  Spring AOP 不需要控制类加载器层次结构,因此适合在 servlet 容器或应用程序服务器中使用.

Spring 目前仅支持方法调用的方式作为连接点(在 Spring  bean 上通知方法的执行) . 虽然可以在不影响到 Spring AOP 核心 API 的情况下加入对成员变量拦截器支持, 但 Spring 并没有实现成员变量拦截器. 如果需要通知对成员变量的访问和更新连接点,可以考虑其它语言,例如 AspectJ.

Spring 实现 AOP 的方法与其他的框架不同,Spring 并不是要尝试提供最完整 的AOP 实现(尽管 Spring AOP 有这个能力) ,相反地,它其实侧重于提供一种 AOP 与 Spring IoC 容器的整合的实现,用于帮助解决在企业级开发中的常见问题.

因此,例如,Spring Framework 的 AOP 功能通常与 Spring IoC 容器一起使用. 通过使用普通 bean 定义语法来配置切面(尽管 Spring 提供了强大的 "自动代理" 功能) .  这是与其他AOP实现的重要区别.  使用 Spring AOP 无法轻松或高效地完成某些操作,例如建议非常细粒度的对象(通常是域对象) .  在这种情况下,AspectJ 是最佳选择.  但是,我们的经验是,Spring AOP 为适合 AOP 的企业 Java 应用程序中的大多数问题提供了出色的解决方案.

Spring AOP从来没有打算通过提供一种全面的 AOP 解决方案用于取代 AspectJ,我们相信,基于代理的框架(如 Spring AOP) 和完整的框架(如 AspectJ) 都很有价值,而且它们是互补的,而不是竞争.  Spring 将 Spring AOP 和 IoC 与 AspectJ 无缝集成,使得所有的 AOP 功能完全融入基于 Spring 的应用体系. 这样的集成不会影响 Spring AOP API 或者 AOP Alliance API.
Spring AOP 仍然向后兼容.  有关Spring AOP API的讨论,请参阅 <<aop-api, 以下章节>>.

[NOTE]
====
Spring 框架的一个核心原则是非侵入性. 这意味着开发者无需在自身的 业务/domain 模型上被迫引入框架特定的类和接口. 然而,有些时候,Spring 框架可以让开发者选择引入 Spring 框架特定的依赖到业务代码.  给予这种选择的理由是因为在某些情况下它可能是更易读或易于编写某些特定功能. Spring 框架(几乎) 总能给出这样的选择,开发者可以自由地做出明智的决定,选择最适合的特定用例或场景.

与本章相关的一个选择是选择哪种 AOP 框架(以及哪种AOP样式) . 您可以选择 AspectJ,Spring AOP 或两者. 也可以选择 `@AspectJ` 注解式的方法或 Spring 的 XML 配置方式.  事实上,本章以介绍 `@AspectJ` 方式为先不应该被视为 Spring 团队倾向于 `@AspectJ` 的方式胜过 Spring 的 XML 配置方式.

请参阅<<aop-choosing,选择要使用的 AOP 声明样式>>,以更全面地讨论每种样式的 "为什么和如何进行".
====

[[aop-introduction-proxies]]
== AOP 代理

Spring 默认使用标准的 JDK 动态代理来作为AOP的代理. 这样任何接口(或者接口的 set) 都可以被代理.

Spring 也支持使用 CGLIB 代理. 对于需要代理类而不是代理接口的时候 CGLIB 代理是很有必要的. 如果业务对象并没有实现接口,默认就会使用 CGLIB 代理 . 此外,面向接口编程也是最佳实践,业务对象通常都会实现一个或多个接口.
此外,还可以<<aop-proxying, 强制的使用 CGLIB 代理>>, 在那些(希望是罕见的) 需要通知没有在接口中声明的方法时,或者当需要传递一个代理对象作为一种具体类型到方法的情况下.

掌握 Spring AOP 是基于代理的这一事实非常重要.  请参阅 <<aop-understanding-aop-proxies,AOP 代理>>,以全面了解此实现细节的实际含义. .

[[aop-ataspectj]]
== @AspectJ 注解支持

`@AspectJ` 会将切面声明为常规 Java 类的注解类型.  https://www.eclipse.org/aspectj[AspectJ project] 引入了 `@AspectJ` 风格,并作为 AspectJ 5 发行版的一部分. Spring 使用的注解类似于 AspectJ 5, 使用 AspectJ 提供的库用来解析和匹配切点. AOP 运行时仍然是纯粹的 Spring AOP,并不依赖 AspectJ 编译器或编织器.

NOTE: 使用 AspectJ 编译器和织入并允许使用全部基于 AspectJ 语言,并在<<aop-using-aspectj>>进行了讨论.

[[aop-aspectj-support]]
=== 启用 @AspectJ 支持

要在 Spring 配置中使用 `@AspectJ` 切面,需要启用 Spring 支持,用于根据 `@AspectJ` 切面配置 Spring AOP,并根据这些切面自动代理 bean (事先判断是否在通知的范围内) .  通过自动代理的意思是: 如果 Spring 确定一个 bean 是由一个或多个切面处理的,将据此为 bean 自动生成代理 bean ,并以拦截方法调用并确保需要执行的通知.

可以使用 XML 或 Java 配置的方式启用 `@AspectJ` 支持. 不管哪一种方式,您还需要确保 AspectJ 的 `aspectjweaver.jar` 库位于应用程序的类路径中(版本 1.8 或更高版本) . 此库可在 AspectJ 分发的 `lib` 目录中或 Maven Central 仓库中找到.

[[aop-enable-aspectj-java]]
==== 使用 Java 配置启用 `@AspectJ` 支持

要使用 Java `@Configuration` 启用 `@AspectJ` 支持,请添加 `@EnableAspectJAutoProxy` 注解,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableAspectJAutoProxy
	public class AppConfig {

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableAspectJAutoProxy
	class AppConfig
----

[[aop-enable-aspectj-xml]]
==== 使用 XML 配置启用 `@AspectJ` 支持

要使用基于 XML 的配置启用 `@AspectJ` 支持,请使用 `aop:aspectj-autoproxy` 元素,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspectj-autoproxy/>
----

这假设您使用 <<core.adoc#core.appendix.xsd-schemas, 基于 XML Schema 配置>> 中描述的 schema 支持. 有关如何在 `aop` 命名空间中导入标签,
请参阅 <<core.adoc#core.appendix.xsd-schemas-aop,  AOP schema>>.

[[aop-at-aspectj]]
=== 声明切面

启用了 `@AspectJ` 支持后,在应用程序上下文中定义的任意 bean (有 `@Aspect` 注解) 的类都将被 Spring 自动检测,并用于配置 Spring AOP.  接下来的两个示例显示了非常有用的方面所需的最小定义.

这两个示例中的第一个示例在应用程序上下文中显示了一个常规 bean 定义,该定义指向具有 `@Aspect` 注解的 bean 类:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="myAspect" class="org.xyz.NotVeryUsefulAspect">
		<!-- configure properties of the aspect here -->
	</bean>
----

这两个示例中的第二个显示了 `NotVeryUsefulAspect` 类定义,该定义使用 `org.aspectj.lang.annotation.Aspect` 注解进行注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package org.xyz;
	import org.aspectj.lang.annotation.Aspect;

	@Aspect
	public class NotVeryUsefulAspect {

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package org.xyz

	import org.aspectj.lang.annotation.Aspect;

	@Aspect
	class NotVeryUsefulAspect
----

切面(使用 `@Aspect` 的类) 可以拥有方法和属性,与其他类并无不同. 也可以包括切点、通知和内置类型(即引入) 声明.

.通过组件扫描自动检测切面
NOTE: 您可以在 Spring XML 配置中将切面类注册为常规 bean 或者在  `@Configuration` 类中配置 `@Bean` 方法 ,Spring 会通过类路径扫描自动检测它们 - 与任何其他 Spring 管理的 bean 相同. 然而注意到 `@Aspect` 注解对于类的自动探测是不够的, 为此,需要单独添加 `@Component` ,注解(或自定义注解声明,用作 Spring 组件扫描器的规则之一) .

.是否可以作为其他切面的切面通知?
NOTE: 在 Spring AOP 中,不可能将切面本身被作为其他切面的目标. 类上的 `@Aspect` 注解表明他是一个切面并且排除在自动代理的范围之外.

[[aop-pointcuts]]
=== 声明切点

切点决定了匹配的连接点,从而使我们能够控制通知何时执行. Spring AOP 只支持使用 Spring  bean 的方法执行连接点,所以可以将切点看出是匹配 Spring  bean 上方法的执行.  切点的声明包含两个部分: 包含名称和任意参数的签名,以及明确需要匹配的方式执行的切点表达式.
在 `@AspectJ` 注解方式的 AOP 中,一个切点的签名由常规方法定义来提供, 并且切点表达式使用 `@Pointcut` 注解指定(方法作为切点签名必须有类型为 `void` 的返回) .

使用例子有助于更好地区分切点签名和切点表达式之间的关系. 以下示例定义名为 `anyOldTransfer` 的切点,该切点与名为 `transfer` 的任何方法的执行相匹配:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Pointcut("execution(* transfer(..))") // the pointcut expression
	private void anyOldTransfer() {} // the pointcut signature
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Pointcut("execution(* transfer(..))") // the pointcut expression
	private fun anyOldTransfer() {} // the pointcut signature
----

切点表达式由 `@Pointcut` 注解的值是常规的 AspectJ 切点表达式. 关于 AspectJ 切点语言的描述,见 https://www.eclipse.org/aspectj/doc/released/progguide/index.html[AspectJ
Programming Guide] (作为扩展, 请参考 https://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html[AspectJ 5 Developer's Notebook]) 或者 Colyer 著的关于 AspectJ 的书籍.  例如, _Eclipse AspectJ_,或者参看 Ramnivas Laddad的 _AspectJ in Action_.

[[aop-pointcuts-designators]]
==== 支持切点标识符

Spring AOP 支持使用以下 AspectJ 切点标识符(PCD),用于切点表达式:

* `execution`: 用于匹配方法执行连接点.  这是使用 Spring AOP 时使用的主要切点标识符.
* `within`: 限制匹配特定类型中的连接点(在使用 Spring AOP 时,只需执行在匹配类型中声明的方法) .
* `this`: 在 bean 引用(Spring AOP 代理) 是给定类型的实例的情况下,限制匹配连接点(使用 Spring AOP 时方法的执行) .
* `target`: 限制匹配到连接点(使用 Spring AOP 时方法的执行) ,其中目标对象(正在代理的应用程序对象) 是给定类型的实例.
* `args`: 限制与连接点的匹配(使用 Spring AOP 时方法的执行) ,其中变量是给定类型的实例.
* `@target`: 限制与连接点的匹配(使用 Spring AOP 时方法的执行) ,其中执行对象的类具有给定类型的注解.
* `@args`: 限制匹配连接点(使用 Spring AOP 时方法的执行) ,其中传递的实际参数的运行时类型具有给定类型的注解.
* `@within`: 限制与具有给定注解的类型中的连接点匹配(使用 Spring AOP 时在具有给定注解的类型中声明的方法的执行) .
* `@annotation`: 限制匹配连接点(在 Spring AOP 中执行的方法具有给定的注解) .

.其他切点类型
****
Spring 并没有完全地支持 AspectJ 切点语言声明的切点标识符,包括 `call`, `get`, `set`, `preinitialization`,
`staticinitialization`, `initialization`, `handler`, `adviceexecution`, `withincode`, `cflow`,`cflowbelow`, `if`, `@this`, 和 `@withincode`. 在由 Spring AOP 解释的切点表达式中, 使用这些切点标识符将导致 `IllegalArgumentException` 异常.

Spring AOP 支持的切点标识符可以在将来的版本中扩展,以支持更多的 AspectJ 切点标识符.
****

因为 Spring AOP 限制了只匹配方法的连接点执行,所以上面的切点标识符的讨论比在 AspectJ 编程指南中找到的定义要窄. 另外,AspectJ 本身具有基于类型的语义,
并且在执行连接点上,`this` 和 `target` 都指向同一个对象-即执行方法的对象. Spring AOP 是一个基于代理的系统,区分代理对象本身(绑定到 `this`) 和代理(绑定到 `target`) 后的目标对象.

[NOTE]
====
由于 Spring AOP 框架是基于代理的特性,定义的 protected 方法将不会被处理,不管是 JDK 的代理(做不到) 还是 CGLIB 代理(有技术可以实现但是不建议) .  因此,任何给定的切点将只能与 public 方法匹配.

请注意,切点定义通常与任何截获的方法匹配.  如果切点严格意义上是暴露的,即使在通过代理进行潜在非公共交互的 CGLIB 代理方案中,也需要相应地定义切点.

如果需要拦截包括 protected 和 private 方法甚至是构造函数,请考虑使用基于 Spring 驱动的<<aop-aj-ltw, 本地 AspectJ 织入>>而不是 Spring 的基于代理的 AOP 框架.
这构成了不同特性的 AOP 使用模式,所以在做出决定之前一定要先熟悉一下编织.
====

Spring AOP 支持更多的 PCD 命名 `bean`. PCD允许将连接点的匹配限制为特定的 Spring `bean` 或一系列 Spring `bean`.  bean PCD 具有以下形式:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	bean(idOrNameOfBean)
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	bean(idOrNameOfBean)
----

`idOrNameOfBean` 标识可以是任意符合 Spring  bean 的名字, 提供了使用 `*` 字符的有限通配符支持,因此,如果为 Spring `bean` 建立了一些命名约定,则可以编写 bean  PCD 表达式来选择它们.  与其他切点标识符的情况一样,PCD  bean 可以是 `&&` (and), `||` (or), and `!`(negation).

[NOTE]
====
`bean` PCD 仅在 Spring AOP 中受支持,而在本地 AspectJ 编织中不受支持.  它是 AspectJ 定义的标准 PCD 的 Spring 特定扩展,因此不适用于 `@Aspect` 模型中声明的切面.

`bean` PCD 运行在实例级别上(基于 Spring  bean 名称概念构建) ,而不是仅在类型级别(这是基于编织的 AOP 所限制的) .  基于实例的切点标识符是 Spring 基于代理的 AOP 框架的特殊功能,它与 Spring  bean 工厂紧密集成,通过名称识别特定的 bean 是自然而直接的.
====

[[aop-pointcuts-combining]]
==== 合并切点表达式

您可以使用 `&&,` `||` 和 `!` 等符号进行合并操作. 也可以通过名字来指向切点表达式.  以下示例显示了三个切入点表达式:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Pointcut("execution(public * \*(..))")
	private void anyPublicOperation() {} // <1>

	@Pointcut("within(com.xyz.myapp.trading..*)")
	private void inTrading() {} // <2>

	@Pointcut("anyPublicOperation() && inTrading()")
	private void tradingOperation() {} // <3>
----
<1> `anyPublicOperation` 如果方法执行连接点表示任何公共方法的执行,则匹配
<2> `inTrading` 如果方法执行在 trading 中,则匹配.
<3> `tradingOperation` 如果方法执行表示 trading 中的任何公共方法,则匹配.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Pointcut("execution(public * \*(..))")
	private fun anyPublicOperation() {} // <1>

	@Pointcut("within(com.xyz.myapp.trading..*)")
	private fun inTrading() {} // <2>

	@Pointcut("anyPublicOperation() && inTrading()")
	private fun tradingOperation() {} // <3>
----
<1> `anyPublicOperation` 如果方法执行连接点表示任何公共方法的执行,则匹配
<2> `inTrading` 如果方法执行在 trading 中,则匹配.
<3> `tradingOperation` 如果方法执行表示 trading 中的任何公共方法,则匹配.

如上所示,用更小的命名组件构建更复杂的切入点表达式是最佳实践. 当按名称引用切点时,将应用普通的 Java 可见性规则(可以看到相同类型的私有切点,层次结构中受保护的切点,任何位置的公共切点等) . 可见性并不影响切点匹配.

[[aop-common-pointcuts]]
==== 共享通用的切点定义

在处理企业应用程序时,通常需要从几个切面来引用应用程序的模块和特定的操作集. 建议定义一个 `CommonPointcuts` 切面,以此为目的捕获通用的切点表达式. 这样的切面通常类似于以下示例:

[source,java,indent=0,subs="verbatim",role="primary"]
.Java
----
	package com.xyz.myapp;

	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.Pointcut;

	@Aspect
	public class CommonPointcuts {

		/**
		 * A join point is in the web layer if the method is defined
		 * in a type in the com.xyz.myapp.web package or any sub-package
		 * under that.
		 */
		@Pointcut("within(com.xyz.myapp.web..*)")
		public void inWebLayer() {}

		/**
		 * A join point is in the service layer if the method is defined
		 * in a type in the com.xyz.myapp.service package or any sub-package
		 * under that.
		 */
		@Pointcut("within(com.xyz.myapp.service..*)")
		public void inServiceLayer() {}

		/**
		 * A join point is in the data access layer if the method is defined
		 * in a type in the com.xyz.myapp.dao package or any sub-package
		 * under that.
		 */
		@Pointcut("within(com.xyz.myapp.dao..*)")
		public void inDataAccessLayer() {}

		/**
		 * A business service is the execution of any method defined on a service
		 * interface. This definition assumes that interfaces are placed in the
		 * "service" package, and that implementation types are in sub-packages.
		 *
		 * If you group service interfaces by functional area (for example,
		 * in packages com.xyz.myapp.abc.service and com.xyz.myapp.def.service) then
		 * the pointcut expression "execution(* com.xyz.myapp..service.*.*(..))"
		 * could be used instead.
		 *
		 * Alternatively, you can write the expression using the 'bean'
		 * PCD, like so "bean(*Service)". (This assumes that you have
		 * named your Spring service beans in a consistent fashion.)
		 */
		@Pointcut("execution(* com.xyz.myapp..service.*.*(..))")
		public void businessService() {}

		/**
		 * A data access operation is the execution of any method defined on a
		 * dao interface. This definition assumes that interfaces are placed in the
		 * "dao" package, and that implementation types are in sub-packages.
		 */
		@Pointcut("execution(* com.xyz.myapp.dao.*.*(..))")
		public void dataAccessOperation() {}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package com.xyz.myapp

	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.Pointcut

	@Aspect
	class CommonPointcuts {

		/**
		* A join point is in the web layer if the method is defined
		* in a type in the com.xyz.myapp.web package or any sub-package
		* under that.
		*/
		@Pointcut("within(com.xyz.myapp.web..*)")
		fun inWebLayer() {
		}

		/**
		* A join point is in the service layer if the method is defined
		* in a type in the com.xyz.myapp.service package or any sub-package
		* under that.
		*/
		@Pointcut("within(com.xyz.myapp.service..*)")
		fun inServiceLayer() {
		}

		/**
		* A join point is in the data access layer if the method is defined
		* in a type in the com.xyz.myapp.dao package or any sub-package
		* under that.
		*/
		@Pointcut("within(com.xyz.myapp.dao..*)")
		fun inDataAccessLayer() {
		}

		/**
		* A business service is the execution of any method defined on a service
		* interface. This definition assumes that interfaces are placed in the
		* "service" package, and that implementation types are in sub-packages.
		*
		* If you group service interfaces by functional area (for example,
		* in packages com.xyz.myapp.abc.service and com.xyz.myapp.def.service) then
		* the pointcut expression "execution(* com.xyz.myapp..service.*.*(..))"
		* could be used instead.
		*
		* Alternatively, you can write the expression using the 'bean'
		* PCD, like so "bean(*Service)". (This assumes that you have
		* named your Spring service beans in a consistent fashion.)
		*/
		@Pointcut("execution(* com.xyz.myapp..service.*.*(..))")
		fun businessService() {
		}

		/**
		* A data access operation is the execution of any method defined on a
		* dao interface. This definition assumes that interfaces are placed in the
		* "dao" package, and that implementation types are in sub-packages.
		*/
		@Pointcut("execution(* com.xyz.myapp.dao.*.*(..))")
		fun dataAccessOperation() {
		}

	}
----

像这样定义的切点可以用在任何需要切点表达式的地方, 例如,要使服务层具有事务性,您可以编写以下内容:

[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	<aop:config>
		<aop:advisor
			pointcut="com.xyz.myapp.CommonPointcuts.businessService()"
			advice-ref="tx-advice"/>
	</aop:config>

	<tx:advice id="tx-advice">
		<tx:attributes>
			<tx:method name="*" propagation="REQUIRED"/>
		</tx:attributes>
	</tx:advice>
----

`<aop:config>` 和 `<aop:advisor>` 元素在 <<aop-schema,基于 Schema>>的 AOP 支持中进行了讨论.   <<data-access.adoc#transaction,  事务管理>>中讨论了事务元素.


[[aop-pointcuts-examples]]
==== Examples

Spring AOP 用户可能最常使用 `execution` 切点标识符 ,执行表达式的格式为:

[literal,subs="verbatim,quotes"]
----
	execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)
				throws-pattern?)
----

除返回类型模式(上面片段中的 `ret-type-pattern` ) 以外的所有部件、名称模式和参数模式都是可选的. 返回类型模式确定要匹配的连接点的方法的返回类型必须是什么.  通常,可以使用 `{asterisk}` 作为返回类型模式,它匹配任何返回类型. 只有当方法返回给定类型时,完全限定的类型名称才会匹配. 名称模式与方法名称匹配,可以将 `{asterisk}` 通配符用作名称模式的全部或部分.  如果指定声明类型模式,则需要有后缀 .将其加入到名称模式组件中.
参数模式稍微复杂一点. `()` 匹配没有参数的方法.  `(..)` 匹配任意个数的参数(0个或多个) .  ( `{asterisk}` )匹配任何类型的单个参数. `(*,String)` 匹配有两个参数而且第一个参数是任意类型,第二个必须是 `String` 的方法. 有关更多信息,请参阅AspectJ编程指南的 https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html[Language
Semantics]部分.

以下示例显示了一些常见的切点表达式:

* 匹配任意公共方法的执行:
+
[literal,subs="verbatim,quotes"]
----
	execution(public * *(..))
----

* 匹配任意以 `set` 开始的方法:
+
[literal,subs="verbatim,quotes"]
----
	execution(* set*(..))
----

* 匹配定义了 `AccountService` 接口的任意方法:
+
[literal,subs="verbatim,quotes"]
----
	execution(* com.xyz.service.AccountService.*(..))
----

* 匹配定义在 `service` 包中的任意方法:
+
[literal,subs="verbatim,quotes"]
----
	execution(* com.xyz.service.\*.*(..))
----

* 匹配定义在 `service` 包和其子包中的任意方法:
+
[literal,subs="verbatim,quotes"]
----
	execution(* com.xyz.service..\*.*(..))
----

* 匹配在 `service` 包中的任意连接点(只在 Spring AOP 中的方法执行) :
+
[literal,subs="verbatim,quotes"]
----
	within(com.xyz.service.*)
----

* 匹配在 `service` 包及其子包中的任意连接点(只在 Spring AOP 中的方法执行)
+
[literal,subs="verbatim,quotes"]
----
	within(com.xyz.service..*)
----

* 匹配代理实现了 `AccountService` 接口的任意连接点(只在 Spring AOP 中的方法执行) :
+
[literal,subs="verbatim,quotes"]
----
	this(com.xyz.service.AccountService)
----
+
NOTE: `this` 常常以捆绑的形式出现.  见后续的章节讨论如何在 <<aop-advice,声明通知>> 中使用代理对象.

* 匹配当目标对象实现了 `AccountService` 接口的任意连接点(只在 Spring AOP 中的方法执行) :
+
[literal,subs="verbatim,quotes"]
----
	target(com.xyz.service.AccountService)
----
+
NOTE: `target`  常常以捆绑的形式出现. 见后续的章节讨论如何在 <<aop-advice,声明通知>> 中使用目标对象.

* 匹配使用了单一的参数,并且参数在运行时被传递时可以 `Serializable` 的任意连接点(只在 Spring 的 AOP 中的方法执行) :
+
[literal,subs="verbatim,quotes"]
----
	args(java.io.Serializable)
----
+
NOTE: `args` 常常以捆绑的形式出现.见后续的章节讨论如何在 <<aop-advice,声明通知>> 中使用方法参数.
+
注意在这个例子中给定的切点不同于 `execution(* *(java.io.Serializable))`. 如果在运行时传递的参数是可序列化的,则与 `execution` 匹配,如果方法签名声明单个参数类型为  `Serializable`,则与 args 匹配.

* 匹配当目标对象有 `@Transactional` 注解时的任意连接点(只在 Spring AOP 中的方法执行) .
+
[literal,subs="verbatim,quotes"]
----
	@target(org.springframework.transaction.annotation.Transactional)
----
+
NOTE: `@target` 也可以以捆绑的形式使用.见后续的章节讨论如何在<<aop-advice,声明通知>>中使用注解对象.

* 匹配当目标对象的定义类型有 `@Transactional` 注解时的任意连接点(只在 Spring 的 AOP 中的方法执行)
+
[literal,subs="verbatim,quotes"]
----
	@within(org.springframework.transaction.annotation.Transactional)
----
+
NOTE: `@within` 也可以以捆绑的形式使用.见后续的章节讨论如何在 <<aop-advice,声明通知>> 中使用注解对象.

* 匹配当执行的方法有 `@Transactional` 注解的任意连接点(只在 Spring AOP 中的方法执行) :
+
[literal,subs="verbatim,quotes"]
----
	@annotation(org.springframework.transaction.annotation.Transactional)
----
+
NOTE: `@annotation` 也可以以捆绑的形式使用.见后续的章节讨论如何在 <<aop-advice,声明通知>> 中使用注解对象.

* 匹配有单一的参数并且在运行时传入的参数类型有 `@Classified` 注解的任意连接点(只在 Spring AOP 中的方法执行) :
+
[literal,subs="verbatim,quotes"]
----
	@args(com.xyz.security.Classified)
----
+
NOTE: `@args` 也可以以捆绑的形式使用.见后续的章节讨论如何在 <<aop-advice,声明通知>> 中使用注解对象.

* 匹配在名为 `tradeService` 的 Spring bean 上的任意连接点(只在Spring AOP中的方法执行) :
+
[literal,subs="verbatim,quotes"]
----
	bean(tradeService)
----

* 匹配以 `*Service` 结尾的 Spring bean 上的任意连接点(只在 Spring AOP 中方法执行)  :
+
[literal,subs="verbatim,quotes"]
----
	bean(*Service)
----


[[writing-good-pointcuts]]
==== 编写好的切点

在编译过程中,AspectJ 会尝试和优化匹配性能来处理切点. 检查代码并确定每个连接点是否匹配(静态或动态) 给定切点是一个代价高昂的过程. (动态匹配意味着无法从静态分析中完全确定匹配, 并且将在代码中放置测试,以确定在运行代码时是否存在实际匹配) . 在第一次遇到切点声明时,AspectJ 会将它重写为匹配过程的最佳形式. 这是什么意思? 基本上,切点是在 DNF(析取范式) 中重写的 ,切点的组成部分会被排序,以便先检查那些比较明确的组件. 这意味着开发者不必担心各种切点标识符的性能,并且可以在切点声明中以任何顺序编写.

但是,AspectJ 只能与被它指定的内容协同工作,并且为了获得最佳的匹配性能,开发者应该考虑它们试图实现的目标,并在定义中尽可能缩小匹配的搜索空间.  现有的标识符会自动选择下面三个中的一个 kinded, scoping, 和 contextual:

* Kinded 选择特定类型的连接点的标识符:
`execution`, `get`, `set`, `call`, 和 `handler`.
* Scoping 选择一组连接点的匹配 (可能是许多种类) : `within` 和 `withincode`
* Contextual 基于上下文匹配 (或可选绑定) 的标识符:
`this`, `target`, 和 `@annotation`

一个写得很好的切入点应该至少包括前两种类型(kinded 和 scoping) . 同时 contextual 标识符或许会被包括如果希望匹配基于连接点上下文或绑定在通知中使用的上下文.  只是提供 kinded 标识符或只提供 contextual 标识符器也能够工作,但是可能影响处理性能(时间和内存的使用) ,浪费了额外的处理和分析时间或空间. scoping 标识符可以快速匹配并且使用 AspectJ 可以快速排除不会被处理的连接点组, 这也说明编写好的切点表达式是很重要的(因为没有明确指定时,它就会 Loop Lookup 循环匹配) .

[[aop-advice]]
=== 声明通知

通知是与切点表达式相关联的概念,可以在切点匹配的方法之前、之后或之间执行. 切点表达式可以是对命名切点的简单引用,也可以是即时声明的切点表达式.

[[aop-advice-before]]
==== 前置通知

您可以使用 `@Before` 注解在切面中的通知之前声明:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.Before;

	@Aspect
	public class BeforeExample {

		@Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
		public void doAccessCheck() {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.Before

	@Aspect
	class BeforeExample {

		@Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
		fun doAccessCheck() {
			// ...
		}
	}
----

如果使用内置切点表达式,我们可以重写前面的示例,如下例所示:

[source,java,indent=0,subs="verbatim",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.Before;

	@Aspect
	public class BeforeExample {

		@Before("execution(* com.xyz.myapp.dao.*.*(..))")
		public void doAccessCheck() {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.Before

	@Aspect
	class BeforeExample {

		@Before("execution(* com.xyz.myapp.dao.*.*(..))")
		fun doAccessCheck() {
			// ...
		}
	}
----


[[aop-advice-after-returning]]
==== 后置返回通知

要想用后置返回通知可以在切面上添加 `@AfterReturning` 注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.AfterReturning;

	@Aspect
	public class AfterReturningExample {

		@AfterReturning("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
		public void doAccessCheck() {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.AfterReturning

	@Aspect
	class AfterReturningExample {

		@AfterReturning("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
		fun doAccessCheck() {
			// ...
		}
	}
----

NOTE: 在同一切面中当然可以声明多个通知. 在此只是为了迎合讨论的主题而只涉及单个通知.

有些时候需要在通知中获取实际的返回值. 可以使用 `@AfterReturning` ,并指定 `returning` 字段如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.AfterReturning;

	@Aspect
	public class AfterReturningExample {

		@AfterReturning(
			pointcut="com.xyz.myapp.CommonPointcuts.dataAccessOperation()",
			returning="retVal")
		public void doAccessCheck(Object retVal) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.AfterReturning

	@Aspect
	class AfterReturningExample {

		@AfterReturning(
			pointcut = "com.xyz.myapp.CommonPointcuts.dataAccessOperation()",
			returning = "retVal")
		fun doAccessCheck(retVal: Any) {
			// ...
		}
	}
----

在 `returning` 属性中使用的名字必须和通知方法中的参数名相关,方法执行返回时,返回值作为相应的参数值传递给 advice 方法. `returning` 子句还限制只匹配那些返回指定类型的值的方法执行(在本例中为 `Object`,它匹配任何返回值对象) .

请注意,当使用 `after-returning` 的通知时. 不能返回不同的引用.


[[aop-advice-after-throwing]]
==== 后置异常通知

当方法执行并抛出异常时后置异常通知会被执行,需要使用 `@AfterThrowing` 注解来定义. 如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.AfterThrowing;

	@Aspect
	public class AfterThrowingExample {

		@AfterThrowing("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
		public void doRecoveryActions() {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.AfterThrowing

	@Aspect
	class AfterThrowingExample {

		@AfterThrowing("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
		fun doRecoveryActions() {
			// ...
		}
	}
----

开发者常常希望当给定类型的异常被抛出时执行通知,并且也需要在通知中访问抛出的异常. 使用 `throwing` 属性来限制匹配(如果需要,使用 `Throwable` 作为异常类型) ,并将引发的异常绑定到通知参数. 以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.AfterThrowing;

	@Aspect
	public class AfterThrowingExample {

		@AfterThrowing(
			pointcut="com.xyz.myapp.CommonPointcuts.dataAccessOperation()",
			throwing="ex")
		public void doRecoveryActions(DataAccessException ex) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.AfterThrowing

	@Aspect
	class AfterThrowingExample {

		@AfterThrowing(
			pointcut = "com.xyz.myapp.CommonPointcuts.dataAccessOperation()",
			throwing = "ex")
		fun doRecoveryActions(ex: DataAccessException) {
			// ...
		}
	}
----

`throwing` 属性中使用的名字必须和通知方法中的参数名相关. 当方法执行并抛出异常时,异常将会传递给通知方法作为相关的参数值.  抛出子句还限制与只引发指定类型的异常(在本例中为 `DataAccessException`) 的方法执行的匹配.

[NOTE]
====
请注意,`@AfterThrowing` 并不表示常规的异常处理回调. 具体来说,`@AfterThrowing` 通知方法仅应从连接点 (用户声明的目标方法) 本身接收异常,而不能从随附的 `@After`/`@AfterReturning` 方法接收异常.
====

[[aop-advice-after-finally]]
==== 后置通知(总会执行)

当匹配方法执行之后后置通知(总会执行) 会被执行. 这种情况使用 `@After` 注解来定义. 后置通知必须被准备来处理正常或异常的返回条件. 通常用于释放资源等等:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.After;

	@Aspect
	public class AfterFinallyExample {

		@After("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
		public void doReleaseLock() {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.After

	@Aspect
	class AfterFinallyExample {

		@After("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
		fun doReleaseLock() {
			// ...
		}
	}
----

[NOTE]
====
请注意,AspectJ 中的 `@After` 建议被定义为 "after finally advice",类似于 try-catch 语句中的 finally 块.
与 `@AfterReturning` 相反 (仅适用于成功的正常返回) ,它将为从连接点 (用户声明的目标方法) 抛出任何异常,正常返回或异常调用.
====

[[aop-ataspectj-around-advice]]
==== 环绕通知

最后一种通知是 _环绕通知_,环绕通知围绕方法执行. 可以在方法执行之前和执行之后执行,并且定义何时做什么,甚至是否真正得到执行. 如果需要在方法执行之前和之后以线程安全的方式 (例如启动和停止计时器)  共享状态

[TIP]
====
确认可使用的通知形式, 要符合最小匹配原则.

例如，如果 _before_ 通知足以满足您的需求，则不要使用 _around_ 通知。
====

环绕通知是通过使用 `@Around` 注解对方法进行注解来声明的。 这个方法应该声明 `Object` 作为它的返回类型，以及方法的第一个参数 必须是  `ProceedingJoinPoint` 类型。 在通知方法的主体内，您必须在 `ProceedingJoinPoint` 上调用 `proceed()` 以使底层方法。 不带参数调用 `proceed()` 将导致调用者的调用底层方法时提供原始参数。 这属于高级用途
`proceed` 方法也可以通过传递 `Object[]` 数组的值给原方法作为传入参数， 数组中的值将用作调用时的底层方法。


使用 `@Around` 注解来定义环绕通知,第一个参数必须是 `ProceedingJoinPoint` 类型的. 在通知中调用 `ProceedingJoinPoint` 中的 `proceed()` 方法来引用执行的方法. `proceed` 方法也可以被调用传递数组对象- 数组的值将会被当作参数在方法执行时被使用.
`proceed` 方法也可以传入 `Object[]`.  数组中的值在进行时用作方法执行的参数.


[NOTE]
====
 在使用 `Object[]` 调用时 `proceed` 的行为与在 AspectJ 编译器编译的环绕通知进行的行为略有不同. 对于使用传统 AspectJ 语言编写的通知, 传递给 `proceed` 的参数数必须与传递给环绕通知的参数数量(不是被连接点处理的参数的数目) 匹配,并且传递的值将 `proceed` 在给定的参数位置取代该值绑定到的实体的连接点的原始值(如果现在无法理解 ,请不要担心) .

Spring 处理的方式是简单的并且基于代理的,会生成更好的匹配语义. 现在只需意识到这两种是有这么一点的不同的即可. 为 Spring 编写的 `@AspectJ` 方面并在 AspectJ 中使用带有参数的 `proceed`
编译器和编织器。 有一种方法可以编写出 100% 兼容 Spring AOP 和 AspectJ 的匹配, 在后续的章节中将会讨论 <<aop-ataspectj-advice-proceeding-with-the-call, 通知的参数>>.
====

环绕通知返回的值将会被调用的方法看到,例如,一个简单的缓存切面可以从缓存中返回一个值(如果有的话) ,如果没有则调用 `proceed()`.  请注意,可以在 around 通知的主体内调用一次,多次或根本不调用.  所有这些都是合法的.

WARNING: 如果您将环绕通知方法的返回类型声明为 `void`，`null` 则 `proceed()` 将忽略任何调用的结果返回给调用者，因此，建议使用环绕通知方法声明返回
`Object` 的类型。 通知方法通常应该返回从调用 `proceed()`，即使底层方法具有 `void` 返回类型。
但是，通知可以选择返回缓存值、包装值或其他一些值取决于用例。

以下示例显示如何使用 `around` 通知:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.Around;
	import org.aspectj.lang.ProceedingJoinPoint;

	@Aspect
	public class AroundExample {

		@Around("com.xyz.myapp.CommonPointcuts.businessService()")
		public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
			// start stopwatch
			Object retVal = pjp.proceed();
			// stop stopwatch
			return retVal;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.Around
	import org.aspectj.lang.ProceedingJoinPoint

	@Aspect
	class AroundExample {

		@Around("com.xyz.myapp.CommonPointcuts.businessService()")
		fun doBasicProfiling(pjp: ProceedingJoinPoint): Any {
			// start stopwatch
			val retVal = pjp.proceed()
			// stop stopwatch
			return retVal
		}
	}
----



[[aop-ataspectj-advice-params]]
==== 通知的参数

Spring 提供了全部类型的通知,这意味着需在通知签名中声明所需的参数(正如上面返回和异常的示例) ,而不是一直使用 `Object[]` 数组. 接着将会看到怎么声明参数以及上下文的值是如何在通知实体中被使用的.  首先,来看看如何编写一般的通知,找出编写通知的法子.

[[aop-ataspectj-advice-params-the-joinpoint]]
===== 访问当前的 `JoinPoint`

任何通知方法都可以声明一个类型为 `org.aspectj.lang.JoinPoint` 的参数作为其第一个参数(注意,需要使用 环绕通知来声明一个类型为 `ProceedingJoinPoint` 的第一个参数, 它是 `JoinPoint` 的一个子类. `JoinPoint` 接口提供很多有用的方法:

* `getArgs()`: 返回方法参数.
* `getThis()`: 返回代理对象.
* `getTarget()`: 返回目标对象.
* `getSignature()`: 返回正在通知的方法的描述.
* `toString()`: 打印方法被通知的有用描述.

See the https://www.eclipse.org/aspectj/doc/released/runtime-api/org/aspectj/lang/JoinPoint.html[javadoc] for more detail.

[[aop-ataspectj-advice-params-passing]]
===== 传递参数给通知

我们已经看到了如何绑定返回的值或异常值(在返回之后和抛出通知之后使用) . 为了在通知代码段中使用参数值,可以使用绑定 `args` 的形式. 如果在 `args` 表达式中使用参数名代替类型名称, 则在调用通知时,要将相关的参数值当作参数传递. 例如,假如在 dao 操作时将 `Account` 对象作为第一个参数传递给通知,并且需要在通知代码段内访问 `Account`,可以这样写:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation() && args(account,..)")
	public void validateAccount(Account account) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation() && args(account,..)")
	fun validateAccount(account: Account) {
		// ...
	}
----

切点表达式的 `args(account,..)` 部分有两个目的. p 它严格匹配了至少带一个参数的执行方法,并且传递给传递的参数是 `Account` 实例.  第二,它使得实际的 `Account` 对象通过 `account` 参数提供给通知.

另一个方法写法就是先定义切点,然后, "provides" `Account` 对象给匹配的连接点,有了连接点,那么引用连接点作为切点的通知就能获得 `Account` 对象的值. 这看起来如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Pointcut("com.xyz.myapp.CommonPointcuts.dataAccessOperation() && args(account,..)")
	private void accountDataAccessOperation(Account account) {}

	@Before("accountDataAccessOperation(account)")
	public void validateAccount(Account account) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Pointcut("com.xyz.myapp.CommonPointcuts.dataAccessOperation() && args(account,..)")
	private fun accountDataAccessOperation(account: Account) {
	}

	@Before("accountDataAccessOperation(account)")
	fun validateAccount(account: Account) {
		// ...
	}
----

有关更多详细信息,请参阅 AspectJ 编程指南.

代理对象( `this`),目标对象 ( `target`)和注解 ( `@within`, `@target`, `@annotation`, 和 `@args`)都可以以类似的方式绑定. 接下来的两个示例显示如何匹配带有 `@Auditable` 注解的注解方法的执行并获取audit 代码:

首先是 `@Auditable` 注解的定义:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Retention(RetentionPolicy.RUNTIME)
	@Target(ElementType.METHOD)
	public @interface Auditable {
		AuditCode value();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Retention(AnnotationRetention.RUNTIME)
	@Target(AnnotationTarget.FUNCTION)
	annotation class Auditable(val value: AuditCode)
----

然后是匹配 `@Auditable` 方法通知的执行

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before("com.xyz.lib.Pointcuts.anyPublicMethod() && @annotation(auditable)")
	public void audit(Auditable auditable) {
		AuditCode code = auditable.value();
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before("com.xyz.lib.Pointcuts.anyPublicMethod() && @annotation(auditable)")
	fun audit(auditable: Auditable) {
		val code = auditable.value()
		// ...
	}
----

[[aop-ataspectj-advice-params-generics]]
===== 通知参数和泛型

Spring AOP 可以处理类声明和方法参数中使用的泛型. 假设如下泛型类型:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public interface Sample<T> {
		void sampleGenericMethod(T param);
		void sampleGenericCollectionMethod(Collection<T> param);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	interface Sample<T> {
		fun sampleGenericMethod(param: T)
		fun sampleGenericCollectionMethod(param: Collection<T>)
	}
----

只需将通知参数输入要拦截方法的参数类型,就可以将方法类型的检测限制为某些参数类型:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before("execution(* ..Sample+.sampleGenericMethod(*)) && args(param)")
	public void beforeSampleMethod(MyType param) {
		// Advice implementation
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before("execution(* ..Sample+.sampleGenericMethod(*)) && args(param)")
	fun beforeSampleMethod(param: MyType) {
		// Advice implementation
	}
----

此方法不适用于泛型集合.  因此,您无法按如下方式定义切点:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) && args(param)")
	public void beforeSampleMethod(Collection<MyType> param) {
		// Advice implementation
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) && args(param)")
	fun beforeSampleMethod(param: Collection<MyType>) {
		// Advice implementation
	}
----

为了使这项工作,我们必须检查集合的每个元素,这是不合理的,因为我们也无法决定如何处理 `null` 值.  要实现与此类似的操作,您必须将参数输入 `Collection<?>` 并手动检查元素的类型.

[[aop-ataspectj-advice-params-names]]
===== 声明参数的名字

参数在通知中的绑定依赖于名字匹配,重点在切点表达式中定义的参数名的方法签名上(通知和切点) . 参数名称不能通过 Java 反射获得,因此 Spring AOP 使用以下策略来确定参数名称:

* 如果用户已明确指定参数名称,则使用指定的参数名称. 通知和切点注解都有一个可选的 `argNames` 属性,您可以使用该属性指定带注解的方法的参数名称.  这些参数名称在运行时可用.  以下示例显示如何使用 `argNames` 属性:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)",
			argNames="bean,auditable")
	public void audit(Object bean, Auditable auditable) {
		AuditCode code = auditable.value();
		// ... use code and bean
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before(value = "com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)", argNames = "bean,auditable")
	fun audit(bean: Any, auditable: Auditable) {
		val code = auditable.value()
		// ... use code and bean
	}
----

如果第一个参数是 `JoinPoint`, `ProceedingJoinPoint`, 或 `JoinPoint.StaticPart` 类型,则可以从 `argNames` 属性的值中省略参数的名称.  例如,如果修改前面的通知以接收连接点对象,则 `argNames` 属性不需要包含它:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)",
			argNames="bean,auditable")
	public void audit(JoinPoint jp, Object bean, Auditable auditable) {
		AuditCode code = auditable.value();
		// ... use code, bean, and jp
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before(value = "com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)", argNames = "bean,auditable")
	fun audit(jp: JoinPoint, bean: Any, auditable: Auditable) {
		val code = auditable.value()
		// ... use code, bean, and jp
	}
----

对 `JoinPoint`,`ProceedingJoinPoint`, 和 `JoinPoint.StaticPart` 类型的第一个参数的特殊处理方便不收集任何其他连接点上下文的通知.  在这种情况下,可以简单地省略 `argNames` 属性. 例如,以下建议无需声明 `argNames` 属性:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Before("com.xyz.lib.Pointcuts.anyPublicMethod()")
	public void audit(JoinPoint jp) {
		// ... use jp
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Before("com.xyz.lib.Pointcuts.anyPublicMethod()")
	fun audit(jp: JoinPoint) {
		// ... use jp
	}
----

* 使用 `argNames` 属性有点笨拙,所以如果没有指定 `argNames` 属性,Spring AOP会查看该类的调试信息,并尝试从局部变量表中确定参数名称. 只要使用调试信息( `-g:vars` ) 编译类, 就会出现此信息.
使用此标志进行编译的后果是: (1).您的代码将容易被理解(逆向工程. (2). 类文件的大小将会有些大(通常不是什么事). (3). 对非使用本地变量的优化将不会应用于你的编译器.  换句话说,通过使用此标志构建,您应该不会遇到任何困难.
+
NOTE: 如果即使没有调试信息,AspectJ 编译器(`ajc`) 也编译了 `@AspectJ` 方面,则无需添加 `argNames` 属性,因为编译器会保留所需的信息.

* 如果代码是在没有必要的调试信息的情况下编译的,那么 Spring AOP 将尝试推断绑定变量与参数的配对(例如,如果在切点表达式中只绑定了一个变量,并且该通知方法只需要一个参数,此时两者匹配是明显的) .  如果给定了可用信息,变量的绑定是不明确的话,则会引发 `AmbiguousBindingException` 异常.
* 如果上述所有策略都失败,则抛出 `IllegalArgumentException` 异常.

[[aop-ataspectj-advice-proceeding-with-the-call]]
===== 处理参数

前面说过. 将描述如何用在 Spring AOP 和 AspectJ 中一致的参数中编写 `proceed` 处理函数. 解决方案是确保建议签名按顺序绑定每个方法参数.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Around("execution(List<Account> find*(..)) && " +
			"com.xyz.myapp.CommonPointcuts.inDataAccessLayer() && " +
			"args(accountHolderNamePattern)")
	public Object preProcessQueryPattern(ProceedingJoinPoint pjp,
			String accountHolderNamePattern) throws Throwable {
		String newPattern = preProcess(accountHolderNamePattern);
		return pjp.proceed(new Object[] {newPattern});
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Around("execution(List<Account> find*(..)) && " +
			"com.xyz.myapp.CommonPointcuts.inDataAccessLayer() && " +
			"args(accountHolderNamePattern)")
	fun preProcessQueryPattern(pjp: ProceedingJoinPoint,
							accountHolderNamePattern: String): Any {
		val newPattern = preProcess(accountHolderNamePattern)
		return pjp.proceed(arrayOf<Any>(newPattern))
	}
----

在许多情况下,无论如何都要执行此绑定(如前面的示例所示) .


[[aop-ataspectj-advice-ordering]]
==== 通知的顺序

当多个通知都希望在同一连接点上运行时会发生什么情况? Spring AOP 遵循与 AspectJ 相同的优先级规则来确定通知执行的顺序. 拥有最高优先权的通知会途中先"进入"(因此,给定两条前置通知,优先级最高的通知首先运行) .  从连接点"退出",拥有最高优先级的通知最后才运行(退出) ((因此,如果有两个后置通知,那么拥有最高优先级的将在最后运行(退出) ) .

如果在不同切面定义的两个通知都需要在同一个连接点运行,那么除非开发者指定运行的先后,否则执行的顺序是未定义的.  可以通过指定优先级来控制执行顺序. 这也是 Spring 推荐的方式,通过在切面类实现 `org.springframework.core.Ordered` 接口或使用 `@Order` 对其进行注解即可.
如果有两个切面,从 `Ordered.getOrder()`(或注解值) 返回较低值的方面具有较高的优先级.

[NOTE]
====
每一个切面的不同通知类型都应作用于连接点,因此 `@AfterThrowing` 通知方法不应该随同和 `@After`/`@AfterReturning`方法接收异常

从 Spring Framework 5.2.7 开始,在相同 `@Aspect` 类中定义的,需要在同一连接点运行的通知方法将根据其通知类型从高到低的优先级 `@Around`,`@Before` ,`@After`,`@AfterReturning`,`@AfterThrowing` (从高到低).
但是请注意,由于 Spring 的 `AspectJAfterAdvice` 中的实现方式,在同一切面中的任何 `@AfterReturning` 或 `@AfterThrowing` 通知方法之后,都会调用 `@After` 通知方法.遵循 AspectJ 的 `@After` 的 "after finally advice" 语义.

当在同一切面定义的两条通知都需要在同一个连接点上运行时,排序也是未定义的(因为没有办法通过反射检索Javac编译的类的声明顺序)  . 考虑将通知方法与一个通知方法合并,根据每个连接点在每个切面类或将通知切分为切面类,可以在切面级别指定顺序.

当在同一个 `@Aspect` 类中定义的两个相同类型的通知(例如,两个 `@After` 通知方法)都需要在同一个连接点上运行时,其顺序是不确定的(因为没有办法通过反射检索 Javac 编译的类的声明顺序).考虑将通知方法与一个通知方法合并,根据每个连接点在每个切面类或将重构为单独的 `@Aspect` 类,可以在切面级别 通过 `Ordered` 或 `@Order` 指定顺序.
考虑将此类建议方法折叠为每个 `@Aspect` 类中每个连接点的一个建议方法,或将建议重构为单独的 `@Aspect` 类,您可以在这些方面通过 `Ordered` 或 `@Order` 进行排序.
====

[[aop-introductions]]
=== 引入

引入(作为 AspectJ 中内部类型的声明) 允许切面定义通知的对象实现给定的接口,并代表这些对象提供该接口的实现.

引入使用 `@DeclareParents` 注解来定义,这个注解用于声明匹配拥有新的父类的类型(因此得名) . 例如, 给定名为 `UsageTracked` 的接口和名为 `DefaultUsageTracked` 的接口的实现,以下切面声明服务接口的所有实现者也实现 `UsageTracked` 接口(例如,通过JMX暴露统计信息) :

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Aspect
	public class UsageTracking {

		@DeclareParents(value="com.xzy.myapp.service.*+", defaultImpl=DefaultUsageTracked.class)
		public static UsageTracked mixin;

		@Before("com.xyz.myapp.CommonPointcuts.businessService() && this(usageTracked)")
		public void recordUsage(UsageTracked usageTracked) {
			usageTracked.incrementUseCount();
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Aspect
	class UsageTracking {

		companion object {
			@DeclareParents(value = "com.xzy.myapp.service.*+", defaultImpl = DefaultUsageTracked::class)
			lateinit var mixin: UsageTracked
		}

		@Before("com.xyz.myapp.CommonPointcuts.businessService() && this(usageTracked)")
		fun recordUsage(usageTracked: UsageTracked) {
			usageTracked.incrementUseCount()
		}
	}
----

要实现的接口由注解属性的类型来确定.  `@DeclareParents` 注解的 `value` 值是 AspectJ 类型模式引过来的. 任何匹配类型的 bean 实现了 `UsageTracked` 接口。注意上面例子中的前置通知, 服务 bean 可以直接作为 `UsageTracked` 接口的实现,如果以编程方式访问 bean,您将编写以下内容:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	UsageTracked usageTracked = (UsageTracked) context.getBean("myService");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val usageTracked = context.getBean("myService") as UsageTracked
----


[[aop-instantiation-models]]
=== 切面实例化模型

NOTE: 这是一个高级主题.  如果您刚刚开始使用 AOP,您可以跳过它直到稍后再了解.

默认情况下,应用程序上下文中的每个切面都有一个实例. AspectJ 将其称为单例实例化模型.  可以使用交替生命周期定义切面.  Spring 支持 AspectJ 的 `perthis` 和 `pertarget` 实例化模型(目前不支持 `percflow`, `percflowbelow`, 和 `pertypewithin`) .

您可以通过在 `@Aspect` 注解中指定 `perthis` 子句来声明相关方面.  请考虑以下示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Aspect("perthis(com.xyz.myapp.CommonPointcuts.businessService())")
	public class MyAspect {

		private int someState;

		@Before("com.xyz.myapp.CommonPointcuts.businessService()")
		public void recordServiceUsage() {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Aspect("perthis(com.xyz.myapp.CommonPointcuts.businessService())")
	class MyAspect {

		private val someState: Int = 0

		@Before(com.xyz.myapp.CommonPointcuts.businessService())
		fun recordServiceUsage() {
			// ...
		}
	}
----

在前面的示例中,`perthis` 子句的作用是为执行业务服务的每个唯一服务对象创建一个切面实例(每个唯一对象在由切点表达式匹配的连接点处绑定到 `this`) .  方法实例是在第一次在服务对象上调用方法时创建的.
当服务对象超出作用域时,该切面也将超出作用域. 在创建切面实例之前,它包含的任意通知都不会执行. 在创建了切面实例后, 其中声明的通知将在匹配的连接点中执行,但仅当服务对象是此切面关联的通知时才会运行. 有关 `per` 子句的更多信息,请参阅 AspectJ 编程指南.

`pertarget` 实例化模型的工作方式与 `perthis` 完全相同,但它为匹配的连接点处的每个唯一目标对象创建一个切面实例.

[[aop-ataspectj-example]]
=== AOP 例子

现在您已经了解了所有组成部分的工作原理,我们可以将它们放在一起做一些有用的事情.

由于并发问题(例如,死锁失败者) ,业务服务的执行有时会失败. 如果重试该操作,则可能在下次尝试时成功. 对于适合在这种情况下重试的业务服务(不需要返回给用户来解决冲突的幂等操作) .  希望透明地重试该操作,以避免客户端看到 `PessimisticLockingFailureException` 异常. 这个需求很明显,它跨越了服务层中的多个服务,因此非常适合通过切面来实现.

因为我们想要重试操作,所以我们需要使用环绕通知,以便我们可以多次调用 `proceed`.  以下清单显示了基本方面的实现:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Aspect
	public class ConcurrentOperationExecutor implements Ordered {

		private static final int DEFAULT_MAX_RETRIES = 2;

		private int maxRetries = DEFAULT_MAX_RETRIES;
		private int order = 1;

		public void setMaxRetries(int maxRetries) {
			this.maxRetries = maxRetries;
		}

		public int getOrder() {
			return this.order;
		}

		public void setOrder(int order) {
			this.order = order;
		}

		@Around("com.xyz.myapp.CommonPointcuts.businessService()")
		public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
			int numAttempts = 0;
			PessimisticLockingFailureException lockFailureException;
			do {
				numAttempts++;
				try {
					return pjp.proceed();
				}
				catch(PessimisticLockingFailureException ex) {
					lockFailureException = ex;
				}
			} while(numAttempts <= this.maxRetries);
			throw lockFailureException;
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Aspect
	class ConcurrentOperationExecutor : Ordered {

		private val DEFAULT_MAX_RETRIES = 2
		private var maxRetries = DEFAULT_MAX_RETRIES
		private var order = 1

		fun setMaxRetries(maxRetries: Int) {
			this.maxRetries = maxRetries
		}

		override fun getOrder(): Int {
			return this.order
		}

		fun setOrder(order: Int) {
			this.order = order
		}

		@Around("com.xyz.myapp.CommonPointcuts.businessService()")
		fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
			var numAttempts = 0
			var lockFailureException: PessimisticLockingFailureException
			do {
				numAttempts++
				try {
					return pjp.proceed()
				} catch (ex: PessimisticLockingFailureException) {
					lockFailureException = ex
				}

			} while (numAttempts <= this.maxRetries)
			throw lockFailureException
		}
	}
----

请注意,该方面实现了 `Ordered` 接口,以便我们可以将切面的优先级设置为高于事务通知(我们每次重试时都需要一个新的事务) .  `maxRetries` 和 `order` 属性都由 Spring 配置. 主要的操作是在 `doConcurrentOperation` 的环绕通知中.
请注意,请注意,目前,我们将重试逻辑应用于每个 `businessService()`.  尝试执行时,如果失败了,将产生 `PessimisticLockingFailureException` 异常,但是不用管它,只需再次尝试执行即可,除非已经用尽所有的重试次数.

相应的 Spring 配置如下:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspectj-autoproxy/>

	<bean id="concurrentOperationExecutor" class="com.xyz.myapp.service.impl.ConcurrentOperationExecutor">
		<property name="maxRetries" value="3"/>
		<property name="order" value="100"/>
	</bean>
----

为了优化切面以便它只重试幂等操作,我们可以定义以下 `Idempotent` 注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Retention(RetentionPolicy.RUNTIME)
	public @interface Idempotent {
		// marker annotation
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Retention(AnnotationRetention.RUNTIME)
	annotation class Idempotent// marker annotation
----

然后使用它来注解服务操作的实现. 对切面的更改只需要重试等幂运算,只需细化切点表达式,以便只匹配 `@Idempotent` 操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Around("com.xyz.myapp.CommonPointcuts.businessService() && " +
			"@annotation(com.xyz.myapp.service.Idempotent)")
	public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Around("com.xyz.myapp.CommonPointcuts.businessService() && " +
			"@annotation(com.xyz.myapp.service.Idempotent)")
	fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
		// ...
	}
----

[[aop-schema]]
== 基于 Schema 的 AOP 支持

如果您更喜欢基于 XML 的格式,Spring 还支持使用新的 `aop` 命名空间标签定义切面.
完全相同的切点表达式和通知类型在使用 `@AspectJ` 方式时同样得到支持. 因此,在本节中,我们将重点放在新语法上,并将读者引用到上一节(<<aop-ataspectj,@AspectJ 注解支持>>) 中的讨论,以了解编写切点表达式和通知参数的绑定.

要使用本节中描述的 `aop` 命名空间标签,您需要导入 `spring-aop` schema,如 <<core.adoc#core.appendix.xsd-schemas, 基于 XML 模式的配置中>> 所述. 有关如何在 aop 命名空间中导入标记,请参阅<<core.adoc#core.appendix.xsd-schemas-aop, AOP schema>>.

在 Spring 配置中,所有 aspect 和 advisor 元素必须放在 `<aop:config>` 元素中(在应用程序上下文配置中可以有多个 `<aop:config>` 元素) .  `<aop:config>` 元素可以包含切点,通知者和切面元素(请注意,这些元素必须按此顺序声明) .

WARNING: `<aop:config>` 配置样式大量使用了Spring的<<aop-autoproxy, 自动代理>> 机制.如果已经通过使用 `BeanNameAutoProxyCreator` 或类似的类使用了显式的自动代理, 则可能会出现问题(如通知还没被编织) .
建议的使用模式是仅使用 `<aop:config>` 样式或仅使用 `AutoProxyCreator` 样式,并且永远不要混用它们.

[[aop-schema-declaring-an-aspect]]
=== 声明切面

如果使用 schema,那么切面只是在 Spring 应用程序上下文中定义为 bean 的常规 Java 对象.在对象的字段和方法中获取状态和行为,并且在 XML 中获取切点和通知信息.

您可以使用 `<aop:aspect>` 元素声明方面,并使用 `ref` 属性引用支持 bean,如以下示例所示:


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:config>
		<aop:aspect id="myAspect" ref="aBean">
			...
		</aop:aspect>
	</aop:config>

	<bean id="aBean" class="...">
		...
	</bean>
----

支持切面的 bean (在这种情况下是 `aBean`) 当然可以像任何其他 Spring bean 一样配置和依赖注入.

[[aop-schema-pointcuts]]
=== 声明切点

您可以在 `<aop:config>` 元素中声明一个命名切点,让切点定义在多个切面和通知者之间共享.

表示服务层中任何业务服务执行的切点可以定义如下:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:config>

		<aop:pointcut id="businessService"
			expression="execution(* com.xyz.myapp.service.*.*(..))"/>

	</aop:config>
----

切点表达式本身使用的是相同的 AspectJ 切点表达式语言,如 <<aop-ataspectj,@Aspect 注解支持>> 所述. 如果使用基于 schema 的声明样式,则可以引用在切点表达式内的类型(`@Aspects`)中定义的命名切点 . 定义上述切入点的另一种方法如下:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:config>

		<aop:pointcut id="businessService"
			expression="com.xyz.myapp.CommonPointcuts.businessService()"/>

	</aop:config>
----

假设有一个 `CommonPointcuts` 的切面(如<<aop-common-pointcuts,共享通用的切点>>定义一节所述) .

切面声明切点与声明 top-level 切点非常相似,如下例所示:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:config>

		<aop:aspect id="myAspect" ref="aBean">

			<aop:pointcut id="businessService"
				expression="execution(* com.xyz.myapp.service.*.*(..))"/>

			...
		</aop:aspect>

	</aop:config>
----

与 `@AspectJ` 方面的方法相同,使用基于 schema 的定义样式声明的切点可能会收集连接点上下文. 例如,以下切点将 `this` 对象收集为连接点上下文并将其传递给通知:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:config>

		<aop:aspect id="myAspect" ref="aBean">

			<aop:pointcut id="businessService"
				expression="execution(* com.xyz.myapp.service.*.*(..)) &amp;&amp; this(service)"/>

			<aop:before pointcut-ref="businessService" method="monitor"/>

			...
		</aop:aspect>

	</aop:config>
----

必须通过包含匹配名称的参数来声明接收所收集的连接点上下文的通知,如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public void monitor(Object service) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun monitor(service: Any) {
		// ...
	}
----

在组合切点表达式中, `+&amp;&amp;+` 在 XML 文档中很难处理,因此您可以分别使用 `and`, `or` 和 `not` 分别用来代替 `+&amp;&amp;+`, `||`, 和 `!` . 例如,以前的切点可以更好地编写如下:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:config>

		<aop:aspect id="myAspect" ref="aBean">

			<aop:pointcut id="businessService"
				expression="execution(* com.xyz.myapp.service.*.*(..)) and this(service)"/>

			<aop:before pointcut-ref="businessService" method="monitor"/>

			...
		</aop:aspect>
	</aop:config>
----

以这种方式定义的切点由其 XML `id` 引用,不能用作命名切点以形成复合切点. 因此,基于 schema 定义样式中的命名切点比 `@AspectJ` 样式提供的受到更多的限制.


[[aop-schema-advice]]
=== 声明通知

同样的五种通知类型也支持 `@AspectJ` 样式,并且它们具有完全相同的语义.


[[aop-schema-advice-before]]
==== 前置通知

前置通知很明显是在匹配方法执行之前被调用, 它通过使用 `<aop:aspect>` 元素在 `<aop:aspect>` 中声明,如下例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspect id="beforeExample" ref="aBean">

		<aop:before
			pointcut-ref="dataAccessOperation"
			method="doAccessCheck"/>

		...

	</aop:aspect>
----

这里 `dataAccessOperation` 是在最外层的(`<aop:config>`)定义的切点 `id`. 若要以内联方式定义切点,请将 `pointcut-ref` 属性替换为 `pointcut` 属性. 如下所示:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:aspect id="beforeExample" ref="aBean">

		<aop:before
			pointcut="execution(* com.xyz.myapp.dao.*.*(..))"
			method="doAccessCheck"/>

		...

	</aop:aspect>
----

正如我们在讨论 `@AspectJ` 样式时所提到的,使用命名切点可以显着提高代码的可读性.

`method` 属性定义的 (`doAccessCheck`)方法用于通知的代码体内. 这个方法包含切面元素所引用的 bean. 在数据访问操作之前通知会被执行(当然连接点匹配中的切点), 即切面 bean 的 `doAccessCheck` 方法会被调用.

[[aop-schema-advice-after-returning]]
==== 后置返回通知

在匹配的方法执行正常完成后返回通知运行.  它在 `<aop:aspect>` 中以与前置通知相同的方式声明.  以下示例显示了如何声明它:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspect id="afterReturningExample" ref="aBean">

		<aop:after-returning
			pointcut-ref="dataAccessOperation"
			method="doAccessCheck"/>

		...

	</aop:aspect>
----

与 `@AspectJ` 样式一样,可以在通知代码体内获取返回值. 为此,使用 `returning` 属性定义参数的名字来传递返回值,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspect id="afterReturningExample" ref="aBean">

		<aop:after-returning
			pointcut-ref="dataAccessOperation"
			returning="retVal"
			method="doAccessCheck"/>

		...

	</aop:aspect>
----

`doAccessCheck` 方法必须声明一个名为 `retVal` 的参数,此参数的类型约束匹配的方式与 `@AfterReturning` 所描述的相同. 例如,您可以按如下方式声明方法签名:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public void doAccessCheck(Object retVal) {...
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun doAccessCheck(retVal: Any) {...
----


[[aop-schema-advice-after-throwing]]
==== 后置异常通知

就是匹配的方法运行抛出异常后后置异常通知会运行,它在 `<aop:aspect>` 中使用 `after-throwing` 元素声明. 如下例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspect id="afterThrowingExample" ref="aBean">

		<aop:after-throwing
			pointcut-ref="dataAccessOperation"
			method="doRecoveryActions"/>

		...

	</aop:aspect>
----

与 `@AspectJ` 样式一样,可以在通知代码体内获取抛出的异常,使用 `throwing` 属性定义参数的名字来传递异常. 如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspect id="afterThrowingExample" ref="aBean">

		<aop:after-throwing
			pointcut-ref="dataAccessOperation"
			throwing="dataAccessEx"
			method="doRecoveryActions"/>

		...

	</aop:aspect>
----

`doRecoveryActions` 方法必须声明名为 `dataAccessEx` 的参数. 此参数的类型约束匹配的方式与 `@AfterThrowing` 所描述的相同.  例如,方法签名可以声明如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public void doRecoveryActions(DataAccessException dataAccessEx) {...
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun doRecoveryActions(dataAccessEx: DataAccessException) {...
----


[[aop-schema-advice-after-finally]]
==== 后置通知(总会执行的)

当方法执行完成并退出后,后置通知会被执行(而且是总会被执行). 你可以使用 `after` 元素声明. 如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspect id="afterFinallyExample" ref="aBean">

		<aop:after
			pointcut-ref="dataAccessOperation"
			method="doReleaseLock"/>

		...

	</aop:aspect>
----


[[aop-schema-advice-around]]
==== 环绕通知

最后一种通知是环绕通知. 环绕通知 "around" 匹配的方法执行运行. 它有机会在方法执行之前和之后进行工作,并确定方法何时、 如何以及甚至是否真正执行. 环绕通知经常用于需要在方法执行前或后在线程安全的情况下共享状态(例如开始和结束时间) .

[TIP]
====
确认可使用的通知形式, 要符合最小匹配原则.

例如，如果 _before_ 通知足以满足您的需求，则不要使用 _around_ 通知。
====

您可以使用 `aop:around` 元素声明环绕通知. 通知方法应该以 `Object` 作为它的返回类型，第一个参数必须是 `ProceedingJoinPoint` 类型. 在通知代码体中,调用 `ProceedingJoinPoint` 实现的 `proceed()` 会使匹配的方法继续执行.
`proceed` 方法也可以通过传递 `Object[]` 数组的值给原方法作为传入参数. 有关调用继续使用 `Object[]` 的说明,请参阅 <<aop-ataspectj-around-advice>>.  以下示例显示如何在 XML 中声明通知:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspect id="aroundExample" ref="aBean">

		<aop:around
			pointcut-ref="businessService"
			method="doBasicProfiling"/>

		...

	</aop:aspect>
----

`doBasicProfiling` 通知的运行与 `@AspectJ` 示例中的完全相同(当然省略了注解) . 如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
		// start stopwatch
		Object retVal = pjp.proceed();
		// stop stopwatch
		return retVal;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun doBasicProfiling(pjp: ProceedingJoinPoint): Any {
		// start stopwatch
		val retVal = pjp.proceed()
		// stop stopwatch
		return pjp.proceed()
	}
----


[[aop-schema-params]]
==== 通知参数

基于 schema 的声明样式支持所有类型的通知,其方式与 `@AspectJ` 支持的描述相同 - 通过按名称匹配切点参数与通知方法参数相匹配. 有关详细信息,请参阅<<aop-ataspectj-advice-params,通知参数>>.
如果希望显式指定通知方法的参数名称(不依赖于前面描述的检测策略) 则使用通知元素的 `arg-names` 属性来完成这一操作. 其处理方式和通知注解中的 `argNames` 属性是相同的, 在通知注解中(如<<aop-ataspectj-advice-params-names,声明参数的名字>>中所述) .  以下示例显示如何在 XML 中指定参数名称:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:before
		pointcut="com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)"
		method="audit"
		arg-names="auditable"/>
----

`arg-names` 属性接受以逗号分隔的参数名称列表.

下面是一个基于 XSD 方式的多调用示例,它说明环绕通知是如何与一些强类型参数共同使用的:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package x.y.service;

	public interface PersonService {

		Person getPerson(String personName, int age);
	}

	public class DefaultPersonService implements PersonService {

		public Person getPerson(String name, int age) {
			return new Person(name, age);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package x.y.service

	interface PersonService {

		fun getPerson(personName: String, age: Int): Person
	}

	class DefaultPersonService : PersonService {

		fun getPerson(name: String, age: Int): Person {
			return Person(name, age)
		}
	}
----

接下来定义切面. 请注意,`profile(..)` 方法接受许多强类型参数,其中第一个是用于方法调用的连接点. 这个参数用于声明 `profile(..)` 作为环绕通知来使用,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package x.y;

	import org.aspectj.lang.ProceedingJoinPoint;
	import org.springframework.util.StopWatch;

	public class SimpleProfiler {

		public Object profile(ProceedingJoinPoint call, String name, int age) throws Throwable {
			StopWatch clock = new StopWatch("Profiling for '" + name + "' and '" + age + "'");
			try {
				clock.start(call.toShortString());
				return call.proceed();
			} finally {
				clock.stop();
				System.out.println(clock.prettyPrint());
			}
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.aspectj.lang.ProceedingJoinPoint
	import org.springframework.util.StopWatch

	class SimpleProfiler {

		fun profile(call: ProceedingJoinPoint, name: String, age: Int): Any {
			val clock = StopWatch("Profiling for '$name' and '$age'")
			try {
				clock.start(call.toShortString())
				return call.proceed()
			} finally {
				clock.stop()
				println(clock.prettyPrint())
			}
		}
	}
----

最后,下面是为特定连接点执行上述建议所需的 XML 配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd">

		<!-- this is the object that will be proxied by Spring's AOP infrastructure -->
		<bean id="personService" class="x.y.service.DefaultPersonService"/>

		<!-- this is the actual advice itself -->
		<bean id="profiler" class="x.y.SimpleProfiler"/>

		<aop:config>
			<aop:aspect ref="profiler">

				<aop:pointcut id="theExecutionOfSomePersonServiceMethod"
					expression="execution(* x.y.service.PersonService.getPerson(String,int))
					and args(name, age)"/>

				<aop:around pointcut-ref="theExecutionOfSomePersonServiceMethod"
					method="profile"/>

			</aop:aspect>
		</aop:config>

	</beans>
----

请考虑以下驱动程序脚本:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.springframework.beans.factory.BeanFactory;
	import org.springframework.context.support.ClassPathXmlApplicationContext;
	import x.y.service.PersonService;

	public final class Boot {

		public static void main(final String[] args) throws Exception {
			BeanFactory ctx = new ClassPathXmlApplicationContext("x/y/plain.xml");
			PersonService person = (PersonService) ctx.getBean("personService");
			person.getPerson("Pengo", 12);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun main() {
		val ctx = ClassPathXmlApplicationContext("x/y/plain.xml")
		val person = ctx.getBean("personService") as PersonService
		person.getPerson("Pengo", 12)
	}
----

使用这样的 Boot 类,我们将在标准输出上获得类似于以下内容的输出:

[literal,subs="verbatim,quotes"]
----
StopWatch 'Profiling for 'Pengo' and '12': running time (millis) = 0
-----------------------------------------
ms     %     Task name
-----------------------------------------
00000  ?  execution(getFoo)
----


[[aop-ordering]]
==== 通知的顺序

当多个通知需要在同一个连接点(执行方法) 执行时,排序规则如 <<aop-ataspectj-advice-ordering,通知的顺序>> 中所述.  方面之间的优先级是通过将 `order` 属性添加到 `<aop:aspect>` 元素或 `@Order` 注解添加到支持切面的 bean 或通过让 bean 实现 `Ordered` 接口来确定的.

[NOTE]
====
与在同一 `@Aspect` 类中定义的通知方法的优先规则相反,当在同一 `<aop:aspect>` 元素中定义的两条通知都需要在同一连接点上运行时,优先级由中的顺序确定在封闭的 `<aop:aspect>` 元素中声明的通知元素,从最高优先级到最低优先级.

例如,给定一个环绕通知和一个在同一 `<aop:aspect>` 元素中定义的,适用于同一连接点的前置通知,以确保环绕通知的优先级高于前置通知的 `<aop:around>` 元素必须在 `<aop:before>` 元素之前声明.

根据一般经验,如果发现在同一 `<aop:aspect>` 元素中定义了多个通知,这些通知适用于同一连接点,请考虑将这些通知方法合并成每个 `<aop:aspect>` 元素,或将通知重构为单独的 `<aop:aspect>` 元素,您可以在切面级别进行排序.
====

[[aop-schema-introductions]]
=== 引入

引入(作为 AspectJ 中内部类型的声明) 允许切面定义通知的对象实现给定的接口,并代表这些对象提供该接口的实现.

您可以在 `aop:aspect` 中使用 `aop:declare-parents` 元素进行引入.  您可以使用 `aop:declare-parents` 元素声明匹配类型具有父级(因此名称) .  例如,给定名为 `UsageTracked` 的接口和名为 `DefaultUsageTracked` 的接口的实现,以下方面声明服务接口的所有实现者也实现 `UsageTracked` 接口.  (例如,为了通过JMX暴露统计信息. )

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspect id="usageTrackerAspect" ref="usageTracking">

		<aop:declare-parents
			types-matching="com.xzy.myapp.service.*+"
			implement-interface="com.xyz.myapp.service.tracking.UsageTracked"
			default-impl="com.xyz.myapp.service.tracking.DefaultUsageTracked"/>

		<aop:before
			pointcut="com.xyz.myapp.CommonPointcuts.businessService()
				and this(usageTracked)"
				method="recordUsage"/>

	</aop:aspect>
----

然后,支持 `usageTracking` bean的类将包含以下方法:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public void recordUsage(UsageTracked usageTracked) {
		usageTracked.incrementUseCount();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun recordUsage(usageTracked: UsageTracked) {
		usageTracked.incrementUseCount()
	}
----

要实现的接口由 `implement-interface` 属性确定. `types-matching` 属性的值是 AspectJ 类型模式. 任何匹配类型的 bean 都将实现 `UsageTracked` 接口.  请注意,在前面的示例的通知中,服务 bean 可以直接用作 `UsageTracked` 接口的实现. 要以编程方式访问 bean,您可以编写以下代码:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	UsageTracked usageTracked = (UsageTracked) context.getBean("myService");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val usageTracked = context.getBean("myService") as UsageTracked
----

[[aop-schema-instatiation-models]]
=== 切面实例化模型

唯一受支持的 schema 定义的实例化模型是单例模型,在将来的版本中可能支持其他实例化模型.

[[aop-schema-advisors]]
=== 通知者

"`advisors`" 的概念是在 Spring 1.2 中提出的,能被 AOP 支持. 而在 AspectJ 中没有等价的概念. 通知者就像迷你的切面,包含单一的通知. 通知本身可以通过 bean 来代表,并且必须实现 Spring 中的 <<aop-api-advice-types>> 中描述的通知接口之一, 通知者可以利用 AspectJ 的切点表达式

Spring 使用 `<aop:advisor>` 元素支持通知者概念. 通常会看到它与事务性通知一起使用,它在 Spring 中也有自己的命名空间支持.  以下示例显示了一个通知者:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:config>

		<aop:pointcut id="businessService"
			expression="execution(* com.xyz.myapp.service.*.*(..))"/>

		<aop:advisor
			pointcut-ref="businessService"
			advice-ref="tx-advice"/>

	</aop:config>

	<tx:advice id="tx-advice">
		<tx:attributes>
			<tx:method name="*" propagation="REQUIRED"/>
		</tx:attributes>
	</tx:advice>
----

除了前面示例中使用的 `pointcut-ref` 属性之外,您还可以使用 `pointcut`  属性来内联定义切点表达式.

如果想将通知排序,可以定义通知者的优先级. 在通知者上可以使用 `order` 属性来定义 `Ordered` 值.


[[aop-schema-example]]
=== AOP Schema 例子

本节说明如何使用 Schema 支持重写 An AOP Example <<aop-ataspectj-example>> 中的并发锁定失败重试示例.

由于并发问题(例如,死锁失败者) ,业务服务的执行有时会失败. 如果重试该操作,则可能在下次尝试时成功. 对于适合在这种情况下重试的业务服务(不需要返回给用户来解决冲突的幂等操作) .  希望透明地重试该操作,以避免客户端看到 `PessimisticLockingFailureException` 异常. 这个需求很明显,它跨越了服务层中的多个服务,因此非常适合通过切面来实现.

因为我们想要重试操作,所以我们需要使用环绕通知,以便我们可以多次调用 `proceed`.  以下清单显示了基本方面的实现(使用 Schema 支持的常规 Java 类) :

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ConcurrentOperationExecutor implements Ordered {

		private static final int DEFAULT_MAX_RETRIES = 2;

		private int maxRetries = DEFAULT_MAX_RETRIES;
		private int order = 1;

		public void setMaxRetries(int maxRetries) {
			this.maxRetries = maxRetries;
		}

		public int getOrder() {
			return this.order;
		}

		public void setOrder(int order) {
			this.order = order;
		}

		public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
			int numAttempts = 0;
			PessimisticLockingFailureException lockFailureException;
			do {
				numAttempts++;
				try {
					return pjp.proceed();
				}
				catch(PessimisticLockingFailureException ex) {
					lockFailureException = ex;
				}
			} while(numAttempts <= this.maxRetries);
			throw lockFailureException;
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ConcurrentOperationExecutor : Ordered {

		private val DEFAULT_MAX_RETRIES = 2
		
		private var maxRetries = DEFAULT_MAX_RETRIES
		private var order = 1

		fun setMaxRetries(maxRetries: Int) {
			this.maxRetries = maxRetries
		}

		override fun getOrder(): Int {
			return this.order
		}

		fun setOrder(order: Int) {
			this.order = order
		}
		
		fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
			var numAttempts = 0
			var lockFailureException: PessimisticLockingFailureException
			do {
				numAttempts++
				try {
					return pjp.proceed()
				} catch (ex: PessimisticLockingFailureException) {
					lockFailureException = ex
				}

			} while (numAttempts <= this.maxRetries)
			throw lockFailureException
		}
	}
----

请注意,该方面实现了 `Ordered` 接口,以便我们可以将切面的优先级设置为高于事务通知(我们每次重试时都需要一个新的事务) .  `maxRetries` 和 `order` 属性都由 Spring 配置. 主要的操作是在 `doConcurrentOperation` 的环绕通知中. 请注意,请注意,目前,我们将重试逻辑应用于每个 `businessService()`.  尝试执行时,如果失败了,将产生 `PessimisticLockingFailureException` 异常,但是不用管它,只需再次尝试执行即可,除非已经用尽所有的重试次数.

NOTE: 此类与 `@AspectJ` 示例中使用的类相同,但删除了注解.

相应的Spring配置如下:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:config>

		<aop:aspect id="concurrentOperationRetry" ref="concurrentOperationExecutor">

			<aop:pointcut id="idempotentOperation"
				expression="execution(* com.xyz.myapp.service.*.*(..))"/>

			<aop:around
				pointcut-ref="idempotentOperation"
				method="doConcurrentOperation"/>

		</aop:aspect>

	</aop:config>

	<bean id="concurrentOperationExecutor"
		class="com.xyz.myapp.service.impl.ConcurrentOperationExecutor">
			<property name="maxRetries" value="3"/>
			<property name="order" value="100"/>
	</bean>
----

请注意,在当时,我们假设所有业务服务都是幂等的. 如果不是这种情况,我们可以通过引入 `Idempotent` 注解并使用注解来注解服务操作的实现来优化切面,使其重试时是幂等操作,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Retention(RetentionPolicy.RUNTIME)
	public @interface Idempotent {
		// marker annotation
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Retention(AnnotationRetention.RUNTIME)
	annotation class Idempotent {
		// marker annotation
	}
----

对切面的更改只需要重试等幂运算,只需细化切点表达式,以便只匹配 `@Idempotent` 操作,如下所示:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:pointcut id="idempotentOperation"
			expression="execution(* com.xyz.myapp.service.*.*(..)) and
			@annotation(com.xyz.myapp.service.Idempotent)"/>
----

[[aop-choosing]]
== 选择要使用的 AOP 声明样式

一旦确定某个切面是实现给定需求的最佳方法,您如何决定使用 Spring AOP 或 AspectJ 以及 Aspect语言(代码) 样式, `@AspectJ` 注解样式还是 Spring XML 样式? 这些决策受到许多因素的影响,包括应用程序要求,开发工具和团队对 AOP 的熟悉程度.


[[aop-spring-or-aspectj]]
=== 使用 Spring AOP 还是全面使用 AspectJ?

使用最简单的方法.  Spring AOP 比使用完整的 AspectJ 更 简单,因为不需要在开发和构建过程中引入 AspectJ 编译器/ 编织器. 如果只是需要在 Spring bean 上执行通知操作,那么使用 Spring AOP 是正确的选择.  如果需要的通知不是由 Spring 容器管理的对象(通常是域对象) ,那么就需要使用 AspectJ. 如果想使用通知连接点而不是简单的方法执行,也需要使用 AspectJ(例如,字段获取或设置连接点等) ,则还需要使用 AspectJ.

使用 AspectJ 时,您可以选择 AspectJ 语言语法(也称为 "代码样式") 或 `@AspectJ` 注解样式. 显然,如果没有使用 Java 5+ 版本那么选择已经确定了...使用代码方式.  如果切面在你的设计中扮演重要角色,并且想使用针对Eclipse的(https://www.eclipse.org/ajdt/[AspectJ 开发工具 (AJDT)] )  插件,那么 AspectJ 语言语法是首选项: 它更清晰和更简单,因为语言是专门用于编写切面的.
如果没有使用 Eclipse,或者只有一些切面在应用程序中不起主要作用,那么可能需要考虑使用 `@AspectJ` 方式,并在 IDE 中使用常规 Java 编译,并加入切面编织阶段构建的脚本.

[[aop-ataspectj-or-xml]]
=== 选择 @AspectJ 注解还是 Spring AOP 的 XML 配置?

如果您选择使用 Spring AOP,则可以选择 `@AspectJ` 或 XML 样式.  需要考虑各种权衡.

XML 样式可能是现有 Spring 用户最熟悉的,并且由真正的 POJO 支持. 当使用 AOP 作为一种工具来配置企业服务时, XML 就是一个很好的选择(可以用以下方法测试: 是否认为切入点表达式是想要独立改变的配置的一部分) .  使用 XML 配置的方式,可以从配置中更清楚地了解系统中存在哪些切面.

XML 样式有两个缺点. 首先,它并没有按实现的要求完全封装到单个地方. DRY 原则是说: 在任何知识系统中,应该有一个单一的、明确的、权威的职责. 使用 XML 的样式时,如果要求的知识是实现拆分的 bean 类的声明,并且是配置在文件的 XML 中.  当使用 `@AspectJ` 的风格实现单一的模块时,切面的信息是封装的. 其次,XML 的样式在能表达的功能方面比 `@AspectJ` 风格的有更多的限制,只有 "singleton" 切面的实例化模式得到支持,这在XML声明的切点中是不可能的.  例如,在 `@AspectJ` 样式中,您可以编写如下内容:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Pointcut("execution(* get*())")
	public void propertyAccess() {}

	@Pointcut("execution(org.xyz.Account+ *(..))")
	public void operationReturningAnAccount() {}

	@Pointcut("propertyAccess() && operationReturningAnAccount()")
	public void accountPropertyAccess() {}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Pointcut("execution(* get*())")
	fun propertyAccess() {}

	@Pointcut("execution(org.xyz.Account+ *(..))")
	fun operationReturningAnAccount() {}

	@Pointcut("propertyAccess() && operationReturningAnAccount()")
	fun accountPropertyAccess() {}
----

在 XML 样式中,您可以声明前两个切入点:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:pointcut id="propertyAccess"
			expression="execution(* get*())"/>

	<aop:pointcut id="operationReturningAnAccount"
			expression="execution(org.xyz.Account+ *(..))"/>
----


XML 的方法的缺点是,您无法通过组合这些定义来定义 `accountPropertyAccess` 切点.

`@AspectJ` 的风格支持更多的实例化模式和丰富的切点组合. 它的优点是将切面确保为单元模块化,`@AspectJ` 的使用对理解切面也很有优势(也很容易接受) , 无论是通过 Spring AOP 还是 AspectJ 的使用 .
所以如果决定需要 AspectJ 的能力解决额外的要求,然后迁移到一个基于 AspectJ 的方法,是非常简单的.  Spring 团队建议使用 `@AspectJ` 的方式.

[[aop-mixing-styles]]
== 混合切面类型

在实际应用中,完全有可能混合使用 `@AspectJ` 的切面方式,用于支持自动代理、schema 定义 `<aop:aspect>`,`<aop:advisor>` 声明通知者甚至在同一配置中定义使用 Spring 1.2 风格的代理和拦截器. 所有这些都是使用相同的底层支持机制实现的,并且可以愉快地共存.

[[aop-proxying]]
== 代理策略

Spring AOP 使用 JDK 动态代理或 CGLIB 为给定的代理创建代理目标对象.  JDK 中内置了 JDK 动态代理,而 CGLIB 是常见的开源类定义库(重新打包为 `spring-core`) .

如果要代理的目标对象实现至少一个接口,则使用 JDK 动态代理.  目标类型实现的所有接口都是代理的.  如果目标对象未实现任何接口,则会创建 CGLIB 代理.

如果要强制使用 CGLIB 代理(例如,代理为目标对象定义的每个方法,而不仅仅是那些由其接口实现的方法) ,您可以这样做.  但是,您应该考虑以下问题:

* `final` 声明为 `final` 的方法不能使用,因为它们不能被覆盖.
* 从 Spring 4.0 开始,代理对象的构造函数不再被调用两次, 因为 CGLIB 代理实例是通过 `Objenesis` 创建的.  仅当您的 JVM 执行不允许绕过构造函数,您可能会看到两次调用和 来自 Spring 的 AOP 支持的相应调试日志条目.

要强制使用 CGLIB 代理,请将 `<aop:config>` 元素的 `proxy-target-class` 属性的值设置为 `true`,如下所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:config proxy-target-class="true">
		<!-- other beans defined here... -->
	</aop:config>
----

要在使用 `@AspectJ` 自动代理支持时强制 CGLIB 代理,请将 `<aop:aspectj-autoproxy>` 元素的 `proxy-target-class` 属性设置为 `true`,如下所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspectj-autoproxy proxy-target-class="true"/>
----

[NOTE]
====
多个 `<aop:config/>` 选择被集合到一个统一的自动代理创建器中运行,它使用了一个强代理设置,这些配置是任意 `<aop:config/>` 的子代码段(通常是来自不同的 XML bean 定义文件)  . 这也适用于 `<tx:annotation-driven/>` 和 `<aop:aspectj-autoproxy/>`.

要明确的是,在 `<tx:annotation-driven/>`,`<aop:aspectj-autoproxy/>` 或 `<aop:config/>` 元素上使用 `proxy-target-class="true"` 会强制使用 CGLIB 代理 他们.
====

[[aop-understanding-aop-proxies]]
=== 理解 AOP 代理

Spring AOP 是基于代理的,在编写自定义切面或使用 Spring 框架提供的任何基于 Spring AOP 的切面前,掌握上一个语句的实际语义是非常重要的.

首先需要考虑的情况如下,假设有一个普通的、非代理的、没有什么特殊的、直接的引用对象. 如下面的代码片段所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimplePojo implements Pojo {

		public void foo() {
			// this next method invocation is a direct call on the 'this' reference
			this.bar();
		}

		public void bar() {
			// some logic...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimplePojo : Pojo {

		fun foo() {
			// this next method invocation is a direct call on the 'this' reference
			this.bar()
		}

		fun bar() {
			// some logic...
		}
	}
----

如果在对象引用上调用方法,则直接在该对象引用上调用该方法,如下图所示:

image::{image-resource}/aop-proxy-plain-pojo-call.png[]

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class Main {

		public static void main(String[] args) {
			Pojo pojo = new SimplePojo();
			// this is a direct method call on the 'pojo' reference
			pojo.foo();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun main() {
		val pojo = SimplePojo()
		// this is a direct method call on the 'pojo' reference
		pojo.foo()
	}
----

当客户端代码是代理的引用时,事情发生了细微的变化. 请考虑以下图表和代码段:

image::{image-resource}/aop-proxy-call.png[]

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class Main {

		public static void main(String[] args) {
			ProxyFactory factory = new ProxyFactory(new SimplePojo());
			factory.addInterface(Pojo.class);
			factory.addAdvice(new RetryAdvice());

			Pojo pojo = (Pojo) factory.getProxy();
			// this is a method call on the proxy!
			pojo.foo();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
fun main() {
	val factory = ProxyFactory(SimplePojo())
	factory.addInterface(Pojo::class.java)
	factory.addAdvice(RetryAdvice())

	val pojo = factory.proxy as Pojo
	// this is a method call on the proxy!
	pojo.foo()
}
----

这里要理解的关键是 `Main` 类的 `main(..)` 方法中的客户端代码具有对代理的引用. 这意味着对该对象引用的方法将在代理上调用,因此代理将能够委托与该特定方法调用相关的所有拦截器(通知) .
然而,一旦调用终于达到了目标对象(在这个例子中是 `SimplePojo` 引用) ,任何方法调用都会传递给他,例如 `this.bar()` 或 `this.foo()`, 都会调用这个引用,而不是代理. 这具有重要的意义,这意味着自我调用不会导致与方法调用相关联的通知,从而也不会获得执行的机会.

好的,那要做些什么呢? 最好的方法(这个 "`best`" , 的,也是迫不得已的) 是重构代码,以便不会发生自我调用. 这确实需要您做一些工作,但这是最好的,最少侵入性的方法.  下一个办法绝对是可怕的,我几乎不愿意指出,正是因为它是如此可怕. 您可以(对我们来说很痛苦) 将类中的逻辑完全绑定到 Spring AOP,如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimplePojo implements Pojo {

		public void foo() {
			// this works, but... gah!
			((Pojo) AopContext.currentProxy()).bar();
		}

		public void bar() {
			// some logic...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimplePojo : Pojo {

		fun foo() {
			// this works, but... gah!
			(AopContext.currentProxy() as Pojo).bar()
		}

		fun bar() {
			// some logic...
		}
	}
----

这完全将代码与 AOP 相耦合,这使类本身意识到它正在 AOP 上下文中使用,犹如在 AOP 面前耍大刀一般. 当创建代理时,它还需要一些额外的配置. 如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class Main {

		public static void main(String[] args) {
			ProxyFactory factory = new ProxyFactory(new SimplePojo());
			factory.addInterface(Pojo.class);
			factory.addAdvice(new RetryAdvice());
			factory.setExposeProxy(true);

			Pojo pojo = (Pojo) factory.getProxy();
			// this is a method call on the proxy!
			pojo.foo();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun main() {
		val factory = ProxyFactory(SimplePojo())
		factory.addInterface(Pojo::class.java)
		factory.addAdvice(RetryAdvice())
		factory.isExposeProxy = true

		val pojo = factory.proxy as Pojo
		// this is a method call on the proxy!
		pojo.foo()
	}
----

最后,必须注意的是 AspectJ 没有这种自我调用问题,因为它不是基于代理的 AOP 框架.

[[aop-aspectj-programmatic]]
== 编程创建@AspectJ代理

除了在配置中使用 `<aop:config>` 或 `<aop:aspectj-autoproxy>` 来声明切面外,还可以使用编程的方式创建代理的通知目标对象.  有关 Spring 的 AOP API 的完整详细信息,请参阅<<aop-api, 下一章>>. 在这里,我们的关注点是希望使用@AspectJ方面自动创建代理的能力.

您可以使用 `org.springframework.aop.aspectj.annotation.AspectJProxyFactory` 类为一个或多个 `@AspectJ` 切面通知的目标对象创建代理.  此类的基本用法非常简单,如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// create a factory that can generate a proxy for the given target object
	AspectJProxyFactory factory = new AspectJProxyFactory(targetObject);

	// add an aspect, the class must be an @AspectJ aspect
	// you can call this as many times as you need with different aspects
	factory.addAspect(SecurityManager.class);

	// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect
	factory.addAspect(usageTracker);

	// now get the proxy object...
	MyInterfaceType proxy = factory.getProxy();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// create a factory that can generate a proxy for the given target object
	val factory = AspectJProxyFactory(targetObject)

	// add an aspect, the class must be an @AspectJ aspect
	// you can call this as many times as you need with different aspects
	factory.addAspect(SecurityManager::class.java)

	// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect
	factory.addAspect(usageTracker)

	// now get the proxy object...
	val proxy = factory.getProxy<Any>()
----

See the {api-spring-framework}/aop/aspectj/annotation/AspectJProxyFactory.html[javadoc] for more information.


[[aop-using-aspectj]]
== 在 Spring 应用中使用 AspectJ

到目前为止,我们在本章中介绍的所有内容都是纯粹的 Spring AOP. 将介绍如何使用 AspectJ 编译器/编织器代替 AOP,还介绍了超越 Spring AOP 而单独提供的功能.

Spring 有一个小的 AspectJ 切面库,是一个单独管理的 `spring-aspects.jar` 包. 如果使用到切面那么需要将它添加到类路径中. 在使用<<aop-atconfigurable,Spring 中的 AspectJ 独立注入域对象>> 和 在 Spring 中使用的 <<aop-ajlib-other,AspectJ 另外的切面>> 会讨论这个库的内容以及如何使用.
使用 Spring 的 IoC<<aop-aj-configure,配置 AspectJ 切面>> 讨论如何依赖于使用 AspectJ 编译器编织的 AspectJ 切面. 最后, 在 在 Spring 框架中使用<<aop-aj-ltw,AspectJ 的加载时织入>> 将讨论在 Spring 的应用中使用 AspectJ 涉及的编织时机的讨论.


[[aop-atconfigurable]]
=== 使用 Spring 中的 AspectJ 独立注入域对象

Spring 容器实例化和配置会在应用程序上下文中定义 bean. 也可以让 bean 工厂配置预先存在的对象,给定一个包含要应用的配置的 bean 定义名称. `spring-aspects.jar` 包含了注解驱动的切面, 利用这个功能来允许依赖注入到任意对象. 该支持旨在用于在创建任何容器控制之外的对象. 域对象通常属于这一类,因为它们通常是使用 `new` 的操作符以编程方式创建的,或由 ORM 工具为数据库查询的结果创建的.

`@Configurable` 注解标记一个类符合 Spring 驱动配置的条件,在最简单的情况下,您可以纯粹使用它作为标记注解,如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package com.xyz.myapp.domain;

	import org.springframework.beans.factory.annotation.Configurable;

	@Configurable
	public class Account {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package com.xyz.myapp.domain

	import org.springframework.beans.factory.annotation.Configurable

	@Configurable
	class Account {
		// ...
	}
----

作为这样一个标识接口, Spring 将会为这个注解类型(在例子中是 `Account`) 利用定义 bean 的方式(典型的原型作用域) 配置一个新实例, 这个实例拥有与完全限定类型相同的名字(`com.xyz.myapp.domain.Account`).
因为一个 bean 的默认名称是它的类型的完全限定名,这个简便的方式只是省略了它的 `id` 属性. 如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="com.xyz.myapp.domain.Account" scope="prototype">
		<property name="fundsTransferService" ref="fundsTransferService"/>
	</bean>
----

如果想要显式指定为原型 bean 使用的名称,可以直接在注解执行此操作,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package com.xyz.myapp.domain;

	import org.springframework.beans.factory.annotation.Configurable;

	@Configurable("account")
	public class Account {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package com.xyz.myapp.domain

	import org.springframework.beans.factory.annotation.Configurable

	@Configurable("account")
	class Account {
		// ...
	}
----

Spring 现在查找名为 `account` 的bean定义,并将其用作配置新 `Account` 实例的定义.

也可以使用自动装配以避免指定一个特定的专用 bean 定义. Spring 将利用 `@Configurable` 注解的自动装配属性来自动装配 bean,可以使用 `@Configurable(autowire=Autowire.BY_NAME` 或者 `@Configurable(autowire=Autowire.BY_TYPE)` 分别自动装配基于名称和基于类型的 bean.作为替代方法,您可以在其类上或方法级别上使用 `@Autowired` 或 `@Inject` 能够使用注解驱动的依赖注入.  有关更多详细信息,请参阅 <<beans-annotation-config>> 基于注解的容器配置.

最后,可以使用 Spring 依赖的名为 `dependencyCheck` 的特性去检查新建的对象引用以及配置对象(例如, `@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)`)  . 如果将此特性设置为 `true`,那么 Spring 将在配置之后确认所有属性(非原始或集合) 已被设置.

当然,使用注解本身没有任何作用. 这是 `spring-aspects.jar` 包中的 `AnnotationBeanConfigurerAspect` 注解的存在行为. 实质上, 该切面表达的是,一个带有 `@Configurable` 注解类型的新对象在初始化返回之后,按照注解的属性使用 Spring 配置创建新的对象.
在这种情况下,初始化是指新实例化的对象(例如, 用 `new` 运算符实例化的对象) 以及正在经历反序列化(例如,通过 https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html[readResolve()]) 的 `Serializable` 对象.

[NOTE]
=====
上一段的一个关键短语是 "实质".. 在大多数情况下,精确的语义从一个新对象初始化后返回是适合的. "初始化后"意味着依赖将会在对象被构建完毕后注入 , 这意味着依赖在类构造器当中是不能使用的. 如果想依赖的注入发生在构造器执行之前,而且能够用在构造器之中,那么需要像下面这样声明 `@Configurable`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configurable(preConstruction = true)
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configurable(preConstruction = true)
----

您可以在 https://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html[本附录]  中 https://www.eclipse.org/aspectj/doc/next/progguide/index.html[AspectJ编程指南]一书中找到更多有关 AspectJ 的信息
=====

这个注解类型必须使用 AspectJ 编织织入才可以工作 , 开发者可以使用构建组件 Ant 或 Maven 来完成这个任务(https://www.eclipse.org/aspectj/doc/released/devguide/antTasks.html[AspectJ Development
Environment Guide]有参考例子) ,或者在装配时织入(请参考 在 Spring 框架中使用<<aop-aj-ltw,AspectJ 的加载时织入>>) .
`AnnotationBeanConfigurerAspect` 注解本身需要 Spring 来配置(为了获取一个 bean 工厂引用,被用于配置新的对象) . 如果使用基于 Java 的配置, 那么只需将 `@EnableSpringConfigured` 注解加入到任意的 `@Configuration` 类中即可,如下所示:


[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableSpringConfigured
	public class AppConfig {
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableSpringConfigured
	class AppConfig {
	}
----

如果基于 XML 配置,那么只要在 Spring<<core.adoc#core.appendix.xsd-schemas-context, `context` 命名空间>>声明中添加 `context:spring-configured`.
您可以按如下方式使用它:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<context:spring-configured/>
----

在配置切面之前创建 `@Configurable` 对象的实例将会向调试日志发消息,并且不会对该对象进行配置. 一个例子是在 Spring 配置中的一个 bean,它在 Spring 初始化时创建域对象.  在这种情况下,可以使用 `depends-onbean` 属性来手动指定 bean 依赖的切面配置. 以下示例显示了如何使用 `depends-on` 属性:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="myService"
			class="com.xzy.myapp.service.MyService"
			depends-on="org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect">

		<!-- ... -->

	</bean>
----

NOTE: 不用通过 bean 的切面配置来激活 `@Configurable` 处理过程,除非真的想在运行中依赖其语义. 特别地,不要在一个已经在容器上注册过的 Spring bean 上去再去使用 `@Configurable` 注解.  否则,这个 bean 将会被初始化两次,容器一次,切面一次.


[[aop-configurable-testing]]
==== 单元测试 `@Configurable` 的对象

开启 `@Configurable` 支持的一个目标就是使单元测试独立于域对象,从而没有碰到诸如硬编码查找一样的困难. 如果 `@Configurable` 注解没有使用 AspectJ 织入那么它就不会对单元测试造成影响, 这样就可以正常地进行 mock 或 stub 测试.
如果 `@Configurable` 是使用 AspectJ 织入的,那么依然可以在容器之外正常地进行单元测试,但是如果每次都构建一个 `@Configurable` 对象都会看到警告消息, 它表示此配置并非 Spring 的配置.

[[aop-configurable-container]]
==== 多个应用上下文一起工作

`AnnotationBeanConfigurerAspect` 类在AspectJ中用来实现 `@Configurable` 支持的单个切面. 单个切面的作用域与静态成员的作用域是相同的, 也就是说每一个类加载器都会定义这个切面的实例类型. 这意味着,如果使用相同的类加载器层来定义多个应用上下文. 那么必须考虑在哪儿定义 `@EnableSpringConfigured` bean以及在哪个路径存放 `spring-aspects.jar` 包.

考虑一个典型的 Spring Web 应用程序配置,其中有一个共享的父应用上下文,定义公共业务服务和支持它们所需的所有内容,每个Servlet包含一个子应用上下文, 其中包含特定于Servlet的定义. 所有这些上下文共存于相同的类加载器层次,所以 `AnnotationBeanConfigurerAspect` 能够持有他们之中的一个的引用. 在这种情况下, 建议在共享的(父) 应用上下文上使用 `@EnableSpringConfigured` bean 定义,这个定义的服务,
可能想注入到域对象中. 结果是,开发者不能在子上下文(特定的 Servlet)  中使用 `@Configurable` 去定义域对象的引用bean(也许并不想做些什么) .

在同一个容器部署多个 Web 应用程序时,确保每个 Web 应用程序加载 `spring-aspects.jar` 类型是在使用自己的加载器引用(例如,通过 `WEB-INF/lib`) . 如果 `spring-aspects.jar` 仅在容器的类路径下(也就是装在父母共享的加载器的引用) ,所有 的 Web 应用程序将共享相同的切面实例,而这可能不是你想要的.

[[aop-ajlib-other]]
=== 在Spring中使用的AspectJ额外的切面

除了 `@Configurable` 切面,`spring-aspects.jar` 还包含 AspectJ 切面,可以用来驱动 Spring 的事务管理,用于注解带 `@Transactional` 注解的类型和方法 . 这主要是为那些希望在 Spring 容器之外使用 Spring 框架的事务支持的用户而设计的.

解析 `@Transactional` 注解的切面是 `AnnotationTransactionAspect`. 当使用这个切面时,必须注解这个实现类(和/或在类的方法上) ,不是接口(如果有的话)  的实现类. AspectJ 遵循 Java 的规则,注解的接口不能被继承.

`@Transactional` 注解的类指定默认的事务语义的各种公共操作的类.

在类的方法上注解 `@Transactional` 将会覆盖由给定默认事务语义的注解(如果存在) ,任意可见性的方法都可以被注解,包括私有方法. 直接注解非公共方法是获得执行此类方法的事务划分的唯一方法.

TIP: 从 Spring Framework 4.2 开始, `spring-aspects` 提供了类似的切面,为标准的 `jakarta.transaction.Transactional` 注解提供了完全相同的功能.  查看
`JtaAnnotationTransactionAspect` 获取更多细节.

对于希望使用 Spring 配置和事务管理支持但不希望(或不能) 使用注解的 AspectJ 程序员, `spring-aspects.jar` 还包含可以扩展以提供自定义切点定义的抽象切面.  有关更多信息,请参阅 `AbstractBeanConfigurerAspect` 和 `AbstractTransactionAspect` 切面的源码.
作为示例,以下摘录显示了如何使用与完全限定的类名匹配的原型 bean 定义来编写一个切面 ,用于配置 domain 模型中定义的所有对象实例:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public aspect DomainObjectConfiguration extends AbstractBeanConfigurerAspect {

		public DomainObjectConfiguration() {
			setBeanWiringInfoResolver(new ClassNameBeanWiringInfoResolver());
		}

		// the creation of a new bean (any object in the domain model)
		protected pointcut beanCreation(Object beanInstance) :
			initialization(new(..)) &&
			CommonPointcuts.inDomainModel() &&
			this(beanInstance);
	}
----



[[aop-aj-configure]]
=== 使用 Spring IoC 配置 AspectJ 切面

当在 Spring 应用中使用 AspectJ 的切面时,很自然的希望能够使用 Spring 来配置切面. AspectJ 运行时本身是负责创建和配置切面的, AspectJ 通过 Spring 创建切面取决于 AspectJ 实例化模型的方法(`per-xxx` 引起的) 的切面使用.

多数的 AspectJ 切面是单例切面. 这些切面的配置非常容易,只需正常地创建一个 bean 定义引用切面的类型,包含 bean 属性 `factory-method="aspectOf"` . 这保证了 Spring 获得的是 AspectJ 的实例而不是试图创建实例本身的切面. 下示例显示如何使用 `factory-method="aspectOf"` 属性:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="profiler" class="com.xyz.profiler.Profiler"
			factory-method="aspectOf"> <1>

		<property name="profilingStrategy" ref="jamonProfilingStrategy"/>
	</bean>
----
<1> 注意 `factory-method="aspectOf"` 属性


非单例切面很难配置,但是这样做也是有可能的,通过创建原型 bean 的定义和从 `spring-aspects.jar` 中使用 `@Configurable` 的支持. 这些工作需要在 AspectJ 运行之后在创建之中去配置切面实例才能成功.

如果想要使用 AspectJ 编写一些 `@AspectJ` 切面(例如,针对领域模型类型使用加载时编织) 以及希望与 Spring AOP 一起使用的其他 `@AspectJ` 切面,并且这些切面都使用 Spring 进行配置 .  那么需要告诉 Spring AOP `@AspectJ` 自动代理支持在配置中定义的 `@AspectJ` 方面的确切子集应该用于自动代理. 可以通过在 `<aop:aspectj-autoproxy/>` 元素中声明使用一个或多个 `<include/>` 元素来完成此操作.
每个 `<include/>` 元素指定一个名称模式,并且只有名称与至少一个模式相匹配的 bean 才会用于 Spring AOP 自动代理配置. 以下示例显示了如何使用 `<include/>` 元素:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<aop:aspectj-autoproxy>
		<aop:include name="thisBean"/>
		<aop:include name="thatBean"/>
	</aop:aspectj-autoproxy>
----

NOTE: 不要被 `<aop:aspectj-autoproxy/>` 元素的名称误导.  使用它会导致创建 Spring AOP 代理.  切面声明的 `@AspectJ` 方式只是在这里使用,AspectJ 运行时是没有用到的.

[[aop-aj-ltw]]
=== 在 Spring 框架中使用 AspectJ 的加载时织入

是指 AspectJ 切面在 JVM 加载类文件时被织入到程序的类文件的过程. 本部分的重点是配置和使用 LTW 在 Spring 框架上的具体内容,本节不是 LTW 的简介.  只有 AspectJ 能够详细地讲述 LTW 的特性和配置(与 Spring 完全没有关系) ,可以参看 https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html[LTW section of the AspectJ
Development Environment Guide].

Spring 框架在 AspectJ 的 LTW 织入的过程中提供了更细粒度的控制,'Vanilla' AspectJ LTW 是一个高效的使用 Java(1.5+) 的代理,它会在 JVM 启动的时候改变一个 VM 参数.  这是一种 JVM 范围的设置,在某些情况下可能会很适合,但是太粗粒度了. Spring 的 LTW 能够为 LTW 提供类加载前的织入,显然这是一个更细粒度的控制,而且它在 `'single-JVM-multiple-application'` 的环境下更具意义(在典型的应用程序服务器环境中就是这样做的) .

此外,在特定的环境中(查看<<aop-aj-ltw-environments, 在某些环境>>) ,这种方式可以在对应用程序服务器运行脚本不做任何修改的情形下支持 LTW, 但需要添加 `-javaagent:path/to/aspectjweaver.jar`(本节稍后将会描述) 或 `-javaagent:path/to/org.springframework.instrument-{version}.jar`(原名为 spring-agent.jar) .  开发人员只需修改构成应用程序上下文的一个或多个文件,以启用加载时编入,而不是依赖通常负责部署配置的管理文件. 例如启动脚本.

到此为止,推销宣传部分已经结束了,那么让我们首先介绍使用 Spring 的 AspectJ LTW 的快速示例,然后详细介绍示例中介绍的元素.  有关完整示例,请参阅 https://github.com/spring-projects/spring-petclinic[Petclinic示例应用程序].

[[aop-aj-ltw-first-example]]
==== 第一个例子

假设您是一名应用程序开发人员,负责诊断系统中某些性能问题的原因. 我们无需打开一个分析工具,而是要打开一个简单的剖析切面,让我们能够很快获得了一些性能指标, 这样我们就可以在随后立即使用更细粒度的分析工具.

NOTE: 这里介绍的例子使用 XML 格式的配置,也可以使用 <<beans-java, Java配置>>和 `@AspectJ` 的方式. 特别是 `@EnableLoadTimeWeaving` 注解可以起 到替代 `<context:load-time-weaver/>` (<<aop-aj-ltw-spring, 详情见下文>> ) .

下面是一个用于性能分析的切面,它不需要太花哨,它是一个基于时间的分析器,它使用 `@AspectJ` 样式的方面声明:

[source,java,indent=0,subs="verbatim",role="primary"]
.Java
----
	package foo;

	import org.aspectj.lang.ProceedingJoinPoint;
	import org.aspectj.lang.annotation.Aspect;
	import org.aspectj.lang.annotation.Around;
	import org.aspectj.lang.annotation.Pointcut;
	import org.springframework.util.StopWatch;
	import org.springframework.core.annotation.Order;

	@Aspect
	public class ProfilingAspect {

		@Around("methodsToBeProfiled()")
		public Object profile(ProceedingJoinPoint pjp) throws Throwable {
			StopWatch sw = new StopWatch(getClass().getSimpleName());
			try {
				sw.start(pjp.getSignature().getName());
				return pjp.proceed();
			} finally {
				sw.stop();
				System.out.println(sw.prettyPrint());
			}
		}

		@Pointcut("execution(public * foo..*.*(..))")
		public void methodsToBeProfiled(){}
	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	package foo

	import org.aspectj.lang.ProceedingJoinPoint
	import org.aspectj.lang.annotation.Aspect
	import org.aspectj.lang.annotation.Around
	import org.aspectj.lang.annotation.Pointcut
	import org.springframework.util.StopWatch
	import org.springframework.core.annotation.Order

	@Aspect
	class ProfilingAspect {

		@Around("methodsToBeProfiled()")
		fun profile(pjp: ProceedingJoinPoint): Any {
			val sw = StopWatch(javaClass.simpleName)
			try {
				sw.start(pjp.getSignature().getName())
				return pjp.proceed()
			} finally {
				sw.stop()
				println(sw.prettyPrint())
			}
		}

		@Pointcut("execution(public * foo..*.*(..))")
		fun methodsToBeProfiled() {
		}
	}
----

此外还需要创建一个 `META-INF/aop.xml` 文件,它将通知 AspectJ 将 `ProfilingAspect` 织入到类中. 这是文件的惯例, 即在 Java 类路径中存在名为 `META-INF/aop.xml` 的文件(或多个文件) 是标准 AspectJ.  以下示例显示了 `aop.xml` 文件:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!DOCTYPE aspectj PUBLIC "-//AspectJ//DTD//EN" "https://www.eclipse.org/aspectj/dtd/aspectj.dtd">
	<aspectj>

		<weaver>
			<!-- only weave classes in our application-specific packages -->
			<include within="foo.*"/>
		</weaver>

		<aspects>
			<!-- weave in just this aspect -->
			<aspect name="foo.ProfilingAspect"/>
		</aspects>

	</aspectj>
----

现在来配置的 Spring 特定部分.  我们需要配置 `LoadTimeWeaver`(稍后解释) . LTW 是从一个或多个 `META-INF/aop.xml` 文件中织入到应用类的切面配置的主要部分. 幸运的是它不需要大量的配置,如下所示(还有一些选项可以指定,但是后面会详细介绍) . 如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<!-- a service object; we will be profiling its methods -->
		<bean id="entitlementCalculationService"
				class="foo.StubEntitlementCalculationService"/>

		<!-- this switches on the load-time weaving -->
		<context:load-time-weaver/>
	</beans>
----

现在所有必需的材料( aspect, `META-INF/aop.xml` 文件, Spring 的配置) 都已到位,我们可以使用 `main(..)` 方法创建以下驱动程序类,以演示 LTW 的运行情况:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package foo;

	import org.springframework.context.support.ClassPathXmlApplicationContext;

	public final class Main {

		public static void main(String[] args) {
			ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml", Main.class);

			EntitlementCalculationService entitlementCalculationService =
					(EntitlementCalculationService) ctx.getBean("entitlementCalculationService");

			// the profiling aspect is 'woven' around this method execution
			entitlementCalculationService.calculateEntitlement();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package foo

	import org.springframework.context.support.ClassPathXmlApplicationContext

	fun main() {
		val ctx = ClassPathXmlApplicationContext("beans.xml")

		val entitlementCalculationService = ctx.getBean("entitlementCalculationService") as EntitlementCalculationService

		// the profiling aspect is 'woven' around this method execution
		entitlementCalculationService.calculateEntitlement()
	}
----

我们还有最后一件事要做.  本节的介绍确实说可以使用 Spring 在每个 `ClassLoader` 的基础上有选择地打开 LTW,这是事实.  但是,对于此示例,我们使用 Java 代理(随 Spring 提供) 来打开 LTW.  我们使用以下命令来运行前面显示的 `Main` 类:

[literal,subs="verbatim,quotes"]
----
java -javaagent:C:/projects/foo/lib/global/spring-instrument.jar foo.Main
----

`-javaagent` 是一个标志,用于指定和启用 https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html[代理程序来检测在 JVM 上运行的程序]. Spring Framework 附带了一个代理程序 `InstrumentationSavingAgent`, 它包装在 `spring-instrument.jar` 中,它作为前面示例中 `-javaagent` 参数的值提供.

`Main` 的输出将如下所示. (前面已经介绍了 `Thread.sleep(..)` 声明为 `calculateEntitlement()` 实现使分析器实际上捕获了比 0 毫秒更多的东西(`01234` 毫秒不是 AOP 引入的开销)  ) 下面的清单显示了输出 我们运行我们的探查器时得到了:

[literal,subs="verbatim,quotes"]
----
Calculating entitlement

StopWatch 'ProfilingAspect': running time (millis) = 1234
------ ----- ----------------------------
ms     %     Task name
------ ----- ----------------------------
01234  100%  calculateEntitlement
----

由于 LTW 是会对 AspectJ 产生影响的,而不是仅仅局限在 Spring 的 beans. 在 `Main` 程序的轻微变化会产生相同的结果:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package foo;

	import org.springframework.context.support.ClassPathXmlApplicationContext;

	public final class Main {

		public static void main(String[] args) {
			new ClassPathXmlApplicationContext("beans.xml", Main.class);

			EntitlementCalculationService entitlementCalculationService =
					new StubEntitlementCalculationService();

			// the profiling aspect will be 'woven' around this method execution
			entitlementCalculationService.calculateEntitlement();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package foo

	import org.springframework.context.support.ClassPathXmlApplicationContext

	fun main(args: Array<String>) {
		ClassPathXmlApplicationContext("beans.xml")

		val entitlementCalculationService = StubEntitlementCalculationService()

		// the profiling aspect will be 'woven' around this method execution
		entitlementCalculationService.calculateEntitlement()
	}
----

请注意,在前面的程序中,我们如何引导 Spring 容器,然后在 Spring 的上下文之外创建一个新的 `StubEntitlementCalculationService` 实例.  分析通知依然会被编织.

不可否认,这个例子很简单. 但是在 Spring 中支持 LTW 的基础都介绍到了,而且为什么使用以及怎样使用配置在后面的章节也将解释.

NOTE: 在这个例子中使用的 `ProfilingAspect` 可能很基础的,但它非常有用. 是一个开发者可以使用在开发过程中使用开发时间切面的例子, 然后很容易地排除来自应用程序被部署到测试或生产中的因素.

[[aop-aj-ltw-the-aspects]]
==== 切面

在 LTW 使用的 aspects 必须是 AspectJ 的切面. 它们可以写在 AspectJ 语言本身也可以在 `@AspectJ` 方式声明. 这意味着 aspects 在 AspectJ 和 Spring AOP 的切面都有效.  此外,编译切面的类需要包含在类路径中.

[[aop-aj-ltw-aop_dot_xml]]
==== 'META-INF/aop.xml'

使用 AspectJ LTW 的基础设施是一个或多个 `META-INF/aop.xml` 配置文件,这是在 Java 类路径中的(直接的或者更通常是一个 JAR 文件) .

LTW 部分 https://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html[AspectJ 参考文档]中详细介绍了此文件的结构和内容.  由于 `aop.xml` 文件是 100％ AspectJ,因此我们不在此进一步描述.


[[aop-aj-ltw-libraries]]
==== 需要的类库(JARS)

至少,您需要以下库来使用 Spring Framework 对 AspectJ LTW 的支持:

* `spring-aop.jar`
* `aspectjweaver.jar`

如果使用<<aop-aj-ltw-environments-generic,Spring 提供的代理程序启用检测>>,则还需要:

* `spring-instrument.jar`


[[aop-aj-ltw-spring]]
==== Spring 的配置

Spring 支持 LTW 的关键部件是 `LoadTimeWeaver` 接口(位于 `org.springframework.instrument.classloading` 包) ,而这接口有大部分的实现分布在 Spring 中.
`LoadTimeWeaver` 负责添加一个或多个 `java.lang.instrument.ClassFileTransformers` 到运行时的类装载器中.  这为各种有趣的应用程序打开了大门,其中一个恰好是方面的 LTW.

TIP: 如果您不熟悉运行时类文件转换的概念,请在继续之前查看 `java.lang.instrument` 包的 javadoc API 文档. 虽然该文档并不全面,但至少可以看到关键接口和类(供您阅读本节时参考) .

配置一个特定的 `ApplicationContext` `LoadTimeWeaver` 就像加入一行代码一样容易. (请注意,几乎可以肯定会将 `ApplicationContext` 作为的Spring容器- 通常一个 `BeanFactory` 是不够的,因为LTW的支持利用到 `BeanFactoryPostProcessors`) .

要启用 Spring Framework 的 LTW 支持,您需要配置 `LoadTimeWeaver`,通常使用 `@EnableLoadTimeWeaving` 注解来完成,如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableLoadTimeWeaving
	public class AppConfig {
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableLoadTimeWeaving
	class AppConfig {
	}
----

或者,如果您更喜欢基于 XML 的配置,请使用 `<context:load-time-weaver/>` 元素. 请注意,元素是在 `context` 命名空间中定义的.  以下示例显示如何使用 `<context:load-time-weaver/>`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:load-time-weaver/>

	</beans>
----

上面的配置自动为你登记了一些特定的基础 beans,例如 `LoadTimeWeaver` 和 `AspectJWeavingEnabler`.  默认的 `LoadTimeWeaver` 是 `DefaultContextLoadTimeWeaver` 类,它试图装饰并自动检测 `LoadTimeWeaver`.  "自动检测" 的 `LoadTimeWeaver` 的确切类型取决于您的运行时环境.  下表总结了各种 `LoadTimeWeaver` 实现:

[[aop-aj-ltw-spring-env-impls]]
.DefaultContextLoadTimeWeaver LoadTimeWeavers
|===
| Runtime Environment| `LoadTimeWeaver` implementation

| Running in https://tomcat.apache.org/[Apache Tomcat]
| `TomcatLoadTimeWeaver`

| Running in https://eclipse-ee4j.github.io/glassfish/[GlassFish] (limited to EAR deployments)
| `GlassFishLoadTimeWeaver`

| Running in Red Hat's https://www.jboss.org/jbossas/[JBoss AS] or https://www.wildfly.org/[WildFly]
| `JBossLoadTimeWeaver`

| Running in IBM's https://www-01.ibm.com/software/webservers/appserv/was/[WebSphere]
| `WebSphereLoadTimeWeaver`

| Running in Oracle's
  https://www.oracle.com/technetwork/middleware/weblogic/overview/index-085209.html[WebLogic]
| `WebLogicLoadTimeWeaver`

| JVM started with Spring `InstrumentationSavingAgent`
  (`java -javaagent:path/to/spring-instrument.jar`)
| `InstrumentationLoadTimeWeaver`

| Fallback, expecting the underlying ClassLoader to follow common conventions
  (namely `addTransformer` and optionally a `getThrowawayClassLoader` method)
| `ReflectiveLoadTimeWeaver`
|===

请注意,该表仅列出使用 `DefaultContextLoadTimeWeaver` 时自动检测的 `LoadTimeWeavers`.  您可以准确指定要使用的 `LoadTimeWeaver` 实现.

使用 Java 配置指定特定的 `LoadTimeWeaver` 实现 `LoadTimeWeavingConfigurer` 接口并覆盖 `getLoadTimeWeaver()` 方法. 以下示例指定 `ReflectiveLoadTimeWeaver`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableLoadTimeWeaving
	public class AppConfig implements LoadTimeWeavingConfigurer {

		@Override
		public LoadTimeWeaver getLoadTimeWeaver() {
			return new ReflectiveLoadTimeWeaver();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableLoadTimeWeaving
	class AppConfig : LoadTimeWeavingConfigurer {

		override fun getLoadTimeWeaver(): LoadTimeWeaver {
			return ReflectiveLoadTimeWeaver()
		}
	}
----

如果使用基于 XML 的配置,则可以将完全限定的类名指定为 `<context:load-time-weaver/>` 元素上的 `weaver-class` 属性的值.  同样,以下示例指定了 `ReflectiveLoadTimeWeaver`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:load-time-weaver
				weaver-class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"/>

	</beans>
----

稍后可以使用众所周知的名称 `loadTimeWeaver` 从 Spring 容器中检索由配置定义和注册的 `LoadTimeWeaver` . 请记住, `LoadTimeWeaver` 只是作为 Spring 的 LTW 基础结构的机制来添加一个或多个 `ClassFileTransformer`,执行LTW的实际 `ClassFileTransformers` 是 `ClassPreProcessorAgentAdapter`(来自 `org.aspectj.weaver.loadtime` 包) .
有关详细信息,请参阅 `ClassPreProcessorAgentAdapter` 类的类级 javadoc, 因为编织实际如何实现的细节超出了本文档的范围.

剩下要讨论的配置有一个 `final` 属性: `aspectjWeaving` 属性(如果使用 XML,则为 `aspectj-weaving`) .  此属性控制是否启用 LTW.  它接受三个可能值中的一个,如果该属性不存在,则默认值为 `autodetect`.  下表总结了三个可能的值:

[[aop-aj-ltw-ltw-tag-attrs]]
.AspectJ织入的属性值
|===
| Annotation Value| XML Value| Explanation

| `ENABLED`
| `on`
| AspectJ 编织开启,切面在加载时织入.

| `DISABLED`
| `off`
| LTW 已关闭.  没有切面加载时织入.

| `AUTODETECT`
| `autodetect`
| 如果 Spring LTW 基础结构可以找到至少一个 `META-INF/aop.xml` 文件,那么 AspectJ 编织就会打开.  否则,它关闭.  这是默认值.
|===


[[aop-aj-ltw-environments]]
==== 特定环境的配置

最后一部分包含在应用程序服务器 和 Web 容器等环境中使用 Spring LTW 支持时所需的任何其他设置和配置.

[[aop-aj-ltw-environments-tomcat-jboss-etc]]
===== Tomcat, JBoss, WebSphere, WebLogic

Tomcat, JBoss/WildFly, IBM WebSphere Application Server 和 Oracle WebLogic Server  提供了一个能够进行本地检测的 `ClassLoader`. Spring的原生 LTW 利用这种 `ClassLoader` 实现来实现 AspectJ 织入.   <<aop-using-aspectj, 如前所述>>,您可以通过激活加载时织入来启用 LTW.  具体来说,您无需修改启动脚本即可添加 `-javaagent:path/to/spring-instrument.jar`.

注意在 JBoss 中, 应用程序服务器的扫描需要禁用,防止它加载的类的应用之前实际上已经开始. 快速的解决方案是增加一个叫 `WEB-INF/jboss-scanning.xml` 的文档并加入以下内容:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<scanning xmlns="urn:jboss:scanning:1.0"/>
----

[[aop-aj-ltw-environments-generic]]
===== 通用的 Java 应用

在不支持现有 `LoadTimeWeaver` 实现或不受现有 `LoadTimeWeaver` 实现支持的环境中需要类检测时,使用 JDK 代理可能是唯一的解决方案. 对于这种情况, Spring 提供了 `InstrumentationLoadTimeWeaver`,它需要 Spring 特有的(但也是非常普通的) VM 代理包 `spring-instrument.jar` .
通过常见的 `@EnableLoadTimeWeaving` 和 `<context: load-time-weaver />` 设置.

要使用它,必须通过提供以下 JVM 选项来启动带有 Spring 代理的虚拟机:

[literal]
[subs="verbatim,quotes"]
----
-javaagent:/path/to/spring-instrument.jar
----

请注意,这需要修改 JVM 启动脚本,这可能会阻止在应用服务器环境中使用它(具体取决于操作策略) .  就是说,对于每个 JVM 一个应用程序的部署,例如独立
在 Spring Boot 应用程序中,通常无论如何都要控制整个 JVM 设置.


[[aop-resources]]
== 更多资源

有关 AspectJ 的更多信息可以在 https://www.eclipse.org/aspectj[AspectJ website]上找到.

_Eclipse AspectJ_ 由 Adrian Colyer(Addison-Wesley, 2005) 出版 提供了详尽的有关 AspectJ 语言的介绍

_AspectJ in Action_, 一书的第二版由 Ramnivas Laddad(Manning,2009) 出版,也是强烈推荐的. 这本书的重点是 AspectJ,但也在一定的深度上探讨了普通的 AOP 主题.

