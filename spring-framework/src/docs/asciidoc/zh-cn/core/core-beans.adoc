[[beans]]
= IOC 容器

本章介绍了 Spring 的 IoC 容器.

[[beans-introduction]]
==  Spring IoC 容器和 bean 的介绍

本章介绍 Spring 框架中控制反转 IOC 的实现.
IOC 与大家熟知的依赖注入同理,这是一个通过依赖注入对象的过程 也就是说,依赖的对象通过构造参数、工厂方法参数或者属性注入,
创建 bean 后容器注入这些依赖对象. 也就是 domain 对象.创建过程相对于普通创建对象的过程是反向的(因此称之为 IoC) ,它通过直接使用构造类来控制实例化,
或者定义它们之间的依赖,或者类似于服务定位模式的一种机制.

`org.springframework.beans` 和 `org.springframework.context` 包是实现 Spring IOC 容器的基础 .
{api-spring-framework}/beans/factory/BeanFactory.html[`BeanFactory`] 接口提供了一种更先进的配置机制来管理任意类型的对象.
{api-spring-framework}/context/ApplicationContext.html[`ApplicationContext`]是 `BeanFactory` 的子接口. 他提供了:

* 更容易与 Spring 的 AOP 特性集成
* 消息资源处理(用于国际化)
* 事件发布
* 应用层特定的上下文,如用于 web 应用程序的 `WebApplicationContext`

简而言之, `BeanFactory` 提供了配置框架的基本功能,`ApplicationContext` 添加了更多特定于企业的功能.
`ApplicationContext` 完全扩展了 `BeanFactory` 的功能,这些内容将在介绍 Spring IoC 容器的专门章节讲解.
有关使用 `BeanFactory`  代替 `ApplicationContext,` 的更多信息,请参考 <<beans-beanfactory, `BeanFactory` API>>.

在 Spring 中,由 Spring IOC 容器管理的,构成程序的骨架的对象称为 Bean. bean 对象是指经过 IoC 容器实例化,组装和管理的对象. 此外,bean 就是应用程序中众多对象之一 . bean 和 bean 的依赖是由容器所使用的配置元数据反射而来.

[[beans-basics]]
== 容器概述

`org.springframework.context.ApplicationContext` 是 Spring IoC 容器实现的代表,它负责实例化,配置和组装 Bean. 容器通过读取配置元数据获取有关实例化、配置和组装哪些对象的说明 .
配置元数据可以使用 XML、Java 注解或 Java 代码来呈现. 它允许你处理应用程序的对象与其他对象之间的互相依赖.


Spring 提供了 `ApplicationContext` 接口的几个实现.  在独立应用程序中,通常创建
{api-spring-framework}/context/support/ClassPathXmlApplicationContext.html[`ClassPathXmlApplicationContext`]
或 {api-spring-framework}/context/support/FileSystemXmlApplicationContext.html[`FileSystemXmlApplicationContext`] 的实例. 虽然 XML 一直是定义配置元数据的传统格式, 但是您可以指定容器使用 Java 注解或编程的方式编写元数据格式,并通过提供少量的 XML 配置以声明对某些额外元数据的支持.

在大多数应用场景中,不需要用户显式的编写代码来实例化 IOC 容器的一个或者多个实例. 例如,在 Web 应用场景中,只需要在 `web.xml` 中添加大概 8 行简单的 web 描述样板就行了(see <<context-create>>).
如果你使用的是基于 Eclipse 的 https://spring.io/tools[Spring Tools for Eclipse] 开发环境,该样板配置只需点击几下鼠标或按几下键盘就能创建了.

下图展示了 Spring 工作方式的高级视图,应用程序的类与元数据配置相互配合,这样,在 `ApplicationContext`  创建和初始化后,你立即拥有一个可配置的,可执行的系统或应用程序.

. IOC容器

image::{image-resource}/container-magic.png[]

[[beans-factory-metadata]]
=== 配置元数据

如上图所示,Spring IOC 容器使用元数据配置这种形式,这个配置元数据表示了应用开发人员告诉 Spring 容器以何种方式实例化、配置和组装应用程序中的对象.

配置元数据通常以简单、直观的 XML 格式提供,本章的大部分内容都使用这种格式来说明 Spring IoC 容器的关键概念和特性.

NOTE: XML 并不是配置元数据的唯一方式,Spring IoC 容器本身是完全与元数据配置的实际分离的. 现在,许多开发人员选择 <<beans-java, 基于 Java 配置>> 来开发应用程序.

更多其他格式的元数据见:

* <<beans-annotation-config,基于注解的配置>>: 基于注解的元数据配置.
* <<beans-java, 基于 Java 的配置 >>: 使用 Java 配置来代替 XML 配置定义外部 bean . 要使用这些功能,请参阅
{api-spring-framework}/context/annotation/Configuration.html[`@Configuration`],
{api-spring-framework}/context/annotation/Bean.html[`@Bean`],
{api-spring-framework}/context/annotation/Import.html[`@Import`],
  和 {api-spring-framework}/context/annotation/DependsOn.html[`@DependsOn`] 注解.

Spring 的 Bean (至少一个)  由容器来管理,基于 XML 的元数据配置将这些 bean 配置为 `<beans/>` 元素.并放置于 `<beans/>` 元素内部. 基于 Java 的配置通常是使用 `@Configuration` 注解过的类中,在它的方法上使用 `@Bean` 注解.

这些 bean 定义会对应到构成应用程序的实际对象. 通常你会定义服务层对象, 持久层对象（repositories） ,数据访问层对象（DAOs）表示对象(如  Web controllers 的实例),
基础对象(如 JPA 的 `EntityManagerFactory`, JMS `Queues` 等等) .通常,不会在容器中配置细粒度的 domain 对象,因为创建和加载 domain 对象通常是 DAO 和业务逻辑的职责.

下面的示例显示了基于 XML 元数据配置的基本结构:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="..." class="..."> <1> <2>
			<!-- collaborators and configuration for this bean go here -->
		</bean>

		<bean id="..." class="...">
			<!-- collaborators and configuration for this bean go here -->
		</bean>

		<!-- more bean definitions go here -->

	</beans>
----

<1>  `id` 属性是字符串 ,用来识别唯一的 bean 定义.

<2>  `class` 属性定义了 bean 的类型,使用全类名.

`id` 属性的值是指引用依赖对象(在这个例子没有声明用于引用依赖对象的 XML) . 请参阅 <<beans-dependencies,依赖>> 获取更多信息



[[beans-factory-instantiation]]
=== 实例化容器

提供给 `ApplicationContext` 构造函数的路径就是实际的资源字符串,使容器能从各种外部资源(如本地文件系统、Java `CLASSPATH` 等)装载元数据配置.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
----
.Kotlin
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
    val context = ClassPathXmlApplicationContext("services.xml", "daos.xml")
----

[NOTE]
====
当你了解 Spring IoC 容器之后,你可能想知道更多关于 Spring 的 `Resource` (如 <<resources>> 中描述的). 它提供了一种简便的方法来通过 InputStream 读取 URI 定义的位置 ,资源路径被用于构建应用程序上下文的应用环境和资源路径, 如 <<resources-app-ctx>> 描述
====

下面的例子显示了服务层对象 `(services.xml)` 配置文件:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<!-- services -->

		<bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl">
			<property name="accountDao" ref="accountDao"/>
			<property name="itemDao" ref="itemDao"/>
			<!-- additional collaborators and configuration for this bean go here -->
		</bean>

		<!-- more bean definitions for services go here -->

	</beans>
----

下面的示例显示了数据访问对象 `daos.xml` 配置文件:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="accountDao"
			class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao">
			<!-- additional collaborators and configuration for this bean go here -->
		</bean>

		<bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao">
			<!-- additional collaborators and configuration for this bean go here -->
		</bean>

		<!-- more bean definitions for data access objects go here -->

	</beans>
----

在上面的例子中,服务层由 `PetStoreServiceImpl` 类和两个数据访问对象 `JpaAccountDao` 和 `JpaItemDao` (基于 JPA 对象/关系映射标准)组成.
 `property name` 元素是指 JavaBean 属性的名称,而 `ref` 元素引用另一个bean定义的名称. `id` 和 `ref` 元素之间的这种联系表达了组合对象之间的相互依赖. 有关对象间的依赖,请参阅 <<beans-dependencies,依赖>>.

[[beans-factory-xml-import]]
==== 组合基于 XML 的元数据配置

使用 XML 配置,可以让 bean 定义分布在多个 XML 文件上,这种方法直观优雅清晰明显. 通常,每个单独的 XML 配置文件代表架构中的一个逻辑层或模块.

你可以使用应用程序上下文构造函数从所有这些 XML 片段加载 bean 定义,这个构造函数可以输入多个 `Resource` 位置,<<beans-factory-instantiation, 如上一节所示>>.  或者,使用 `<import/>` 元素也可以从另一个(或多个) 文件加载 bean 定义. 例如:


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<import resource="services.xml"/>
		<import resource="resources/messageSource.xml"/>
		<import resource="/resources/themeSource.xml"/>

		<bean id="bean1" class="..."/>
		<bean id="bean2" class="..."/>
	</beans>
----

上面的例子中,使用了3个文件: `services.xml`, `messageSource.xml`, 和 `themeSource.xml` 来加载外部Bean的定义. 导入文件采用的都是相对路径,因此  `services.xml` 必须和导入文件位于同一目录或类路径中,
而 `messageSource.xml` 和 `themeSource.xml` 必须在导入文件的资源位置中. 正如你所看到的,前面的斜线将会被忽略,但考虑到这些路径是相对的,最佳的使用是不用斜线的.  这个XML文件的内容都会被导入,包括顶级的
`<beans/>` 元素, 但必须遵循 Spring Schema 定义 XML bean 定义的规则.

[NOTE]
====
这种相对路径的配置是可行的,但不推荐这样做. 在使用 "../" 引用目录时,这样做会对当前应用程序之外的文件产生依赖.
特别是对于 `classpath:` URLs (例如, `classpath:../services.xml`), ,不建议使用此引用方式,因为在该引用方式中,运行时解析过程选择 "`最近的`" classpath 根目录,然后查看其父目录.  类路径的变化或者选择了不正确的目录都会导致此配置不可用.

您可以使用完全限定的资源位置而不是相对路径:例如, `file:C:/config/services.xml` 或 `classpath:/config/services.xml`. 但是,请注意,您正在将应用程序的配置与特定的绝对位置耦合. 通常会选取间接的方式应对这种绝对路径,例如使用占位符 "${…}" 来解决对JVM系统属性的引用.
====

`import` 是由 bean 命名空间本身提供的功能. 在 Spring 提供的 XML 命名空间中,如 `context` 和 `util` 命名空间,可以用于对普通 bean 定义进行更高级的功能配置.


[[groovy-bean-definition-dsl]]
==== DSL 定义Groovy Bean

作为从外部配置元数据的另一个示例, bean 定义也可以使用 Spring 的 Groovy DSL 来定义. Grails 框架有此配置实例,通常, 可以在具有以下结构的 ".groovy" 文件中配置 bean 定义. 例如:

[source,groovy,indent=0,subs="verbatim,quotes"]
----
	beans {
		dataSource(BasicDataSource) {
			driverClassName = "org.hsqldb.jdbcDriver"
			url = "jdbc:hsqldb:mem:grailsDB"
			username = "sa"
			password = ""
			settings = [mynew:"setting"]
		}
		sessionFactory(SessionFactory) {
			dataSource = dataSource
		}
		myService(MyService) {
			nestedBean = { AnotherBean bean ->
				dataSource = dataSource
			}
		}
	}
----

这种配置风格在很大程度上等价于 XML bean 定义,甚至支持 Spring 的 XML 配置命名空间. 它还允许通过 `importBeans` 指令导入 XML bean 定义文件.

[[beans-factory-client]]
=== 使用容器

`ApplicationContext` 是能够创建 bean 定义以及处理相互依赖的高级工厂接口,使用方法 `T getBean(String
name, Class<T> requiredType)`, 获取容器实例.

`ApplicationContext` 可以读取 bean 定义并访问它们 如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// create and configure beans
	ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

	// retrieve configured instance
	PetStoreService service = context.getBean("petStore", PetStoreService.class);

	// use configured instance
	List<String> userList = service.getUsernameList();
----
.Kotlin
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
    import org.springframework.beans.factory.getBean

	// create and configure beans
    val context = ClassPathXmlApplicationContext("services.xml", "daos.xml")

    // retrieve configured instance
    val service = context.getBean<PetStoreService>("petStore")

    // use configured instance
    var userList = service.getUsernameList()
----

使用 Groovy 配置引导看起来非常相似,只是用到不同的上下文实现类: 它是对 Groovy 感知的(但也需理解 XML bean 定义)  如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	ApplicationContext context = new GenericGroovyApplicationContext("services.groovy", "daos.groovy");
----
.Kotlin
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
----
val context = GenericGroovyApplicationContext("services.groovy", "daos.groovy")
----

最灵活的实现是 `GenericApplicationContext` , 例如读取 XML 文件的 `XmlBeanDefinitionReader` 如下面的示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	GenericApplicationContext context = new GenericApplicationContext();
	new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
	context.refresh();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val context = GenericApplicationContext()
	XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml")
	context.refresh()
----

您还可以为 Groovy 文件使用 `GroovyBeanDefinitionReader` 如下面的示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	GenericApplicationContext context = new GenericApplicationContext();
	new GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy");
	context.refresh();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val context = GenericApplicationContext()
	GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy")
	context.refresh()
----

这一类的读取可以在同一个 `ApplicationContext`,上混合使用,也可以自动匹配,如果需要可以从不同的配置源读取 bean 定义.

您可以使用  `getBean` 来获取 bean 实例,  `ApplicationContext` 接口也可以使用其他的方法来获取 bean. 但是在理想情况下,应用程序代码永远不应该使用它们.  事实上,你的应用程序代码也不应该调用
`getBean()` 方法,因此对 Spring API 没有依赖. 例如,Spring 与 Web 框架的集成为各种 Web 框架组件(如控制器和 JSF 管理 bean)  提供了依赖注入功能,从而允许开发者通过元数据声明对特定 bean 的依赖(例如,自动注解) .

[[beans-definition]]
== Bean 的概述

Spring IoC 容器管理一个或多个 bean. 这些 bean 是由您提供给容器的元数据配置创建的(例如,XML `<bean/>` 定义的形式).

在容器内部,这些 bean 定义表示为 `BeanDefinition` 对象,其中包含(其他信息) 以下元数据

* 限定包类名称: 通常,定义的 bean 的实际实现类.
* bean 行为配置元素, 定义 Bean 的行为约束(例如作用域,生命周期回调等等)
* bean 需要引用其他 bean 来完成工作. 这些引用也称为协作或依赖.
* 其他配置用于新对象的创建,例如使用 bean 的数量来管理连接池,或者限制池的大小.

以下是每个 bean 定义的属性:

[[beans-factory-bean-definition-tbl]]
.Bean的定义
|===
| 属性| 对应章节介绍...

| Class
| <<beans-factory-class>>

| Name
| <<beans-beanname>>

| Scope
| <<beans-factory-scopes>>

| Constructor arguments
| <<beans-factory-collaborators>>

| Properties
| <<beans-factory-collaborators>>

| Autowiring mode
| <<beans-factory-autowire>>

| Lazy initialization mode
| <<beans-factory-lazy-init>>

| Initialization method
| <<beans-factory-lifecycle-initializingbean>>

| Destruction method
| <<beans-factory-lifecycle-disposablebean>>
|===

除了 bean 定义包含如何创建特定的 bean 的信息外, `ApplicationContext` 实现还允许用户在容器中注册现有的、已创建的对象. 这是通过 `getBeanFactory()` 方法访问 `ApplicationContext` 的 `BeanFactory` 来完成的,
该方法返回 BeanFactory `DefaultListableBeanFactory` 实现. `DefaultListableBeanFactory` 支持通过 `registerSingleton(..)` 和
`registerBeanDefinition(..)` 方法来注册对象.  然而,典型的应用程序只能通过元数据配置来定义 bean.

[NOTE]
====
为了让容器正确推断它们在自动装配和其它内置步骤,需要尽早注册 Bean 的元数据和手动使用单例的实例. 虽然覆盖现有的元数据和现有的单例实例在某种程度上是支持的, 但是新 bean 在运行时(同时访问动态工厂) 注册官方并不支持,可能会导致并发访问异常、bean 容器中的不一致状态,或者两者兼有.
====

[[beans-beanname]]
=== Bean 的命名

每个 bean 都有一个或多个标识符,这些标识符在容器托管时必须是唯一的. bean 通常只有一个标识符,但如果需要多个标识符时,可以考虑使用别名.

在基于 XML 的配置中,开发者可以使用 `id` 属性,  `name` 属性, 或两者都指定 bean 的标识符  `id` 属性 允许您指定一个 `id`. 通常这些名字使用字母和数字的组合('myBean', 'someService', 等.), 但也可以包含特殊字符.  如果你想使用 bean 别名,您可以在 `name` 属性上定义,使用逗号  (`,`), 分好 (`;`), 或空白符. 由于历史因素, 请注意,在 Spring 3.1 之前的版本中, `id` 属性被定义为 `xsd:ID` 类型, 它会限制某些字符. 从 3.1 开始,它被定义为 `xsd:string` 类型. 请注意,由于 bean `id` 的唯一性,他仍然由容器执行,不再由 XML 解析器执行.

您也无需提供 bean 的 `name` 或 `id` 如果没有显式地提供 `name` 或 `id` 容器会给 bean 生成唯一的名称.  然而,如果你想引用 bean 的名字,可以使用 `ref` 元素或使用 Service Locator 来进行查找(此时必须提供名称) .  不使用名称的情况有: <<beans-inner-beans,内部 bean>> 和 <<beans-factory-autowire,自动装配>>.

.Bean 的命名约定
****
bean 的命名是按照标准的 Java 字段名称命名来进行的. 也就是说,bean 名称开始需要以小写字母开头,后面采用 "驼峰式" 的方法.  例如 `accountManager`,
`accountService`, `userDao`, `loginController`.

一致的 beans 命名能够让配置更方便阅读和理解,如果你正在使用 Spring AOP,当你通过 bean 名称应用到通知时,这种命名方式会有很大的帮助.
****

NOTE: 在类路径中进行组件扫描时, Spring 会根据上面的规则为未命名的组件生成 bean 名称,规则是: 采用简单的类名,并将其初始字符转化为小写字母.  然而,在特殊情况下,当有一个以上的字符,同时第一个和第二个字符都是大写时,原来的规则仍然应该保留. 这些规则与 Java 中定义实例的相同.
例如 Spring 使用的 `java.beans.Introspector.decapitalize` 类.


[[beans-beanname-alias]]
==== 定义外部 Bean 的别名

在对 bean 定义时,除了使用 `id` 属性指定唯一的名称外,还可以提供多个别名,这需要通过 `name` 属性指定.  所有这个名称都会指向同一个 bean,在某些情况下提供别名非常有用,例如为了让应用每一个组件都能更容易的对公共组件进行引用.

然而,在定义 bean 时就指定所有的别名并不是很恰当的. 有时期望能够在当前位置为那些在别处定义的 bean 引入别名. 在 XML 配置文件中, 可以通过 `<alias/>` 元素来定义 bean 别名,例如:


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<alias name="fromName" alias="toName"/>
----

上面示例中,在同一个容器中名为 `fromName` 的 bean 定义,在增加别名定义后,也可以使用 `toName` 来引用. .

例如,在子系统 A 中通过名字 `subsystemA-dataSource` 配置的数据源. 在子系统 B 中可能通过名字 `subsystemB-dataSource` 来引用. .当两个子系统构成主应用的时候,主应用可能通过名字 `myApp-dataSource` 引用数据源,将全部三个名字引用同一个对象,你可以将下面的别名定义添加到应用配置中:


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<alias name="myApp-dataSource" alias="subsystemA-dataSource"/>
	<alias name="myApp-dataSource" alias="subsystemB-dataSource"/>
----

现在,每个组件和主应用程序都可以通过一个唯一的名称引用 dataSource,并保证不与任何其他定义冲突(有效地创建命名空间) ,但它们引用相同的 bean.

.Java 配置
****
如果你使用 Javaconfiguration,  `@Bean` 可以用来提供别名,详情见  <<beans-java-bean-annotation>>
****

[[beans-factory-class]]
=== 实例化 Bean

bean 定义基本上就是用来创建一个或多个对象的配置,当需要 bean 的时候,容器会查找配置并且根据 bean 定义封装的元数据来创建(或获取) 实际对象.

如果你使用基于 XML 的配置,那么可以在 `<bean/>` 元素中通过 `class` 属性来指定对象类型.  `class` 属性实际上就是  `BeanDefinition` 实例中的 `class` 属性.
他通常是必需的(一些例外情况,<<beans-factory-class-instance-factory-method>> 和 <<beans-child-bean-definitions>>). 有两种方式使用 `Class` 属性


* 通常情况下,会直接通过反射调用构造方法来创建 bean,这种方式与 Java 代码的 new 创建相似.
* 通过静态工厂方法创建,类中包含静态方法. 通过调用静态方法返回对象的类型可能和 Class 一样,也可能完全不一样.

.内部类的名
****
如果你想配置静态内部类,那么必须使用内部类的二进制名称.

例如,在 `com.example` 包下 有一个名为 `SomeThing` 的类, 这个类里面有个静态内部类 `OtherThing`,他们可以以 (`$`) 或 (`.`) 作为分隔符.  这种情况下 bean 定义的 `class` 属性应该写作 `com.example.SomeThing$OtherThing` 或 `com.example.SomeThing.OtherThing`.

使用 `$` 字符来分隔外部类和内部类的名称
****


[[beans-factory-class-ctor]]
==== 通过构造器实例化

当通过构造器创建 Bean 时,Spring 兼容所有可以使用的普通类,也就是说,正在开发的类不需要实现任何特定接口或以特定方式编码. 只要指定 bean 类就足够了.
但是,根据您为该特定 bean 使用的 IoC 类型,您可能需要一个默认(空) 构造函数.

Spring IoC 容器几乎可以管理您希望它管理的任何类. 它不仅限于管理真正的 JavaBeans. 大多数 Spring 用户更喜欢管理那些只有一个默认构造函数(无参数)  和有合适的 setter 和 getter 方法的真实的 JavaBeans,还可以在容器中放置更多的外部非 bean 形式(non-bean-style)类,例如: 如果需要使用一个绝对违反 JavaBean 规范的遗留连接池时 Spring 也是可以管理它的.

使用基于 XML 的配置元数据,您可以按如下方式指定 bean 类:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean"/>

	<bean name="anotherExample" class="examples.ExampleBeanTwo"/>
----

给构造方法指定参数以及为 bean 实例化设置属性将在后面的 <<beans-factory-collaborators,依赖注入>> 中说明.


[[beans-factory-class-static-factory-method]]
==== 通过静态工厂方法实例化

当采用静态工厂方法创建 bean 时,除了需要指定 class 属性外,还需要通过 `factory-method` 属性来指定创建 bean 实例的工厂方法.  Spring 将会调用此方法(其可选参数接下来会介绍) 返回实例对象. 从这样看来,它与通过普通构造器创建类实例没什么两样.

下面的 bean 定义展示了如何通过工厂方法来创建 bean 实例. 注意,此定义并未指定对象的返回类型,只是指定了该类包含的工厂方法,在这个例中, `createInstance()`
必须是一个静态(`static`) 的方法:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="clientService"
		class="examples.ClientService"
		factory-method="createInstance"/>
----

以下示例显示了一个可以使用前面的 bean 定义的类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ClientService {
		private static ClientService clientService = new ClientService();
		private ClientService() {}

		public static ClientService createInstance() {
			return clientService;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ClientService private constructor() {
		companion object {
			private val clientService = ClientService()
            @JvmStatic
			fun createInstance() = clientService
		}
	}
----

给工厂方法指定参数以及为 bean 实例设置属性的详细内容请查阅 <<beans-factory-properties-detailed,依赖和配置细节>>.


[[beans-factory-class-instance-factory-method]]
==== 通过实例工厂方法实例化

通过调用工厂实例的非静态方法进行实例化与 <<beans-factory-class-static-factory-method,通过静态工厂方法实例化类似>>, 请将 `class` 属性保留为空,并在 `factory-bean`,
属性中指定当前(或父级或祖先) 容器中 bean 的名称,该容器包含要调用以创建对象的实例方法.  使用 `factory-method`,属性设置工厂方法本身的名称. 以下示例显示如何配置此类 bean:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- the factory bean, which contains a method called createInstance() -->
	<bean id="serviceLocator" class="examples.DefaultServiceLocator">
		<!-- inject any dependencies required by this locator bean -->
	</bean>

	<!-- the bean to be created via the factory bean -->
	<bean id="clientService"
		factory-bean="serviceLocator"
		factory-method="createClientServiceInstance"/>
----

以下示例显示了相应的 Java 类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class DefaultServiceLocator {

		private static ClientService clientService = new ClientServiceImpl();

		public ClientService createClientServiceInstance() {
			return clientService;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class DefaultServiceLocator {
		companion object {
			private val clientService = ClientServiceImpl()
		}
		fun createClientServiceInstance(): ClientService {
			return clientService
		}
	}
----

一个工厂类也可以包含多个工厂方法,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="serviceLocator" class="examples.DefaultServiceLocator">
		<!-- inject any dependencies required by this locator bean -->
	</bean>

	<bean id="clientService"
		factory-bean="serviceLocator"
		factory-method="createClientServiceInstance"/>

	<bean id="accountService"
		factory-bean="serviceLocator"
		factory-method="createAccountServiceInstance"/>
----

以下示例显示了相应的 Java 类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class DefaultServiceLocator {

		private static ClientService clientService = new ClientServiceImpl();

		private static AccountService accountService = new AccountServiceImpl();

		public ClientService createClientServiceInstance() {
			return clientService;
		}

		public AccountService createAccountServiceInstance() {
			return accountService;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class DefaultServiceLocator {
		companion object {
			private val clientService = ClientServiceImpl()
			private val accountService = AccountServiceImpl()
		}

		fun createClientServiceInstance(): ClientService {
			return clientService
		}

		fun createAccountServiceInstance(): AccountService {
			return accountService
		}
	}
----

这种方法表明可以通过依赖注入(DI) 来管理和配置工厂 bean 本身. 请参阅详细信息中的 <<beans-factory-properties-detailed,依赖和配置细节>>.

NOTE: 在 Spring 文档中, "factory bean" 是指在 Spring 容器中通过
<<beans-factory-class-instance-factory-method,实例>> 或
<<beans-factory-class-static-factory-method,静态>> 工厂方法 创建对象的 bean.
相比之下,`FactoryBean` (注意大小写) 是指 Spring 特定的 <<beans-factory-extension-factorybean, `FactoryBean`>>.

[[beans-factory-type-determination]]
==== 确定 Bean 的运行时类型

想要确定 Bean 运行时的类型并不简单,在 bean 元数据定义中只是一个初始类引用,可能会因为声明的工厂方法组合或者 `FactoryBean` 而造成不用的运行时类型,或者在创建 bean 的
实例不设置 工厂方法(通过指定的 "factory-bean" 名称解析).此外,AOP 代理可以将 bean 的实例和基于接口的代理一起包装为目标 bean 的实际类型(仅是其实现的接口).

找出指定 bean 的实际运行时类型的推荐方法是通过 `BeanFactory.getType` 指定 bean 的名称,这需要考虑到大小写并且和 `BeanFactory.getBean` 调用对象返回相同的 bean 名称

[[beans-dependencies]]
== 依赖

一般情况下企业应用不会只有一个对象(Spring Bean) ,甚至最简单的应用都需要多个对象协同工作. 下一部分将解释如何从定义单个 Bean 到让多个 Bean 协同工作.

[[beans-factory-collaborators]]
=== 依赖注入

依赖注入 (DI) 是让对象只通过构造参数、工厂方法的参数或者配置的属性来定义他们的依赖的过程. 这些依赖也是其他对象所需要协同工作的对象, 容器会在创建 Bean 的时候注入这些依赖. 整个过程完全反转了由 Bean 自己控制实例化或者依赖引用,所以这个过程也称之为 "控制反转"

当使用了依赖注入的特性以后,会让开发者更容易管理和解耦对象之间的依赖,使代码变得更加简单. 对象之间不再关注依赖,也不需要知道依赖类的位置. 如此一来,开发的类更易于测试 尤其是当开发者的依赖是接口或者抽象类的情况时,开发者可以轻易地在单元测试中 mock 对象.

依赖注入主要使用两种方式: <<beans-constructor-injection,基于构造函数的注入>> and <<beans-setter-injection,基于 Setter 方法的依赖注入>>.

[[beans-constructor-injection]]
==== 基于构造函数的注入

基于构造函数的依赖注入是由 IoC 容器来调用类的构造函数,构造函数的参数代表这个 Bean 所依赖的对象. 构造函数的依赖注入与调用带参数的静态工厂方法基本一样.
调用具有特定参数的静态工厂方法来构造 bean 几乎是等效的,本讨论同样处理构造函数和静态工厂方法的参数. 下面的例子展示了一个通过构造函数来实现依赖注入的类. :

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		// the SimpleMovieLister has a dependency on a MovieFinder
		private final MovieFinder movieFinder;

		// a constructor so that the Spring container can inject a MovieFinder
		public SimpleMovieLister(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// business logic that actually uses the injected MovieFinder is omitted...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// a constructor so that the Spring container can inject a MovieFinder
	class SimpleMovieLister(private val movieFinder: MovieFinder) {
		// business logic that actually uses the injected MovieFinder is omitted...
	}
----

请注意,这个类没有什么特别之处.  它是一个 POJO,它不依赖于容器特定的接口,父类或注解.

[[beans-factory-ctor-arguments-resolution]]
===== 解析构造器参数

构造函数的参数解析是通过参数的类型来匹配的. 如果在 Bean 的构造函数参数不存在歧义,那么构造器参数的顺序也就是就是这些参数实例化以及装载的顺序. 参考如下代码:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package x.y;

	public class ThingOne {

		public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package x.y

	class ThingOne(thingTwo: ThingTwo, thingThree: ThingThree)
----

假设  `ThingTwo` 和 `ThingThree` 不存在继承关系 也没有什么歧义. 下面的配置完全可以工作正常. 开发者无需再到 `<constructor-arg/>` 元素中指定构造函数参数的 `index` 或 `type`
[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="beanOne" class="x.y.ThingOne">
			<constructor-arg ref="beanTwo"/>
			<constructor-arg ref="beanThree"/>
		</bean>

		<bean id="beanTwo" class="x.y.ThingTwo"/>

		<bean id="beanThree" class="x.y.ThingThree"/>
	</beans>
----

当引用另一个 bean 时,如果类型是已知的,匹配就会工作正常(与前面的示例一样) . 当使用简单类型的时候, 例如: `<value>true</value>`, Spring IoC 容器无法判断值的类型,所以也是无法匹配的,考虑代码:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package examples;

	public class ExampleBean {

		// Number of years to calculate the Ultimate Answer
		private final int years;

		// The Answer to Life, the Universe, and Everything
		private final String ultimateAnswer;

		public ExampleBean(int years, String ultimateAnswer) {
			this.years = years;
			this.ultimateAnswer = ultimateAnswer;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package examples

	class ExampleBean(
		private val years: Int, // Number of years to calculate the Ultimate Answer
		private val ultimateAnswer: String // The Answer to Life, the Universe, and Everything
	)
----

.[[beans-factory-ctor-arguments-type]]
构造函数参数类型匹配
--
在前面的场景中,如果使用  `type`  属性显式指定构造函数参数的类型,则容器可以使用与简单类型的类型匹配. 如下例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean">
		<constructor-arg type="int" value="7500000"/>
		<constructor-arg type="java.lang.String" value="42"/>
	</bean>
----
--

.[[beans-factory-ctor-arguments-index]]
构造函数参数索引
--
您可以使用 `index` 属性显式指定构造函数参数的索引,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean">
		<constructor-arg index="0" value="7500000"/>
		<constructor-arg index="1" value="42"/>
	</bean>
----

除了解决多个简单值的歧义之外,指定索引还可以解决构造函数具有相同类型的两个参数的歧义.

NOTE: index 从 0 开始.
--

.[[beans-factory-ctor-arguments-name]]
构造函数参数名称
--
您还可以使用构造函数参数名称消除歧义,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean">
		<constructor-arg name="years" value="7500000"/>
		<constructor-arg name="ultimateAnswer" value="42"/>
	</bean>
----

需要注意的是,解析这个配置的代码必须启用了 debug 来编译,这样 Spring 才可以从构造函数查找参数名称. 开发者也可以使用
https://download.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html[@ConstructorProperties]
注解来显式声明构造函数的名称.  例如下面代码:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package examples;

	public class ExampleBean {

		// Fields omitted

		@ConstructorProperties({"years", "ultimateAnswer"})
		public ExampleBean(int years, String ultimateAnswer) {
			this.years = years;
			this.ultimateAnswer = ultimateAnswer;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package examples

	class ExampleBean
	@ConstructorProperties("years", "ultimateAnswer")
	constructor(val years: Int, val ultimateAnswer: String)
----
--


[[beans-setter-injection]]
==== 基于 Setter 方法的依赖注入

基于 setter 函数的依赖注入是让容器调用 Bean 的无参构造函数,或者无参静态工厂方法,然后再来调用 setter 方法来实现依赖注入.

下面的例子展示了使用 setter 方法进行的依赖注入的过程. 其中类对象只是简单的 POJO,它不依赖于容器特定的接口,父类或注解.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		// the SimpleMovieLister has a dependency on the MovieFinder
		private MovieFinder movieFinder;

		// a setter method so that the Spring container can inject a MovieFinder
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// business logic that actually uses the injected MovieFinder is omitted...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class SimpleMovieLister {

	// a late-initialized property so that the Spring container can inject a MovieFinder
	lateinit var movieFinder: MovieFinder

	// business logic that actually uses the injected MovieFinder is omitted...
}
----


`ApplicationContext` 所管理 Bean 同时支持基于构造函数和基于 setter 方法的依赖注入,同时也支持使用 setter 方法在通过构造函数注入依赖之后再次注入依赖.  开发者在 `BeanDefinition`
中可以使用 `PropertyEditor` 实例来自由选择注入方式. 然而,大多数的开发者并不直接使用这些类,而是更喜欢使用 XML 配置来进行 `bean` 定义, 或者基于注解的组件 (例如使用 `@Component`,
`@Controller`), 或者在配置了 `@Configuration` 类中使用 `@Bean` 的方法.  然后,这些会在 Spring 内部转换为 `BeanDefinition` 实例,并用于加载整个 Spring IoC 容器实例.

[[beans-constructor-vs-setter-injection]]
.如何选择基于构造器和基于 setter 方法?
****
因为开发者可以混用两种依赖注入方式,两种方式用于处理不同的情况: 必要的依赖通常通过构造函数注入,而可选的依赖则通过 setter 方法注入.
其中,在 setter 方法上添加 <<beans-autowired-annotation, @Autowired>> 注解可用于构造必要的依赖. 但是,最好使用带有参数验证的构造函数注入.


Spring 团队推荐使用基于构造函数的注入,因为这种方式会促使开发者将组件开发成不可变对象并且确保注入的依赖不为 null. 另外,基于构造函数的注入的组件被客户端调用的时候也已经是完全构造好的 .
当然,从另一方面来说,过多的构造函数参数也是非常糟糕的代码方式,这种方式说明类附带了太多的功能,最好重构将不同职能分离.

基于 setter 的注入只用于可选的依赖,但是也最好配置一些合理的默认值. 否则,只能对代码的依赖进行非 null 值检查了. 基于 setter 方法的注入有一个便利之处是: 对象可以重新配置和重新注入.
因此,使用 setter 注入管理 <<integration.adoc#jmx,JMX MBeans>> 是很方便的

依赖注入的两种风格适合大多数的情况,但是在使用第三方库的时候,开发者可能并没有源码,那么就只能使用基于构造函数的依赖注入了.
****

[[beans-dependency-resolution]]
==== 决定依赖的过程

容器解析 Bean 的过程如下:

* 创建并根据描述的元数据来实例化 `ApplicationContext` 元数据配置可以是 XML 文件、Java 代码或者注解.
* 每一个 Bean 的依赖都通过构造函数参数或属性,或者静态工厂方法的参数等等来表示. 这些依赖会在 Bean 创建的时候装载和注入
* 每一个属性或者构造函数的参数都是真实定义的值或者引用容器其他的 Bean.
* 每一个属性或者构造参数可以根据指定的类型转换为所需的类型. Spring 也可以将 String 转成默认的 Java 内置类型. 例如 `int`,`long`, `String`, `boolean`,等.

Spring 容器会在容器创建的时候针对每一个 Bean 进行校验. 但是 Bean 的属性在 Bean 没有真正创建之前是不会进行配置的,单例类型的 Bean 是容器创建的时候配置成预实例状态的. <<beans-factory-scopes,Bean 的作用域>> 后面再说,
其他的 Bean 都只有在请求的时候,才会创建,显然创建 Bean 对象会有一个依赖顺序图,这个图表示 Bean 之间的依赖.  容器根据此来决定创建和配置 Bean 的顺序.

.循环依赖
****
如果开发者主要使用基于构造函数的依赖注入,那么很有可能出现循环依赖的情况.

例如: 类 A 在构造函数中依赖于类 B 的实例,而类 B 的构造函数又依赖类 A 的实例. 如果这样配置类 A 和类 B 相互注入的话,Spring IoC 容器会发现这个运行时的循环依赖, 并且抛出 `BeanCurrentlyInCreationException` 异常.

开发者可以选择 setter 方法来配置依赖注入,这样就不会出现循环依赖的情况. 或者根本就不使用基于构造函数的依赖注入,而仅仅使用基于 setter 方法的依赖注入.  换言之,但是开发者可以将循环依赖配置为基于 Setter 方法的依赖注入(尽管不推荐这样做)

与典型情况(没有循环依赖) 不同,Bean A 和Bean B 之间的循环依赖迫使其中一个 Bean 在完全完全初始化之前被注入另一个 Bean(经典的"鸡与蛋"场景) .
****

你可以信任 Spring 做正确的事. 它在容器加载时检测配置问题,例如对不存在的 bean 和循环依赖的引用.  当实际创建 bean 时,Spring 会尽可能晚地设置属性并解析依赖. 这也意味着 Spring 容器加载正确后会在 bean 注入依赖出错的时候抛出异常. 例如,bean 抛出缺少属性或者属性不合法的异常 ,这种延迟的解析也是
`ApplicationContext`  的实现会令单例 Bean 处于预实例化状态的原因. 这样,通过创建 bean,可以在真正使用 bean 之前消耗一些内存代价而发现配置的问题 . 开发者也可以覆盖默认的行为让单例 bean 延迟加载,而不总是处于预实例化状态.

如果不存在循环依赖的话,bean 所引用的依赖会预先全部构造. 举例来说,如果 bean A  依赖于 bean B,那么 Spring IoC 容器会先配置 bean B,然后调用 bean A 的 setter 方法来构造 bean A.
换言之,bean 先会实例化,然后再注入依赖,最后才是相关生命周期方法的调用(就像 <<beans-factory-lifecycle-initializingbean, 配置文件的 init 方法>> 或者<<beans-factory-lifecycle-initializingbean,InitializingBean 的回调函数>>) .


[[beans-some-examples]]
==== 依赖注入的例子

下面的例子使用基于 XML 的元数据配置,然后使用 setter 方式进行依赖注入. 下面是 Spring 中使用 XML 文件声明 bean 定义的片段:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean">
		<!-- setter injection using the nested ref element -->
		<property name="beanOne">
			<ref bean="anotherExampleBean"/>
		</property>

		<!-- setter injection using the neater ref attribute -->
		<property name="beanTwo" ref="yetAnotherBean"/>
		<property name="integerProperty" value="1"/>
	</bean>

	<bean id="anotherExampleBean" class="examples.AnotherBean"/>
	<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
----

以下示例显示了相应的 `ExampleBean` 类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ExampleBean {

		private AnotherBean beanOne;

		private YetAnotherBean beanTwo;

		private int i;

		public void setBeanOne(AnotherBean beanOne) {
			this.beanOne = beanOne;
		}

		public void setBeanTwo(YetAnotherBean beanTwo) {
			this.beanTwo = beanTwo;
		}

		public void setIntegerProperty(int i) {
			this.i = i;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class ExampleBean {
	lateinit var beanOne: AnotherBean
	lateinit var beanTwo: YetAnotherBean
	var i: Int = 0
}
----

在前面的示例中,setter 被声明为与 XML 文件中指定的属性匹配. 以下示例使用基于构造函数的 DI:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean">
		<!-- constructor injection using the nested ref element -->
		<constructor-arg>
			<ref bean="anotherExampleBean"/>
		</constructor-arg>

		<!-- constructor injection using the neater ref attribute -->
		<constructor-arg ref="yetAnotherBean"/>

		<constructor-arg type="int" value="1"/>
	</bean>

	<bean id="anotherExampleBean" class="examples.AnotherBean"/>
	<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
----

以下示例显示了相应的 `ExampleBean` 类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ExampleBean {

		private AnotherBean beanOne;

		private YetAnotherBean beanTwo;

		private int i;

		public ExampleBean(
			AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
			this.beanOne = anotherBean;
			this.beanTwo = yetAnotherBean;
			this.i = i;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class ExampleBean(
		private val beanOne: AnotherBean,
		private val beanTwo: YetAnotherBean,
		private val i: Int)
----

bean 定义中指定的构造函数参数用作 `ExampleBean` 的构造函数的参数. .

现在考虑这个示例的情况,其中,不使用构造函数,而是告诉 Spring 调用静态工厂方法来返回对象的实例:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleBean" class="examples.ExampleBean" factory-method="createInstance">
		<constructor-arg ref="anotherExampleBean"/>
		<constructor-arg ref="yetAnotherBean"/>
		<constructor-arg value="1"/>
	</bean>

	<bean id="anotherExampleBean" class="examples.AnotherBean"/>
	<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
----

以下示例显示了相应的 `ExampleBean` 类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ExampleBean {

		// a private constructor
		private ExampleBean(...) {
			...
		}

		// a static factory method; the arguments to this method can be
		// considered the dependencies of the bean that is returned,
		// regardless of how those arguments are actually used.
		public static ExampleBean createInstance (
			AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

			ExampleBean eb = new ExampleBean (...);
			// some other operations...
			return eb;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ExampleBean private constructor() {
		companion object {
			// a static factory method; the arguments to this method can be
			// considered the dependencies of the bean that is returned,
			// regardless of how those arguments are actually used.
			@JvmStatic
            fun createInstance(anotherBean: AnotherBean, yetAnotherBean: YetAnotherBean, i: Int): ExampleBean {
				val eb = ExampleBean (...)
				// some other operations...
				return eb
			}
		}
	}
----

静态工厂方法的参数由 `<constructor-arg/>` 元素提供,与实际使用的构造函数完全相同. 工厂方法返回类的类型不必与包含静态工厂方法 的类完全相同,
尽管在本例中是这样. 实例(非静态) 工厂方法的使用方式也是相似的(除了使用 `factory-bean` 属性而不是 `class` 属性. 因此此处不在展开讨论.

[[beans-factory-properties-detailed]]
=== 依赖和配置细节

<<beans-factory-collaborators, 如上一节所述>>, 您可以将 bean 的属性和构造函数参数定义为对其他 bean 的引用,或者作为其内联定义的值. Spring 可以允许您在基于 XML 的配置元数据(定义 Bean) 中使用子元素 `<property/>` 和 `<constructor-arg/>` 来达到这种目的.

[[beans-value-element]]
==== 直接值(基本类型,String 等等)

`<property/>` 元素的 `value` 属性 将属性或构造函数参数指定为人类可读的字符串表示形式, Spring 的 <<core-convert-ConversionService-API, conversion service>> 用于将这些值从 String 转换为属性或参数的实际类型.  以下示例显示了要设置的各种值:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<!-- results in a setDriverClassName(String) call -->
		<property name="driverClassName" value="com.mysql.jdbc.Driver"/>
		<property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
		<property name="username" value="root"/>
		<property name="password" value="misterkaoli"/>
	</bean>
----

以下示例使用 <<beans-p-namespace,p-namespace>> 进行更简洁的 XML 配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
		https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
			destroy-method="close"
			p:driverClassName="com.mysql.jdbc.Driver"
			p:url="jdbc:mysql://localhost:3306/mydb"
			p:username="root"
			p:password="misterkaoli"/>

	</beans>
----

前面的 XML 更简洁.  但是因为属性的类型是在运行时确定的,而非设计时确定的. 所有有可能在运行时发现拼写错误. ,除非您在创建 bean 定义时使用支持自动属性完成的 IDE(例如 https://www.jetbrains.com/idea/[IntelliJIDEA] 或者 https://spring.io/tools[Spring Tools for Eclipse]) .  所以,强烈建议使用此类 IDE 帮助.

你也可以配置一个 `java.util.Properties` 的实例,如下:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="mappings"
		class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">

		<!-- typed as a java.util.Properties -->
		<property name="properties">
			<value>
				jdbc.driver.className=com.mysql.jdbc.Driver
				jdbc.url=jdbc:mysql://localhost:3306/mydb
			</value>
		</property>
	</bean>
----

Spring 的容器会将 `<value/>` 里面的文本通过 JavaBean 的 `PropertyEditor` 机制转换成 `java.util.Properties`  实例, 这种嵌套 `<value/>` 元素的快捷方式也是 Spring 团队推荐使用的.

[[beans-idref-element]]
=====  `idref` 元素

`idref` 元素只是一种防错方法,可以将容器中另一个 bean 的 `id` (字符串值 - 而不是引用) 传递给 `<constructor-arg/>` 或 `<property/>` 元素.

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="theTargetBean" class="..."/>

	<bean id="theClientBean" class="...">
		<property name="targetName">
			<idref bean="theTargetBean"/>
		</property>
	</bean>
----

前面的 bean 定义代码段运行时与以下代码段完全等效:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="theTargetBean" class="..." />

	<bean id="client" class="...">
		<property name="targetName" value="theTargetBean"/>
	</bean>
----

Spring 团队更推荐第一种方式,因为使用了 `idref` 标签,它会让容器在部署阶段就对 bean 进行校验,以确保 bean 一定存在. 而使用第二种方式的话,是没有任何校验的. 只有实际上引用了 `client` bean 的 `targetName` 属性
不对其值进行校验. 在实例化 client 的时候才会被发现. 如果 `client` 是 <<beans-factory-scopes,prototype>> 类型的 Bean 的话,那么类似拼写之类的错误会在容器部署以后很久才能发现.

NOTE: `idref`  元素的 `local` 属性 属性在 Spring 4.0 以后的 xsd 中已经不再支持了,而是使用了 `bean` 引用. 如果更新了版本的话,只要将 `idref local` 引用都转换成  `idref bean` 即可.

在 Spring 2.0 之前的版本中,`<idref/>` 在 `ProxyFactoryBean` bean定义中的 <<aop-pfb-1,AOP interceptors>>  的配置中 常见,指定拦截器名称时使用 `<idref/>` 元素可防止您拼写错误的拦截器 ID.

[[beans-ref-element]]
==== 引用其他的 Bean(装配)

`ref` 元素是  `<constructor-arg/>` or `<property/>` 定义元素中的最后一个元素.  你可以通过这个标签配置一个 bean 来引用另一个 bean. 当需要引用一个 bean 的时候,被引用的 bean 会先实例化,
然后配置属性,也就是引用的依赖. 如果该 bean 是单例 bean 的话 ,那么该 bean 会早由容器初始化. 最终会引用另一个对象的所有引用,bean 的作用域以及校验取决于你是否有通过  `bean`, 或 `parent` 这些属性来指定对象的 `id` 或者 `name` 属性. .

通过指定 bean 属性中的 `<ref/>` 元素来指定依赖是最常见的一种方式,可以引用容器或者父容器中的 bean,不在同一个 XML 文件定义也可以引用.  其中 bean 属性中的值可以和其他引用 bean 中的 `id` 属性一致,或者和其中的某个 `name` 属性一致,以下示例显示如何使用 `ref` 元素:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<ref bean="someBean"/>
----

通过指定 bean 的 `parent` 属性可以创建一个引用到当前容器的父容器之中. `parent` 属性的值可以与目标 bean 的 `id` 属性一致,或者和目标 bean 的 `name` 属性中的某个一致,目标 bean 必须是当前引用目标 bean 容器的父容器 .
开发者一般只有在具有层次化容器,并且希望通过代理来包裹父容器中一个存在的 bean 的时候才会用到这个属性.  以下一对列表显示了如何使用 `parent` 属性:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- in the parent context -->
	<bean id="accountService" class="com.something.SimpleAccountService">
		<!-- insert dependencies as required as here -->
	</bean>
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- in the child (descendant) context -->
	<bean id="accountService" <!-- bean name is the same as the parent bean -->
		class="org.springframework.aop.framework.ProxyFactoryBean">
		<property name="target">
			<ref parent="accountService"/> <!-- notice how we refer to the parent bean -->
		</property>
		<!-- insert other configuration and dependencies as required here -->
	</bean>
----

NOTE:  `ref` 元素中的 `local` 标签在 xsd 4.0,以后已经不再支持了,开发者可以通过将已存在的 `ref local` 改为  `ref bean` 来完成 Spring 版本升级.


[[beans-inner-beans]]
==== 内部 bean

定义在 `<bean/>` 元素的 `<property/>` 或者 `<constructor-arg/>` 元素之内的 bean 叫做内部 bean,如下例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="outer" class="...">
		<!-- instead of using a reference to a target bean, simply define the target bean inline -->
		<property name="target">
			<bean class="com.example.Person"> <!-- this is the inner bean -->
				<property name="name" value="Fiona Apple"/>
				<property name="age" value="25"/>
			</bean>
		</property>
	</bean>
----

内部 bean 定义不需要定义的 ID 或名称. 如果指定,则容器不使用此类值作为标识符. 容器还会在创建时忽略 `scope` 标签,因为内部 bean 始终是匿名的,并且始终使用外部 bean 创建.  开发者是无法将内部 bean 注入到外部 bean 以外的其他 bean 中的.


作为一个极端情况,可以从自定义作用域接收销毁回调,例如: 请求作用域的内部 bean 包含了单例 bean,那么内部 bean 实例会绑定到包含的 bean,而包含的 bean 允许访问 request 的 scope 生命周期.  这种场景并不常见,内部  bean 通常只是供给它的外部 bean 使用.


[[beans-collection-elements]]
==== 集合

在 `<list/>`, `<set/>`, `<map/>`, 和 `<props/>` 元素中,您可以分别配置 Java `Collection` 类型 `List`, `Set`, `Map`, 和 `Properties` 的属性和参数.  以下示例显示了如何使用它们:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="moreComplexObject" class="example.ComplexObject">
		<!-- results in a setAdminEmails(java.util.Properties) call -->
		<property name="adminEmails">
			<props>
				<prop key="administrator">administrator@example.org</prop>
				<prop key="support">support@example.org</prop>
				<prop key="development">development@example.org</prop>
			</props>
		</property>
		<!-- results in a setSomeList(java.util.List) call -->
		<property name="someList">
			<list>
				<value>a list element followed by a reference</value>
				<ref bean="myDataSource" />
			</list>
		</property>
		<!-- results in a setSomeMap(java.util.Map) call -->
		<property name="someMap">
			<map>
				<entry key="an entry" value="just some string"/>
				<entry key="a ref" value-ref="myDataSource"/>
			</map>
		</property>
		<!-- results in a setSomeSet(java.util.Set) call -->
		<property name="someSet">
			<set>
				<value>just some string</value>
				<ref bean="myDataSource" />
			</set>
		</property>
	</bean>
----

当然,map 的 key 或者 value,或者集合的 value 都可以配置为下列元素之一:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	bean | ref | idref | list | set | map | props | value | null
----

[[beans-collection-elements-merging]]
===== 集合的合并

Spring 的容器也支持集合合并,开发者可以定义父样式的 `<list/>`, `<map/>`, `<set/>` 或 `<props/>` 元素,
同时有子样式的 `<list/>`, `<map/>`, `<set/>` 或 `<props/>` 元素. 也就是说,子集合的值是父元素和子元素集合的合并值.

有关合并的这一节讨论父子 bean 机制,不熟悉父和子 bean 定义的读者可能希望在继续之前阅读<<beans-child-bean-definitions,相关部分>>

以下示例演示了集合合并:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="parent" abstract="true" class="example.ComplexObject">
			<property name="adminEmails">
				<props>
					<prop key="administrator">administrator@example.com</prop>
					<prop key="support">support@example.com</prop>
				</props>
			</property>
		</bean>
		<bean id="child" parent="parent">
			<property name="adminEmails">
				<!-- the merge is specified on the child collection definition -->
				<props merge="true">
					<prop key="sales">sales@example.com</prop>
					<prop key="support">support@example.co.uk</prop>
				</props>
			</property>
		</bean>
	<beans>
----

请注意,在 `child` bean 定义的 `adminEmails` 中的 `<props/>` 使用 `merge=true`  属性.  当容器解析并实例化 `child` bean时,
生成的实例有一个 `adminEmails` 属性集合, 其实例中包含的 `adminEmails` 集合就是child的 `adminEmails` 以及 parent 的 `adminEmails` 集合. 以下清单显示了结果:


[literal,subs="verbatim,quotes"]
----
administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk
----

子属性集合的 `Properties` 集合继承父 `<props/>` 的所有属性元素,子值的支持值覆盖父集合中的值.


这个合并的行为和 `<list/>`, `<map/>`, 和 `<set/>` 之类的集合类型的行为是类似的.  `<list/>` 在特定例子中,与  `List` 集合类型类似, 有着隐含的 `ordered` 概念. 所有的父元素里面的值,是在所有子元素的值之前配置的.
但是像 `Map`, `Set`, 和 `Properties` 的集合类型,是不存在顺序的.

[[beans-collection-merge-limitations]]
===== 集合合并的限制

您不能合并不同类型的集合(例如要将 `Map` 和 `List` 合并是不可能的) . 如果开发者硬要这样做就会抛出异常, `merge` 的属性是必须特指到更低级或者继承的子节点定义上, 特指 `merge` 属性到父集合的定义上是冗余的,而且在合并上也没有任何效果.

[[beans-collection-elements-strongly-typed]]
===== 强类型的集合

感谢 Java 对泛型类型的支持. 也就是,开发者可以声明 `Collection` 类型,然后这个集合只包含 `String` 元素(举例来说) .  如果开发者通过 Spring 来注入强类型的 `Collection` 到 bean 中,开发者就可以利用 Spring 的类型转换支持来做到 以下 Java 类和 bean 定义显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SomeClass {

		private Map<String, Float> accounts;

		public void setAccounts(Map<String, Float> accounts) {
			this.accounts = accounts;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class SomeClass {
	lateinit var accounts: Map<String, Float>
}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="something" class="x.y.SomeClass">
			<property name="accounts">
				<map>
					<entry key="one" value="9.99"/>
					<entry key="two" value="2.75"/>
					<entry key="six" value="3.99"/>
				</map>
			</property>
		</bean>
	</beans>
----

当 `something` 的属性 `accounts` 准备注入的时候,`accounts` 的泛型信息 `MapMap<String, Float>` 就会通过反射拿到.  这样 Spring 的类型转换系统能够识别不同的类型,如上面的例子 `Float` 然后会将字符串的值 `9.99`, `2.75`, 和 `3.99` 转换成对应的 `Float` 类型.

[[beans-null-element]]
==== Null 和 空字符串

`Strings` 将属性的空参数视为空字符串. 下面基于XML的元数据配置就会将 email 属性配置 `String` 值("").

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="ExampleBean">
		<property name="email" value=""/>
	</bean>
----

上面的示例等效于以下 Java 代码:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	exampleBean.setEmail("");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	exampleBean.email = ""
----


`<null/>` 将被处理为 `null` 值. 以下清单显示了一个示例:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="ExampleBean">
		<property name="email">
			<null/>
		</property>
	</bean>
----

上述配置等同于以下 Java 代码:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	exampleBean.setEmail(null);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	exampleBean.email = null
----


[[beans-p-namespace]]
==== 使用 p 命名空间简化 XML 配置

p 命名空间让开发者可以使用 `bean`  的属性,而不必使用嵌套的 `<property/>` 元素.

Spring 是支持基于 XML 的格式化 <<core.adoc#core.appendix.xsd-schemas,命名空间>>扩展的. 本节讨论的 `beans` 配置都是基于 XML 的,`p` 命名空间是定义在 Spring Core 中的(不是在 XSD 文件) .

以下示例显示了两个 XML 片段(第一个使用标准XML格式,第二个使用 `p` 命名空间) ,它们解析为相同的结果:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean name="classic" class="com.example.ExampleBean">
			<property name="email" value="someone@somewhere.com"/>
		</bean>

		<bean name="p-namespace" class="com.example.ExampleBean"
			p:email="someone@somewhere.com"/>
	</beans>
----

上面的例子在 bean 中定义了 `email` 的属性. 这种定义告知 Spring 这是一个属性声明. 如前面所描述的,`p` 命名空间并没有标准的定义模式,所以开发者可以将属性的名称配置为依赖名称.

下一个示例包括另外两个 bean 定义,它们都引用了另一个 bean:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean name="john-classic" class="com.example.Person">
			<property name="name" value="John Doe"/>
			<property name="spouse" ref="jane"/>
		</bean>

		<bean name="john-modern"
			class="com.example.Person"
			p:name="John Doe"
			p:spouse-ref="jane"/>

		<bean name="jane" class="com.example.Person">
			<property name="name" value="Jane Doe"/>
		</bean>
	</beans>
----

此示例不仅包含使用 `p` 命名空间的属性值,还使用特殊格式来声明属性引用. 第一个 bean 定义使用  `<property name="spouse" ref="jane"/>` 来创建从 bean `john` 到 bean `jane` 的引用,
而第二个 bean 定义使用 `p:spouse-ref="jane"` 来作为指向 bean 的引用. 在这个例子中 `spouse` 是属性的名字,而 `-ref` 部分表名这个依赖不是直接的类型,而是引用另一个 bean.


NOTE: `p` 命名空间并不如标准XML格式灵活. 例如,声明属性的引用可能和一些以 `Ref` 结尾的属性相冲突,而标准的 XML 格式就不会. Spring 团队推荐开发者能够和团队商量一下,协商使用哪一种方式,而不要同时使用三种方法.

[[beans-c-namespace]]
==== 使用 c  命名空间简化 XML

与 <<beans-p-namespace>> `p` 命名空间类似,c 命名空间是在 Spring 3.1 首次引入的,c 命名空间允许使用内联的属性来配置构造参数而不必使用 `constructor-arg` .

以下示例使用 `c:` 命名空间的例子来执行与 <<beans-constructor-injection>> 基于 Constructor 的依赖注入相同的操作:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:c="http://www.springframework.org/schema/c"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd">

		<bean id="beanTwo" class="x.y.ThingTwo"/>
		<bean id="beanThree" class="x.y.ThingThree"/>

		<!-- traditional declaration with optional argument names -->
		<bean id="beanOne" class="x.y.ThingOne">
			<constructor-arg name="thingTwo" ref="beanTwo"/>
			<constructor-arg name="thingThree" ref="beanThree"/>
			<constructor-arg name="email" value="something@somewhere.com"/>
		</bean>

		<!-- c-namespace declaration with argument names -->
		<bean id="beanOne" class="x.y.ThingOne" c:thingTwo-ref="beanTwo"
			c:thingThree-ref="beanThree" c:email="something@somewhere.com"/>

	</beans>
----

`c:` 命名空间使用了和 `p:` 命名空间相类似的方式(使用了 `-ref` 来配置引用).而且,同样的,c 命名空间也是定义在 Spring Core 中的(不是 XSD 模式).

在少数的例子之中,构造函数的参数名字并不可用(通常,如果字节码没有 debug 信息的编译),你可以使用回调参数的索引,如下面的例子:


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- c-namespace index declaration -->
	<bean id="beanOne" class="x.y.ThingOne" c:_0-ref="beanTwo" c:_1-ref="beanThree"
		c:_2="something@somewhere.com"/>
----

NOTE: 由于 XML 语法,索引表示法需要使用 `_` 作为属性名字的前缀,因为 XML 属性名称不能以数字开头(即使某些 IDE 允许它) . 相应的索引符号也可用于 `<constructor-arg>` 元素,但并不常用,因为声明的普通顺序在那里就足够了.

实际上,<<beans-factory-ctor-arguments-resolution,机制>> 在匹配参数方面非常有效,因此除非您确实需要,否则我们建议在整个配置中使用名称表示法.

[[beans-compound-property-names]]
==== 组合属性名

开发者可以配置混合的属性,只需所有的组件路径(除了最后一个属性名字) 不能为 `null` 即可. 参考如下定义:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="something" class="things.ThingOne">
		<property name="fred.bob.sammy" value="123" />
	</bean>
----

`something` 有 `fred` 属性, 而其中 `fred` 属性有 `bob` 属性,而 `bob` 属性之中有 `sammy` 属性,那么最后这个 `sammy` 属性会配置为 `123` .  想要上述的配置能够生效,`fred` 属性需要有 `bob` 属性而且在 `fred` 构造之后不为 `null` 即可.

[[beans-factory-dependson]]
=== 使用 `depends-on`

如果一个 bean 是另一个 bean 的依赖,通常这个 bean 也就是另一个 bean 的属性之一. 多数情况下,开发者可以在配置 XML 元数据的时候使用 <<beans-ref-element, `<ref/>` 元素>>  然而,有时 bean 之间的依赖不是直接关联的. 例如: 需要调用类的静态实例化器来触发依赖,类似数据库驱动注册. `depends-on` 属性可以显式强制初始化一个或多个 bean.  以下示例使用 `depends-on` 属性表示对单个bean的依赖:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="beanOne" class="ExampleBean" depends-on="manager"/>
	<bean id="manager" class="ManagerBean" />
----

如果想要依赖多个bean,可以提供多个名字作为 `depends-on` 的值. 以逗号、空格或者分号分割:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
		<property name="manager" ref="manager" />
	</bean>

	<bean id="manager" class="ManagerBean" />
	<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />
----

NOTE:  `depends-on` 属性既可以指定初始化时间依赖性,也可以仅在 <<beans-factory-scopes-singleton,singleton>> bean 的情况下指定相应的销毁时间依赖性. 独立定义了 `depends-on` 属性的 bean 会优先销毁 (相对于 `depends-on` 的 bean 销毁,这样 `depends-on` 可以控制销毁的顺序.


[[beans-factory-lazy-init]]
=== 懒加载 Bean

默认情况下, `ApplicationContext` 会在实例化的过程中创建和配置所有的单例<<beans-factory-scopes-singleton,singleton>> bean. 总的来说, 这个预初始化是很不错的. 因为这样能及时发现环境上的一些配置错误,而不是系统运行了很久之后才发现.
如果这个行为不是迫切需要的,开发者可以通过将 Bean 标记为延迟加载就能阻止这个预初始化 懒加载 bean 会通知 IoC 不要让 bean 预初始化而是在被引用的时候才会实例化.

在 XML 中,此行为由 `<bean/>` 元素上的 `lazy-init` 属性控制,如以下示例所示:


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="lazy" class="com.something.ExpensiveToCreateBean" lazy-init="true"/>
	<bean name="not.lazy" class="com.something.AnotherBean"/>
----

当将 bean 配置为上述 XML 的时候,  `ApplicationContext` 之中的 `lazy` bean 是不会随着 `ApplicationContext` 的启动而进入到预初始化状态的.  只有那些 `not.lazy` 加载的 bean 是处于预初始化的状态的.

然而,如果延迟加载的类是作为单例非延迟加载的 bean 的依赖而存在的话,`ApplicationContext` 仍然会在 `ApplicationContext` 启动的时候加载.  因为作为单例 bean 的依赖,会随着单例 bean 的实例化而实例化.

您还可以使用 `<beans/>` 元素上的 `default-lazy-init` 属性在容器级别控制延迟初始化,如下:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans default-lazy-init="true">
		<!-- no beans will be pre-instantiated... -->
	</beans>
----

[[beans-factory-autowire]]
=== 自动装配

Spring 容器可以根据 bean 之间的依赖自动装配,开发者可以让 Spring 通过 `ApplicationContext` 来自动解析这些关联,自动装载有很多优点:

* 自动装载能够明显的减少指定的属性或者是构造参数. (在 <<beans-child-bean-definitions,本章其他地方讨论>> 的其他机制,如 bean 模板,在这方面也很有价值. )
* 自动装载可以扩展开发者的对象,比如说,如果开发者需要加一个依赖,只需关心如何更改配置即可自动满足依赖关联. 这样,自动装载在开发过程中是极其高效的,无需明确选择装载的依赖会使系统更加稳定

使用基于 XML 的配置元数据(see <<beans-factory-collaborators>>), 可以使用 `<bean/>` 元素的 `autowire` 属性 为 bean 定义指定 autowire 模式.  自动装配功能有四种方式. 开发者可以指定每个 bean 的装配方式,这样 bean 就知道如何加载自己的依赖. 下表描述了四种自动装配模式:

[[beans-factory-autowiring-modes-tbl]]
.Autowiring modes
[cols="20%,80%"]
|===
| Mode| Explanation

| `no`
| (默认) 不自动装配. Bean 引用必须由 `ref` 元素定义,对于比较大的项目的部署,不建议修改默认的配置 ,因为明确指定协作者可以提供更好的控制和清晰度. 在某种程度上,它记录了系统的结构.

| `byName`
| 按属性名称自动装配.  Spring 查找与需要自动装配的属性同名的 bean.  例如,如果 bean 配置为根据名字装配,他包含 的属性名字为 `master`(即,它具有 `setMaster(..)` 方法) ,则 Spring 会查找名为 `master` 的 bean 定义并使用它来设置属性.

| `byType`
| 如果需要自动装配的属性的类型在容器中只存在一个的话,他允许自动装配. 如果存在多个,则抛出致命异常,这表示您不能对该 bean 使用 `byType` 自动装配.  如果没有匹配的 bean,则不会发生任何事情(未设置该属性) .

| `constructor`
| 类似于 `byType` ,但应用于构造函数参数.  如果容器中没有一个 Bean 的类型和构造函数参数类型一致的话,则会引发致命错误.
|===

通过 `byType` 或者 `constructor` 的自动装配方式,开发者可以装载数组和强类型集合. 在这样的例子中,所有容器中的匹配了指定类型的 bean 都会自动装配到 bean 上来完成依赖注入.  开发者可以自动装配 key 为 `String` 强类型的 `Map` . 自动装配的 `Map` 值会包含所有的 bean 实例值来匹配指定的类型,`Map` 的 `key` 会包含关联的 bean 的名字.

[[beans-autowired-exceptions]]
==== 自动装配的局限和缺点

自动装配在项目中一致使用时效果最佳. 如果一般不使用自动装配,那么开发人员使用它来装配一个或两个 bean 定义可能会让人感到困惑.

* `property` 和 `constructor-arg` 设置中的显式依赖始终覆盖自动装配. 开发者不能自动装配一些简单属性,您不能自动装配简单属性,例如基本类型 ,`Strings`, 和 `Classes`(以及此类简单属性的数组) . 这种限制是按设计的.
* 自动装配比显式的配置更容易歧义,尽管上表表明了不同自动配置的特点,Spring 也会尽可能避免不必要的装配错误. 但是 Spring 管理的对象关系仍然不如显式配置那样明确.
* 从 Spring 容器生成文档的工具可能无法有效的提供装配信息.
* 容器中的多个 bean 定义可能与 setter 方法或构造函数参数所指定的类型相匹配, 这有利于自动装配. 对于 arrays, collections, 或者 Map 实例来说这不是问题. 但是如果是对只有一个依赖的值是有歧义的话,那么这个项是无法解析的. 如果没有唯一的 bean,则会抛出异常.

在后面的场景,你可有如下的选择:

* 放弃自动装配,改用显式的配置.
* 通过将 `autowire-candidate` 属性设置为 `false`, 避免对 bean 定义进行自动装配, <<beans-factory-autowire-candidate, 如下一节所述>>.
* 通过将其 `<bean/>` 元素的 `primary` 属性设置为 `true`.将单个 bean 定义指定为主要候选项.
* 使用基于注解的配置实现更细粒度的控制,如<<beans-annotation-config,基于注解的容器配置中>>所述.

[[beans-factory-autowire-candidate]]
==== 将 bean 从自动装配中排除

在每个 bean 的基础上,您可以从自动装配中排除 bean.  在 Spring 的 XML 格式中,将 `<bean/>` 元素的 `autowire-candidate`  属性设置为 `false`. 容器使特定的 bean 定义对自动装配基础结构不可用(包括注解样式配置,如<<beans-autowired-annotation,`@Autowired`>>) .


NOTE: `autowire-candidate` 属性旨在仅影响基于类型的自动装配.  它不会影响名称的显式引用,即使指定的 bean 未标记为 autowire 候选,也会解析它.  因此,如果名称匹配,则按名称自动装配会注入 bean.

开发者可以通过模式匹配而不是 Bean 的名字来限制自动装配的候选者. 最上层的 `<beans/>` 元素会在 `default-autowire-candidates`  属性中来配置多种模式.  例如,限制自动装配候选者的名字以 `Repository` 结尾,可以配置成 `*Repository`.
如果需要配置多种模式,只需要用逗号分隔开即可.  bean定义的 `autowire-candidate` 属性的显式值 `true` 或 `false` 始终优先.  对于此类 bean,模式匹配规则不适用.

上面的这些技术在配置那些无需自动装配的 bean 是相当有效的,当然这并不是说这类 bean 本身无法自动装配其他的 bean. 而是说这些 bean 不再作为自动装配的依赖候选者.

[[beans-factory-method-injection]]
=== 查找方法注入

在大多数的应用场景下,多数的 bean 都是<<beans-factory-scopes-singleton,singletons>>的. 当这个单例的 bean 需要和另一个单例的或者非单例的 bean 协作使用的时候,开发者只需要配置依赖 bean 为这个 bean 的属性即可.  但是有时会因为 bean 具有不同的生命周期而产生问题.
假设单例的 bean A 在每个方法调用中使用了非单例的 bean B. 容器只会创建 bean A 一次,而只有一个机会来配置属性.  那么容器就无法为每一次创建 bean A 时都提供新的 bean B 实例.

一种解决方案就是放弃 IoC,开发者可以通过实现 `ApplicationContextAware`  接口 <<beans-factory-aware,让bean A对 `ApplicationContextAware` 可见>> .  <<beans-factory-client,从容器中调用 `getBean("B")` >>调用来使 bean A 知道该容器,以便每次 bean A 需要它时都请求一个(通常是新的) bean B 实例. 参考下面例子.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// a class that uses a stateful Command-style class to perform some processing
	package fiona.apple;

	// Spring-API imports
	import org.springframework.beans.BeansException;
	import org.springframework.context.ApplicationContext;
	import org.springframework.context.ApplicationContextAware;

	public class CommandManager implements ApplicationContextAware {

		private ApplicationContext applicationContext;

		public Object process(Map commandState) {
			// grab a new instance of the appropriate Command
			Command command = createCommand();
			// set the state on the (hopefully brand new) Command instance
			command.setState(commandState);
			return command.execute();
		}

		protected Command createCommand() {
			// notice the Spring API dependency!
			return this.applicationContext.getBean("command", Command.class);
		}

		public void setApplicationContext(
				ApplicationContext applicationContext) throws BeansException {
			this.applicationContext = applicationContext;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// a class that uses a stateful Command-style class to perform some processing
	package fiona.apple

	// Spring-API imports
	import org.springframework.context.ApplicationContext
	import org.springframework.context.ApplicationContextAware

	class CommandManager : ApplicationContextAware {

		private lateinit var applicationContext: ApplicationContext

		fun process(commandState: Map<*, *>): Any {
			// grab a new instance of the appropriate Command
			val command = createCommand()
			// set the state on the (hopefully brand new) Command instance
			command.state = commandState
			return command.execute()
		}

		// notice the Spring API dependency!
		protected fun createCommand() =
				applicationContext.getBean("command", Command::class.java)

		override fun setApplicationContext(applicationContext: ApplicationContext) {
			this.applicationContext = applicationContext
		}
	}
----

上面的代码并不让人十分满意,因为业务的代码已经与 Spring 框架耦合在一起. 方法注入是 Spring IoC 容器的一个高级功能,可以让您处理这种问题.  Spring 提供了一个稍微高级的注入方式来处理这种问题

****
您可以在此 https://spring.io/blog/2004/08/06/method-injection/[this blog entry]中阅读有关方法注入的更多信息.
****

[[beans-factory-lookup-method-injection]]
==== 查找方法注入

查找方法注入是容器覆盖管理 bean 上的方法的能力,以便返回容器中另一个命名 bean 的查找结果. 查找方法通常涉及原型 bean,如<<beans-factory-method-injection, 前面描述的场景>>.  Spring 框架通过使用 CGLIB 库生成的字节码来生成动态子类重写的方法实现此注入.

[NOTE]
====
* 如果想让这个动态子类正常工作,那么 Spring 容器所继承的 Bean 不能是 `final` 的,而覆盖的方法也不能是 `final` 的.
* 对具有抽象方法的类进行单元测试时,需要开发者对类进行子类化,并提供抽象方法的具体实现.
* 组件扫描也需要具体的方法,因为它需要获取具体的类.
* 另一个关键限制是查找方法不适用于工厂方法,特别是在配置类中不使用 `@Bean` 的方法. 因为在这种情况下,容器不负责创建实例,因此不能在运行时创建运行时生成的子类.
====

对于前面代码片段中的 `CommandManager` 类,Spring 容器动态地覆盖 `createCommand()` 方法的实现.  `CommandManager` 类不再拥有任何的 Spring 依赖,如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package fiona.apple;

	// no more Spring imports!

	public abstract class CommandManager {

		public Object process(Object commandState) {
			// grab a new instance of the appropriate Command interface
			Command command = createCommand();
			// set the state on the (hopefully brand new) Command instance
			command.setState(commandState);
			return command.execute();
		}

		// okay... but where is the implementation of this method?
		protected abstract Command createCommand();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package fiona.apple

	// no more Spring imports!

	abstract class CommandManager {

		fun process(commandState: Any): Any {
			// grab a new instance of the appropriate Command interface
			val command = createCommand()
			// set the state on the (hopefully brand new) Command instance
			command.state = commandState
			return command.execute()
		}

		// okay... but where is the implementation of this method?
		protected abstract fun createCommand(): Command
	}
----

在包含需要注入方法的客户端类中 (在本例中为 `CommandManager` ) 注入方法的签名需要如下形式:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<public|protected> [abstract] <return-type> theMethodName(no-arguments);
----

如果方法是 abstract 的, 那么动态生成的子类会实现该方法. 否则,动态生成的子类将覆盖原始类定义的具体方法. 例如:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- a stateful bean deployed as a prototype (non-singleton) -->
	<bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype">
		<!-- inject dependencies here as required -->
	</bean>

	<!-- commandProcessor uses statefulCommandHelper -->
	<bean id="commandManager" class="fiona.apple.CommandManager">
		<lookup-method name="createCommand" bean="myCommand"/>
	</bean>
----

当需要新的 `myCommand` bean实例时,标识为 `commandManager` 的bean会调用自身的 `createCommand()` 方法.开发者必须小心部署 `myCommand` bean为<<beans-factory-scopes-singleton,singleton>>bean. 如果所需的 bean 是单例的,那么每次都会返回相同的 `myCommand` bean 实例.

另外,如果是基于注解的配置模式,你可以在查找方法上定义 `@Lookup` 注解,如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public abstract class CommandManager {

		public Object process(Object commandState) {
			Command command = createCommand();
			command.setState(commandState);
			return command.execute();
		}

		@Lookup("myCommand")
		protected abstract Command createCommand();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	abstract class CommandManager {

		fun process(commandState: Any): Any {
			val command = createCommand()
			command.state = commandState
			return command.execute()
		}

		@Lookup("myCommand")
		protected abstract fun createCommand(): Command
	}
----

或者,更常见的是,开发者也可以根据查找方法的返回类型来查找匹配的 bean,如下

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public abstract class CommandManager {

		public Object process(Object commandState) {
			Command command = createCommand();
			command.setState(commandState);
			return command.execute();
		}

		@Lookup
		protected abstract Command createCommand();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	abstract class CommandManager {

		fun process(commandState: Any): Any {
			val command = createCommand()
			command.state = commandState
			return command.execute()
		}

		@Lookup
		protected abstract fun createCommand(): Command
	}
----

注意开发者可以通过创建子类实现 lookup 方法,以便使它们与 Spring 的组件扫描规则兼容,同时抽象类会在默认情况下被忽略. 这种限制不适用于显式注册 bean 或明确导入 bean 的情况.

[TIP]
====
另一种可以访问不同生命周期的方法是 `ObjectFactory`/`Provider` 注入,具体参看 <<beans-factory-scopes-other-injection,bean 的作用域的注入>>

您可能还会发现 `ServiceLocatorFactoryBean` (在 `org.springframework.beans.factory.config` 包中) 很有用.
====

[[beans-factory-arbitrary-method-replacement]]
==== 替换任意方法

从前面的描述中,我们知道查找方法是有能力来覆盖任何由容器管理的 bean 方法的. 开发者最好跳过这一部分,除非一定需要用到这个功能.

通过基于 XML 的元数据配置,开发者可以使用 `replaced-method` 元素来替换已存在方法的实现. 考虑以下类,它有一个我们想要覆盖的名为 `computeValue` 的方法:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyValueCalculator {

		public String computeValue(String input) {
			// some real code...
		}

		// some other methods...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyValueCalculator {

		fun computeValue(input: String): String {
			// some real code...
		}

		// some other methods...
	}
----

实现 `org.springframework.beans.factory.support.MethodReplacer` 接口的类提供了新的方法定义,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	/**
	 * meant to be used to override the existing computeValue(String)
	 * implementation in MyValueCalculator
	 */
	public class ReplacementComputeValue implements MethodReplacer {

		public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
			// get the input value, work with it, and return a computed result
			String input = (String) args[0];
			...
			return ...;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	/**
	 * meant to be used to override the existing computeValue(String)
	 * implementation in MyValueCalculator
	 */
	class ReplacementComputeValue : MethodReplacer {

		override fun reimplement(obj: Any, method: Method, args: Array<out Any>): Any {
			// get the input value, work with it, and return a computed result
			val input = args[0] as String;
			...
			return ...;
		}
	}
----

如果需要覆盖 bean 方法的 XML 配置如下类似于以下示例:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="myValueCalculator" class="x.y.z.MyValueCalculator">
		<!-- arbitrary method replacement -->
		<replaced-method name="computeValue" replacer="replacementComputeValue">
			<arg-type>String</arg-type>
		</replaced-method>
	</bean>

	<bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/>
----

您可以在 `<replaced-method/>` 元素中使用一个或多个  `<arg-type/>`  元素来指示被覆盖的方法的方法. 当需要覆盖的方法存在重载方法时,必须指定所需参数.  为了方便起见,字符串的类型会匹配以下类型,它完全等同于 `java.lang.String`:

[source,java,indent=0,subs="verbatim,quotes"]
----
	java.lang.String
	String
	Str
----

因为,通常来说参数的个数已经足够区别不同的方法,这种快捷的写法可以省去很多的代码.

[[beans-factory-scopes]]
== Bean 的作用域

创建 bean 定义时,同时也会定义该如何创建 Bean 实例.  这些具体创建的过程是很重要的,因为它意味着像创建类一样,您可以通过简单的定义来创建许多 bean 的实例.

您不仅可以将不同的依赖注入到 bean 中,还可以配置 bean 的作用域. 这种方法是非常强大而且也非常灵活,开发者可以通过配置来指定对象的作用域,无需在 Java 类的层次上配置.
bean 可以配置多种作用域,Spring 框架支持六种作用域,有四种作用域是当开发者使用基于 Web 的 `ApplicationContext` 的时候才有效的. 您还可以创建<<beans-factory-scopes-custom,自定义作用域.>>

下表描述了支持的作用域:

[[beans-factory-scopes-tbl]]
.Bean scopes
[cols="20%,80%"]
|===
| Scope| Description

| <<beans-factory-scopes-singleton,singleton>>
| (默认) 每一 Spring IOC 容器都拥有唯一的实例对象.

| <<beans-factory-scopes-prototype,prototype>>
| 一个 Bean 定义可以创建任意多个实例对象.

| <<beans-factory-scopes-request,request>>
| 将单个 bean 作用域限定为单个 HTTP 请求的生命周期.  也就是说,每个 HTTP 请求都有自己的 bean 实例,它是在单个 bean 定义的后面创建的.  只有基于 Web 的 Spring  `ApplicationContext` 的才可用.

| <<beans-factory-scopes-session,session>>
| 将单个 bean 作用域限定为HTTP `Session` 的生命周期.  只有基于 Web 的Spring `ApplicationContext` 的才可用.

| <<beans-factory-scopes-application,application>>
| 将单个 bean 作用域限定为 `ServletContext` 的生命周期.  只有基于 Web 的 Spring  `ApplicationContext` 的才可用.
| <<web.adoc#websocket-stomp-websocket-scope,websocket>>
| 将单个 bean 作用域限定为 `WebSocket` 的生命周期.  只有基于 Web 的 Spring `ApplicationContext` 的才可用.

|===

NOTE: 从 Spring 3.0 开始,线程作用域默认是可用的,但默认情况下未注册.  有关更多信息,请参阅 {api-spring-framework}/context/support/SimpleThreadScope.html[`SimpleThreadScope`] 的文档.  有关如何注册此作用域或任何其他自定义作用域的说明,请参阅使用<<beans-factory-scopes-custom-using>>.

[[beans-factory-scopes-singleton]]
=== Singleton 作用域

单例 bean 在全局只有一个共享的实例,所有依赖单例 bean 的场景中,容器返回的都是同一个实例.

换句话说,当您定义一个 bean 并且它的作用域是一个单例时,Spring IoC 容器只会根据 bean 的定义来创建该 bean 的唯一实例.  这些唯一的实例会缓存到容器中,后续针对单例 bean 的请求和引用,都会从这个缓存中拿到这个唯一实例.  下图显示了单例作用域的工作原理:

image::{image-resource}/singleton.png[]

Spring 的单例 bean 概念不同于设计模式(GoF) 之中所定义的单例模式. 设计模式中的单例模式是将一个对象的作用域硬编码的,一个 ClassLoader 只能有唯一的一个实例.  而 Spring 的单例作用域是以容器为前提的,每个容器每个 bean 只能有一个实例.  这意味着,如果在单个 Spring 容器中为特定类定义一个 bean,则 Spring 容器会根据 bean 定义创建唯一的 bean 实例.  单例作用域是 Spring 的默认作用域.  下面的例子是在 XML 中配置单例模式 Bean 的例子:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="accountService" class="com.something.DefaultAccountService"/>

	<!-- the following is equivalent, though redundant (singleton scope is the default) -->
	<bean id="accountService" class="com.something.DefaultAccountService" scope="singleton"/>
----



[[beans-factory-scopes-prototype]]
=== Prototype 作用域

非单例的、原型 bean 指的是每次请求 bean 实例时,返回的都是新的对象实例. 也就是说,每次注入到另外的 bean 或者通过调用 `getBean()` 方法来获得的 bean 都是全新的实例.  基于线程安全性的考虑,当 bean 对象有状态时使用原型作用域,而无状态时则使用单例作用域.

下图显示了原型作用域的工作原理:

image::{image-resource}/prototype.png[]

(数据访问对象(DAO) 通常不配置为原型,因为典型的 DAO 不具有任何会话状态. 我们可以更容易重用单例图的核心. )

用下面的例子来说明 Spring 的原型作用域:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="accountService" class="com.something.DefaultAccountService" scope="prototype"/>
----

与其他作用域相比,Spring 不会完整地管理原型 bean 的生命周期.  Spring 容器只会初始化、配置和装载这些 bean,然后传递给 Client. 但是之后就不会再有该原型实例的进一步记录.
也就是说,初始化生命周期回调方法在所有作用域的 bean 是都会调用的,但是销毁生命周期回调方法在原型 bean 是不会调用的. 所以,客户端代码必须注意清理原型 bean 以及释放原型 bean 所持有的资源.
可以通过使用自定义的<<beans-factory-extension-bpp,bean post-processor>>(Bean的后置处理器) 来让 Spring 释放掉原型 bean 所持有的资源.

在某些方面,Spring 容器关于原型作用域的 bean 就是取代了 Java 的 `new` 操作符.  所有的生命周期的控制都由客户端来处理(有关 Spring 容器中 bean 的生命周期的详细信息,请参阅<<beans-factory-lifecycle>>) .

[[beans-factory-scopes-sing-prot-interaction]]
=== 单例 bean 依赖原型 bean

当单例 bean 依赖原型 bean 时,请注意在实例化时解析依赖.  因此,如果将原型 bean 注入到单例的 bean 中,则会实例化一个新的原型 bean,然后将依赖注入到单例 bean 中.  这个依赖的原型 bean 仍然是同一个实例.

但是,假设您希望单例 bean 在运行时重复获取原型 bean 的新实例.  您不能将原型 bean 依赖注入到您的单例 bean 中, 因为当 Spring 容器实例化单例 bean 并解析注入其依赖时,该注入只发生一次.  如果您需要在运行时多次使用原型 bean 的新实例,请参阅<<beans-factory-method-injection>>.

[[beans-factory-scopes-other]]
=== Request, Session, Application, 和 WebSocket 作用域

`request`, `session`, `application`, 和 `websocket` 作用域只有在 Web 中使用 Spring 的 `ApplicationContext` 的实现,(例如 `ClassPathXmlApplicationContext`) 的情况下才用得上.
如果在普通的 Spring IoC 容器,例如 `ClassPathXmlApplicationContext` 中使用这些作用域,将会抛出 `IllegalStateException` 异常来说明使用了未知的作用域.

[[beans-factory-scopes-other-web-configuration]]
==== 初始化 Web Configuration

为了能够使用 `request`, `session`, `application`, 和
`websocket` 作用域 (Web 作用域的 bean) , 需要在配置 bean 之前作一些基础配置.  而对于标准的作用域,例如单例和原型作用域,这种基础配置是不需要的.

如何完成此初始设置取决于您的特定 Servlet 环境.

例如,如果开发者使用了 Spring Web MVC 框架,那么每一个请求都会通过 Spring 的 `DispatcherServlet` 来处理,那么也无需特殊的设置了. `DispatcherServlet` 和 `DispatcherPortlet` 已经包含了相应状态.

如果您使用 Servlet Web 容器,并且在 Spring 的 `DispatcherServlet` 之外处理请求(例如,使用 JSF 时) ,
则需要注册 `org.springframework.web.context.request.RequestContextListener` 或者 `ServletRequestListener`.
可以使用 `WebApplicationInitializer` 接口以编程方式完成此操作。或者将以下声明添加到 Web 应用程序的 `web.xml` 文件中:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<web-app>
		...
		<listener>
			<listener-class>
				org.springframework.web.context.request.RequestContextListener
			</listener-class>
		</listener>
		...
	</web-app>
----

或者,如果对 Listener 不是很熟悉,请考虑使用 Spring 的 `RequestContextFilter`.
Filter 映射取决于 Web 应用的配置,因此您必须根据需要进行更改.  以下清单显示了 Web 应用程序的过滤器部分:


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<web-app>
		...
		<filter>
			<filter-name>requestContextFilter</filter-name>
			<filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>
		</filter>
		<filter-mapping>
			<filter-name>requestContextFilter</filter-name>
			<url-pattern>/*</url-pattern>
		</filter-mapping>
		...
	</web-app>
----

`DispatcherServlet`, `RequestContextListener`, 和 `RequestContextFilter` 所做的工作实际上是一样的,都是将 request 对象请求绑定到服务的 `Thread` 上.  这才使 bean 在之后的调用链上对请求和会话作用域可见.

[[beans-factory-scopes-request]]
==== Request 作用域

参考下面这个 XML 配置的 bean 定义:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="loginAction" class="com.something.LoginAction" scope="request"/>
----

Spring 容器会在每次使用 `LoginAction` 来处理每个 HTTP 请求时都会创建新的 `loginAction` 实例. 也就是说,`loginAction`  bean 的作用域是 HTTP Request 级别的.
开发者可以随意改变实例的状态,因为其他通过 `loginAction`  请求来创建的实例根本看不到开发者改变的实例状态,所有创建的 Bean 实例都是根据独立的请求创建的. 当请求处理完毕,这个 bean 也将会销毁.

当使用注解配置或 Java 配置时,使用 `@RequestScope` 注解修饰的 bean 会被设置成 `request` 作用域.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RequestScope
	@Component
	public class LoginAction {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RequestScope
	@Component
	class LoginAction {
		// ...
	}
----

[[beans-factory-scopes-session]]
==== Session 作用域

参考下面 XML 配置的 bean 的定义:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>
----

Spring 容器通过在单个 HTTP 会话的生命周期中使用 `UserPreferences` bean 定义来创建 `UserPreferences` bean 的新实例. 换言之,`UserPreferences` Bean 的作用域是 HTTP Session 级别的,在 request-scoped 作用域的 bean 上,
开发者可以随意的更改实例的状态,同样,其他 HTTP Session 的基本实例在每个 Session 中都会请求 `userPreferences` 来创建新的实例,所以,开发者更改 bean 的状态, 对于其他的 Bean 仍然是不可见的. 当 HTTP Session 被销毁时,根据这个 Session 来创建的 bean 也将会被销毁.

使用注解配置和 Java 配置时,使用 `@SessionScope` 注解修饰的 bean 会被设置成 `session` 作用域.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@SessionScope
	@Component
	public class UserPreferences {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@SessionScope
	@Component
	class UserPreferences {
		// ...
	}
----

[[beans-factory-scopes-application]]
==== Application 作用域

参考下面用 XML 配置的 bean 的定义:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="appPreferences" class="com.something.AppPreferences" scope="application"/>
----

Spring 容器会在整个 Web 应用内使用到 `appPreferences` 的时候创建一个新的 `AppPreferences` 的实例. 也就是说,`appPreferences` bean是在 `ServletContext` 级别的, 就像普通的 `ServletContext` 属性一样.
这种作用域和 Spring 的单例作用域有一些相似的地方,但是也有两个重要的不同之处,它对于每一个 `ServletContext` 来说是单例的,但是对 Spring `ApplicationContext` 来说不是的(某些 web 应用可能包含多个 `ApplicationContext`) .
实际上它是被暴露在外的,并且作为 `ServletContext` 属性对外可见.

当使用注解配置或 Java 配置时,使用 `@ApplicationScope` 注解修饰的 bean 会被设置成 `application` 作用域 . 以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ApplicationScope
	@Component
	public class AppPreferences {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ApplicationScope
	@Component
	class AppPreferences {
		// ...
	}
----

[[beans-factory-scopes-websocket]]
==== WebSocket 作用域

WebSocket 作用域与 WebSocket 会话的生命周期相关联，适用于 STOMP over WebSocket 应用程序，请参阅
<<web.adoc#websocket-stomp-websocket-scope,WebSocket 作用域>>了解更多详情。


[[beans-factory-scopes-other-injection]]
==== 依赖有 Scope 的 Bean

Spring IoC 容器不仅仅管理对象(bean) 的实例化,同时也负责装配依赖. 如果开发者要将一个 bean 装配到比它作用域更广的 bean 时(例如 HTTP 请求返回的 bean) ,那么开发者应当选择注入 AOP 代理而不是使用带作用域的 bean.
也就是说,开发者需要注入代理对象,而这个代理对象既可以找到实际的 bean,还能够创建全新的 bean.

[NOTE]
====
您还可以在作为单例的作用域的 bean 之间使用 `<aop:scoped-proxy/>`,然后引用通过可序列化的中间代理,从而能够在反序列化时重新获取目标单例 bean.

当针对原型作用域的 bean 声明 `<aop:scoped-proxy/>` 时,每个通过代理的调用都会产生新的目标实例.

此外,作用域代理并不是取得作用域 bean 的唯一安全方式.  开发者也可以通过简单的声明注入(即构造函数或 setter 参数或自动装配字段) `ObjectFactory<MyTargetBean>`, 然后允许通过类似 `getObject()` 的方法调用来获取一些指定的依赖,而不是直接储存依赖的实例.

作为扩展变体,您可以声明 `ObjectProvider<MyTargetBean>`,它提供了几个额外的访问方法,包括 `getIfAvailable` 和 `getIfUnique`.

JSR-330 将这样的方法称为 Provider,它使用 `Provider<MyTargetBean>` 声明以及相关的 `get()` 方法来尝试获取每一个配置.  有关 JSR-330 整体的更多详细信息,请参看<<beans-standard-annotations,此处>> .
====

以下示例中的配置只有一行,但了解 "`why`" 以及它背后的 "`how`" 非常重要:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<!-- an HTTP Session-scoped bean exposed as a proxy -->
		<bean id="userPreferences" class="com.something.UserPreferences" scope="session">
			<!-- instructs the container to proxy the surrounding bean -->
			<aop:scoped-proxy/> <1>
		</bean>

		<!-- a singleton-scoped bean injected with a proxy to the above bean -->
		<bean id="userService" class="com.something.SimpleUserService">
			<!-- a reference to the proxied userPreferences bean -->
			<property name="userPreferences" ref="userPreferences"/>
		</bean>
	</beans>
----
<1> 定义代理的行.

要创建这样的一个代理,只需要在带作用域的 bean 定义中添加子节点 `<aop:scoped-proxy/>` 即可(具体查看<<beans-factory-scopes-other-injection-proxies>> 和
<<core.adoc#core.appendix.xsd-schemas, 基于 XML Schema 的配置>>) .
为什么在 `request`, `session` 和自定义作用域级别的bean定义需要 `<aop:scoped-proxy/>`, 考虑以下单例 bean 定义,并与这些特殊的作用域定义的内容进行相比(请注意,以下 `userPreferencesbean` 定义不完整) :


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session"/>

	<bean id="userManager" class="com.something.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
----

在上面的例子中,单例 bean(`userManager`) 注入了 HTTP Session 级别的 `userPreferences` 依赖.  显然, 问题就是 `userPreferences` 在 Spring 容器中只会实例化一次.
它的依赖(在这种情况下只有一个,`userPreferences` ) 也只注入一次.  这意味着 `userManager` 每次使用的是完全相同的 `userPreferences` 对象(即最初注入它的对象) 进行操作.

这不是将短周期作用域 bean 注入到长周期作用域bean时所需的行为,例如将 HTTP Session 级别的作用域 bean 作为依赖注入到单例 bean 中. 相反,开发者需要一个 `userManager` 对象, 而在 HTTP Session 的生命周期中,
开发者需要一个特定于 HTTP Session 的 `userPreferences` 对象. 因此,容器创建一个对象,该对象暴露与 `UserPreferences` 类(理想情况下为 `UserPreferences` 实例的对象)  完全相同的公共接口,
该对象可以从作用域机制( HTTP Request、Session 等) 中获取真实的 `UserPreferences` 对象. 容器将这个代理对象注入到 `userManager` 中, 而不知道这个 `UserPreferences` 引用是一个代理.
在这个例子中,当一个 `UserManager` 实例在依赖注入的 `UserPreferences` 对象上调用一个方法时, 它实际上是在调用代理的方法,再由代理从 HTTP Session (本例) 获取真实的 `UserPreferences` 对象,并将方法调用委托给检索到的实际 `UserPreferences` 对象.

因此,在将 `request-` and `session-scoped` 的bean来作为依赖时,您需要以下(正确和完整) 配置,如以下示例所示:  所以当开发者希望能够正确的使用配置请求、会话或者全局会话级别的bean来作为依赖时,需要进行如下类似的配置.


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="userPreferences" class="com.something.UserPreferences" scope="session">
		<aop:scoped-proxy/>
	</bean>

	<bean id="userManager" class="com.something.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
----

[[beans-factory-scopes-other-injection-proxies]]
===== 选择要创建的代理类型

默认情况下,当 Spring 容器为使用 `<aop:scoped-proxy/>` 元素标记的 bean 创建代理时,将创建基于 CGLIB 的类代理.

[NOTE]
====
CGLIB 代理只拦截 `public` 方法调用！ 不要在这样的代理上调用非 `public` 方法.  它们不会委托给实际的作用域目标对象.
====

或者,您可以通过为 `<aop:scoped-proxy/>` 元素的 `proxy-target-class` 属性的值指定 `false` 来配置 Spring 容器, 以便为此类作用域 bean 创建基于 JDK 接口的标准代理.
使用基于接口的 JDK 代理意味着开发者无需引入第三方库即可完成代理.  但是,这也意味着带作用域的 bean 需要额外实现一个接口,而依赖是从这些接口来获取的.  以下示例显示基于接口的代理:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- DefaultUserPreferences implements the UserPreferences interface -->
	<bean id="userPreferences" class="com.stuff.DefaultUserPreferences" scope="session">
		<aop:scoped-proxy proxy-target-class="false"/>
	</bean>

	<bean id="userManager" class="com.stuff.UserManager">
		<property name="userPreferences" ref="userPreferences"/>
	</bean>
----

有关选择基于类或基于接口的代理的更多详细信息,请参阅 <<aop-proxying>>.

[[beans-factory-scopes-custom]]
=== 自定义 Scopes

bean 的作用域机制是可扩展的,开发者可以自定义作用域,甚至重新定义已经存在的作用域,但是 Spring 团队不推荐这样做,而且开发者也不能重写 `singleton` 和 `prototype` 作用域.

[[beans-factory-scopes-custom-creating]]
==== 创建自定义作用域

为了能够使 Spring 可以管理开发者定义的作用域,开发者需要实现 `org.springframework.beans.factory.config.Scope·`. 如何实现自定义的作用域, 可以参考 Spring 框架的一些实现或者有关 {api-spring-framework}/beans/factory/config/Scope.html[`Scope`] 的javadoc

Scope 接口有四个方法用于操作对象,例如获取、移除或销毁等操作.

例如,传入 Session 作用域该方法将会返回一个 session-scoped 的 bean (如果它不存在,那么将会返回绑定 session 作用域的新实例) . 下面的方法返回相应作用域的对象:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Object get(String name, ObjectFactory<?> objectFactory)
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun get(name: String, objectFactory: ObjectFactory<*>): Any
----

下面的方法将从相应的作用域中移除对象. 同样,以会话为例,该函数会删除会话作用域的 Bean. 删除的对象会作为返回值返回,当无法找到对象时将返回 null.  以下方法从相应作用域中删除对象:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Object remove(String name)
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun remove(name: String): Any
----

以下方法注册作用域在销毁时或在 Scope 中的指定对象被销毁时应该执行的回调:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	void registerDestructionCallback(String name, Runnable destructionCallback)
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun registerDestructionCallback(name: String, destructionCallback: Runnable)
----

有关销毁回调的更多信息,请参看 {api-spring-framework}/beans/factory/config/Scope.html#registerDestructionCallback[javadoc] 或 Spring 的 Scope 实现部分.

下面的方法获取相应作用域的区分标识符:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	String getConversationId()
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun getConversationId(): String
----

这个标识符在不同的作用域中是不同的. 例如对于会话作用域,这个标识符就是会话的标识符.

[[beans-factory-scopes-custom-using]]
==== 使用自定义作用域

在实现了自定义作用域后,开发者还需要让 Spring 容器能够识别发现所创建的新作用域. 下面的方法就是在 Spring 容器中用来注册新 `Scope` 的:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	void registerScope(String scopeName, Scope scope);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun registerScope(scopeName: String, scope: Scope)
----

这个方法是在 `ConfigurableBeanFactory` 的接口中声明的,可以用在多数的 `ApplicationContext` 实现,也可以通过 `BeanFactory` 属性来调用.

`registerScope(..)` 方法的第一个参数是相关作用域的唯一名称. 举例来说,Spring 容器中的单例和原型就以它本身来命名.  第二个参数就是开发者希望注册和使用的自定义 `Scope` 实现的实例对象


假定开发者实现了自定义 `Scope` ,然后可以按如下步骤来注册.

NOTE: 下一个示例使用 `SimpleThreadScope` ,这个例子在 Spring 中是有实现的,但没有默认注册.  您自定义的作用域也可以通过如下的方式来注册.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Scope threadScope = new SimpleThreadScope();
	beanFactory.registerScope("thread", threadScope);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val threadScope = SimpleThreadScope()
	beanFactory.registerScope("thread", threadScope)
----

然后,您可以创建符合自定义 `Scope` 的作用域规则的 bean 定义,如下所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="..." class="..." scope="thread">
----

在自定义作用域中,开发者也不限于仅仅通过编程的方式来注册作用域,还可以通过配置 `CustomScopeConfigurer` 类来实现. 如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">
			<property name="scopes">
				<map>
					<entry key="thread">
						<bean class="org.springframework.context.support.SimpleThreadScope"/>
					</entry>
				</map>
			</property>
		</bean>

		<bean id="thing2" class="x.y.Thing2" scope="thread">
			<property name="name" value="Rick"/>
			<aop:scoped-proxy/>
		</bean>

		<bean id="thing1" class="x.y.Thing1">
			<property name="thing2" ref="thing2"/>
		</bean>

	</beans>
----

NOTE: 在 `FactoryBean` 实现中添加了 `<aop:scoped-proxy/>`  `<bean>` 元素时,它是工厂 bean 本身的作用域,而不是从 `getObject()` 方法返回的对象.

[[beans-factory-nature]]
== 自定义 Bean 的特性

Spring Framework 提供了许多可用于自定义 bean 特性的接口.  本节将它们分组如下:

* <<beans-factory-lifecycle>>
* <<beans-factory-aware>>
* <<aware-list>>

[[beans-factory-lifecycle]]
=== 生命周期回调

你可以实现 `InitializingBean` 和 `DisposableBean` 接口,让容器里管理 Bean 的生命周期. 容器会在调用 `afterPropertiesSet()` 之后和 `destroy()` 之前会允许 bean 在初始化和销毁 bean 时执行某些操作.


[TIP]
====
JSR-250 `@PostConstruct` 和 `@PreDestroy` 注解通常被认为是在现代 Spring 应用程序中接收生命周期回调的最佳实践.  使用这些注解意味着您的 bean 不会耦合到特定于 Spring 的接口.  有关详细信息,请参阅使用 <<beans-postconstruct-and-predestroy-annotations,@PostConstruct 和 @PreDestroy.>>

如果您不想使用 JSR-250 注解但仍想删除耦合,请考虑使用 `init-method` 和 `destroy-method` 定义对象元数据.
====

在内部,Spring 框架使用 `BeanPostProcessor` 实现来处理任何回调接口并调用适当的方法.  如果您需要 Spring 默认提供的自定义功能或其他生命周期行为,您可以自己实现 `BeanPostProcessor`.
有关更多信息,请参阅 <<beans-factory-extension>>.

除了初始化和销毁方法的回调,Spring 管理的对象也实现了 `Lifecycle` 接口来让管理的对象在容器的生命周期内启动和关闭.

本节描述了生命周期回调接口.

[[beans-factory-lifecycle-initializingbean]]
==== 初始化方法回调

`org.springframework.beans.factory.InitializingBean` 接口允许 bean 在所有的必要的依赖配置完成后执行 bean 的初始化, `InitializingBean` 接口中指定使用如下方法:

[source,java,indent=0,subs="verbatim,quotes"]
----
	void afterPropertiesSet() throws Exception;
----

Spring 团队是不建议开发者使用 `InitializingBean` 接口,因为这样会将代码耦合到 Spring 的特殊接口上. 他们建议使用 <<beans-postconstruct-and-predestroy-annotations, `@PostConstruct`>> 注解或者指定一个 POJO 的实现方法, 这会比实现接口更好.
在基于 XML 的元数据配置上,开发者可以使用 `init-method` 属性来指定一个没有参数的方法,使用 Java 配置的开发者可以在 `@Bean` 上添加 `initMethod` 属性.  请参阅<<beans-java-lifecycle-callbacks>>:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/>
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ExampleBean {

		public void init() {
			// do some initialization work
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ExampleBean {

		fun init() {
			// do some initialization work
		}
	}
----

前面的示例与以下示例(由两个列表组成) 具有几乎完全相同的效果:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class AnotherExampleBean implements InitializingBean {

		@Override
		public void afterPropertiesSet() {
			// do some initialization work
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class AnotherExampleBean : InitializingBean {

		override fun afterPropertiesSet() {
			// do some initialization work
		}
	}
----

但是,前面两个示例中的第一个没有将代码耦合到 Spring.


[[beans-factory-lifecycle-disposablebean]]
==== 销毁方法的回调

实现 `org.springframework.beans.factory.DisposableBean` 接口的 Bean 就能让容器通过回调来销毁 bean 所引用的资源.
`DisposableBean` 接口指定一个方法:

[source,java,indent=0,subs="verbatim,quotes"]
----
	void destroy() throws Exception;
----

我们建议您不要使用 `DisposableBean` 回调接口,因为它会不必要地将代码耦合到 Spring. 或者,我们建议使用<<beans-postconstruct-and-predestroy-annotations, `@PreDestroy`>> 注解 或指定 bean 定义支持的泛型方法.
在基于 XML 的元数据配置中,您可以在 `<bean/>` 上使用 `destroy-method` 属性.  使用 Java 配置,您可以使用 `@Bean` 的 `destroyMethod` 属性.  请参阅<<beans-java-lifecycle-callbacks>>.  考虑以下定义:


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/>
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ExampleBean {

		public void cleanup() {
			// do some destruction work (like releasing pooled connections)
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ExampleBean {

		fun cleanup() {
			// do some destruction work (like releasing pooled connections)
		}
	}
----

前面的定义与以下定义几乎完全相同:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="exampleInitBean" class="examples.AnotherExampleBean"/>
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class AnotherExampleBean implements DisposableBean {

		@Override
		public void destroy() {
			// do some destruction work (like releasing pooled connections)
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class AnotherExampleBean : DisposableBean {

		override fun destroy() {
			// do some destruction work (like releasing pooled connections)
		}
	}
----

但是,前面两个定义中的第一个没有将代码耦合到 Spring. .

TIP: 您可以为 `<bean>` 元素的 `destroy-method` 属性分配一个特殊的(推断的) 值,该值指示 Spring 自动检测特定 bean 类的 `close` 或者 `shutdown` 方法.  (因此,任何实现 `java.lang.AutoCloseable` 或 `java.io.Closeable` 的类都将匹配. )
您还可以在 `<bean>` 元素的 `default-destroy-method` 属性上设置此特殊(推断) 值,用于让所有的 bean 都实现这个行为(参见<<beans-factory-lifecycle-default-init-destroy-methods>>) .
请注意,这是 Java 配置的默认行为.

[[beans-factory-lifecycle-default-init-destroy-methods]]
==== 默认初始化和销毁方法

当您不使用 Spring 特有的 `InitializingBean` 和 `DisposableBean` 回调接口来实现初始化和销毁方法时,您定义方法的名称最好类似于 `init()`, `initialize()`, `dispose()`.
这样可以在项目中标准化类方法,并让所有开发者都使用一样的名字来确保一致性.

您可以配置 Spring 容器来针对每一个 Bean 都查找这种名字的初始化和销毁回调方法. 也就是说, 任意的开发者都会在应用的类中使用一个叫 `init()` 的初始化回调. 而不需要在每个 bean 中都定义 `init-method="init"` 这种属性,
Spring IoC 容器会在 bean 创建的时候调用那个回调方法(如<<beans-factory-lifecycle, 前面描述>>的标准生命周期一样) . 这个特性也将强制开发者为其他的初始化以及销毁回调方法使用同样的名字.

假设您的初始化回调方法名为 `init()`,而您的 `destroy` 回调方法名为 `destroy()`.  然后,您的类类似于以下示例中的类

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class DefaultBlogService implements BlogService {

		private BlogDao blogDao;

		public void setBlogDao(BlogDao blogDao) {
			this.blogDao = blogDao;
		}

		// this is (unsurprisingly) the initialization callback method
		public void init() {
			if (this.blogDao == null) {
				throw new IllegalStateException("The [blogDao] property must be set.");
			}
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class DefaultBlogService : BlogService {

		private var blogDao: BlogDao? = null
		
		// this is (unsurprisingly) the initialization callback method
		fun init() {
			if (blogDao == null) {
				throw IllegalStateException("The [blogDao] property must be set.")
			}
		}
	}
----

然后,您可以在类似于以下内容的 bean 中使用该类:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans default-init-method="init">

		<bean id="blogService" class="com.something.DefaultBlogService">
			<property name="blogDao" ref="blogDao" />
		</bean>

	</beans>
----

顶级 `<beans/>` 元素属性上存在 `default-init-method` 属性会导致 Spring IoC 容器将 bean 类上的 `init` 方法识别为初始化方法回调.  当 bean 被创建和组装时,如果 bean 拥有同名方法的话,则在适当的时候调用它.

您可以使用 `<beans/>` 元素上的 `default-destroy-method` 属性,以类似方式(在 XML 中) 配置destroy方法回调.


当某些 bean 已有的回调方法与配置的默认回调方法不相同时,开发者可以通过特指的方式来覆盖掉默认的回调方法. 以 XML 为例,可以通过使用元素的 `init-method` 和 `destroy-method` 属性来覆盖掉 `<bean/>` 中的配置.

Spring 容器会做出如下保证,bean 会在装载了所有的依赖以后,立刻就开始执行初始化回调. 这样的话,初始化回调只会在直接的 bean 引用装载好后调用, 而此时 AOP 拦截器还没有应用到 bean 上. 首先目标的 bean 会先完全初始化,
然后 AOP 代理和拦截链才能应用. 如果目标 bean 和代理是分开定义的,那么开发者的代码甚至可以跳过 AOP 而直接和引用的 bean 交互.  因此,在初始化方法中应用拦截器会前后矛盾,因为这样做耦合了目标 bean 的生命周期和代理/拦截器,还会因为与 bean 产生了直接交互进而引发不可思议的现象.

[[beans-factory-lifecycle-combined-effects]]
==== 组合生命周期策略

从 Spring 2.5 开始,您有三种选择用于控制 bean 生命周期行为:

*  <<beans-factory-lifecycle-initializingbean, `InitializingBean`>> 和
<<beans-factory-lifecycle-disposablebean, `DisposableBean`>> 回调接口
* 自定义 `init()` 和 `destroy()` 方法
* <<beans-postconstruct-and-predestroy-annotations, `@PostConstruct` 和 `@PreDestroy` 注解>>. 你也可以在 bean 上同时使用这些机制.

NOTE: 如果 bean 配置了多个生命周期机制,而且每个机制都配置了不同的方法名字时,每个配置的方法会按照以下描述的顺序来执行. 但是,如果配置了相同的名字, 例如初始化回调为 `init()`,在不止一个生命周期机制配置为这个方法的情况下,这个方法只会执行一次. 如 <<beans-factory-lifecycle-default-init-destroy-methods, 上一节中所述>>.

为同一个 bean 配置的多个生命周期机制具有不同的初始化方法,如下所示:

. 包含 `@PostConstruct` 注解的方法
. 在 `InitializingBean` 接口中的 `afterPropertiesSet()` 方法
. 自定义的 `init()` 方法

Destroy 方法以相同的顺序调用:

. 包含 `@PreDestroy` 注解的方法
. 在 `DisposableBean` 接口中的 `destroy()` 方法
. 自定义的 `destroy()` 方法

[[beans-factory-lifecycle-processor]]
==== 开始和关闭回调

`Lifecycle` 接口中为所有具有自定义生命周期需求的对象定义了一些基本方法(例如启动或停止一些后台进程) :

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface Lifecycle {

		void start();

		void stop();

		boolean isRunning();
	}
----

任何 Spring 管理的对象都可以实现 `Lifecycle` 接口. 然后,当 `ApplicationContext` 接收到启动和停止信号时(例如,对于运行时的停止/重启场景) ,
`ApplicationContext` 会通知到所有上下文中包含的生命周期对象.  它通过委托 `LifecycleProcessor` 完成此操作,如下面的清单所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface LifecycleProcessor extends Lifecycle {

		void onRefresh();

		void onClose();
	}
----

请注意,`LifecycleProcessor` 是 `Lifecycle` 接口的扩展.  它还添加了另外两种方法来响应刷新和关闭的上下文.

[TIP]
====
注意,常规的 `org.springframework.context.Lifecycle` 接口只是为明确的开始/停止通知提供一个约束,而并不表示在上下文刷新就会自动开始.
要对特定 bean 的自动启动(包括启动阶段) 进行细粒度控制,请考虑实现 `org.springframework.context.SmartLifecycle` 接口.

同时,停止通知并不能保证在销毁之前出现. 在正常的关闭情况下,所有的 `Lifecycle` 都会在销毁回调准备好之前收到停止通知,然而, 在上下文生命周期中的热刷新或者停止尝试刷新时,则只会调用销毁方法.

====

启动和关闭调用的顺序非常重要. 如果任何两个对象之间存在  "`depends-on`" 关系,则依赖方在其依赖之后开始,并且在其依赖之前停止. 但是,有时,直接依赖性是未知的.
您可能只知道某种类型的对象应该在另一种类型的对象之前开始.
在这些情况下, `SmartLifecycle` 接口定义了另一个选项,即在其超级接口 `Phased` 上定义的 `getPhase()` 方法.  以下清单显示了 `Phased` 接口的定义


[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface Phased {

		int getPhase();
	}
----

以下清单显示了 `SmartLifecycle` 接口的定义:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface SmartLifecycle extends Lifecycle, Phased {

		boolean isAutoStartup();

		void stop(Runnable callback);
	}
----

当启动时,拥有最低 `phased` 的对象会优先启动,而当关闭时,会相反的顺序执行. 因此,如果一个对象实现了 `SmartLifecycle`,然后令其 `getPhase()` 方法返回 `Integer.MIN_VALUE` 值的话,
就会让该对象最早启动,而最晚销毁. 显然,如果 `getPhase()` 方法返回了 `Integer.MAX_VALUE` 值则表明该对象会最晚启动,而最早销毁.
当考虑到使用 `phased` 值时,也同时需要了解正常没有实现 `SmartLifecycle` 的 `Lifecycle` 对象的默认值,这个值是 `0` . 因此,配置任意的负值都将表明将对象会在标准组件启动之前启动 ,
而在标准组件销毁以后再进行销毁.

`SmartLifecycle` 接口也定义了一个名为 `stop` 的回调方法,任何实现了 `SmartLifecycle` 接口的方法都必须在关闭流程完成之后调用回调中的 `run()` 方法.
这样做可以进行异步关闭,而 `lifecycleProcessor` 的默认实现 `DefaultLifecycleProcessor` 会等到配置的超时时间之后再调用回调.
默认的每一阶段的超时时间为 `30` 秒.  您可以通过在上下文中定义名为 `lifecycleProcessor` 的 bean 来覆盖默认生命周期处理器实例.  如果您只想修改超时,则定义以下内容就足够了:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="lifecycleProcessor" class="org.springframework.context.support.DefaultLifecycleProcessor">
		<!-- timeout value in milliseconds -->
		<property name="timeoutPerShutdownPhase" value="10000"/>
	</bean>
----

如前所述,`LifecycleProcessor` 接口还定义了用于刷新和关闭上下文的回调方法. 在关闭过程中,如果 `stop()` 方法已经被调用,则就会执行关闭流程.  但是如果上下文正在关闭中则不会在进行此流程, 而刷新的回调会使用到 `SmartLifecycle` 的另一个特性.
当上下文刷新完毕(所有的对象已经实例化并初始化) 后, 就会调用刷新回调,默认的生命周期处理器会检查每一个 `SmartLifecycle` 对象的 `isAutoStartup()` 方法返回的 `Boolean` 值.如果为真, 对象将会自动启动而不是等待明确的上下文调用,
或者调用自己的 `start()` 方法(不同于上下文刷新,标准的上下文实现是不会自动启动的) . `phase` 的值以及 "depends-on" 关系会决定对象启动和销毁的顺序.

[[beans-factory-shutdown]]
==== 在非 Web 应用中优雅地关闭 Spring IoC 容器

[NOTE]
====
本节仅适用于非 Web 应用程序.  Spring 的基于 Web 的 `ApplicationContext` 实现已经具有代码,可以在关闭相关 Web 应用程序时正常关闭 Spring IoC 容器.
====

如果开发者在非 Web 应用环境使用 Spring IoC 容器的话(例如,在桌面客户端的环境下) 开发者需要在 JVM 上注册一个关闭的钩子,来确保在关闭 Spring IoC 容器的时候能够调用相关的销毁方法来释放掉引用的资源.
当然,开发者也必须正确配置和实现那些销毁回调.

要注册关闭钩子,请调用 `ConfigurableApplicationContext` 接口上声明的 `registerShutdownHook()` 方法,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.springframework.context.ConfigurableApplicationContext;
	import org.springframework.context.support.ClassPathXmlApplicationContext;

	public final class Boot {

		public static void main(final String[] args) throws Exception {
			ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");

			// add a shutdown hook for the above context...
			ctx.registerShutdownHook();

			// app runs here...

			// main method exits, hook is called prior to the app shutting down...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.context.support.ClassPathXmlApplicationContext

	fun main() {
		val ctx = ClassPathXmlApplicationContext("beans.xml")

		// add a shutdown hook for the above context...
		ctx.registerShutdownHook()

		// app runs here...

		// main method exits, hook is called prior to the app shutting down...
	}
----

[[beans-factory-aware]]
=== `ApplicationContextAware` 和  `BeanNameAware`

当 `ApplicationContext` 创建实现 `org.springframework.context.ApplicationContextAware` 接口的对象实例时,将为该实例提供对该 `ApplicationContext` 的引用.  以下清单显示了 `ApplicationContextAware` 接口的定义:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface ApplicationContextAware {

		void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
	}
----

这样 bean 就能够通过编程的方式创建和操作 `ApplicationContext` 了. 通过 `ApplicationContext` 接口,或者通过将引用转换成已知的接口的子类, 例如 `ConfigurableApplicationContext` 就能够提供一些额外的功能. 其中的一个用法就是可以通过编程的方式来获取其他的 bean.有时候这个能力非常有用. 当然,Spring 团队并不推荐这样做,
因为这样会使代码与 Spring 框架耦合,同时也没有遵循 IoC 的风格.  `ApplicationContext` 中其它的方法可以提供一些诸如资源的访问、发布应用事件或者添加 `MessageSource` 之类的功能. `ApplicationContext` 的<<context-introduction>>中描述了这些附加功能.

自动装配是另一种获取 `ApplicationContext` 引用的替代方法. 传统的的构造函数 和 `byType` 的装载方式自动装配模式(如 <<beans-factory-autowire,自动装配>>中所述)
可以通过构造函数或 `setter` 方法的方式注入,开发者也可以通过注解注入的方式. 为了更为方便,包括可以注入的字段和多个参数方法,请使用新的基于注解的自动装配功能.
这样,`ApplicationContext` 将自动装配字段、构造函数参数或方法参数,如果相关的字段,构造函数或方法带有 `@Autowired` 注解,则该参数需要 `ApplicationContext` 类型.  有关更多信息,请参阅使用 <<beans-autowired-annotation>>.


当 `ApplicationContext` 创建实现了 `org.springframework.beans.factory.BeanNameAware` 接口的类,那么这个类就可以针对其名字进行配置. 以下清单显示了 `BeanNameAware` 接口的定义:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public interface BeanNameAware {

		void setBeanName(String name) throws BeansException;
	}
----

这个回调的调用在属性配置完成之后,但是在初始化回调之前. 例如 `InitializingBean.afterPropertiesSet()` 方法以及自定义的初始化方法等.

[[aware-list]]
=== 其他 `Aware` 接口

除了 `ApplicationContextAware` 和 `BeanNameAware`(<<beans-factory-aware, 前面已讨论过>>) 之外,Spring还提供了一系列 `Aware` 回调接口,让 bean 告诉容器,它们需要一些具体的基础配置信息. 一些重要的 `Aware` 接口如下表:

[[beans-factory-nature-aware-list]]
.Aware interfaces
|===
| Name| Injected Dependency| Explained in...

| `ApplicationContextAware`
| 声明  `ApplicationContext`.
| <<beans-factory-aware>>

| `ApplicationEventPublisherAware`
|  `ApplicationContext` 的事件发布者.
| <<context-introduction>>

| `BeanClassLoaderAware`
| 用于加载bean类的类加载器
| <<beans-factory-class>>

| `BeanFactoryAware`
| 声明  `BeanFactory`.
| <<beans-beanfactory>>

| `BeanNameAware`
| 声明bean的名称.
| <<beans-factory-aware>>

| `LoadTimeWeaverAware`
| 定义的 weaver 用于在加载时处理类定义.
| <<aop-aj-ltw>>

| `MessageSourceAware`
| 用于解析消息的已配置策略(支持参数化和国际化)
| <<context-introduction>>

| `NotificationPublisherAware`
| Spring JMX 通知发布者
| <<integration.adoc#jmx-notifications, Notifications>>

| `ResourceLoaderAware`
| 配置的资源加载器
| <<resources>>

| `ServletConfigAware`
| 当前 `ServletConfig` 容器运行. 仅在 Web 下的 Spring `ApplicationContext` 中有效
  `ApplicationContext`.
| <<web.adoc#mvc, Spring MVC>>

| `ServletContextAware`
| 容器运行的当前 `ServletContext`. 仅在 Web 下的 Spring `ApplicationContext` 中有效.
| <<web.adoc#mvc, Spring MVC>>
|===

请再次注意,使用这些接口会将您的代码绑定到 Spring API,而不会遵循 IoC 原则.  因此,我们建议将它们用于需要以编程方式访问容器的基础架构 bean.

[[beans-child-bean-definitions]]
== Bean 继承的定义

bean 定义可以包含许多配置信息,包括构造函数参数,属性值和特定于容器的信息,例如初始化方法,静态工厂方法名称等.  子 bean 定义从父定义继承配置数据.  子定义可以覆盖某些值或根据需要添加其他值.  使用父子 bean 定义可以节省很多配置输入.  实际上,这是一种模板形式.

如果开发者编程式地使用 `ApplicationContext` 接口,子 bean 定义可以通过 `ChildBeanDefinition` 类来表示. 很多开发者不会使用这个级别的方法,
而是会在类似于 `ClassPathXmlApplicationContext` 中声明式地配置 bean 定义. 当你使用基于 XML 的配置时,你可以在子 bean 中使用 parent 属性,该属性的值用来识别父 bean.  以下示例显示了如何执行此操作:


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="inheritedTestBean" abstract="true"
			class="org.springframework.beans.TestBean">
		<property name="name" value="parent"/>
		<property name="age" value="1"/>
	</bean>

	<bean id="inheritsWithDifferentClass"
			class="org.springframework.beans.DerivedTestBean"
			parent="inheritedTestBean" init-method="initialize">  <1>
		<property name="name" value="override"/>
		<!-- the age property value of 1 will be inherited from parent -->
	</bean>
----
<1> 请注意 `parent` 属性.

子 bean 如果没有指定 class,它将使用父 bean 定义的 class. 但也可以进行重写. 在后一种情况中,子 bean 必须与父bean兼容,也就是说,它必须接受父bean的属性值.

子 bean 定义从父类继承作用域、构造器参数、属性值和可重写的方法,除此之外,还可以增加新值. 开发者指定任何作用域、初始化方法、销毁方法和/或者静态工厂方法设置都会覆盖相应的父bean设置.

剩下的设置会取子 bean 定义: 依赖、自动注入模式、依赖检查、单例、延迟加载.

前面的示例通过使用 `abstract` 属性将父 bean 定义显式标记为 `abstract`.  如果父定义未指定类,则需要将父 bean 定义显式标记为 `abstract`,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="inheritedTestBeanWithoutClass" abstract="true">
		<property name="name" value="parent"/>
		<property name="age" value="1"/>
	</bean>

	<bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
			parent="inheritedTestBeanWithoutClass" init-method="initialize">
		<property name="name" value="override"/>
		<!-- age will inherit the value of 1 from the parent bean definition-->
	</bean>
----

父 bean 不能单独实例化,因为它不完整,并且也明确标记为 `abstract`. 当定义是 `abstract` 的时,它只能用作纯模板 bean 定义,用作子定义的父定义. 如果试图单独地使用声明了 `abstract` 的父 bean,
通过引用它作为另一个bean的 `ref` 属性,或者使用父 bean id 进行显式的 `getBean()` 调用,都将返回一个错误. 同样,容器内部的 `preInstantiateSingletons()` 方法也会忽略定义为 `abstract` 的bean.

NOTE: `ApplicationContext` 默认会预先实例化所有的单例 bean. 因此,如果开发者打算把(父) bean 定义仅仅作为模板来使用,同时为它指定了 `class` 属性, 那么必须确保设置 _abstract_ 的属性值为 _true_. 否则,应用程序上下文会(尝试) 预实例化这个 `abstract` bean.

[[beans-factory-extension]]
== 容器扩展点

通常,应用程序开发者无需继承 `ApplicationContext` 的实现类. 相反,Spring IoC 容器可以通过插入特殊的集成接口实现进行扩展. 接下来的几节将介绍这些集成接口.

[[beans-factory-extension-bpp]]
=== 使用 `BeanPostProcessor` 自定义 Bean

`BeanPostProcessor` 接口定义了可以实现的回调方法,以提供您自己的(或覆盖容器的默认) 实例化逻辑,依赖解析逻辑等.  如果要在 Spring 容器完成实例化,配置和初始化 bean 之后实现某些自定义逻辑,则可以插入一个或多个自定义 `BeanPostProcessor` 实现.

您可以配置多个 `BeanPostProcessor` 实例,并且可以通过设置 `order` 属性来控制这些 `BeanPostProcessor` 实例的执行顺序.  仅当 `BeanPostProcessor` 实现 `Ordered` 接口时,才能设置此属性. 如果编写自己的 `BeanPostProcessor` ,
则应考虑实现 `Ordered` 接口.  有关更多详细信息, 请参阅 {api-spring-framework}/beans/factory/config/BeanPostProcessor.html[`BeanPostProcessor`] 和
{api-spring-framework}/core/Ordered.html[`Ordered`] 的javadoc.  另请参阅有关<<beans-factory-programmatically-registering-beanpostprocessors, `BeanPostProcessor` 实例的编程注册>> .

[NOTE]
====
`BeanPostProcessor` 实例在 bean (或对象) 实例上运行.  也就是说,Spring IoC 容器实例化一个 bean 实例,然后才能用 `BeanPostProcessor` 对这个实例进行处理.

`BeanPostProcessor` 会在整个容器内起作用,所有它仅仅与正在使用的容器相关. 如果在一个容器中定义了 `BeanPostProcessor`,那么它只会处理那个容器中的 bean.  换句话说,在一个容器中定义的 bean 不会被另一个容器定义的 `BeanPostProcessor` 处理,即使这两个容器都是同一层次结构的一部分.

要更改实际的 bean 定义(即定义 bean 的蓝图) ,您需要使用 `BeanFactoryPostProcessor`,使用 `BeanFactoryPostProcessor` 自定义配置元数据. <<beans-factory-extension-factory-postprocessors>>

====

`org.springframework.beans.factory.config.BeanPostProcessor` 接口由两个回调方法组成,当一个类被注册为容器的后置处理器时,对于容器创建的每个 bean 实例, 后置处理器都会在容器初始化方法(如 `InitializingBean.afterPropertiesSet()` 之前和容器声明的 `init` 方法) 以及任何 bean 初始化回调之后被调用.
后置处理器可以对 bean 实例执行任何操作, 包括完全忽略回调. bean 后置处理器,通常会检查回调接口或者使用代理包装 bean. 一些 Spring AOP 基础架构类为了提供包装好的代理逻辑,会被实现为 bean 后置处理器.

`ApplicationContex` 会自动地检测所有定义在配置元文件中,并实现了 `BeanPostProcessor` 接口的 bean. `ApplicationContext` 会注册这些 beans 为后置处理器, 使他们可以在 bean 创建完成之后被调用. bean 后置处理器可以像其他 bean 一样部署到容器中.

当在配置类上使用 `@Bean` 工厂方法声明 `BeanPostProcessor` 时,工厂方法返回的类型应该是实现类自身. ,或至少也是 `org.springframework.beans.factory.config.BeanPostProcessor` 接口, 要清楚地表明这个 `bean` 的后置处理器的本质特点.
否则,在它完全创建之前,`ApplicationContext` 将不能通过类型自动探测它. 由于 `BeanPostProcessor` 在早期就需要被实例化, 以适应上下文中其他 bean 的实例化,因此这个早期的类型检查是至关重要的.


[[beans-factory-programmatically-registering-beanpostprocessors]]
.`BeanPostProcessor` 实例的编程注册
NOTE: 以编程方式注册 `BeanPostProcessor` 实例,虽然 `BeanPostProcessor` 注册的推荐方法是通过 `ApplicationContext` 自动检测(如前所述) ,但您可以以编程的方式使用 `ConfigurableBeanFactory` 的 `addBeanPostProcessor` 方法进行注册.  这对于在注册之前需要对条件逻辑进行评估,或者是在继承层次的上下文之间复制 bean 的后置处理器中是有很有用的.
但请注意,以编程方式添加的 `BeanPostProcessor` 实例不遵循 `Ordered` 接口. 这里,注册顺序决定了执行的顺序.  另请注意,以编程方式注册的 `BeanPostProcessor` 实例始终在通过自动检测注册的实例之前处理,而不管任何显式排序.

.`BeanPostProcessor` 实例 和 AOP 自动代理
[NOTE]
====
实现 `BeanPostProcessor` 接口的类是特殊的,容器会对它们进行不同的处理. 所有 `BeanPostProcessor` 和他们直接引用的 beans 都会在容器启动的时候被实例化, 并作为 `ApplicationContext` 特殊启动阶段的一部分. 接着,所有的 `BeanPostProcessor` 都会以一个有序的方式进行注册,并应用于容器中的所有bean.
因为 AOP 自动代理本身被实现为 `BeanPostProcessor`,这个 `BeanPostProcessor` 和它直接应用的beans都不适合进行自动代理,因此也就无法在它们中织入切面.

对于所有这样的 bean,您应该看到一条信息性日志消息: `Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)`.

如果你使用自动装配或 `@Resource`(可能会回退到自动装配) 将 Bean 连接到 `BeanPostProcessor` 中,Spring 可能会在搜索类型匹配的依赖候选时访问到意外类型的 bean;  因此,对它们不适合进行自动代理,或者对其他类型的 bean 进行后置处理. 例如,如果有一个使用 `@Resource` 注解的依赖,其中字段或 `setter` 名称不直接对应于bean的声明名称而且没有使用name属性, 则 Spring 会访问其他 bean 以按类型匹配它们.

====

以下示例显示如何在 `ApplicationContext` 中编写,注册和使用 `BeanPostProcessor` 实例.


[[beans-factory-extension-bpp-examples-hw]]
==== Example: Hello World, `BeanPostProcessor`-style

第一个例子说明了基本用法.  该示例显示了一个自定义 `BeanPostProcessor` 实现,该实现在容器创建时调用每个 bean 的 `toString()` 方法,并将生成的字符串输出到系统控制台.

以下清单显示了自定义 `BeanPostProcessor` 实现类定义:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package scripting;

	import org.springframework.beans.factory.config.BeanPostProcessor;

	public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {

		// simply return the instantiated bean as-is
		public Object postProcessBeforeInitialization(Object bean, String beanName) {
			return bean; // we could potentially return any object reference here...
		}

		public Object postProcessAfterInitialization(Object bean, String beanName) {
			System.out.println("Bean '" + beanName + "' created : " + bean.toString());
			return bean;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.config.BeanPostProcessor

	class InstantiationTracingBeanPostProcessor : BeanPostProcessor {

		// simply return the instantiated bean as-is
		override fun postProcessBeforeInitialization(bean: Any, beanName: String): Any? {
			return bean // we could potentially return any object reference here...
		}

		override fun postProcessAfterInitialization(bean: Any, beanName: String): Any? {
			println("Bean '$beanName' created : $bean")
			return bean
		}
	}
----

以下 `beans` 元素使用 `InstantiationTracingBeanPostProcessor`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:lang="http://www.springframework.org/schema/lang"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/lang
			https://www.springframework.org/schema/lang/spring-lang.xsd">

		<lang:groovy id="messenger"
				script-source="classpath:org/springframework/scripting/groovy/Messenger.groovy">
			<lang:property name="message" value="Fiona Apple Is Just So Dreamy."/>
		</lang:groovy>

		<!--
		when the above bean (messenger) is instantiated, this custom
		BeanPostProcessor implementation will output the fact to the system console
		-->
		<bean class="scripting.InstantiationTracingBeanPostProcessor"/>

	</beans>
----

注意 `InstantiationTracingBeanPostProcessor` 是如何定义的,它甚至没有名字,因为它是一个 bean,所以它可以像任何其他 bean 一样进行依赖注入 (前面的配置还定义了一个由 Groovy 脚本支持的 bean. 在<<languages.adoc#dynamic-language, 动态语言>>支持一章中详细介绍了 Spring 动态语言支持) .

下面简单的 Java 应用执行了前面代码和配置:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.springframework.context.ApplicationContext;
	import org.springframework.context.support.ClassPathXmlApplicationContext;
	import org.springframework.scripting.Messenger;

	public final class Boot {

		public static void main(final String[] args) throws Exception {
			ApplicationContext ctx = new ClassPathXmlApplicationContext("scripting/beans.xml");
			Messenger messenger = ctx.getBean("messenger", Messenger.class);
			System.out.println(messenger);
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
    import org.springframework.beans.factory.getBean

	fun main() {
		val ctx = ClassPathXmlApplicationContext("scripting/beans.xml")
		val messenger = ctx.getBean<Messenger>("messenger")
		println(messenger)
	}
----

上述应用程序的输出类似于以下内容:

[literal,subs="verbatim,quotes"]
----
Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961
org.springframework.scripting.groovy.GroovyMessenger@272961
----


[[beans-factory-extension-bpp-examples-aabpp]]
==== Example:  `AutowiredAnnotationBeanPostProcessor`

自定义 `BeanPostProcessor` 实现与回调接口或注解配合使用,是一种常见的扩展 Spring IoC 容器手段,一个例子就是 `AutowiredAnnotationBeanPostProcessor`,这是 `BeanPostProcessor` 实现.  自动注解字段， setter 方法， 和任意配置方法.

[[beans-factory-extension-factory-postprocessors]]
=== 使用 `BeanFactoryPostProcessor` 自定义元数据配置

下一个我们要关注的扩展点是 `org.springframework.beans.factory.config.BeanFactoryPostProcessor`. 这个接口的语义与 `BeanPostProcessor` 类似, 但有一处不同,`BeanFactoryPostProcessor` 操作 bean 的元数据配置.
也就是说,Spring IoC 容器允许 `BeanFactoryPostProcessor` 读取配置元数据, 并可能在容器实例化除 `BeanFactoryPostProcessor` 实例之外的任何 bean _之前_ 更改它.

您可以配置多个 `BeanFactoryPostProcessor` 实例,并且可以通过设置 `order` 属性来控制这些 `BeanFactoryPostProcessor` 实例的运行顺序( `BeanFactoryPostProcessor` 必须实现了 `Ordered` 接口才能设置这个属性) .
如果编写自己的 `BeanFactoryPostProcessor` ,则应考虑实现 `Ordered` 接口.  有关更多详细信息, 请参阅
{api-spring-framework}/beans/factory/config/BeanFactoryPostProcessor.html[`BeanFactoryPostProcessor`] 和 {api-spring-framework}/core/Ordered.html[`Ordered`] 接口的 javadoc.

[NOTE]
====
如果想修改实际的 bean 实例(也就是说,从元数据配置中创建的对象) 那么需要使用 `BeanPostProcessor`(前面在使用 `BeanPostProcessor` 自定义 Bean 中进行了描述<<beans-factory-extension-bpp>>) 来替代.
在 `BeanFactoryPostProcessor` (例如使用 `BeanFactory.getBean()`) 中使用这些 bean 的实例虽然在技术上是可行的,但这么来做会将bean过早实例化,
这违反了标准的容器生命周期. 同时也会引发一些副作用,例如绕过 bean 的后置处理.

`BeanFactoryPostProcessor` 会在整个容器内起作用,所有它仅仅与正在使用的容器相关. 如果在一个容器中定义了 `BeanFactoryPostProcessor`,
那么它只会处理那个容器中的 bean.  换句话说,在一个容器中定义的 bean 不会被另一个容器定义的 `BeanFactoryPostProcessor` 处理,即使这两个容器都是同一层次结构的一部分.
====

bean 工厂后置处理器在 `ApplicationContext` 中声明时自动执行,这样就可以对定义在容器中的元数据配置进行修改.  Spring 包含许多预定义的 bean 工厂后处理器,
例如 `PropertyOverrideConfigurer` 和 `PropertySourcesPlaceholderConfigurer`.  您还可以使用自定义 `BeanFactoryPostProcessor`.
例如,注册自定义属性编辑器 .

`ApplicationContext` 自动检测部署到其中的任何实现 `BeanFactoryPostProcessor` 接口的 bean.  它在适当的时候使用这些 bean 作为 bean 工厂后置处理器.  你可以部署这些后置处理器为你想用的任意其它 bean.

NOTE: 注意,和 `BeanPostProcessor` 一样,通常不应该配置 `BeanFactoryPostProcessor` 来进行延迟初始化. 如果没有其它 bean 引用 `Bean(Factory)PostProcessor`, 那么后置处理器就不会被初始化.
因此,标记它为延迟初始化就会被忽略,,即便你在 `<beans />` 元素声明中设置 `default-lazy-init=true` 属性,`Bean(Factory)PostProcessor` 也会提前初始化 bean.

[[beans-factory-placeholderconfigurer]]
==== Example: 类名替换 `PropertySourcesPlaceholderConfigurer`

您可以使用 `PropertySourcesPlaceholderConfigurer` 通过使用标准 Java `Properties` 格式从单独文件中的 bean 定义外部化属性值.
这样做可以使部署应用程序的人能够定制特定于环境的属性,如数据库 URL 和密码,而无需修改容器的主 XML 定义文件或文件的复杂性或风险.

考虑以下这个基于 XML 的元数据配置代码片段,这里的 `DataSource` 使用了占位符来定义:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">
		<property name="locations" value="classpath:com/something/jdbc.properties"/>
	</bean>

	<bean id="dataSource" destroy-method="close"
			class="org.apache.commons.dbcp.BasicDataSource">
		<property name="driverClassName" value="${jdbc.driverClassName}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.username}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>
----

该示例显示了从外部属性文件配置的属性. 在运行时,`PropertySourcesPlaceholderConfigurer` 应用于替换 `DataSource` 的某些属性的元数据.  要替换的值被指定为  pass:q[`${property-name}`] 形式的占位符,它遵循 Ant 和 log4j 以及 JSP EL 样式.

而真正的值是来自于标准的 Java `Properties` 格式的文件:

[literal,subs="verbatim,quotes"]
----
jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root
----

在上面的例子中,`${jdbc.username}` 字符串在运行时将替换为值 'sa',并且同样适用于与属性文件中的键匹配的其他占位符值.  `PropertySourcesPlaceholderConfigurer` 检查 bean 定义的大多数属性和属性中的占位符.  此外,您可以自定义占位符前缀和后缀.

使用 Spring 2.5 中引入的 `context` 命名空间,您可以使用专用配置元素配置属性占位符.  您可以在 `location` 属性中以逗号分隔列表的形式提供一个或多个位置,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<context:property-placeholder location="classpath:com/something/jdbc.properties"/>
----

`PropertySourcesPlaceholderConfigurer` 不仅在您指定的属性文件中查找属性.  默认情况下,如果它在指定的属性文件中找不到属性,则会检查 Spring `Environment` 属性和常规 Java `System` 属性.

[TIP]
=====
你可以使用 `PropertySourcesPlaceholderConfigurer` 来替换类名,当开发者在运行时需要选择某个特定的实现类时,这是很有用的. 例如

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer">
		<property name="locations">
			<value>classpath:com/something/strategy.properties</value>
		</property>
		<property name="properties">
			<value>custom.strategy.class=com.something.DefaultStrategy</value>
		</property>
	</bean>

	<bean id="serviceStrategy" class="${custom.strategy.class}"/>
----

如果在运行时无法将类解析为有效类,则在即将创建 bean 时,bean 的解析将失败,这是 `ApplicationContext` 在对非延迟初始化 bean 的 `preInstantiateSingletons()` 阶段发生的事.
=====


[[beans-factory-overrideconfigurer]]
==== Example: The `PropertyOverrideConfigurer`

`PropertyOverrideConfigurer`, 另外一种 bean 工厂后置处理器,类似于 `PropertyPlaceholderConfigurer`,但与后者不同的是: 对于所有的 bean 属性,原始定义可以有默认值或也可能没有值.  如果一个 `Properties` 覆盖文件没有配置特定的 bean 属性,则就会使用默认的上下文定义

注意,bean 定义是不知道是否被覆盖的,所以从 XML 定义文件中不能马上看到那个配置正在被使用. 在拥有多个 `PropertyOverrideConfigurer` 实例的情况下,为相同 bean 的属性定义不同的值时,基于覆盖机制只会有最后一个生效.

属性文件配置行采用以下格式:

[literal,subs="verbatim,quotes"]
----
beanName.property=value
----

例如:

[literal,subs="verbatim,quotes"]
----
dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb
----

这个示例文件可以和容器定义一起使用,该容器定义包含一个名为 `dataSource` 的 bean,该 bean 具有 `driver` 和 `url` 属性

复合属性名称也是被支持的,只要被重写的最后一个属性以外的路径中每个组件都已经是非空时(假设由构造方法初始化) .  在下面的示例中,`tom` bean 的 `fred` 属性的 `bob` 属性的 `sammy` 属性设置值为 `123`:

[literal,subs="verbatim,quotes"]
----
tom.fred.bob.sammy=123
----


NOTE: 指定的覆盖值通常是文字值,它们不会被转换成 bean 的引用. 这个约定也适用于当 XML 中的 bean 定义的原始值指定了 bean 引用时.
使用 Spring 2.5 中引入的 `context` 命名空间,可以使用专用配置元素配置属性覆盖,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<context:property-override location="classpath:override.properties"/>
----

[[beans-factory-extension-factorybean]]
=== 使用 `FactoryBean` 自定义初始化逻辑

为自己工厂的对象实现 `org.springframework.beans.factory.FactoryBean` 接口.

`FactoryBean` 接口就是 Spring IoC 容器实例化逻辑的可插拔点,如果你的初始化代码非常复杂,那么相对于(潜在地) 大量详细的 XML 而言,最好是使用 Java 语言来表达.  你可以创建自定义的 `FactoryBean` ,在该类中编写复杂的初始化代码. 然后将自定义的 `FactoryBean` 插入到容器中.

`FactoryBean<T>` 接口提供下面三个方法


* `T getObject()`: 返回这个工厂创建的对象实例. 这个实例可能是共享的,这取决于这个工厂返回的是单例还是原型实例.
* `boolean isSingleton()`: 如果 `FactoryBean` 返回单例,那么这个方法就返回 `true`,否则返回 `false`. 此方法的默认实现返回 `true`。
* ``Class<?> getObjectType()`: 返回由 `getObject()` 方法返回的对象类型,如果事先不知道的类型则会返回 `null`.

Spring 框架大量地使用了 `FactoryBean` 的概念和接口,`FactoryBean` 接口的 50 多个实现都随着 Spring 一同提供.

当开发者需要向容器请求一个真实的 `FactoryBean` 实例(而不是它生产的bean) 时,调用 `ApplicationContext` 的 `getBean()` 方法时在 bean 的 id 之前需要添加连字符(`&`)  所以对于一个给定 `id` 为 `myBean` 的 `FactoryBean`,
调用容器的 `getBean("myBean")` 方法返回的是 `FactoryBean` 的代理,而调用 `getBean("&myBean")` 方法则返回 `FactoryBean` 实例本身

[[beans-annotation-config]]
== 基于注解的容器配置

.注解是否比 XML 配置更好?
****
在引入基于注解的配置之后,便出现了注解是否比 XML 配置更好的问题. 答案是,得看情况,每种方法都有其优缺点,通常由开发人员决定使用那种方式. 首先看看两种定义方式,注解在它们的声明中提供了很多上下文信息,使得配置变得更短、更简洁;
但是,XML 擅长于在不接触源码或者无需反编译的情况下装配组件,一些开发人员更喜欢在源码上使用注解配置.  而另一些人认为注解类不再是 POJO,同时认为注解配置会很分散,最终难以控制.

无论选择如何,Spring 都可以兼顾两种风格,甚至可以将它们混合在一起. Spring 通过其  <<beans-java, JavaConfig>> 选项,允许注解以无侵入的方式使用,即无需接触目标组件源代码.  而且在工具应用方面, https://spring.io/tools[Spring Tools for Eclipse] 支持所有配置形式.
****

XML 配置的替代方法是基于注解的配置,它依赖于字节码元数据来连接组件进而替代 XML 声明. 开发人员通过使用相关类、方法或字段上声明的注解来将配置移动到组件类本身. 而不是使用  `XML bean` 来配置.
如 <<beans-factory-extension-bpp-examples-aabpp>> 所述,`AutowiredAnnotationBeanPostProcessor`,将 `BeanPostProcessor` 与注解混合使用是扩展 Spring IoC 容器的常用方法.
例如, Spring 2.5 引用了一种基于注解的方式来进行 Spring 的依赖注入.
本质上,`@Autowired` 注解提供的功能与 <<beans-factory-autowire>>  中描述的相同,但具有更细粒度的控制和更广泛的适用性.  Spring 2.5 还增加了对 JSR-250 注解的支持,例如 `@PostConstruct` 和 `@PreDestroy`. Spring 3.0 增加了对 JSR-330 (Dependency
Injection for Java)  包含在 `javax.inject` 包中的注解，例如 `@Inject` 和 `@Named`。 有关这些注解的详细信息，请参见 <<beans-standard-annotations,相关部分>>

[NOTE]
====
注解注入在 XML 注入之前执行,因此同时使用这两种方式进行注入时,XML 配置会覆盖注解配置.
====

与之前一样,你可以将它们注册为单独的 bean 定义,但也可以通过在基于 XML 的 Spring 配置中包含以下标记来隐式注册它们(请注意包含 `context` 命名空间) :

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:annotation-config/>

	</beans>
----

`<context:annotation-config/>` 元素隐式注册如下后置处理器:

* {api-spring-framework}/context/annotation/ConfigurationClassPostProcessor.html[`ConfigurationClassPostProcessor`]
* {api-spring-framework}/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html[`AutowiredAnnotationBeanPostProcessor`]
* {api-spring-framework}/context/annotation/CommonAnnotationBeanPostProcessor.html[`CommonAnnotationBeanPostProcessor`]
* {api-spring-framework}/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html[`PersistenceAnnotationBeanPostProcessor`]
* {api-spring-framework}/context/event/EventListenerMethodProcessor.html[`EventListenerMethodProcessor`]

[NOTE]
====
`<context:annotation-config/>` 只有在定义 bean 的相同应用程序上下文中查找 bean 上的注解.  这意味着,如果将 `<context:annotation-config/>`  放在 `DispatcherServlet` 的 `WebApplicationContext` 中,
 它只检查控制器中的 `@Autowired` bean,而不检查您的服务.  有关更多信息,请参阅 <<web.adoc#mvc-servlet, The DispatcherServlet>> .
====

[[beans-autowired-annotation]]
=== 使用 `@Autowired`

[NOTE]
====
JSR 330 的 `@Inject` 注解代替本节中包含的示例中的 Spring 的 `@Autowired` 注解.  有关详细信息,请参见<<beans-standard-annotations,此处>>
====

开发者可以在构造器上使用 `@Autowired` 注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		private final CustomerPreferenceDao customerPreferenceDao;

		@Autowired
		public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
			this.customerPreferenceDao = customerPreferenceDao;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender @Autowired constructor(
		private val customerPreferenceDao: CustomerPreferenceDao)
----

[NOTE]
====
从 Spring Framework 4.3 开始,如果目标 bean 仅定义一个构造函数,则不再需要 `@Autowired` 构造函数. 如果有多个构造函数可用并且没有 primary/default 构造器,则至少有一个必须注解 `@Autowired` 以让容器知道它使用的是哪个.
可以查阅 <<beans-autowired-annotation-constructor-resolution, 构造函数解析>> 的讨论获取更多细节.
====

您还可以将 `@Autowired` 注解应用于 _传统_ setter 方法,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Autowired
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimpleMovieLister {

		@set:Autowired
		lateinit var movieFinder: MovieFinder

		// ...

	}
----

您还可以将注解应用于具有任意名称和多个参数的方法,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		private MovieCatalog movieCatalog;

		private CustomerPreferenceDao customerPreferenceDao;

		@Autowired
		public void prepare(MovieCatalog movieCatalog,
				CustomerPreferenceDao customerPreferenceDao) {
			this.movieCatalog = movieCatalog;
			this.customerPreferenceDao = customerPreferenceDao;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		private lateinit var movieCatalog: MovieCatalog

		private lateinit var customerPreferenceDao: CustomerPreferenceDao

		@Autowired
		fun prepare(movieCatalog: MovieCatalog,
					customerPreferenceDao: CustomerPreferenceDao) {
			this.movieCatalog = movieCatalog
			this.customerPreferenceDao = customerPreferenceDao
		}

		// ...
	}
----

还可以将 `@Autowired` 应用于字段,甚至可以和构造函数混合使用:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		private final CustomerPreferenceDao customerPreferenceDao;

		@Autowired
		private MovieCatalog movieCatalog;

		@Autowired
		public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
			this.customerPreferenceDao = customerPreferenceDao;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender @Autowired constructor(
		private val customerPreferenceDao: CustomerPreferenceDao) {

		@Autowired
		private lateinit var movieCatalog: MovieCatalog

		// ...
	}
----

[TIP]
====
确保您的组件(例如,`MovieCatalog` 或 `CustomerPreferenceDao` ) 始终按照用于 `@Autowired` 注入的类型声明.  否则,由于在运行时未找到类型匹配,注入可能会失败.

对于通过类路径扫描找到的 XML 定义的 bean 或组件类,容器通常预先知道具体类型.  但是,对于 `@Bean` 工厂方法,您需要确保其声明的具体返回类型.  对于实现多个接口的组件或可能由其实现类型引用的组件,请考虑在工厂方法上声明最具体的返回类型(至少与引用 bean 的注入点所需的特定类型一致) .
====

您还可以通过将 `@Autowired` 注解添加到需要该类型数组的字段或方法来指示 Spring 从 `ApplicationContext` 提供特定类型的所有 bean，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		@Autowired
		private MovieCatalog[] movieCatalogs;

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		@Autowired
		private lateinit var movieCatalogs: Array<MovieCatalog>

		// ...
	}
----

也可以应用于集合类型,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		private Set<MovieCatalog> movieCatalogs;

		@Autowired
		public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {
			this.movieCatalogs = movieCatalogs;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		@Autowired
		lateinit var movieCatalogs: Set<MovieCatalog>
		
		// ...
	}
----

[[beans-factory-ordered]]
[TIP]
====
如果想让数组元素或集合元素按特定顺序排列, 可以实现 `org.springframework.core.Ordered` , 或者使用 `@Order` 或标准的 `@Priority` 注解,否则,它们的顺序遵循容器中相应目标 bean 定义的注册顺序.

您可以在类级别和 `@Bean` 方法上声明 `@Order` 注解,可能是通过单个 bean 定义(在多个定义使用相同 bean 类的情况下) .  `@Order` 值可能会影响注入点的优先级,但要注意它们不会影响单例启动顺序,这是由依赖和 `@DependsOn` 声明确定的.

请注意,标准的 `jakarta.annotation.Priority` 注解在 `@Bean` 级别不可用,因为它无法在方法上声明.  它的语义可以通过 `@Order` 值与 `@Primary` 定义每个类型的单个 bean 上.
====

只要键类型是 String,`Map` 类型就可以自动注入.  Map 值将包含所有类型的 bean,并且键将包含相应的 bean 名称. 如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		private Map<String, MovieCatalog> movieCatalogs;

		@Autowired
		public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {
			this.movieCatalogs = movieCatalogs;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		@Autowired
		lateinit var movieCatalogs: Map<String, MovieCatalog>
		
		// ...
	}
----

默认情况下,当没有候选的 bean 可用时,自动注入将会失败; 对于声明的数组,集合或映射,至少应有一个匹配元素.

默认的处理方式是将带有注解的方法、构造函数和字段标明为必须依赖,也可以使用 `@Autowired` 中的 `required=false` 属性. 来标明这种依赖不是必须的,如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Autowired(required = false)
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimpleMovieLister {

		@Autowired(required = false)
		var movieFinder: MovieFinder? = null

		// ...
	}
----

[NOTE]
====
如果不需要的方法(或在多个参数的情况下,其中一个依赖) 不可用,则根本不会调用该方法.  在这种情况下,完全不需要填充非必需字段,而将其默认值保留在适当的位置.

换句话说，将 `required` 属性设置为  `false` 来表示此属性是可选的，属性表示该属性不是自动装配必需的，如果不能自动装配则忽略，这允许为属性分配默认值，可以通过依赖注入选择性地覆盖它。
====

[[beans-autowired-annotation-constructor-resolution]]

构造函数和工厂方法参数注入是一种特殊情况,因为由于 Spring 的构造函数解析算法可能会处理多个构造函数,因此 `@Autowired` 中的 `required` 属性的含义有所不同.  默认情况下,需要构造函数和工厂方法参数,但是在单构造函数场景中有一些特殊规则,
例如,如果没有可用的匹配 bean,则多元素注入点(数组,集合,映射) 解析为空实例.  这允许一种通用的实现模式,其中所有依赖都可以在唯一的多参数构造函数中声明-例如,声明为没有 `@Autowired` 注解的单个公共构造函数.

[NOTE]
====
每个类仅可以有一个带  `@Autowired` 注解,并将 `required` 属性设置为 `true` 的构造函数,但是可以注解多个构造函数. 在这种情况下,它们都必须声明 `required = false` 才能被
被视为自动装配的候选对象(类似于XML中的 `autowire = constructor`).而 Spring 使用的是最贪婪的构造函数.这个构造函数的依赖可以得到满足,那就是具有最多参数的构造函数.同样,如果一个类
声明了多个构造函数,但是没有一个用 `@Autowired` 注解,然后将使用 primary/default 构造函数(如果存在).如果一个类仅声明一个构造函数,即使没有注解,也将始终使用它.请注意带注解的构造函数不必是 public 的.
====

或者,您可以通过 Java 8 的 `java.util.Optional` 表达特定依赖的非必需特性,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public class SimpleMovieLister {

		@Autowired
		public void setMovieFinder(Optional<MovieFinder> movieFinder) {
			...
		}
	}
----

从 Spring Framework 5.0 开始,您还可以使用 `@Nullable` 注解(任何包中的任何类型,例如,来自 JSR-305 的 `javax.annotation.Nullable`)

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		@Autowired
		public void setMovieFinder(@Nullable MovieFinder movieFinder) {
			...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimpleMovieLister {

		@Autowired
		var movieFinder: MovieFinder? = null

		// ...
	}
----

您也可以使用 `@Autowired` 作为常见的可解析依赖的接口,`BeanFactory`, `ApplicationContext`, `Environment`, `ResourceLoader`, `ApplicationEventPublisher`, 和 `MessageSource` 这些接口及其扩展接口
(例如 `ConfigurableApplicationContext` 或 `ResourcePatternResolver`)  会自动解析,无需特殊设置.  以下示例自动装配 `ApplicationContext` 对象:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		@Autowired
		private ApplicationContext context;

		public MovieRecommender() {
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class MovieRecommender {

	@Autowired
	lateinit var context: ApplicationContext

	// ...
}
----

[NOTE]
====

`@Autowired`, `@Inject`, `@Value`, 和 `@Resource` 注解 由 Spring BeanPostProcessor 实现.
也就是说开发者不能使用自定义的 `BeanPostProcessor` 或者自定义 `BeanFactoryPostProcessor` 来使用这些注解 必须使用 XML 或 Spring `@Bean` 方法显式地"连接"这些类型.
====

[[beans-autowired-annotation-primary]]
===  `@Primary`

由于按类型的自动注入可能匹配到多个候选者,所以通常需要对选择过程添加更多的约束. 使用 Spring 的 `@Primary` 注解是实现这个约束的一种方法.
它表示如果存在多个候选者且另一个 bean 只需要一个特定类型的 bean 依赖时,就明确使用标记有 `@Primary` 注解的那个依赖. 如果候选中只有一个"Primary" bean,那么它就是自动注入的值

请考虑以下配置,将 `firstMovieCatalog` 定义为主要 `MovieCatalog` :

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class MovieConfiguration {

		@Bean
		@Primary
		public MovieCatalog firstMovieCatalog() { ... }

		@Bean
		public MovieCatalog secondMovieCatalog() { ... }

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class MovieConfiguration {

		@Bean
		@Primary
		fun firstMovieCatalog(): MovieCatalog { ... }

		@Bean
		fun secondMovieCatalog(): MovieCatalog { ... }

		// ...
	}
----

使用上述配置,以下 `MovieRecommender` 将与 `firstMovieCatalog` 一起自动装配:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		@Autowired
		private MovieCatalog movieCatalog;

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class MovieRecommender {

	@Autowired
	private lateinit var movieCatalog: MovieCatalog

	// ...
}
----

相应的bean定义如下:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:annotation-config/>

		<bean class="example.SimpleMovieCatalog" primary="true">
			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean class="example.SimpleMovieCatalog">
			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean id="movieRecommender" class="example.MovieRecommender"/>

	</beans>
----



[[beans-autowired-annotation-qualifiers]]
=== @Qualifier

`@Primary` 是一种用于解决自动装配多个值的注入的有效的方法,当需要对选择过程做更多的约束时,可以使用 Spring 的 `@Qualifier` 注解,可以为指定的参数绑定限定的值.  缩小类型匹配集,以便为每个参数选择特定的 bean.  在最简单的情况下,这可以是一个简单的描述性值,如以下示例所示:

--
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		@Autowired
		@Qualifier("main")
		private MovieCatalog movieCatalog;

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		@Autowired
		@Qualifier("main")
		private lateinit var movieCatalog: MovieCatalog

		// ...
	}
----
--

您还可以在各个构造函数参数或方法参数上指定 `@Qualifier` 注解,如以下示例所示:

--
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		private final MovieCatalog movieCatalog;

		private final CustomerPreferenceDao customerPreferenceDao;

		@Autowired
		public void prepare(@Qualifier("main") MovieCatalog movieCatalog,
				CustomerPreferenceDao customerPreferenceDao) {
			this.movieCatalog = movieCatalog;
			this.customerPreferenceDao = customerPreferenceDao;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		private lateinit var movieCatalog: MovieCatalog

		private lateinit var customerPreferenceDao: CustomerPreferenceDao

		@Autowired
		fun prepare(@Qualifier("main") movieCatalog: MovieCatalog,
					customerPreferenceDao: CustomerPreferenceDao) {
			this.movieCatalog = movieCatalog
			this.customerPreferenceDao = customerPreferenceDao
		}

		// ...
	}
----
--

以下示例显示了相应的 bean 定义.

--
[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:annotation-config/>

		<bean class="example.SimpleMovieCatalog">
			<qualifier value="main"/> <1>

			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean class="example.SimpleMovieCatalog">
			<qualifier value="action"/> <2>

			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean id="movieRecommender" class="example.MovieRecommender"/>

	</beans>
----
<1> 带有限定符 `main` 的 bean 会被装配到拥有相同值的构造方法参数上.
<2> 带有限定符 `action` 的 bean 会被装配到拥有相同值的构造方法参数上.
--

bean 的 name 会作为备用的 qualifier 值,因此可以定义 bean 的 `id` 为 `main` 替代内嵌的 qualifier 元素.这种匹配方式同样有效. 但是,虽然可以使用这个约定来按名称引用特定的 bean, 但是 `@Autowired` 默认是由带限定符的类型驱动注入的. 这就意味着 qualifier 值,甚至是 bean 的 name 作为备选项,只是为了缩小类型匹配的范围.
它们在语义上不表示对唯一 bean `id` 的引用.  良好的限定符值是像 `main` 或 `EMEA` 或 `persistent` 这样的,能表示与 bean `id` 无关的特定组件的特征,在匿名 bean 定义的情况下可以自动生成.

Qualifiers 也可以用于集合类型,如上所述,例如 `Set<MovieCatalog>`. 在这种情况下,根据声明的限定符,所有匹配的 bean 都作为集合注入.
这意味着限定符不必是唯一的.  相反,它们构成过滤标准.  例如,您可以使用相同的限定符值 "`action`" 定义多个 `MovieCatalog` bean,所有这些 bean 都注入到使用 `@Qualifier("action")` 注解的 `Set<MovieCatalog>` 中.

[TIP]
====
在类型匹配候选项中,根据目标 bean 名称选择限定符值,在注入点不需要 `@Qualifier` 注解.  如果没有其他解析指示符(例如限定符或主标记) , 则对于非唯一依赖性情况,Spring 会将注入点名称(即字段名称或参数名称) 与目标  bean 名称进行匹配,然后选择同名的候选者,如果有的话.
====

如果打算 `by name` 来驱动注解注入,那么就不要使用 `@Autowired`(多数情况) ,即使在技术上能够通过 `@Qualifier` 值引用 bean 名字. 相反,应该使用 JSR-250 `@Resource` 注解,该注解在语义上定义为通过其唯一名称标识特定目标组件,
其中声明的类型与匹配进程无关. `@Autowired` 具有多种不同的语义,在 `by type` 选择候选 bean 之后,指定的 String 限定的值只会考虑这些被选择的候选者.  例如将 `account` 限定符与标有相同限定符标签的 bean 相匹配.

对于自身定义为 `collection`, `Map`, 或者 `array` 类型的 bean, `@Resource` 是一个很好的解决方案,通过唯一名称引用特定的集合或数组 bean.  也就是说,从 Spring4.3 开始,
只要元素类型信息保存在 `@Bean` 返回类型签名或集合(或其子类) 中,您就可以通过 Spring 的 `@Autowired` 类型匹配算法匹配 Map 和数组类型.  在这种情况下,可以使用限定的值来选择相同类型的集合,如上一段所述.

从 Spring4.3 开始,`@Autowired` 也考虑了注入的自引用,即引用当前注入的 bean. 自引用只是一种后备选项,还是优先使用正常的依赖注入操作其它 bean.  在这个意义上,自引用不参与到正常的候选者选择中,并且总是次要的,
相反,它们总是拥有最低的优先级. 在实践中,自引用通常被用作最后的手段. 例如,通过 bean 的事务代理在同一实例上调用其他方法 在这种情况下,考虑将受影响的方法分解为单独委托的 bean,或者使用 `@Resource`,它可以通过其唯一名称获取代理返回到当前的 bean 上.

[NOTE]
====
尝试将 `@Bean` 方法的结果注入相同的配置类也实际上是一种自引用方案.  要么在实际需要的方法签名中惰性解析此类引用(与配置类中的自动装配字段相对) , 要么将受影响的 `@Bean` 方法声明为静态,将其与包含的配置类实例及其生命周期脱钩.  否则,仅在回退阶段考虑此类 Bean,而将其他配置类上的匹配 Bean 选作主要候选对象(如果可用) .
====


`@Autowired` 可以应用在字段、构造函数和多参数方法上,允许在参数上使用 qualifier 限定符注解缩小取值范围.  相比之下,`@Resource` 仅支持具有单个参数的字段和 bean 属性 setter 方法.  因此,如果注入目标是构造函数或多参数方法,请使用 qualifiers 限定符.

开发者也可以创建自定义的限定符注解,只需定义一个注解,在其上提供了 `@Qualifier` 注解即可. 如以下示例所示:

--
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target({ElementType.FIELD, ElementType.PARAMETER})
	@Retention(RetentionPolicy.RUNTIME)
	@Qualifier
	public @interface Genre {

		String value();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
	@Retention(AnnotationRetention.RUNTIME)
	@Qualifier
	annotation class Genre(val value: String)
----
--

然后,您可以在自动装配的字段和参数上提供自定义限定符,如以下示例所示:

--
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		@Autowired
		@Genre("Action")
		private MovieCatalog actionCatalog;

		private MovieCatalog comedyCatalog;

		@Autowired
		public void setComedyCatalog(@Genre("Comedy") MovieCatalog comedyCatalog) {
			this.comedyCatalog = comedyCatalog;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		@Autowired
		@Genre("Action")
		private lateinit var actionCatalog: MovieCatalog

		private lateinit var comedyCatalog: MovieCatalog

		@Autowired
		fun setComedyCatalog(@Genre("Comedy") comedyCatalog: MovieCatalog) {
			this.comedyCatalog = comedyCatalog
		}

		// ...
	}
----
--

接下来,提供候选 bean 定义的信息. 开发者可以添加 `<qualifier/>` 标签作为 `<bean/>` 标签的子元素,然后指定 `type` 类型和 `value` 值来匹配自定义的 qualifier 注解.
`type` 是自定义注解的权限定类名(包路径+类名) . 如果没有重名的注解,那么可以使用类名(不含包路径) .  以下示例演示了两种方法:

--
[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:annotation-config/>

		<bean class="example.SimpleMovieCatalog">
			<qualifier type="Genre" value="Action"/>
			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean class="example.SimpleMovieCatalog">
			<qualifier type="example.Genre" value="Comedy"/>
			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean id="movieRecommender" class="example.MovieRecommender"/>

	</beans>
----
--

在 <<beans-classpath-scanning,类路径扫描和组件管理>>,将展示一个基于注解的替代方法,可以在 XML 中提供 qualifier 元数据, 请参阅<<beans-scanning-qualifiers>>.

在某些情况下,使用没有值的注解可能就足够了. 当注解用于更通用的目的并且可以应用在多种不同类型的依赖上时,这是很有用的.  例如,您可以提供可在没有 Internet 连接时搜索的 Offline 目录.
首先,定义简单注解,如以下示例所示:

--
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target({ElementType.FIELD, ElementType.PARAMETER})
	@Retention(RetentionPolicy.RUNTIME)
	@Qualifier
	public @interface Offline {
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
	@Retention(AnnotationRetention.RUNTIME)
	@Qualifier
	annotation class Offline
----
--

然后将注解添加到需要自动注入的字段或属性中:

--
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		@Autowired
		@Offline // <1>
		private MovieCatalog offlineCatalog;

		// ...
	}
----
<1> This line adds the `@Offline` annotation.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class MovieRecommender {

	@Autowired
	@Offline // <1>
	private lateinit var offlineCatalog: MovieCatalog

	// ...
}
----
<1> 此行添加 `@Offline` 注解.
--

现在 bean 定义只需要一个限定符类型,如下例所示:

--
[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean class="example.SimpleMovieCatalog">
		<qualifier type="Offline"/> <1>
		<!-- inject any dependencies required by this bean -->
	</bean>
----
<1> 此元素指定限定符
--

开发者还可以为自定义限定名 qualifier 注解增加属性,用于替代简单的 `value` 属性. 如果在要自动注入的字段或参数上指定了多个属性值,则 bean 的定义必须全部匹配这些属性值才能被视为自动注入候选者.
例如,请考虑以下注解定义:

--
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target({ElementType.FIELD, ElementType.PARAMETER})
	@Retention(RetentionPolicy.RUNTIME)
	@Qualifier
	public @interface MovieQualifier {

		String genre();

		Format format();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
	@Retention(AnnotationRetention.RUNTIME)
	@Qualifier
	annotation class MovieQualifier(val genre: String, val format: Format)
----
--

在这种情况下, `Format` 是一个枚举类型,定义如下:

--
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public enum Format {
		VHS, DVD, BLURAY
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	enum class Format {
		VHS, DVD, BLURAY
	}
----
--

要自动装配的字段使用自定义限定符进行注解,并包含两个属性的值: `genre` 和 `format`,如以下示例所示:

--
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		@Autowired
		@MovieQualifier(format=Format.VHS, genre="Action")
		private MovieCatalog actionVhsCatalog;

		@Autowired
		@MovieQualifier(format=Format.VHS, genre="Comedy")
		private MovieCatalog comedyVhsCatalog;

		@Autowired
		@MovieQualifier(format=Format.DVD, genre="Action")
		private MovieCatalog actionDvdCatalog;

		@Autowired
		@MovieQualifier(format=Format.BLURAY, genre="Comedy")
		private MovieCatalog comedyBluRayCatalog;

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		@Autowired
		@MovieQualifier(format = Format.VHS, genre = "Action")
		private lateinit var actionVhsCatalog: MovieCatalog

		@Autowired
		@MovieQualifier(format = Format.VHS, genre = "Comedy")
		private lateinit var comedyVhsCatalog: MovieCatalog

		@Autowired
		@MovieQualifier(format = Format.DVD, genre = "Action")
		private lateinit var actionDvdCatalog: MovieCatalog

		@Autowired
		@MovieQualifier(format = Format.BLURAY, genre = "Comedy")
		private lateinit var comedyBluRayCatalog: MovieCatalog

		// ...
	}
----
--

最后,bean 定义应包含匹配的限定符值. 此示例还演示了可以使用 bean meta 属性而不是使用 `<qualifier/>` 子元素. 如果可行,
`<qualifier/>` 元素及其属性优先, 但如果不存在此类限定符,那么自动注入机制会使用 `<meta/>` 标签中提供的值,如以下示例中的最后两个 bean 定义:

--
[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:annotation-config/>

		<bean class="example.SimpleMovieCatalog">
			<qualifier type="MovieQualifier">
				<attribute key="format" value="VHS"/>
				<attribute key="genre" value="Action"/>
			</qualifier>
			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean class="example.SimpleMovieCatalog">
			<qualifier type="MovieQualifier">
				<attribute key="format" value="VHS"/>
				<attribute key="genre" value="Comedy"/>
			</qualifier>
			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean class="example.SimpleMovieCatalog">
			<meta key="format" value="DVD"/>
			<meta key="genre" value="Action"/>
			<!-- inject any dependencies required by this bean -->
		</bean>

		<bean class="example.SimpleMovieCatalog">
			<meta key="format" value="BLURAY"/>
			<meta key="genre" value="Comedy"/>
			<!-- inject any dependencies required by this bean -->
		</bean>

	</beans>
----
--

[[beans-generics-as-qualifiers]]
=== 使用泛型作为自动装配限定符

除了 `@Qualifier` 注解之外,您还可以使用 Java 泛型类型作为隐式的限定形式.  例如,假设您具有以下配置:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class MyConfiguration {

		@Bean
		public StringStore stringStore() {
			return new StringStore();
		}

		@Bean
		public IntegerStore integerStore() {
			return new IntegerStore();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class MyConfiguration {

		@Bean
		fun stringStore() = StringStore()
			
		@Bean
		fun integerStore() = IntegerStore()
	}
----

假设上面的 bean 都实现了泛型接口,即 `Store<String>` 和 `Store<Integer>` ,那么可以用 `@Autowire` 来注解 `Store` 接口, 并将泛型用作限定符,如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Autowired
	private Store<String> s1; // <String> qualifier, injects the stringStore bean

	@Autowired
	private Store<Integer> s2; // <Integer> qualifier, injects the integerStore bean
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Autowired
	private lateinit var s1: Store<String> // <String> qualifier, injects the stringStore bean

	@Autowired
	private lateinit var s2: Store<Integer> // <Integer> qualifier, injects the integerStore bean
----

通用限定符也适用于自动装配列表,`Map` 实例和数组.  以下示例自动装配通用 `List` :

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Inject all Store beans as long as they have an <Integer> generic
	// Store<String> beans will not appear in this list
	@Autowired
	private List<Store<Integer>> s;
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Inject all Store beans as long as they have an <Integer> generic
	// Store<String> beans will not appear in this list
	@Autowired
	private lateinit var s: List<Store<Integer>>
----

[[beans-custom-autowire-configurer]]
=== `CustomAutowireConfigurer`

{api-spring-framework}/beans/factory/annotation/CustomAutowireConfigurer.html[`CustomAutowireConfigurer`]
是一个 `BeanFactoryPostProcessor`,它允许开发者注册自定义的 qualifier 注解类型,而无需指定 `@Qualifier` 注解,以下示例显示如何使用 `CustomAutowireConfigurer`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="customAutowireConfigurer"
			class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer">
		<property name="customQualifierTypes">
			<set>
				<value>example.CustomQualifier</value>
			</set>
		</property>
	</bean>
----

`AutowireCandidateResolver` 通过以下方式确定自动注入的候选者:

* 每个bean定义的 `autowire-candidate` 值
* 在 `<beans/>` 元素上使用任何可用的  `default-autowire-candidates` 模式
* 存在 `@Qualifier` 注解以及使用 `CustomAutowireConfigurer` 注册的任何自定义注解

当多个 bean 有资格作为自动注入的候选项时,`primary` 的确定如下: 如果候选者中只有一个 bean 定义的 `primary` 属性设置为 `true`,则选择它.



[[beans-resource-annotation]]
=== `@Resource`

Spring 还通过在字段或 bean 属性 setter 方法上使用 JSR-250 `@Resource`(`jakarta.annotation.Resource`) 注解来支持注入.  这是 Jakarta EE 中的常见模式(例如,JSF-managed beans 和 JAX-WS 端点中) .
Spring 也为 Spring 管理对象提供这种模式.

`@Resource` 接受一个 `name` 属性.. 默认情况下,Spring 将该值解释为要注入的 bean 名称.  换句话说,它遵循按名称的语义,如以下示例所示:

--
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Resource(name="myMovieFinder") // <1>
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}
	}
----
<1> 这行注入一个 `@Resource`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class SimpleMovieLister {

	@Resource(name="myMovieFinder") // <1>
	private lateinit var movieFinder:MovieFinder
}
----
<1> 这行注入一个 `@Resource`.
--

如果未明确指定名称,则默认名称是从字段名称或 `setter` 方法生成的.  如果是字段,则采用字段名称.  在 `setter` 方法的情况下,它采用 bean 属性名称.  下面的例子将把名为 `movieFinde` r的 bean 注入其 setter 方法:

--
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Resource
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimpleMovieLister {

		@set:Resource
		private lateinit var movieFinder: MovieFinder

	}
----
--

NOTE: `ApplicationContext` 若使用了 `CommonAnnotationBeanPostProcessor` ,注解提供的name名字将被解析为 bean 的 name 名字.  如果配置了 Spring 的 {api-spring-framework}/jndi/support/SimpleJndiBeanFactory.html[`SimpleJndiBeanFactory`],
这些 name 名称就可以通过 JNDI 解析. 但是,推荐使用默认的配置,简单地使用 Spring 的 JNDI,这样可以保持逻辑引用. 而不是直接引用.

`@Resource` 在没有明确指定 name 时,其行为类似于 `@Autowired`,对于特定bean(Spring API内的 bean) , `@Resource` 找到主要类型匹配而不是特定的命名 bean, 并解析众所周知的可解析依赖: `ApplicationContext`, `ResourceLoader`, `ApplicationEventPublisher`, 和 `MessageSource` 接口.

因此,在以下示例中,`customerPreferenceDao` 字段首先查找名为 `customerPreferenceDao` 的 bean,如果未找到,则会使用类型匹配 `CustomerPreferenceDao` 类的实例:

--
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MovieRecommender {

		@Resource
		private CustomerPreferenceDao customerPreferenceDao;

		@Resource
		private ApplicationContext context; // <1>

		public MovieRecommender() {
		}

		// ...
	}
----
<1> `context` 将会注入 `ApplicationContext`

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MovieRecommender {

		@Resource
		private lateinit var customerPreferenceDao: CustomerPreferenceDao


		@Resource
		private lateinit var context: ApplicationContext // <1>

		// ...
	}
----
<1> `context` 将会注入 `ApplicationContext`
--

[[beans-value-annotations]]
===  `@Value`

`@Value` 通常用于注入外部属性:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
    @Component
    public class MovieRecommender {

        private final String catalog;

        public MovieRecommender(@Value("${catalog.name}") String catalog) {
            this.catalog = catalog;
        }
    }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class MovieRecommender(@Value("\${catalog.name}") private val catalog: String)
----

使用以下配置:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
    @Configuration
    @PropertySource("classpath:application.properties")
    public class AppConfig { }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@PropertySource("classpath:application.properties")
	class AppConfig
----

以及以下 `application.properties` 文件:

[source,java,indent=0,subs="verbatim,quotes"]
----
    catalog.name=MovieCatalog
----

在这种情况下,`catalog` 参数和字段将等于 `MovieCatalog` 值.

Spring 提供了一个默认的内嵌值解析器.  它将尝试解析属性值,如果无法解析,则将属性名称(例如 `${catalog.name}`) 作为值注入.  如果要严格控制不存在的值,则应声明一个 `PropertySourcesPlaceholderConfigurer` bean,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {
			return new PropertySourcesPlaceholderConfigurer();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun propertyPlaceholderConfigurer() = PropertySourcesPlaceholderConfigurer()
	}
----

NOTE: 使用 JavaConfig 配置 `PropertySourcesPlaceholderConfigurer` 时,`@Bean` 方法必须是 `static` 的.

如果无法解析任何 `${}` 占位符,则使用上述配置 Spring 初始化会失败.  也可以使用 `setPlaceholderPrefix`,`setPlaceholderSuffix` 或 `setValueSeparator` 之类的方法来自定义占位符.

NOTE: Spring Boot 默认配置一个 `PropertySourcesPlaceholderConfigurer` bean,它将从 `application.properties` 和 `application.yml` 文件获取属性.

Spring 提供的内置转换器支持允许自动处理简单的类型转换(例如,转换为 `Integer` 或 `int`) .  多个逗号分隔的值可以自动转换为 `String` 数组,而无需付出额外的努力.

可以提供如下默认值:


[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
    @Component
    public class MovieRecommender {

        private final String catalog;

        public MovieRecommender(@Value("${catalog.name:defaultCatalog}") String catalog) {
            this.catalog = catalog;
        }
    }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class MovieRecommender(@Value("\${catalog.name:defaultCatalog}") private val catalog: String)
----

Spring `BeanPostProcessor` 在后台使用 `ConversionService` 处理将 `@Value` 中的 `String` 值转换为目标类型的过程.  如果要为自己的自定义类型提供转换支持,则可以提供自己的 `ConversionService` bean 实例,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
    @Configuration
    public class AppConfig {

        @Bean
        public ConversionService conversionService() {
            DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
            conversionService.addConverter(new MyCustomConverter());
            return conversionService;
        }
    }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun conversionService(): ConversionService {
				return DefaultFormattingConversionService().apply {
				addConverter(MyCustomConverter())
			}
		}
	}
----

当 `@Value` 包含 <<expressions, `SpEL` 表达式>> 时,该值将在运行时动态计算,如以下示例所示:


[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
    @Component
    public class MovieRecommender {

        private final String catalog;

        public MovieRecommender(@Value("#{systemProperties['user.catalog'] + 'Catalog' }") String catalog) {
            this.catalog = catalog;
        }
    }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class MovieRecommender(
		@Value("#{systemProperties['user.catalog'] + 'Catalog' }") private val catalog: String)
----

SpEL 还可以使用更复杂的数据结构:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
    @Component
    public class MovieRecommender {

        private final Map<String, Integer> countOfMoviesPerCatalog;

        public MovieRecommender(
                @Value("#{{'Thriller': 100, 'Comedy': 300}}") Map<String, Integer> countOfMoviesPerCatalog) {
            this.countOfMoviesPerCatalog = countOfMoviesPerCatalog;
        }
    }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class MovieRecommender(
		@Value("#{{'Thriller': 100, 'Comedy': 300}}") private val countOfMoviesPerCatalog: Map<String, Int>)
----


[[beans-postconstruct-and-predestroy-annotations]]
=== `@PostConstruct` 和  `@PreDestroy`

`CommonAnnotationBeanPostProcessor` 不仅仅识别 `@Resource` 注解,还识别 JSR-250 生命周期注解 `jakarta.annotation.PostConstruct` 和 `jakarta.annotation.PreDestroy`,在 Spring 2.5 中引入了这些注解, 它们提供了另一个<<beans-factory-lifecycle-initializingbean,代初始化回调>> 和<<beans-factory-lifecycle-disposablebean,销毁回调>>.
如果 `CommonAnnotationBeanPostProcessor` 在Spring `ApplicationContext` 中注册,它会在相应的 Spring bean 生命周期中调用相应的方法,就像是 Spring 生命周期接口方法,或者是明确声明的回调函数那样.  在以下示例中,缓存在初始化时预先填充并在销毁时清除:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class CachingMovieLister {

		@PostConstruct
		public void populateMovieCache() {
			// populates the movie cache upon initialization...
		}

		@PreDestroy
		public void clearMovieCache() {
			// clears the movie cache upon destruction...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class CachingMovieLister {

		@PostConstruct
		fun populateMovieCache() {
			// populates the movie cache upon initialization...
		}

		@PreDestroy
		fun clearMovieCache() {
			// clears the movie cache upon destruction...
		}
	}
----

有关组合各种生命周期机制的影响的详细信息,请参阅<<beans-factory-lifecycle-combined-effects,组合生命周期策略>>.


[NOTE]
====
和 `@Resource` 一样,`@PostConstruct` 和 `@PreDestroy` 注解也是 JDK6-8 的标准 java 库中的一部分,但是,在 JDK 9 中,整个  `javax.annotation` 和 java 核心模块分离,最终在 java 11 中移除.
从 Jakarta EE 9 开始，该包现在位于 `jakarta.annotation` 中。 如果需要的话， 现在需要通过 Maven Central 获取 `jakarta.annotation-api` 构件，
====

[[beans-classpath-scanning]]
== 类路径扫描和管理组件类路径扫描和管理组件

本章中的大多数示例会使用 XML 配置指定在 Spring 容器中生成每个 `BeanDefinition` 的元数据,<<beans-annotation-config,上一节>>(基于注解的容器配置) 演示了如何通过源代码注解提供大量的元数据配置.
然而,即使在这些示例中,注解也仅仅用于驱动依赖注入.  "base" bean依然会显式地在XML文件中定义. 本节介绍通过扫描类路径隐式检测候选组件的选项.
候选者组件是 class 类, 这些类经过过滤匹配,由 Spring 容器注册的 bean 定义会成为 Spring bean. 这消除了使用 XML 执行 bean 注册的需要(也就是没有 XML 什么事儿了),可以使用注解(例如 `@Component`), AspectJ 类型表达式或开发者自定义过滤条件来选择哪些类将在容器中注册 bean 定义.

[NOTE]
====
从 Spring 3.0 开始,Spring JavaConfig 项目提供的许多功能都是核心 Spring 框架的一部分. 这允许开发者使用 Java 而不是使用传统的 XML 文件来定义 bean.  有关如何使用这些新功能的示例,请查看 `@Configuration`, `@Bean`,`@Import`, 和 `@DependsOn` 注解.
====

[[beans-stereotype-annotations]]
=== `@Component` 注解和更多模板注解

`@Repository` 注解用于满足存储库(也称为数据访问对象或DAO)的情况,这个注解的用途是自动转换异常. 如 <<data-access.adoc#orm-exception-translation, 异常转换>> 中所述.

Spring 提供了更多的构造型注解: `@Component`,`@Service`, 和 `@Controller`. `@Component` 可用于管理任何 Spring 的组件.  `@Repository`, `@Service`, 或 `@Controller` 是 `@Component` 的特殊化. 用于更具体的用例(分别在持久性,服务和表示层中) .  因此,您可以使用 `@Component` 注解组件类,但是,通过使用 `@Repository`, `@Service`, 和 `@Controller` 注解它们,能够让你的类更易于被合适的工具处理或与相应的切面关联.
例如,这些注解可以使目标组件变成切入点. 在 Spring 框架的未来版本中,`@Repository`, `@Service`, 和 `@Controller` 也可能带有附加的语义.  因此,如果在使用 `@Component` 或 `@Service` 来选择服务层时,`@Service` 显然是更好的选择. 同理,在持久化层要选择 `@Repository`,它能自动转换异常.

[[beans-meta-annotations]]
=== 使用元注解和组合注解

Spring 提供的许多注解都可以在您自己的代码中用作元注解.  元注解是可以应用于另一个注解的注解.  例如, <<beans-stereotype-annotations, 前面>>提到的 `@Service` 注解是使用 `@Component` 进行元注解的,如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Component // <1>
	public @interface Service {

		// ...
	}
----
<1> `@Component` 使 `@Service` 以与 `@Component` 相同的方式处理.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.TYPE)
	@Retention(AnnotationRetention.RUNTIME)
	@MustBeDocumented
	@Component // <1>
	annotation class Service {

		// ...
	}
----
<1> `@Component` 使 `@Service` 以与 `@Component` 相同的方式处理.

元注解也可以进行组合,进而创建组合注解. 例如,来自 Spring MVC 的 `@RestController` 注解是由 `@Controller` 和 `@ResponseBody` 组成的

此外,组合注解也可以重新定义来自元注解的属性. 这在只想暴露元注解的部分属性时非常有用. 例如,Spring 的 `@SessionScope` 注解将它的作用域硬编码为 `session` ,但仍允许自定义 `proxyMode`.
以下清单显示了 `SessionScope` 注解的定义:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target({ElementType.TYPE, ElementType.METHOD})
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Scope(WebApplicationContext.SCOPE_SESSION)
	public @interface SessionScope {

		/**
		 * Alias for {@link Scope#proxyMode}.
		 * <p>Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
		 */
		@AliasFor(annotation = Scope.class)
		ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)
	@Retention(AnnotationRetention.RUNTIME)
	@MustBeDocumented
	@Scope(WebApplicationContext.SCOPE_SESSION)
	annotation class SessionScope(
			@get:AliasFor(annotation = Scope::class)
			val proxyMode: ScopedProxyMode = ScopedProxyMode.TARGET_CLASS
	)
----

然后,您可以使用 `@SessionScope` 而不声明 `proxyMode` ,如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Service
	@SessionScope
	public class SessionScopedService {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Service
	@SessionScope
	class SessionScopedService {
		// ...
	}
----

您还可以覆盖 `proxyMode` 的值,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Service
	@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
	public class SessionScopedUserService implements UserService {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Service
	@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
	class SessionScopedUserService : UserService {
		// ...	
	}
----

有关更多详细信息,请参阅 https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model[Spring Annotation Programming Model] wiki 页面.


[[beans-scanning-autodetection]]
=== 自动探测类并注册 bean 定义

Spring 可以自动检测各代码层中被注解的类,并使用 `ApplicationContext` 内注册相应的 `BeanDefinition`. 例如,以下两个类就可以被自动探测:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Service
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		public SimpleMovieLister(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Service
	class SimpleMovieLister(private val movieFinder: MovieFinder)
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Repository
	public class JpaMovieFinder implements MovieFinder {
		// implementation elided for clarity
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Repository
	class JpaMovieFinder : MovieFinder {
		// implementation elided for clarity	
	}
----

想要自动检测这些类并注册相应的 bean,需要在 `@Configuration` 配置中添加 `@ComponentScan` 注解,其中 `basePackages` 属性是两个类的父包路径.  (或者,您可以指定以逗号或分号或空格分隔的列表,其中包含每个类的父包) .

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan(basePackages = "org.example")
	public class AppConfig  {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan(basePackages = ["org.example"])
	class AppConfig  {
		// ...
	}
----

NOTE: 为简洁起见,前面的示例可能使用了注解的 `value` 属性(即 `@ComponentScan("org.example")`) .

或者使用 XML 配置代替扫描:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:component-scan base-package="org.example"/>

	</beans>
----

TIP: 使用 `<context:component-scan>` 隐式启用 `<context:annotation-config>` 的功能.  使用 `<context:component-scan>` 时,通常不需要包含 `<context:annotation-config>` 元素.

[NOTE]
====
类路径扫描的包必须保证这些包出现在类路径中. 当使用 Ant 构建 JAR 时,请确保你没有激活 JAR 任务的纯文件开关. 此外在某些环境装由于安全策略,类路径目录可能不能访问.
JDK 1.7.0_45 及更高版本上的独立应用程序(需要在清单中设置 'Trusted-Library')  - 请参阅 http://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources) .

在 JDK 9 的模块路径(Jigsaw) 上,Spring 的类路径扫描通常按预期工作. ,但是,请确保在模块信息描述符中导出组件类.  如果您希望 Spring 调用类的非公共成员,请确保它们已 "打开"(即,它们在 `module-info` 描述符中使用 `opens` 声明而不是 `exports` 声明) .
====
在使用 `component-scan` 元素时, `AutowiredAnnotationBeanPostProcessor` 和 `CommonAnnotationBeanPostProcessor` 都会隐式包含. 意味着这两个组件也是自动探测和注入的.  所有这些都无需 XML 配置.

NOTE: 您可以通过 `annotation-config=false` 属性来禁用 `AutowiredAnnotationBeanPostProcessor` 和 `CommonAnnotationBeanPostProcessor` 的注册.


[[beans-scanning-filters]]
===  在自定义扫描中使用过滤器

默认情况下,使用 `@Component`, `@Repository`, `@Service`,`@Controller` `@Configuration` 注解的类或者注解为 `@Component` 的自定义注解类才能被检测为候选组件.  但是,开发者可以通过应用自定义过滤器来修改和扩展此行为.
将它们添加为 `@ComponentScan` 注解的 `includeFilters` 或 `excludeFilters` 参数(或作为 `component-scan` 元素. 元素的 `include-filter` 或 `exclude-filter` 子元素. 每个 filter 元素都需要包含 `type` 和 `expression` 属性. 下表介绍了筛选选项:

[[beans-scanning-filters-tbl]]
.过滤类型
|===
| 过滤类型 | 表达式例子 | 描述

| annotation (default)
| `org.example.SomeAnnotation`
| 要在目标组件中的类级别出现的注解.

| assignable
| `org.example.SomeClass`
| 目标组件可分配给(继承或实现) 的类(或接口) .

| aspectj
| `org.example..*Service+`
| 要由目标组件匹配的 AspectJ 类型表达式.

| regex
| `org\.example\.Default.*`
| 要由目标组件类名匹配的正则表达式.

| custom
| `org.example.MyTypeFilter`
| `org.springframework.core.type.TypeFilter` 接口的自定义实现.
|===

以下示例显示忽略所有 `@Repository` 注解并使用 "`stub`" 存储库的配置:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan(basePackages = "org.example",
			includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),
			excludeFilters = @Filter(Repository.class))
	public class AppConfig {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan(basePackages = ["org.example"],
			includeFilters = [Filter(type = FilterType.REGEX, pattern = [".*Stub.*Repository"])],
			excludeFilters = [Filter(Repository::class)])
	class AppConfig {
		// ...
	}
----

以下清单显示了等效的 XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<context:component-scan base-package="org.example">
			<context:include-filter type="regex"
					expression=".*Stub.*Repository"/>
			<context:exclude-filter type="annotation"
					expression="org.springframework.stereotype.Repository"/>
		</context:component-scan>
	</beans>
----

NOTE: 你还可以通过在注解上设置 `useDefaultFilters=false` 或通过 `use-default-filters="false"` 作为 `<<component-scan/>` 元素的属性来禁用默认过滤器. 这样将不会自动检测带有 `@Component`, `@Repository`,`@Service`, `@Controller`, 或 `@Configuration`.

[[beans-factorybeans-annotations]]
=== 在组件中定义bean的元数据

Spring 组件也可以向容器提供 bean 定义元数据. 在 `@Configuration` 注解的类中使用 `@Bean` 注解定义 bean 元数据(也就是 Spring bean),以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Component
	public class FactoryMethodComponent {

		@Bean
		@Qualifier("public")
		public TestBean publicInstance() {
			return new TestBean("publicInstance");
		}

		public void doWork() {
			// Component method implementation omitted
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class FactoryMethodComponent {

		@Bean
		@Qualifier("public")
		fun publicInstance() = TestBean("publicInstance")

		fun doWork() {
			// Component method implementation omitted
		}
	}
----

这个类是一个 Spring 组件,它有个 `doWork()` 方法. 然而,它还有一个工厂方法 `publicInstance()` 用于产生 bean 定义.  `@Bean` 注解了工厂方法, 还设置了其他 bean 定义的属性,例如通过 `@Qualifier` 注解的 `qualifier` 值. 可以指定的其他方法级别的注解是 `@Scope`, `@Lazy` 以及自定义的 qualifier 注解.

TIP: 除了用于组件初始化的角色之外,`@Lazy` 注解也可以在 `@Autowired` 或者 `@Inject` 注解上,在这种情况下,该注入将会变成延迟注入代理 `lazy-resolution` proxy(也就是懒加载) 对于复杂的惰性交互，尤其是组合对于可选依赖项，我们推荐使用 `ObjectProvider<MyTargetBean>`。.

自动注入的字段和方法也可以像前面讨论的一样被支持,也支持 `@Bean` 方法的自动注入. 以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Component
	public class FactoryMethodComponent {

		private static int i;

		@Bean
		@Qualifier("public")
		public TestBean publicInstance() {
			return new TestBean("publicInstance");
		}

		// use of a custom qualifier and autowiring of method parameters
		@Bean
		protected TestBean protectedInstance(
				@Qualifier("public") TestBean spouse,
				@Value("#{privateInstance.age}") String country) {
			TestBean tb = new TestBean("protectedInstance", 1);
			tb.setSpouse(spouse);
			tb.setCountry(country);
			return tb;
		}

		@Bean
		private TestBean privateInstance() {
			return new TestBean("privateInstance", i++);
		}

		@Bean
		@RequestScope
		public TestBean requestScopedInstance() {
			return new TestBean("requestScopedInstance", 3);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class FactoryMethodComponent {

		companion object {
			private var i: Int = 0
		}

		@Bean
		@Qualifier("public")
		fun publicInstance() = TestBean("publicInstance")

		// use of a custom qualifier and autowiring of method parameters
		@Bean
		protected fun protectedInstance(
				@Qualifier("public") spouse: TestBean,
				@Value("#{privateInstance.age}") country: String) = TestBean("protectedInstance", 1).apply {
			this.spouse = spouse
			this.country = country
		}

		@Bean
		private fun privateInstance() = TestBean("privateInstance", i++)

		@Bean
		@RequestScope
		fun requestScopedInstance() = TestBean("requestScopedInstance", 3)
	}
----

该示例将方法参数为 `String`,名称为 `country` 的 bean 自动装配为另一个名为 `privateInstance` 的 bean 的 age 属性值.  Spring 表达式语言元素通过记号 `#{ <expression> }` 来定义属性的值. 对于 `@Value` 注解,表达式解析器在解析表达式后,会查找 bean 的名字并设置 value 值.

从 Spring4.3 开始,您还可以声明一个类型为 `InjectionPoint` 的工厂方法参数(或其更具体的子类: `DependencyDescriptor`) 以访问触发创建当前 bean 的请求注入点.  请注意,这仅适用于真实创建的 bean 实例,而不适用于注入现有实例.
因此,这个特性对 prototype scope 的 bean 最有意义. 对于其他作用域,工厂方法将只能看到触发在给定 scope 中创建新 bean 实例的注入点.  例如,触发创建一个延迟单例 bean 的依赖. 在这种情况下,使用提供的注入点元数据拥有优雅的语义.  以下示例显示了如何使用 `InjectionPoint`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Component
	public class FactoryMethodComponent {

		@Bean @Scope("prototype")
		public TestBean prototypeInstance(InjectionPoint injectionPoint) {
			return new TestBean("prototypeInstance for " + injectionPoint.getMember());
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class FactoryMethodComponent {

		@Bean
		@Scope("prototype")
		fun prototypeInstance(injectionPoint: InjectionPoint) =
				TestBean("prototypeInstance for ${injectionPoint.member}")
	}
----

在 Spring 组件中处理 `@Bean` 和在 `@Configuration` 中处理是不一样的,区别在于,在 `@Component` 中,不会使用 CGLIB 增强去拦截方法和属性的调用. 在 `@Configuration` 注解的类中, `@Bean` 注解创建的 bean 对象会使用 CGLIB 代理对方法和属性进行调用.
方法的调用不是常规的 Java 语法,而是通过容器来提供通用的生命周期管理和代理 Spring bean, 甚至在通过编程的方式调用 `@Bean` 方法时也会产生对其它 bean 的引用. 相比之下,在一个简单的 `@Component` 类中调用 `@Bean` 方法中的方法或字段具有标准 Java 语义,这里没有用到特殊的 CGLIB 处理或其他约束.

[NOTE]
====
开发者可以将 `@Bean` 方法声明为 `static` 的,并允许在不将其包含的配置类作为实例的情况下调用它们. 这在定义后置处理器 bean 时是特别有意义的.  例如 `BeanFactoryPostProcessor` 或 `BeanPostProcessor`),,因为这类 bean 会在容器的生命周期前期被初始化,而不会触发其它部分的配置.

对静态 `@Bean` 方法的调用永远不会被容器拦截,即使在 `@Configuration` 类内部. 这是用为 CGLIB 的子类代理限制了只会重写非静态方法. 因此, 对另一个 `@Bean` 方法的直接调用只能使用标准的 Java 语法. 也只能从工厂方法本身直接返回一个独立的实例.

由于 Java 语言的可见性,`@Bean` 方法并不一定会对容器中的 bean 有效. 开发者可能很随意的在非 `@Configuration` 类中定义为静态方法. 然而, 在 `@Configuration` 类中的正常 `@Bean` 方法都会被重写,因此,它们不应该定义为 `private` 或  `final`.

`@Bean` 方法也可以用在父类中,同样适用于 Java 8 接口中的默认方法. 这使得组建复杂的配置时能具有更好的灵活性,甚至可能通过 Java 8 的默认方法实现多重继承.  这种特性在 Spring 4.2 开始支持.

最后,请注意,单个类可以为同一个 bean 保存多个 `@Bean` 方法,例如根据运行时可用的依赖选择合适的工厂方法. 使用算法会选择 "最贪婪" 的构造方法, 一些场景可能会按如下方法选择相应的工厂方法: 满足最多依赖的会被选择,这与使用 `@Autowired` 时选择多个构造方法时类似.
====

[[beans-scanning-name-generator]]
=== 命名自动注册组件

扫描处理过程,其中一步就是自动探测组件,扫描器使用 `BeanNameGenerator` 对探测到的组件命名. 默认情况下,各代码层注解( `@Component`, `@Repository`, `@Service`, 和 `@Controller`)所包含的 name 值,将会作为相应的 bean 定义的名字.

如果这些注解没有 name 值,或者是其他一些被探测到的组件(比如使用自定义过滤器探测到的),默认会又 bean name 生成器生成,使用小写类名作为 bean 名字.  例如,如果检测到以下组件类,则名称为 `myMovieLister` 和 `movieFinderImpl`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Service("myMovieLister")
	public class SimpleMovieLister {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Service("myMovieLister")
	class SimpleMovieLister {
		// ...
	}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Repository
	public class MovieFinderImpl implements MovieFinder {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Repository
	class MovieFinderImpl : MovieFinder {
		// ...
	}
----

如果您不想依赖默认的 bean 命名策略,则可以提供自定义 bean 命名策略. 首先,实现 {api-spring-framework}/beans/factory/support/BeanNameGenerator.html[`BeanNameGenerator`] 接口,并确保包括一个默认的无参构造函数.  然后,在配置扫描程序时提供完全限定的类名,如以下示例注解和 bean 定义所示:

TIP: 如果由于多个自动检测到的组件具有相同的非限定类名称(即,具有相同名称但位于以下位置的类不同的软件包) ,则可能需要配置一个默认为 `BeanNameGenerator` 的 生成的bean名称的完全限定的类名称.  从 Spring Framework 5.2.3 开始, 位于 `org.springframework.context.annotation` 包中的 `FullyQualifiedAnnotationBeanNameGenerator` 可以用于这种目的.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)
	public class AppConfig {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan(basePackages = ["org.example"], nameGenerator = MyNameGenerator::class)
	class AppConfig {
		// ...
	}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<context:component-scan base-package="org.example"
			name-generator="org.example.MyNameGenerator" />
	</beans>
----

作为一般规则,考虑在其他组件可能对其进行显式引用时使用注解指定名称.  另一方面,只要容器负责装配时,自动生成的名称就足够了.



[[beans-scanning-scope-resolver]]
=== 为自动检测的组件提供作用域

与 Spring 管理组件一样,自动检测组件的默认和最常见的作用域是 `singleton`. 但是,有时您需要一个可由 `@Scope` 注解指定的不同作用域.  您可以在注解中提供作用域的名称,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Scope("prototype")
	@Repository
	public class MovieFinderImpl implements MovieFinder {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Scope("prototype")
	@Repository
	class MovieFinderImpl : MovieFinder {
		// ...
	}
----

NOTE: `@Scope` 注解仅在具体 bean 类(用于带注解的组件) 或工厂方法(用于 `@Bean` 方法) 上进行关联.  与 XML bean 定义相比,没有 bean 继承的概念,并且 类级别的继承结构与元数据无关.

有关特定于 Web 的作用域(如 Spring 上下文中的 "`request`" 或 "`session`" ) 的详细信息,请参阅 <<beans-factory-scopes-other>>. 请求,会话,应用程序和 WebSocket 作用域, 这些作用域与构建注解一样,您也可以使用 Spring 的元注解方法编写自己的作用域注解: 例如,使用 `@Scope("prototype")`  进行元注解的自定义注解,可能还会声明自定义作用域代理模式.

NOTE: 想要提供自定义作用域的解析策略,而不是依赖于基于注解的方法,那么需要实现 {api-spring-framework}/context/annotation/ScopeMetadataResolver.html[`ScopeMetadataResolver`] 接口,并确保包含一个默认的无参数构造函数.  然后,在配置扫描程序时提供完全限定类名. 以下注解和 bean 定义示例显示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan(basePackages = "org.example", scopeResolver = MyScopeResolver.class)
	public class AppConfig {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan(basePackages = ["org.example"], scopeResolver = MyScopeResolver::class)
	class AppConfig {
		// ...
	}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<context:component-scan base-package="org.example" scope-resolver="org.example.MyScopeResolver"/>
	</beans>
----

当使用某个非单例作用域时,为作用 domain 对象生成代理可能非常必要,原因参看 <<beans-factory-scopes-other-injection>> 作为依赖的作用域 bean.  为此,组件扫描元素上提供了 scoped-proxy 属性.  三个可能的值是: `no`, `interfaces`, 和 `targetClass`.  例如,以下配置导致标准 JDK 动态代理:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)
	public class AppConfig {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan(basePackages = ["org.example"], scopedProxy = ScopedProxyMode.INTERFACES)
	class AppConfig {
		// ...
	}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<context:component-scan base-package="org.example" scoped-proxy="interfaces"/>
	</beans>
----



[[beans-scanning-qualifiers]]
=== 为注解提供Qualifier元数据

在前面使用 <<beans-autowired-annotation-qualifiers>> 讨论过 `@Qualifier` 注解. 该部分中的示例演示了在解析自动注入候选者时使用 `@Qualifier` 注解和自定义限定符注解以提供细粒度控制.
因为这些示例基于 XML bean 定义,所以使用 XML 中的 `bean` 元素的 `qualifier` 或 `meta` 子元素在候选 bean 定义上提供了限定符元数据. 当依靠类路径扫描并自动检测组件时, 可以在候选类上提供具有类型级别注解的限定符元数据. 以下三个示例演示了此技术:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Component
	@Qualifier("Action")
	public class ActionMovieCatalog implements MovieCatalog {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	@Qualifier("Action")
	class ActionMovieCatalog : MovieCatalog
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Component
	@Genre("Action")
	public class ActionMovieCatalog implements MovieCatalog {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	@Genre("Action")
	class ActionMovieCatalog : MovieCatalog {
		// ...	
	}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Component
	@Offline
	public class CachingMovieCatalog implements MovieCatalog {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Component
@Offline
class CachingMovieCatalog : MovieCatalog {
	// ...
}
----

NOTE: 与大多数基于注解的替代方法一样,注解元数据绑定到类定义本身,而使用在 XML 配置时,允许同一类型的 beans 在 qualifier 元数据中提供变量, 因为元数据是依据实例而不是类来提供的.



[[beans-scanning-index]]
=== 生成候选组件的索引

虽然类路径扫描非常快,但通过在编译时创建候选的静态列表. 可以提高大型应用程序的启动性能. 在此模式下,应用程序的所有模块都必须使用此机制.

NOTE: 将 `@ComponentScan` 或 `<context: component-scan/>` 指令保留为是请求上下文扫描某些程序包中的候选项.  当 `ApplicationContext` 检测到此类索引时,它将自动使用它,而不是扫描类路径.

若要生成索引, 只需向包含组件扫描指令目标组件的每个模块添加一个附加依赖. 以下示例显示了如何使用 Maven 执行此操作:

[source,xml,indent=0,subs="verbatim,quotes,attributes"]
----
	<dependencies>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context-indexer</artifactId>
			<version>{spring-framework-version}</version>
			<optional>true</optional>
		</dependency>
	</dependencies>
----

在 Gradle 4.5 及更早版本中,依赖应在 `compileOnly` 中声明配置,如以下示例所示:

[source,groovy,indent=0,subs="verbatim,quotes,attributes"]
----
	dependencies {
		compileOnly "org.springframework:spring-context-indexer:{spring-framework-version}"
	}
----
====

对于 Gradle 4.6 和更高版本,应在 `annotationProcessor` 配置中声明依赖,如以下示例所示:

====
[source,groovy,indent=0,subs="verbatim,quotes,attributes"]
----
	dependencies {
		annotationProcessor "org.springframework:spring-context-indexer:{spring-framework-version}"
	}
----

`spring-context-indexer` artifact 将产生一个名为 `META-INF/spring.components` 的文件,并将包含在 jar 包中.

NOTE: 在 IDE 中使用此模式时,必须将 `spring-context-indexer` 注册为注解处理器, 以确保更新候选组件时索引是最新的.

TIP: 如果在类路径中找到 `META-INF/spring.components` 文件时,将自动启用索引. 如果某个索引对于某些库(或用例)是不可用的, 但不能为整个应用程序构建,则可以将 `spring.index.ignore` 设置为 `true`,从而将其回退到常规类路径的排列(即根本不存在索引), 或者作为 JVM 系统属性或在 <<appendix.adoc#appendix-spring-properties,`SpringProperties`>> 文件位于类路径的根目录中.



[[beans-standard-annotations]]
== 使用 JSR 330 标准注解

从 Spring 3.0 开始,Spring 提供对 JSR-330 标准注解(依赖注入) 的支持.  这些注解的扫描方式与 Spring 注解相同.  要使用它们,您需要在类路径中包含相关的 jar.

[NOTE]
=====
如果使用 Maven 工具,那么 `jakarta.inject` 可以在 Maven 中央仓库中找到 repository (https://repo1.maven.org/maven2/jakarta/inject/jakarta.inject-api/2.0.0/[https://repo1.maven.org/maven2/jakarta/inject/jakarta.inject-api/2.0.0/]).
您可以将以下依赖添加到文件 `pom.xml`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<dependency>
		<groupId>jakarta.inject</groupId>
		<artifactId>jakarta.inject</artifactId>
		<version>1</version>
	</dependency>
----
=====



[[beans-inject-named]]
=== 使用 `@Inject` 和 `@Named` 注解实现依赖注入

`@jakarta.inject.Inject` 可以使用以下的方式来替代 `@Autowired` 注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import jakarta.inject.Inject;

	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Inject
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		public void listMovies() {
			this.movieFinder.findMovies(...);
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import jakarta.inject.Inject

	class SimpleMovieLister {

		@Inject
		lateinit var movieFinder: MovieFinder


		fun listMovies() {
			movieFinder.findMovies(...)
			// ...
		}
	}
----

与 `@Autowired` 一样,您可以在字段,方法和构造函数参数级别使用 `@Inject` 注解. 此外,还可以将注入点声明为 `Provider`.  它允许按需访问作用域较小的 bean 或通过 `Provider.get()` 调用对其他 bean 进行延迟访问. 以下示例提供了前面示例的变体:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import jakarta.inject.Inject;
	import jakarta.inject.Provider;

	public class SimpleMovieLister {

		private Provider<MovieFinder> movieFinder;

		@Inject
		public void setMovieFinder(Provider<MovieFinder> movieFinder) {
			this.movieFinder = movieFinder;
		}

		public void listMovies() {
			this.movieFinder.get().findMovies(...);
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import jakarta.inject.Inject

	class SimpleMovieLister {

		@Inject
		lateinit var movieFinder: Provider<MovieFinder>


		fun listMovies() {
			movieFinder.get().findMovies(...)
			// ...
		}
	}
----

如果想要为注入的依赖使用限定名称,则应该使用 `@Named` 注解. 如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import jakarta.inject.Inject;
	import jakarta.inject.Named;

	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Inject
		public void setMovieFinder(@Named("main") MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import jakarta.inject.Inject
	import jakarta.inject.Named

	class SimpleMovieLister {

		private lateinit var movieFinder: MovieFinder

		@Inject
		fun setMovieFinder(@Named("main") movieFinder: MovieFinder) {
			this.movieFinder = movieFinder
		}

		// ...
	}
----

与 `@Autowired` 一样,`@Inject` 也可以与 `java.util.Optional` 或 `@Nullable` 一起使用.  这在这里用更适用,因为 `@Inject` 没有 `required` 的属性.  以下一对示例显示了如何使用 `@Inject` 和 `@Nullable`:

[source,java,indent=0,subs="verbatim,quotes"]
----
	public class SimpleMovieLister {

		@Inject
		public void setMovieFinder(Optional<MovieFinder> movieFinder) {
			// ...
		}
	}
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleMovieLister {

		@Inject
		public void setMovieFinder(@Nullable MovieFinder movieFinder) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimpleMovieLister {

		@Inject
		var movieFinder: MovieFinder? = null
	}
----



[[beans-named]]
=== `@Named` 和 `@ManagedBean` 注解: 标准与 `@Component` 注解相同

可以使用 `@jakarta.inject.Named` 或 `jakarta.annotation.ManagedBean` 来替代 `@Component` 注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import jakarta.inject.Inject;
	import jakarta.inject.Named;

	@Named("movieListener")  // @ManagedBean("movieListener") could be used as well
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Inject
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import jakarta.inject.Inject
	import jakarta.inject.Named

	@Named("movieListener")  // @ManagedBean("movieListener") could be used as well
	class SimpleMovieLister {

		@Inject
		lateinit var movieFinder: MovieFinder

		// ...
	}
----

在不指定组件名称的情况下使用 `@Component` 是很常见的.  `@Named` 可以以类似的方式使用,如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import jakarta.inject.Inject;
	import jakarta.inject.Named;

	@Named
	public class SimpleMovieLister {

		private MovieFinder movieFinder;

		@Inject
		public void setMovieFinder(MovieFinder movieFinder) {
			this.movieFinder = movieFinder;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import jakarta.inject.Inject
	import jakarta.inject.Named

	@Named
	class SimpleMovieLister {

		@Inject
		lateinit var movieFinder: MovieFinder

		// ...
	}
----

当使用 `@Named` 或 `@ManagedBean` 时,可以与 Spring 注解完全相同的方式使用组件扫描.  如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan(basePackages = "org.example")
	public class AppConfig  {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan(basePackages = ["org.example"])
	class AppConfig  {
		// ...
	}
----

NOTE: 与 `@Component` 相反,JSR-330 `@Named` 和 JSR-250 `@ManagedBean` 注解不可组合.  请使用 Spring 的原型模型(stereotype mode)来构建自定义组件注解.

[[beans-standard-annotations-limitations]]
=== 使用 JSR-330标准注解的限制

使用标准注解时,需要知道哪些重要功能是不可用的. 如下表所示:

[[annotations-comparison]]
.Spring 的组件模型元素 vs JSR-330 变量
|===
| Spring| jakarta.inject.*| jakarta.inject restrictions / comments

| @Autowired
| @Inject
| `@Inject` 没有 `'required'` 属性.  可以与 Java 8 的 `Optional` 一起使用.

| @Component
| @Named / @ManagedBean
| JSR-330 不提供可组合模型,只是一种识别命名组件的方法.

| @Scope("singleton")
| @Singleton
| JSR-330 的默认作用域就像 Spring 的 `prototype`.  但是,为了使其与 Spring  的一般默认值保持一致,默认情况下,Spring 容器中声明的 JSR-330 bean 是一个 `singleton`.
  为了使用除 singleton 之外的作用域,您应该使用 Spring 的 `@Scope` 注解.  `jakarta.inject` 还提供了 https://download.oracle.com/javaee/6/api/javax/inject/Scope.html[@Scope]  注解.  然而,这个仅用于创建自己的注解.

| @Qualifier
| @Qualifier / @Named
| `jakarta.inject.Qualifier` 只是用于构建自定义限定符的元注解.  可以通过 `jakarta.inject.Named` 创建与 Spring 中 `@Qualifier` 一样的限定符.

| @Value
| -
| 无

| @Lazy
| -
| 无

| ObjectFactory
| Provider
| `jakarta.inject.Provider` `jakarta.inject.Provider` 是 Spring 的 ObjectFactory 的直接替代品, 仅仅使用简短的 `get()` 方法即可.  它也可以与 Spring 的 `@Autowired` 结合使用,也可以与非注解的构造函数和 `setter` 方法结合使用.
|===



[[beans-java]]
== 基于 Java 的容器配置

本节介绍如何在 Java 代码中使用注解来配置 Spring 容器.  它包括以下主题:

* <<beans-java-basic-concepts>>
* <<beans-java-instantiating-container>>
* <<beans-java-bean-annotation>>
* <<beans-java-configuration-annotation>>
* <<beans-java-composing-configuration-classes>>
* <<beans-definition-profiles>>
* <<beans-property-source-abstraction>>
* <<beans-using-propertysource>>
* <<beans-placeholder-resolution-in-statements>>


[[beans-java-basic-concepts]]
=== 基本概念: `@Bean` 和 `@Configuration`

Spring 新的基于 Java 配置的核心内容是 `@Configuration` 注解的类和 `@Bean` 注解的方法.

`@Bean` 注解用于表明方法的实例化,、配置和初始化都是由 Spring IoC 容器管理的新对象,对于那些熟悉 Spring 的 `<beans/>` XML 配置的人来说,

`@Bean` 注解扮演的角色与 `<bean />` 元素相同. 开发者可以在任意的 Spring `@Component` 中使用 `@Bean` 注解方法 ,但大多数情况下,`@Bean` 是配合 `@Configuration` 使用的.

使用 `@Configuration` 注解类时,这个类的目的就是作为 bean 定义的地方. 此外,`@Configuration` 类允许通过调用同一个类中的其他 `@Bean` 方法来定义 bean 间依赖.  最简单的 `@Configuration` 类如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		public MyService myService() {
			return new MyServiceImpl();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun myService(): MyService {
			return MyServiceImpl()
		}
	}
----

前面的 `AppConfig` 类等效于以下 Spring `<beans/>` XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="myService" class="com.acme.services.MyServiceImpl"/>
	</beans>
----

.完整的 `@Configuration` 模式对比 `"lite"` 模式的 `@Bean`?
****
当 `@Bean` 方法在没有用 `@Configuration` 注解的类中声明时,它们将会被称为 "`lite`" 的模式处理. 例如,`@Component` 中声明的 bean 方法或者一个普通的旧类中的 bean 方法将被视为 "`lite`" 的. 包含类的主要目的不同,而 `@Bean` 方法在这里是一种额外的好处.
例如,服务组件可以通过在每个适用的组件类上使用额外的 `@Bean` 方法将管理视图暴露给容器.  在这种情况下,`@Bean` 方法是一种通用的工厂方法机制.

与完整的 `@Configuration` 不同, "`lite`" 的 `@Bean` 方法不能声明 bean 之间的依赖.  相反,它们对其包含组件的内部状态进行操作,并且可以有选择的对它们可能声明的参数进行操作. 因此,这样的 `@Bean` 注解的方法不应该调用其他 `@Bean` 注解的方法.  每个这样的方法实际上只是特定 bean 引用的工厂方法,没有任何特殊的运行时语义. 不经过 CGLIB 处理,所以在类设计方面没有限制(即,包含类可能是 `final` 的) .

在常见的场景中,`@Bean` 方法将在 `@Configuration` 类中声明,确保始终使用 "`full`" 模式,这将防止相同的 `@Bean` 方法被意外地多次调用,这有助于减少在 "`lite`" 模式下操作时难以跟踪的细微错误.
****

`@Bean` 和 `@Configuration` 注解将在下面的章节深入讨论,首先,我们将介绍使用基于 Java 代码的配置来创建 Spring 容器的各种方法.

[[beans-java-instantiating-container]]
=== 使用 `AnnotationConfigApplicationContext` 初始化 Spring 容器

以下部分介绍了 Spring 的 `AnnotationConfigApplicationContext`,它是在 Spring 3.0 中引入的. 这是一个强大的(versatile) `ApplicationContext`  实现,它不仅能解析 `@Configuration` 注解类 ,也能解析 `@Component` 注解的类和使用 JSR-330 注解的类.

当使用 `@Configuration` 类作为输入时,`@Configuration` 类本身被注册为一个 bean 定义,类中所有声明的 `@Bean` 方法也被注册为 bean 定义.

当提供 `@Component` 和 JSR-330 类时,它们被注册为 bean 定义,并且假定在必要时在这些类中使用 DI 元数据,例如 `@Autowired` 或 `@Inject`.


[[beans-java-instantiating-container-constructor]]
==== 简单结构

与实例化 `ClassPathXmlApplicationContext` 时 Spring XML 文件用作输入的方式大致相同, 在实例化 `AnnotationConfigApplicationContext` 时可以使用 `@Configuration` 类作为输入.  这允许完全无 XML 使用 Spring 容器,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
		MyService myService = ctx.getBean(MyService.class);
		myService.doStuff();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	fun main() {
		val ctx = AnnotationConfigApplicationContext(AppConfig::class.java)
		val myService = ctx.getBean<MyService>()
		myService.doStuff()
	}
----

如前所述,`AnnotationConfigApplicationContext` 不仅限于使用 `@Configuration` 类.  任何 `@Component` 或 JSR-330 带注解的类都可以作为输入提供给构造函数,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
		MyService myService = ctx.getBean(MyService.class);
		myService.doStuff();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	fun main() {
		val ctx = AnnotationConfigApplicationContext(MyServiceImpl::class.java, Dependency1::class.java, Dependency2::class.java)
		val myService = ctx.getBean<MyService>()
		myService.doStuff()
	}
----

上面假设 `MyServiceImpl`, `Dependency1`, 和 `Dependency2` 使用 Spring 依赖注入注解,例如 `@Autowired`.


[[beans-java-instantiating-container-register]]
==== 使用 `register(Class<?>…)` 编程构建容器

`AnnotationConfigApplicationContext` 可以通过无参构造函数实例化,然后调用 `register()` 方法进行配置.  这种方法在以编程的方式构建 `AnnotationConfigApplicationContext` 时特别有用. 下列示例显示了如何执行此操作

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(String[] args) {
		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
		ctx.register(AppConfig.class, OtherConfig.class);
		ctx.register(AdditionalConfig.class);
		ctx.refresh();
		MyService myService = ctx.getBean(MyService.class);
		myService.doStuff();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	fun main() {
		val ctx = AnnotationConfigApplicationContext()
		ctx.register(AppConfig::class.java, OtherConfig::class.java)
		ctx.register(AdditionalConfig::class.java)
		ctx.refresh()
		val myService = ctx.getBean<MyService>()
		myService.doStuff()
	}
----


[[beans-java-instantiating-container-scan]]
==== 使用 `scan(String…)` 扫描组件

要启用组件扫描,可以按如下方式注解 `@Configuration` 类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan(basePackages = "com.acme") // <1>
	public class AppConfig  {
		// ...
	}
----
<1> 此注解可启用组件扫描.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan(basePackages = ["com.acme"]) // <1>
	class AppConfig  {
		// ...
	}
----
<1> 此注解可启用组件扫描.


[TIP]
=====
有经验的用户可能更熟悉使用 XML 的 `context:` 命名空间配置形式,如下例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<context:component-scan base-package="com.acme"/>
	</beans>
----
=====

上面的例子中,`com.acme` 包会被扫描,只要是使用了 `@Component` 注解的类,都会被注册进容器中. 同样地,`AnnotationConfigApplicationContext` 暴露的 `scan(String…)` 方法也允许扫描类完成同样的功能 如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(String[] args) {
		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
		ctx.scan("com.acme");
		ctx.refresh();
		MyService myService = ctx.getBean(MyService.class);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun main() {
		val ctx = AnnotationConfigApplicationContext()
		ctx.scan("com.acme")
		ctx.refresh()
		val myService = ctx.getBean<MyService>()
	}
----

NOTE: 请记住 `@Configuration` 类是使用 `@Component` 进行 <<beans-meta-annotations, 元注解>>的,因此它们是组件扫描的候选者.  在前面的示例中, 假设 `AppConfig` 在 `com.acme` 包(或下面的任何包) 中声明,它在 `scan()` 调用期间被拾取.  在 `refresh()` 之后,它的所有 `@Bean` 方法都被处理并在容器中注册为 bean 定义.


[[beans-java-instantiating-container-web]]
==== 使用 `AnnotationConfigWebApplicationContext` 支持Web应用程序

`WebApplicationContext` 与 `AnnotationConfigApplicationContext` 的结合是 `AnnotationConfigWebApplicationContext` 配置.
这个实现可以用于配置 Spring `ContextLoaderListener` servlet 监听器 ,Spring MVC 的 `DispatcherServlet` 等等. 以下 `web.xml` 代码段配置典型的 Spring MVC Web 应用程序(请注意 `contextClass` context-param 和 init-param 的使用) :

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<web-app>
		<!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
			instead of the default XmlWebApplicationContext -->
		<context-param>
			<param-name>contextClass</param-name>
			<param-value>
				org.springframework.web.context.support.AnnotationConfigWebApplicationContext
			</param-value>
		</context-param>

		<!-- Configuration locations must consist of one or more comma- or space-delimited
			fully-qualified @Configuration classes. Fully-qualified packages may also be
			specified for component-scanning -->
		<context-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>com.acme.AppConfig</param-value>
		</context-param>

		<!-- Bootstrap the root application context as usual using ContextLoaderListener -->
		<listener>
			<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
		</listener>

		<!-- Declare a Spring MVC DispatcherServlet as usual -->
		<servlet>
			<servlet-name>dispatcher</servlet-name>
			<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
			<!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
				instead of the default XmlWebApplicationContext -->
			<init-param>
				<param-name>contextClass</param-name>
				<param-value>
					org.springframework.web.context.support.AnnotationConfigWebApplicationContext
				</param-value>
			</init-param>
			<!-- Again, config locations must consist of one or more comma- or space-delimited
				and fully-qualified @Configuration classes -->
			<init-param>
				<param-name>contextConfigLocation</param-name>
				<param-value>com.acme.web.MvcConfig</param-value>
			</init-param>
		</servlet>

		<!-- map all requests for /app/* to the dispatcher servlet -->
		<servlet-mapping>
			<servlet-name>dispatcher</servlet-name>
			<url-pattern>/app/*</url-pattern>
		</servlet-mapping>
	</web-app>
----

NOTE: 对于编程用例，`GenericWebApplicationContext` 可以替代 `AnnotationConfigWebApplicationContext`。 见
{api-spring-framework}/web/context/support/GenericWebApplicationContext.html[`GenericWebApplicationContext`]
javadoc 了解详细信息。

[[beans-java-bean-annotation]]
=== 使用 `@Bean` 注解

`@Bean` 是一个方法级别的注解,它与 XML 中的 `<bean/>` 元素类似. 注解支持 `<bean/>` 提供的一些属性,例如

* <<beans-factory-lifecycle-initializingbean, init-method>>
* <<beans-factory-lifecycle-disposablebean, destroy-method>>
* <<beans-factory-autowire,autowiring>>
* `name`.

开发者可以在 `@Configuration` 类或 `@Component` 类中使用 `@Bean` 注解.


[[beans-java-declaring-a-bean]]
==== 声明一个 Bean

要声明一个 bean,只需使用 `@Bean` 注解方法即可. 使用此方法,将会在 `ApplicationContext` 内注册一个 bean,bean 的类型是方法的返回值类型. 默认情况下, bean 名称将与方法名称相同. 以下示例显示了 `@Bean` 方法声明:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		public TransferServiceImpl transferService() {
			return new TransferServiceImpl();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun transferService() = TransferServiceImpl()
	}
----

前面的配置完全等同于以下 Spring XML:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="transferService" class="com.acme.TransferServiceImpl"/>
	</beans>
----

这两个声明都在 `ApplicationContext` 中创建一个名为 `transferService` 的 bean,并且绑定了 `TransferServiceImpl` 的实例. 如下图所示:

[literal,subs="verbatim,quotes"]
----
transferService -> com.acme.TransferServiceImpl
----

您还可以使用默认方法来定义 bean。 这允许 bean 的组合通过在默认方法上实现带有 bean 定义的接口来进行配置。

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public interface BaseConfig {

		@Bean
		default TransferServiceImpl transferService() {
			return new TransferServiceImpl();
		}
	}

	@Configuration
	public class AppConfig implements BaseConfig {

	}
----

您还可以使用接口(或基类) 返回类型声明 `@Bean` 方法,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		public TransferService transferService() {
			return new TransferServiceImpl();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun transferService(): TransferService {
			return TransferServiceImpl()
		}
	}
----

但是,这会将预先类型预测的可见性限制为指定的接口类型(`TransferService`),然后在实例化受影响的单一 bean 时,只知道容器的完整类型(`TransferServiceImpl`) .
非延迟的单例 bean 根据它们的声明顺序进行实例化,因此开发者可能会看到不同类型的匹配结果,这具体取决于另一个组件尝试按未类型匹配的时间(如 `@Autowired TransferServiceImpl`, 一旦 `transferService` bean 已被实例化,这个问题就被解决了).

TIP: 如果通过声明的服务接口都是引用类型,那么 `@Bean` 返回类型可以安全地加入该设计决策.但是,对于实现多个接口的组件或可能由其实现类型引用的组件, 更安全的方法是声明可能的最具体的返回类型(至少按照注入点所要求的特定你的bean) .


[[beans-java-dependencies]]
==== Bean 的依赖

一个使用 `@Bean` 注解的方法可以具有任意数量的参数描述构建该 bean 所需的依赖,例如,如果我们的 `TransferService` 需要 `AccountRepository`, 我们可以使用方法参数来实现该依赖,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		public TransferService transferService(AccountRepository accountRepository) {
			return new TransferServiceImpl(accountRepository);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun transferService(accountRepository: AccountRepository): TransferService {
			return TransferServiceImpl(accountRepository)
		}
	}
----

这个解析机制与基于构造函数的依赖注入非常相似. 有关详细信息,请参阅<<beans-constructor-injection, 相关部分>>


[[beans-java-lifecycle-callbacks]]
==== 接收生命周期回调

使用 `@Bean` 注解定义的任何类都支持常规的生命周期回调,并且可以使用 JSR-250 的 `@PostConstruct` 和 `@PreDestroy` 注解.  有关更多详细信息,请参阅 <<beans-postconstruct-and-predestroy-annotations, JSR-250 注解>> .

完全支持常规的 Spring <<beans-factory-nature, 生命周期回调>>.  如果 bean 实现 `InitializingBean`, `DisposableBean`, 或 `Lifecycle`,则它们各自的方法由容器调用.

同样地,还完全支持标准的 `*Aware`,如 <<beans-beanfactory, BeanFactoryAware>>,
<<beans-factory-aware, BeanNameAware>>,
<<context-functionality-messagesource, MessageSourceAware>>,
<<beans-factory-aware, ApplicationContextAware>>.

`@Bean` 注解支持指定任意初始化和销毁回调方法,就像 bean 元素上的 Spring XML 的 `init-method` 和 `destroy-method` 属性一样,如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class BeanOne {

		public void init() {
			// initialization logic
		}
	}

	public class BeanTwo {

		public void cleanup() {
			// destruction logic
		}
	}

	@Configuration
	public class AppConfig {

		@Bean(initMethod = "init")
		public BeanOne beanOne() {
			return new BeanOne();
		}

		@Bean(destroyMethod = "cleanup")
		public BeanTwo beanTwo() {
			return new BeanTwo();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
class BeanOne {

	fun init() {
		// initialization logic
	}
}

class BeanTwo {

	fun cleanup() {
		// destruction logic
	}
}

@Configuration
class AppConfig {

	@Bean(initMethod = "init")
	fun beanOne() = BeanOne()

	@Bean(destroyMethod = "cleanup")
	fun beanTwo() = BeanTwo()
}
----

[NOTE]
=====
默认情况下,使用 Java Config 定义的 bean 中 `close` 方法或者 `shutdown` 方法,会作为销毁回调而自动调用. 若 bean 中有 `close` 或 `shutdown` 方法,并且您不希望在容器关闭时调用它,则可以将 `@Bean(destroyMethod = "")` 添加到  bean  定义中以禁用默认 `(inferred)` 模式.

开发者可能希望对通过 JNDI 获取的资源执行此操作,因为它的生命周期是在应用程序外部管理的. 特别是，请确保始终为 `DataSource` 执行此操作，因为众所周知，它在 Jakarta EE 应用程序服务器上存在问题。

以下示例说明如何防止 `DataSource` 的自动销毁回调:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Bean(destroyMethod = "")
	public DataSource dataSource() throws NamingException {
		return (DataSource) jndiTemplate.lookup("MyDS");
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Bean(destroyMethod = "")
	fun dataSource(): DataSource {
		return jndiTemplate.lookup("MyDS") as DataSource
	}
----

同样地,使用 `@Bean` 方法,通常会选择使用程序化的 JNDI 查找: 使用 Spring 的 `JndiTemplate/JndiLocatorDelegate` 帮助类或直接使用 JNDI 的 `InitialContext` ,
但是不要使用 `JndiObjectFactoryBean` 的变体,因为它会强制开发者声明一个返回类型作为 `FactoryBean` 的类型用于代替实际的目标类型,这会使得交叉引用变得很困难.
=====

对于前面注解中上面示例中的 `BeanOne`,在构造期间直接调用 `init()` 方法同样有效,如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		public BeanOne beanOne() {
			BeanOne beanOne = new BeanOne();
			beanOne.init();
			return beanOne;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun beanOne() = BeanOne().apply {
			init()
		}

		// ...
	}
----

TIP: 当您直接使用 Java( new 对象那种) 工作时,您可以使用对象执行任何您喜欢的操作,并且不必总是依赖于容器生命周期.


[[beans-java-specifying-bean-scope]]
==== 指定 Bean 的作用域

Spring包含 `@Scope` 注解,以便您可以指定 bean 的作用域.

[[beans-java-available-scopes]]
===== 使用 `@Scope` 注解
可以使用任意标准的方式为 `@Bean` 注解的 bean 指定一个作用域,你可以使用<<beans-factory-scopes, Bean Scopes>>中的任意标准作用域

默认作用域是 `singleton` 的,但是可以使用 `@Scope` 注解来覆盖. 如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class MyConfiguration {

		@Bean
		@Scope("prototype")
		public Encryptor encryptor() {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class MyConfiguration {

		@Bean
		@Scope("prototype")
		fun encryptor(): Encryptor {
			// ...
		}
	}
----

[[beans-java-scoped-proxy]]
===== `@Scope` 和 `scoped-proxy`

Spring 提供了一种通过<<beans-factory-scopes-other-injection, scoped proxies>>处理作用域依赖的便捷方法. 使用 XML 配置时创建此类代理的最简单方法是 `<aop:scoped-proxy/>` 元素.
使用 `@Scope` 注解在 Java 中配置 bean 提供了与 `proxyMode` 属性的等效支持.  默认值为不应创建作用域代理(`ScopedProxyMode.DEFAULT`) ,但您可以指定 `ScopedProxyMode.TARGET_CLASS` , `ScopedProxyMode.INTERFACES` 或 `ScopedProxyMode.NO`。.

如果使用 Java 将 XML 参考文档(请参阅<<beans-factory-scopes-other-injection, scoped proxies>>) 的作用域代理示例移植到我们的 `@Bean`,它类似于以下内容:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// an HTTP Session-scoped bean exposed as a proxy
	@Bean
	@SessionScope
	public UserPreferences userPreferences() {
		return new UserPreferences();
	}

	@Bean
	public Service userService() {
		UserService service = new SimpleUserService();
		// a reference to the proxied userPreferences bean
		service.setUserPreferences(userPreferences());
		return service;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// an HTTP Session-scoped bean exposed as a proxy
	@Bean
	@SessionScope
	fun userPreferences() = UserPreferences()

	@Bean
	fun userService(): Service {
		return SimpleUserService().apply {
			// a reference to the proxied userPreferences bean
			setUserPreferences(userPreferences())
		}
	}
----

[[beans-java-customizing-bean-naming]]
==== 自定义 Bean 名字

默认情况下,配置类使用 `@Bean` 方法的名称作为结果 bean 的名称.  但是,可以使用 `name` 属性覆盖此功能,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean("myThing")
		public Thing thing() {
			return new Thing();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean("myThing")
		fun thing() = Thing()
	}
----


[[beans-java-bean-aliasing]]
==== Bean 的别名

正如 <<beans-beanname,Bean 的命名>> 中所讨论的,有时需要为单个 bean 提供多个名称,也称为 bean 别名.  `@Bean` 注解的 `name` 属性为此接受 `String` 数组.  以下示例显示如何为 bean 设置多个别名:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean({"dataSource", "subsystemA-dataSource", "subsystemB-dataSource"})
		public DataSource dataSource() {
			// instantiate, configure and return DataSource bean...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean("dataSource", "subsystemA-dataSource", "subsystemB-dataSource")
		fun dataSource(): DataSource {
			// instantiate, configure and return DataSource bean...
		}
	}
----


[[beans-java-bean-description]]
==== Bean 的描述

有时,提供更详细的 bean 文本描述会很有帮助.  当 bean 被暴露(可能通过 JMX) 用于监视目的时,这可能特别有用.

要向 `@Bean` 添加描述,可以使用 {api-spring-framework}/context/annotation/Description.html[`@Description`] 注解,如以下示例所示:


[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		@Description("Provides a basic example of a bean")
		public Thing thing() {
			return new Thing();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		@Description("Provides a basic example of a bean")
		fun thing() = Thing()
	}
----



[[beans-java-configuration-annotation]]
=== 使用 `@Configuration` 注解

`@Configuration` 是一个类级别的注解,表明该类将作为 bean 定义的元数据配置. `@Configuration` 类会将有 `@Bean` 注解的暴露方法声明为 bean .在 `@Configuration` 类上调用 `@Bean` 方法也可以用于定义 bean 间依赖, 有关一般介绍,请参阅 基本概念:<<beans-java-basic-concepts>>


[[beans-java-injecting-dependencies]]
==== 注入内部bean依赖

当 bean 彼此有依赖时,表示依赖就像调用另一个 bean 方法一样简单.如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		public BeanOne beanOne() {
			return new BeanOne(beanTwo());
		}

		@Bean
		public BeanTwo beanTwo() {
			return new BeanTwo();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun beanOne() = BeanOne(beanTwo())

		@Bean
		fun beanTwo() = BeanTwo()
	}
----

在前面的示例中,`beanOne` 通过构造函数注入接收对 `beanTwo` 的引用.

NOTE: 这种声明 bean 间依赖的方法只有在 `@Configuration` 类中声明 `@Bean` 方法时才有效.  您不能使用普通的 `@Component` 类声明 bean 间依赖.


[[beans-java-method-injection]]
==== 查找方法注入

如前所述,<<beans-factory-method-injection, 查找方法注入>> 是一项很少使用的高级功能.  在单例作用域的 bean 依赖于原型作用域的 bean 的情况下,它很有用.  Java 提供了很友好的 API 来实现这种模式. 以下示例显示了如何使用查找方法注入:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public abstract class CommandManager {
		public Object process(Object commandState) {
			// grab a new instance of the appropriate Command interface
			Command command = createCommand();
			// set the state on the (hopefully brand new) Command instance
			command.setState(commandState);
			return command.execute();
		}

		// okay... but where is the implementation of this method?
		protected abstract Command createCommand();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	abstract class CommandManager {
		fun process(commandState: Any): Any {
			// grab a new instance of the appropriate Command interface
			val command = createCommand()
			// set the state on the (hopefully brand new) Command instance
			command.setState(commandState)
			return command.execute()
		}

		// okay... but where is the implementation of this method?
		protected abstract fun createCommand(): Command
	}
----

通过使用 Java 配置,您可以创建 `CommandManager` 的子类,其中抽象的 `createCommand()` 方法被覆盖,以便查找新的(prototype)对象.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Bean
	@Scope("prototype")
	public AsyncCommand asyncCommand() {
		AsyncCommand command = new AsyncCommand();
		// inject dependencies here as required
		return command;
	}

	@Bean
	public CommandManager commandManager() {
		// return new anonymous implementation of CommandManager with createCommand()
		// overridden to return a new prototype Command object
		return new CommandManager() {
			protected Command createCommand() {
				return asyncCommand();
			}
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Bean
	@Scope("prototype")
	fun asyncCommand(): AsyncCommand {
		val command = AsyncCommand()
		// inject dependencies here as required
		return command
	}

	@Bean
	fun commandManager(): CommandManager {
		// return new anonymous implementation of CommandManager with createCommand()
		// overridden to return a new prototype Command object
		return object : CommandManager() {
			override fun createCommand(): Command {
				return asyncCommand()
			}
		}
	}
----


[[beans-java-further-information-java-config]]
==== 有关基于 Java 的配置如何在内部工作的更多信息

请考虑以下示例,该示例显示了被调用两次的 `@Bean` 注解方法:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean
		public ClientService clientService1() {
			ClientServiceImpl clientService = new ClientServiceImpl();
			clientService.setClientDao(clientDao());
			return clientService;
		}

		@Bean
		public ClientService clientService2() {
			ClientServiceImpl clientService = new ClientServiceImpl();
			clientService.setClientDao(clientDao());
			return clientService;
		}

		@Bean
		public ClientDao clientDao() {
			return new ClientDaoImpl();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean
		fun clientService1(): ClientService {
			return ClientServiceImpl().apply {
				clientDao = clientDao()
			}
		}

		@Bean
		fun clientService2(): ClientService {
			return ClientServiceImpl().apply {
				clientDao = clientDao()
			}
		}

		@Bean
		fun clientDao(): ClientDao {
			return ClientDaoImpl()
		}
	}
----

`clientDao()` 在 `clientService1()` 中调用一次,在 `clientService2()` 中调用一次. 由于此方法创建了 `ClientDaoImpl` 的新实例并将其返回,因此通常希望有两个实例(每个服务一个) .
这肯定会有问题: 在 Spring 中,实例化的 bean 默认具有 `singleton` 作用域. 这就是它的神奇之处:所有 `@Configuration` 类在启动时都使用 `CGLIB` 进行子类化.  在子类中,子方法在调用父方法并创建新实例之前,首先检查容器是否有任何缓存(作用域) bean.

NOTE: 这种行为可以根据 bean 的作用域而变化,我们这里只是讨论单例.

[NOTE]
====
从 Spring 3.2 开始,不再需要将 CGLIB 添加到类路径中,因为 CGLIB 类已经在 `org.springframework.cglib` 下重新打包并直接包含在 `spring-core` JAR 中.
====

[TIP]
====
由于 CGLIB 在启动时动态添加功能,因此存在一些限制.  特别是,配置类不能是 final 的.  但是,从 4.3 开始,配置类允许使用任何构造函数,包括使用 `@Autowired` 或单个非默认构造函数声明进行默认注入.

如果想避免因 CGLIB 带来的限制,请考虑声明非 `@Configuration` 类的 `@Bean` 方法,例如在 `@Component` 类 .这样在 `@Bean` 方法之间的交叉方法调用将不会被拦截,此时必须在构造函数或方法级别上进行依赖注入.
====

[[beans-java-composing-configuration-classes]]
=== 编写基于 Java 的配置

Spring 的基于 Java 的配置功能允许您撰写注解,这可以降低配置的复杂性.

[[beans-java-using-import]]
==== 使用 `@Import` 注解

就像在 Spring XML 文件中使用 `<import/>` 元素来帮助模块化配置一样,`@Import` 注解允许从另一个配置类加载 `@Bean` 定义,如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class ConfigA {

		@Bean
		public A a() {
			return new A();
		}
	}

	@Configuration
	@Import(ConfigA.class)
	public class ConfigB {

		@Bean
		public B b() {
			return new B();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class ConfigA {

		@Bean
		fun a() = A()
	}

	@Configuration
	@Import(ConfigA::class)
	class ConfigB {

		@Bean
		fun b() = B()
	}
----

现在,在实例化上下文时,不需要同时指定 `ConfigA.class` 和 `ConfigB.class`,只需要显式提供 `ConfigB`,如下例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);

		// now both beans A and B will be available...
		A a = ctx.getBean(A.class);
		B b = ctx.getBean(B.class);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	fun main() {
		val ctx = AnnotationConfigApplicationContext(ConfigB::class.java)

		// now both beans A and B will be available...
		val a = ctx.getBean<A>()
		val b = ctx.getBean<B>()
	}
----

这种方法简化了容器实例化,因为只需要处理一个类,而不是要求您在构造期间记住可能大量的 `@Configuration` 类.

TIP: 从 Spring Framework 4.2 开始,`@Import` 还支持引用常规组件类,类似于 `AnnotationConfigApplicationContext.register` 方法.  如果要避免组件扫描,这一点特别有用,可以使用一些配置类作为明确定义所有组件的入口点.

[[beans-java-injecting-imported-beans]]
===== 在导入的 `@Bean` 定义上注入依赖

上面的例子可以运行,但是太简单了. 在大多数实际情况下, bean 将在配置类之间相互依赖.在使用XML时,这本身不是问题,因为没有涉及到编译器. 可以简单地声明 `ref="someBean"`,并且相信 Spring 将在容器初始化期间可以很好地处理它. 当然,当使用 `@Configuration` 类时,Java编译器会有一些限制 ,即需符合Java的语法.

幸运的是,解决这个问题很简单. 正如我们 <<beans-java-dependencies, 已经讨论过>> 的,`@Bean` 方法可以有任意数量的参数来描述 bean 的依赖.  考虑以下更多真实场景,其中包含几个 `@Configuration` 类,每个类都取决于其他类中声明的 bean :

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class ServiceConfig {

		@Bean
		public TransferService transferService(AccountRepository accountRepository) {
			return new TransferServiceImpl(accountRepository);
		}
	}

	@Configuration
	public class RepositoryConfig {

		@Bean
		public AccountRepository accountRepository(DataSource dataSource) {
			return new JdbcAccountRepository(dataSource);
		}
	}

	@Configuration
	@Import({ServiceConfig.class, RepositoryConfig.class})
	public class SystemTestConfig {

		@Bean
		public DataSource dataSource() {
			// return new DataSource
		}
	}

	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
		// everything wires up across configuration classes...
		TransferService transferService = ctx.getBean(TransferService.class);
		transferService.transfer(100.00, "A123", "C456");
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	@Configuration
	class ServiceConfig {

		@Bean
		fun transferService(accountRepository: AccountRepository): TransferService {
			return TransferServiceImpl(accountRepository)
		}
	}

	@Configuration
	class RepositoryConfig {

		@Bean
		fun accountRepository(dataSource: DataSource): AccountRepository {
			return JdbcAccountRepository(dataSource)
		}
	}

	@Configuration
	@Import(ServiceConfig::class, RepositoryConfig::class)
	class SystemTestConfig {

		@Bean
		fun dataSource(): DataSource {
			// return new DataSource
		}
	}


	fun main() {
		val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java)
		// everything wires up across configuration classes...
		val transferService = ctx.getBean<TransferService>()
		transferService.transfer(100.00, "A123", "C456")
	}
----

还有另一种方法可以达到相同的效果. 请记住,`@Configuration` 类最终只是容器中的另一个 bean :  这意味着它们可以利用 `@Autowired` 和 `@Value` 注入以及与任何其他 bean 相同的其他功能.

[WARNING]
====
确保以这种方式注入的依赖只是最简单的. `@Configuration` 类在上下文初始化期间很早就被处理,并且强制以这种方式注入依赖可能会导致意外的早期初始化.  尽可能采用基于参数的注入,如前面的示例所示.

另外,要特别注意通过 `@Bean` 的 `BeanPostProcessor` 和 `BeanFactoryPostProcessor` 定义.  这些通常应该声明为 `static @Bean` 方法,而不是触发其包含配置类的实例化.
否则,`@Autowired` 和 `@Value` 不能在配置类本身上工作,因为它早于 {api-spring-framework}/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html[`AutowiredAnnotationBeanPostProcessor`] 被创建为 bean 实例.
====

以下示例显示了如何将一个 bean 自动连接到另一个 bean :

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class ServiceConfig {

		@Autowired
		private AccountRepository accountRepository;

		@Bean
		public TransferService transferService() {
			return new TransferServiceImpl(accountRepository);
		}
	}

	@Configuration
	public class RepositoryConfig {

		private final DataSource dataSource;

		public RepositoryConfig(DataSource dataSource) {
			this.dataSource = dataSource;
		}

		@Bean
		public AccountRepository accountRepository() {
			return new JdbcAccountRepository(dataSource);
		}
	}

	@Configuration
	@Import({ServiceConfig.class, RepositoryConfig.class})
	public class SystemTestConfig {

		@Bean
		public DataSource dataSource() {
			// return new DataSource
		}
	}

	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
		// everything wires up across configuration classes...
		TransferService transferService = ctx.getBean(TransferService.class);
		transferService.transfer(100.00, "A123", "C456");
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	@Configuration
	class ServiceConfig {

		@Autowired
		lateinit var accountRepository: AccountRepository

		@Bean
		fun transferService(): TransferService {
			return TransferServiceImpl(accountRepository)
		}
	}

	@Configuration
	class RepositoryConfig(private val dataSource: DataSource) {

		@Bean
		fun accountRepository(): AccountRepository {
			return JdbcAccountRepository(dataSource)
		}
	}

	@Configuration
	@Import(ServiceConfig::class, RepositoryConfig::class)
	class SystemTestConfig {

		@Bean
		fun dataSource(): DataSource {
			// return new DataSource
		}
	}

	fun main() {
		val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java)
		// everything wires up across configuration classes...
		val transferService = ctx.getBean<TransferService>()
		transferService.transfer(100.00, "A123", "C456")
	}
----

TIP: 仅在 Spring Framework 4.3 中支持 `@Configuration` 类中的构造函数注入.  另请注意,如果目标 bean 仅定义了一个构造函数,则无需指定 `@Autowired`.  在前面的示例中,`RepositoryConfig` 构造函数中不需要 `@Autowired`.

.[[beans-java-injecting-imported-beans-fq]]
完全导入 bean 便于查找
--
在上面的场景中,`@Autowired` 可以很好的工作,使设计更具模块化,但是自动注入哪个 bean 依然有些模糊不清.例如, 作为一个开发者查看 `ServiceConfig` 类时,你怎么知道 `@Autowired AccountRepository` 在哪定义的呢?代码中并未明确指出,
还好, https://spring.io/tools[Spring Tools for Eclipse] 提供的工具可以呈现图表,显示所有内容的连线方式,这可能就是您所需要的.  此外,您的Java IDE可以轻松找到 `AccountRepository` 类型的所有声明和用法,并快速显示返回该类型的 `@Bean` 方法的位置.

万一需求不允许这种模糊的装配,并且您希望从 IDE 中从一个 `@Configuration` 类直接导航到另一个 `@Configuration` 类,请考虑自动装配配置类本身.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class ServiceConfig {

		@Autowired
		private RepositoryConfig repositoryConfig;

		@Bean
		public TransferService transferService() {
			// navigate 'through' the config class to the @Bean method!
			return new TransferServiceImpl(repositoryConfig.accountRepository());
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Configuration
class ServiceConfig {

	@Autowired
	private lateinit var repositoryConfig: RepositoryConfig

	@Bean
	fun transferService(): TransferService {
		// navigate 'through' the config class to the @Bean method!
		return TransferServiceImpl(repositoryConfig.accountRepository())
	}
}
----

在前面的情况中,定义 `AccountRepository` 是完全明确的. 但是,`ServiceConfig` 现在与 `RepositoryConfig` 紧密耦合. 这是一种权衡的方法.  通过使用基于接口的或基于类的抽象 `@Configuration` 类,可以在某种程度上减轻这种紧密耦合. 请考虑以下示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class ServiceConfig {

		@Autowired
		private RepositoryConfig repositoryConfig;

		@Bean
		public TransferService transferService() {
			return new TransferServiceImpl(repositoryConfig.accountRepository());
		}
	}

	@Configuration
	public interface RepositoryConfig {

		@Bean
		AccountRepository accountRepository();
	}

	@Configuration
	public class DefaultRepositoryConfig implements RepositoryConfig {

		@Bean
		public AccountRepository accountRepository() {
			return new JdbcAccountRepository(...);
		}
	}

	@Configuration
	@Import({ServiceConfig.class, DefaultRepositoryConfig.class})  // import the concrete config!
	public class SystemTestConfig {

		@Bean
		public DataSource dataSource() {
			// return DataSource
		}

	}

	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
		TransferService transferService = ctx.getBean(TransferService.class);
		transferService.transfer(100.00, "A123", "C456");
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	@Configuration
	class ServiceConfig {

		@Autowired
		private lateinit var repositoryConfig: RepositoryConfig

		@Bean
		fun transferService(): TransferService {
			return TransferServiceImpl(repositoryConfig.accountRepository())
		}
	}

	@Configuration
	interface RepositoryConfig {

		@Bean
		fun accountRepository(): AccountRepository
	}

	@Configuration
	class DefaultRepositoryConfig : RepositoryConfig {

		@Bean
		fun accountRepository(): AccountRepository {
			return JdbcAccountRepository(...)
		}
	}

	@Configuration
	@Import(ServiceConfig::class, DefaultRepositoryConfig::class)  // import the concrete config!
	class SystemTestConfig {

		@Bean
		fun dataSource(): DataSource {
			// return DataSource
		}

	}

	fun main() {
		val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java)
		val transferService = ctx.getBean<TransferService>()
		transferService.transfer(100.00, "A123", "C456")
	}
----

现在,`ServiceConfig` 与具体的 `DefaultRepositoryConfig` 松散耦合,内置的IDE工具仍然很有用: 您可以很容易获取 `RepositoryConfig` 实现类的继承体系.  以这种方式,操作 `@Configuration` 类及其依赖与操作基于接口的代码的过程没有什么区别
--

TIP: 如果要影响某些 bean 的启动创建顺序,可以考虑将其中一些声明为 `@Lazy` (用于在首次访问时创建而不是在启动时) 或 `@DependsOn` 某些其他 bean (确保在创建之前创建特定的其他 bean (当前的 bean ,超出后者的直接依赖性所暗示的) ) .


[[beans-java-conditional]]
==== 有条件地包含 `@Configuration` 类或 `@Bean` 方法

基于某些任意系统状态,有条件地启用或禁用完整的 `@Configuration` 类甚至单独的 `@Bean` 方法通常很有用.  一个常见的例子是, 只有在 Spring 环境中启用了特定的配置文件时才使用 `@Profile` 注解来激活 bean (有关详细信息,请参阅 Bean<<beans-definition-profiles>>) .

`@Profile` 注解实际上是通过使用更灵活的注解 `@Conditional` 实现的. `@Conditional` 注解表示特定的 `org.springframework.context.annotation.Condition` 实现.  它表明 `@Bean` 被注册之前会先"询问 `@Conditional` 注解.

`Condition` 接口的实现提供了一个返回 `true` 或 `false` 的 `matches(…)` 方法. 例如,以下清单显示了用于 `@Profile` 的实际 `Condition` 实现:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Override
	public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
		// Read the @Profile annotation attributes
		MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
		if (attrs != null) {
			for (Object value : attrs.get("value")) {
				if (context.getEnvironment().acceptsProfiles(((String[]) value))) {
					return true;
				}
			}
			return false;
		}
		return true;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	override fun matches(context: ConditionContext, metadata: AnnotatedTypeMetadata): Boolean {
		// Read the @Profile annotation attributes
		val attrs = metadata.getAllAnnotationAttributes(Profile::class.java.name)
		if (attrs != null) {
			for (value in attrs["value"]!!) {
				if (context.environment.acceptsProfiles(Profiles.of(*value as Array<String>))) {
					return true
				}
			}
			return false
		}
		return true
	}
----

有关更多详细信息,请参阅 {api-spring-framework}/context/annotation/Conditional.html[`@Conditional`] javadoc.


[[beans-java-combining]]
==== 结合 Java 和 XML 配置

Spring的 `@Configuration` 类支持但不一定成为 Spring XML 的 100％ 完全替代品.  某些工具(如 Spring XML 命名空间) 仍然是配置容器的理想方法.
在 XML 方便或必要的情况下,您可以选择: 通过使用例如 `ClassPathXmlApplicationContext` 以 "`XML-centric`" 的方式实例化容器, 或者通过使用 `AnnotationConfigApplicationContext` 以 "`Java-centric`" 的方式实例化它. `@ImportResource` 注解,根据需要导入XML.

[[beans-java-combining-xml-centric]]
===== 以XML为中心使用 `@Configuration` 类

更受人喜爱的方法是从包含 `@Configuration` 类的 XML 启动容器.例如,在使用 Spring 的现有系统中,大量使用的是 Spring XML 配置,所以很容易根据需要创建 `@Configuration` 类 ,并将他们到包含 XML 文件中. 我们将介绍在这种 "`XML-centric`" 的情况下使用 `@Configuration` 类的选项.

.[[beans-java-combining-xml-centric-declare-as-bean]]
将 `@Configuration` 类声明为普通的Spring `<bean/>` 元素
--
请记住,`@Configuration` 类最终也只是容器中的 bean 定义. 在本系列示例中,我们创建一个名为 `AppConfig` 的 `@Configuration` 类,并将其作为 `<bean/>` 定义包含在 `system-test-config.xml` 中.  由于 `<context:annotation-config/>` 已打开,容器会识别 `@Configuration` 注解并正确处理 `AppConfig` 中声明的 `@Bean` 方法.

以下示例显示了 Java 中的普通配置类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Autowired
		private DataSource dataSource;

		@Bean
		public AccountRepository accountRepository() {
			return new JdbcAccountRepository(dataSource);
		}

		@Bean
		public TransferService transferService() {
			return new TransferService(accountRepository());
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Autowired
		private lateinit var dataSource: DataSource

		@Bean
		fun accountRepository(): AccountRepository {
			return JdbcAccountRepository(dataSource)
		}

		@Bean
		fun transferService() = TransferService(accountRepository())
	}
----

以下示例显示了示例 `system-test-config.xml` 文件的一部分:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<!-- enable processing of annotations such as @Autowired and @Configuration -->
		<context:annotation-config/>
		<context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>

		<bean class="com.acme.AppConfig"/>

		<bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.username}"/>
			<property name="password" value="${jdbc.password}"/>
		</bean>
	</beans>
----

以下示例显示了可能的 `jdbc.properties` 文件:

[literal,subs="verbatim,quotes"]
----
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(String[] args) {
		ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml");
		TransferService transferService = ctx.getBean(TransferService.class);
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun main() {
		val ctx = ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml")
		val transferService = ctx.getBean<TransferService>()
		// ...
	}
----


NOTE: 在 `system-test-config.xml` 文件中, `AppConfig <bean/>` 不声明 `id` 元素. 虽然这样做是可以的,但是没有必要,因为没有其他 bean 引用它,并且不太可能通过名称从容器中明确地获取它.  类似地,`DataSource`  bean 只是按类型自动装配,因此不严格要求显式的  bean  `id`.
--

.[[beans-java-combining-xml-centric-component-scan]]
使用 <context:component-scan/> 来获取 `@Configuration` 类
--

因为 `@Configuration` 是 `@Component` 注解的元注解,所以 `@Configuration` 注解的类也可以被自动扫描. 使用与上面相同的场景,可以重新定义 `system-test-config.xml` 以使用组件扫描.  请注意,在这种情况下,我们不需要显式声明 `<context:annotation-config/>`,,因为 `<context:component-scan/>` 启用相同的功能.

以下示例显示了已修改的 `system-test-config.xml` 文件:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<!-- picks up and registers AppConfig as a bean definition -->
		<context:component-scan base-package="com.acme"/>
		<context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>

		<bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.username}"/>
			<property name="password" value="${jdbc.password}"/>
		</bean>
	</beans>
----
--

[[beans-java-combining-java-centric]]
===== 基于 `@Configuration` 混合XML的 `@ImportResource`

在 `@Configuration` 类为配置容器的主要方式的应用程序中,也需要使用一些XML配置. 在这些情况下,只需使用 `@ImportResource` ,并只定义所需的 XML.
这样做可以实现 "`Java-centric`"  的方法来配置容器并尽可能少的使用 XML.  以下示例(包括配置类,定义 bean 的 XML 文件,属性文件和主类) 显示了如何使用 `@ImportResource` 注解来实现根据需要使用 XML 的 "`Java-centric`"  的配置:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ImportResource("classpath:/com/acme/properties-config.xml")
	public class AppConfig {

		@Value("${jdbc.url}")
		private String url;

		@Value("${jdbc.username}")
		private String username;

		@Value("${jdbc.password}")
		private String password;

		@Bean
		public DataSource dataSource() {
			return new DriverManagerDataSource(url, username, password);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ImportResource("classpath:/com/acme/properties-config.xml")
	class AppConfig {

		@Value("\${jdbc.url}")
		private lateinit var url: String

		@Value("\${jdbc.username}")
		private lateinit var username: String

		@Value("\${jdbc.password}")
		private lateinit var password: String

		@Bean
		fun dataSource(): DataSource {
			return DriverManagerDataSource(url, username, password)
		}
	}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	properties-config.xml
	<beans>
		<context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>
	</beans>
----

[literal,subs="verbatim,quotes"]
----
jdbc.properties
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(String[] args) {
		ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
		TransferService transferService = ctx.getBean(TransferService.class);
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	fun main() {
		val ctx = AnnotationConfigApplicationContext(AppConfig::class.java)
		val transferService = ctx.getBean<TransferService>()
		// ...
	}
----



[[beans-environment]]

{api-spring-framework}/core/env/Environment.html[`Environment`] 接口是集成在容器中的抽象,它模拟了应用程序环境的两个关键方面: <<beans-definition-profiles, profiles>> 和  <<beans-property-source-abstraction, properties>>

profile 配置是一个被命名的, bean 定义的逻辑组,这些 bean 只有在给定的 profile 配置激活时才会注册到容器.无论是以 XML 还是通过注解定义, bean 都可以分配给配置文件 .
`Environment` 对象在 profile 中的角色是判断哪一个 profile 应该在当前激活和哪一个 profile 应该在默认情况下激活.

属性在几乎所有应用程序中都发挥着重要作用,可能源自各种源: 属性文件,JVM 系统属性,系统环境变量,JNDI,servlet 上下文参数,ad-hoc 属性对象,`Map` 对象等.
与属性相关的 `Environment` 对象的作用是为用户提供方便的服务接口,用于配置属性源和从中解析属性.


[[beans-definition-profiles]]
=== Bean 定义 Profiles

bean 定义 profiles 是核心容器内的一种机制,该机制能在不同环境中注册不同的 bean."`environment`" 这个词对不同的用户来说意味着不同的东西,这个功能可以帮助解决许多用例,包括:

* 在 QA 或生产环境中,针对开发中的内存数据源而不是从JNDI查找相同的数据源.
* 开发期使用监控组件,当部署以后则关闭监控组件,使应用更高效
* 为用户各自注册自定义 bean 实现.

考虑 `DataSource` 的实际应用程序中的第一个用例.  在测试环境中,配置可能类似于以下内容:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Bean
	public DataSource dataSource() {
		return new EmbeddedDatabaseBuilder()
			.setType(EmbeddedDatabaseType.HSQL)
			.addScript("my-schema.sql")
			.addScript("my-test-data.sql")
			.build();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Bean
	fun dataSource(): DataSource {
		return EmbeddedDatabaseBuilder()
				.setType(EmbeddedDatabaseType.HSQL)
				.addScript("my-schema.sql")
				.addScript("my-test-data.sql")
				.build()
	}
----

现在考虑如何将此应用程序部署到 QA 或生产环境中,假设应用程序的数据源已注册到生产应用程序服务器的 JNDI 目录.  我们的 `dataSource`  bean 现在看起来如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Bean(destroyMethod = "")
	public DataSource dataSource() throws Exception {
		Context ctx = new InitialContext();
		return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Bean(destroyMethod = "")
	fun dataSource(): DataSource {
		val ctx = InitialContext()
		return ctx.lookup("java:comp/env/jdbc/datasource") as DataSource
	}
----

问题是如何根据当前环境在使用这两种变体之间切换. 随着时间的推移,Spring 用户已经设计了许多方法来完成这项工作,通常依赖于系统环境变量和包含  pass:q[`${placeholder}`]  标记的 XML `<import/>` 语句的组合,
这些标记根据值解析为正确的配置文件路径一个环境变量.   bean 定义 profiles 是核心容器功能,可为此问题提供解决方案.

概括一下上面的场景,环境决定 bean 定义,最后发现,我们需要在某些上下文环境中使用某些 bean ,在其他环境中则不用这些 bean .或者说, 在场景 A 中注册一组 bean 定义,而在场景B中注册另外一组. 先看看如何通过修改配置来完成此需求:

[[beans-definition-profiles-java]]
==== 使用 `@Profile`

{api-spring-framework}/context/annotation/Profile.html[`@Profile`]  注解用于当一个或多个配置文件激活的时候,用来指定组件是否有资格注册. 使用前面的示例,我们可以重写 `dataSource` 配置,如下所示:

--
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@Profile("development")
	public class StandaloneDataConfig {

		@Bean
		public DataSource dataSource() {
			return new EmbeddedDatabaseBuilder()
				.setType(EmbeddedDatabaseType.HSQL)
				.addScript("classpath:com/bank/config/sql/schema.sql")
				.addScript("classpath:com/bank/config/sql/test-data.sql")
				.build();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@Profile("development")
	class StandaloneDataConfig {

		@Bean
		fun dataSource(): DataSource {
			return EmbeddedDatabaseBuilder()
					.setType(EmbeddedDatabaseType.HSQL)
					.addScript("classpath:com/bank/config/sql/schema.sql")
					.addScript("classpath:com/bank/config/sql/test-data.sql")
					.build()
		}
	}
----
--

--
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@Profile("production")
	public class JndiDataConfig {

		@Bean(destroyMethod = "")  // <1>
		public DataSource dataSource() throws Exception {
			Context ctx = new InitialContext();
			return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
		}
	}
----
<1> `@Bean(destroyMethod = "")` disables default destroy method inference.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@Profile("production")
	class JndiDataConfig {

		@Bean(destroyMethod = "") // <1>
		fun dataSource(): DataSource {
			val ctx = InitialContext()
			return ctx.lookup("java:comp/env/jdbc/datasource") as DataSource
		}
	}
----
<1> `@Bean(destroyMethod = "")` disables default destroy method inference.
--

NOTE: 如前所述,使用 `@Bean` 方法,您通常选择使用 Spring 的 `JndiTemplate/JndiLocatorDelegate` 帮助程序或前面显示的 直接 JNDI `InitialContext` 用法但不使用 `JndiObjectFactoryBean` 变量来使用编程 JNDI 查找,这会强制您将返回类型声明为 `FactoryBean` 类型.

profile 字符串可以包含简单的 profile 名称(例如,production) 或 profile 表达式.  profile 表达式允许表达更复杂的概要逻辑(例如,`production & us-east`) .  profile 表达式支持以下运算符:


* `!`: 逻辑 非(`NOT`)
* `&`: 逻辑 与(`AND`)
* `|`: 逻辑 或(`OR`)

NOTE: 你必须使用括号混合 `&` 和 `|` .  例如,`production & us-east` | `eu-central` ,它不是一个有效的表达.  它必须表示为 `production & (us-east | eu-central)`.

您可以将 `@Profile` 用作 <<beans-meta-annotations, 元注解>>,以创建自定义组合注解.  以下示例定义了一个自定义 `@Production` 注解,您可以将其用作 `@Profile("production")` 的替代品:

--
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Profile("production")
	public @interface Production {
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.CLASS)
	@Retention(AnnotationRetention.RUNTIME)
	@Profile("production")
	annotation class Production
----
--

TIP: 如果 `@Configuration` 类标有 `@Profile`,类中所有 `@Bean` 和 `@Import` 注解相关的类都将被忽略,除非该 `profile` 被激活.
如果一个 `@Component` 或 `@Configuration` 类被标记为 `@Profile({"p1", "p2"})`. 那么除非 `profile 'p1' or 'p2'` 已被激活.
否则该类将不会注册/处理. 如果给定的配置文件以 NOT 运算符( `!` )为前缀,如果配置文件为没有激活,则注册的元素将被注册.  例如,给定 `@Profile({"p1", "!p2"})`,如果配置文件 `p1` 处于 active 状态或配置文件 `p2` 未激活,则会进行注册.

`@Profile` 也能注解方法,用于配置一个配置类中的指定 bean . 如以下示例所示:

--
[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class AppConfig {

		@Bean("dataSource")
		@Profile("development") // <1>
		public DataSource standaloneDataSource() {
			return new EmbeddedDatabaseBuilder()
				.setType(EmbeddedDatabaseType.HSQL)
				.addScript("classpath:com/bank/config/sql/schema.sql")
				.addScript("classpath:com/bank/config/sql/test-data.sql")
				.build();
		}

		@Bean("dataSource")
		@Profile("production") // <2>
		public DataSource jndiDataSource() throws Exception {
			Context ctx = new InitialContext();
			return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
		}
	}
----
<1>  `standaloneDataSource`  方法仅在 `development` 环境可用.
<2>  `jndiDataSource`  方法仅在 `production` 环境可用.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class AppConfig {

		@Bean("dataSource")
		@Profile("development") // <1>
		fun standaloneDataSource(): DataSource {
			return EmbeddedDatabaseBuilder()
					.setType(EmbeddedDatabaseType.HSQL)
					.addScript("classpath:com/bank/config/sql/schema.sql")
					.addScript("classpath:com/bank/config/sql/test-data.sql")
					.build()
		}

		@Bean("dataSource")
		@Profile("production") // <2>
		fun jndiDataSource() =
			InitialContext().lookup("java:comp/env/jdbc/datasource") as DataSource
	}
----
<1>  `standaloneDataSource`  方法仅在 `development` 环境可用.
<2>  `jndiDataSource`  方法仅在 `production` 环境可用.
--

[NOTE]
====
在 `@Bean` 方法上还添加有 `@Profile` 注解,可能会应用在特殊情况. 在相同 Java 方法名称的重载 `@Bean` 方法(类似于构造函数重载) 的情况下,
需要在所有重载方法上一致声明 `@Profile` 条件,如果条件不一致,则只有重载方法中第一个声明的条件才重要. 因此,`@Profile` 不能用于选择具有特定参数签名的重载方法, 所有工厂方法对相同的 bean 在 Spring 构造器中的解析算法在创建时是相同的.

如果想定义具有不同配置文件条件的备用 bean ,请使用不同的 Java 方法名称,通 XML  bean 定义 profiles 过 `@Bean` 名称属性指向相同的 bean 名称. 如上例所示.  如果参数签名都是相同的(例如,所有的变体都是无参的工厂方法) ,这是安排有效 Java 类放在首要位置的唯一方法(因为只有一个 特定名称和参数签名的方法) .
====


[[beans-definition-profiles-xml]]
====  XML bean 定义profiles
XML 中的 `<beans>` 元素有一个 `profile` 属性,我们之前的示例配置可以在两个XML文件中重写,如下所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans profile="development"
		xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jdbc="http://www.springframework.org/schema/jdbc"
		xsi:schemaLocation="...">

		<jdbc:embedded-database id="dataSource">
			<jdbc:script location="classpath:com/bank/config/sql/schema.sql"/>
			<jdbc:script location="classpath:com/bank/config/sql/test-data.sql"/>
		</jdbc:embedded-database>
	</beans>
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans profile="production"
		xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jee="http://www.springframework.org/schema/jee"
		xsi:schemaLocation="...">

		<jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
	</beans>
----

也可以不用分开 2 个文件,在同一个 XML 中配置 2 个 `<beans/>`,`<beans/>` 元素也有 `profile` 属性. 如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jdbc="http://www.springframework.org/schema/jdbc"
		xmlns:jee="http://www.springframework.org/schema/jee"
		xsi:schemaLocation="...">

		<!-- other bean definitions -->

		<beans profile="development">
			<jdbc:embedded-database id="dataSource">
				<jdbc:script location="classpath:com/bank/config/sql/schema.sql"/>
				<jdbc:script location="classpath:com/bank/config/sql/test-data.sql"/>
			</jdbc:embedded-database>
		</beans>

		<beans profile="production">
			<jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
		</beans>
	</beans>
----

`spring-bean.xsd` 强制允许将 `profile` 元素定义在文件的最后面,这有助于在 XML 文件中提供灵活的方式而又不引起混乱.

[NOTE]
=====

对应 XML 不支持前面描述的 `profile` 表达式.  但是,有可能通过使用 `!` 来否定一个 `profile` 表达式.  也可以通过嵌套 `profiles` 来应用 `"and"` ,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jdbc="http://www.springframework.org/schema/jdbc"
		xmlns:jee="http://www.springframework.org/schema/jee"
		xsi:schemaLocation="...">

		<!-- other bean definitions -->

		<beans profile="production">
			<beans profile="us-east">
				<jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/>
			</beans>
		</beans>
	</beans>
----
在前面的示例中,如果 `production` 和 `us-east` `profiles` 都处于激活状态,则会暴露 `dataSource` bean.
=====


[[beans-definition-profiles-enable]]
==== 激活 Profile
现在已经更新了配置,但仍然需要指定要激活哪个配置文件, 如果我们现在开始我们的示例应用程序, 我们会看到抛出 `NoSuchBeanDefinitionException`,因为容器找不到名为 `dataSource` 的Spring bean.

激活配置文件可以通过多种方式完成,但最直接的方法是以编程方式对可通过 `ApplicationContext` 提供的 `Environment` API 进行操作.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
	ctx.getEnvironment().setActiveProfiles("development");
	ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
	ctx.refresh();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val ctx = AnnotationConfigApplicationContext().apply {
		environment.setActiveProfiles("development")
		register(SomeConfig::class.java, StandaloneDataConfig::class.java, JndiDataConfig::class.java)
		refresh()	
	}
----

此外,配置文件也可以通过 `spring.profiles.active` 属性声明式性地激活,可以通过系统环境变量,JVM系统属性,`web.xml` 中的 Servlet上下文参数指定, 甚至作为JNDI中的一个条目设置(<<beans-property-source-abstraction>>) .
在集成测试中,可以通过 `spring-test` 模块中的 `@ActiveProfiles` 注解来声明 active 配置文件(参见使<<testing.adoc#testcontext-ctx-management-env-profiles,用环境配置文件的上下文配置>>)

配置文件不是 "二选一" 的. 开发者可以一次激活多个配置文件. 使用编程方式,您可以为 `setActiveProfiles()` 方法提供多个配置文件名称,该方法接受 `String...` 变量参数.  以下示例激活多个配置文件:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	ctx.getEnvironment().setActiveProfiles("profile1", "profile2");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	ctx.getEnvironment().setActiveProfiles("profile1", "profile2")
----

声明性地,`spring.profiles.active` 可以接受以逗号分隔的 profile 名列表,如以下示例所示:

[literal,indent=0,subs="verbatim,quotes"]
----
	-Dspring.profiles.active="profile1,profile2"
----


[[beans-definition-profiles-default]]
==== 默认 Profile

default 配置文件表示默认开启的 profile 配置. 考虑以下配置:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@Profile("default")
	public class DefaultDataConfig {

		@Bean
		public DataSource dataSource() {
			return new EmbeddedDatabaseBuilder()
				.setType(EmbeddedDatabaseType.HSQL)
				.addScript("classpath:com/bank/config/sql/schema.sql")
				.build();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@Profile("default")
	class DefaultDataConfig {

		@Bean
		fun dataSource(): DataSource {
			return EmbeddedDatabaseBuilder()
					.setType(EmbeddedDatabaseType.HSQL)
					.addScript("classpath:com/bank/config/sql/schema.sql")
					.build()
		}
	}
----

如果没有配置文件激活,上面的 `dataSource` 就会被创建. 这提供了一种默认的方式,如果有任何一个配置文件启用,default 配置就不会生效.

默认配置文件的名字(default) 可以通过 `Environment` 的 `setDefaultProfiles()` 方法或者 `spring.profiles.default` 属性修改.

[[beans-property-source-abstraction]]
=== `PropertySource` 抽象

Spring的 `Environment` 抽象提供用于一系列的属性配置文件的搜索操作.请考虑以下列表:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	ApplicationContext ctx = new GenericApplicationContext();
	Environment env = ctx.getEnvironment();
	boolean containsMyProperty = env.containsProperty("my-property");
	System.out.println("Does my environment contain the 'my-property' property? " + containsMyProperty);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val ctx = GenericApplicationContext()
	val env = ctx.environment
	val containsMyProperty = env.containsProperty("my-property")
	println("Does my environment contain the 'my-property' property? $containsMyProperty")
----
在上面的代码段中,一个高级别的方法用于访问 Spring 是否为当前环境定义了 `my-property` 属性. 为了回答这个问题,`Environment` 对象对一组 `PropertySource` 对象进行搜索.
{api-spring-framework}/core/env/PropertySource.html[`PropertySource`] 是对任何键值对的简单抽象,Spring 的  {api-spring-framework}/core/env/StandardEnvironment.html[`StandardEnvironment`] 配置有两个 `PropertySource` 对象 ,一个表示JVM系统属性(`System.getProperties()`),一个表示系统环境变量(`System.getenv()`).

NOTE: 这些默认 `property` 源位于 `StandardEnvironment` 中,用于独立应用程序. {api-spring-framework}/web/context/support/StandardServletEnvironment.html[`StandardServletEnvironment`]用默认的 property 配置源填充.
默认配置源包括 Servlet 配置, Servlet 上下文参数和选择启用 {api-spring-framework}/jndi/JndiPropertySource.html[`JndiPropertySource`]. 有关详细信息,请参阅它的 javadocs

具体地说,当您使用 `StandardEnvironment` 时,如果在运行时存在 `my-property` 系统属性或 `my-property` 环境变量,则对 `env.containsProperty("my-property")` 的调用将返回 `true`.

[TIP]
====
执行的搜索是分层的. 默认情况下,系统属性优先于环境变量,因此如果在调用 `env.getProperty("my-property")` 期间碰巧在两个位置都设置了 `my-property` 属性, 系统属性值返回优先于环境变量.  请注意,属性值未合并,而是由前面的条目完全覆盖.

对于常见的 `StandardServletEnvironment`,完整层次结构如下,最高优先级条目位于顶部:

. ServletConfig参数(如果适用 - 例如,在 DispatcherServlet 上下文的情况下)
. ServletContext参数(`web.xml` context-param 条目)
. JNDI 环境变量(`java:comp/env/` entries)
. JVM 系统属性(`-D` 命令行参数)
. JVM 系统环境(操作系统环境变量)
====
最重要的是,整个机制都是可配置的. 也许开发者需要一个自定义的 properties 源,并将该源整合到这个检索层级中. 为此,请实现并实例化您自己的 `PropertySource`,并将其添加到当前 `Environment` 的 `PropertySource` 集合中.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
ConfigurableApplicationContext ctx = new GenericApplicationContext();
MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
sources.addFirst(new MyPropertySource());
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val ctx = GenericApplicationContext()
	val sources = ctx.environment.propertySources
	sources.addFirst(MyPropertySource())
----
在上面的代码中, `MyPropertySource` 在搜索中添加了最高优先级. 如果它包含 `my-property` 属性,则会检测并返回该属性, 优先于其他 `PropertySource` 中的任何 `my-property` 属性.
{api-spring-framework}/core/env/MutablePropertySources.html[`MutablePropertySources`] API 暴露了许多方法,允许你显式操作 property 属性源.

[[beans-using-propertysource]]
=== 使用 `@PropertySource`

{api-spring-framework}/context/annotation/PropertySource.html[`@PropertySource`] 注解提供了便捷的方式,用于增加 `PropertySource` 到Spring的 `Environment` 中.

给定一个名为 `app.properties` 的文件,其中包含键值对 `testbean.name=myTestBean`, 以下 `@Configuration` 类使用 `@PropertySource`,以便调用 `testBean.getName()` 返回 myTestBean:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
   @Configuration
   @PropertySource("classpath:/com/myco/app.properties")
   public class AppConfig {

	   @Autowired
	   Environment env;

	   @Bean
	   public TestBean testBean() {
		   TestBean testBean = new TestBean();
		   testBean.setName(env.getProperty("testbean.name"));
		   return testBean;
	   }
   }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@PropertySource("classpath:/com/myco/app.properties")
	class AppConfig {

		@Autowired
		private lateinit var env: Environment

		@Bean
		fun testBean() = TestBean().apply {
			name = env.getProperty("testbean.name")!!
		}
	}
----
任何的存在于 `@PropertySource` 中的  `${...}` 占位符,将会被解析为定义在环境中的属性配置文件中的属性值.  如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
   @Configuration
   @PropertySource("classpath:/com/${my.placeholder:default/path}/app.properties")
   public class AppConfig {

	   @Autowired
	   Environment env;

	   @Bean
	   public TestBean testBean() {
		   TestBean testBean = new TestBean();
		   testBean.setName(env.getProperty("testbean.name"));
		   return testBean;
	   }
   }
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@PropertySource("classpath:/com/\${my.placeholder:default/path}/app.properties")
	class AppConfig {

		@Autowired
		private lateinit var env: Environment

		@Bean
		fun testBean() = TestBean().apply {
			name = env.getProperty("testbean.name")!!
		}
	}
----

假设 `my.placeholder` 存在于已注册的其中一个属性源中(例如,系统属性或环境变量) ,则占位符将解析为相应的值.  如果不是,则 `default/path` 用作默认值.  如果未指定默认值且无法解析属性,则抛出 `IllegalArgumentException`.

NOTE: 根据Java 8惯例,`@PropertySource` 注解是可重复的.  但是,所有这些 `@PropertySource` 注解都需要在同一级别声明,可以直接在配置类上声明, 也可以在同一自定义注解中作为元注解声明.  不建议混合直接注解和元注解,因为直接注解有效地覆盖了元注解.

[[beans-placeholder-resolution-in-statements]]
=== 在声明中的占位符

之前,元素中占位符的值只能针对 JVM 系统属性或环境变量进行解析. 现在已经打破了这种情况. 因为环境抽象集成在整个容器中,所以很容易通过它来对占位符进行解析. 这意味着开发者可以以任何喜欢的方式来配置这个解析过程,可以改变是优先查找系统 properties 或者是有限查找环境变量,或者删除它们; 增加自定义 property 源,使之成为更合适的配置

具体而言,只要在 `Environment` 中可用,无论 `customer` 属性在何处定义,以下语句都可以工作:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<import resource="com/bank/service/${customer}-config.xml"/>
	</beans>
----




[[context-load-time-weaver]]
== 注册 `LoadTimeWeaver`

`LoadTimeWeaver` 被 Spring 用来在将类加载到 Java 虚拟机(JVM) 中时动态地转换成 字节码 文件

若要开启加载时织入,要在 `@Configuration` 类中增加 `@EnableLoadTimeWeaving` 注解,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableLoadTimeWeaving
	public class AppConfig {
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableLoadTimeWeaving
	class AppConfig
----

或者,对于 XML 配置,您可以使用 `context:load-time-weaver` 元素:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<context:load-time-weaver/>
	</beans>
----

一旦配置为 `ApplicationContext`,该 `ApplicationContext` 中的任何 bean 都可以实现 `LoadTimeWeaverAware`,从而接收对 load-time weaver 实例的引用.  这特别适用于 <<data-access.adoc#orm-jpa, Spring 对 JPA 支持>>.
其中 JPA 类转换可能需要加载时织入.  有关更多详细信息,请参阅 {api-spring-framework}/orm/jpa/LocalContainerEntityManagerFactoryBean.html[`LocalContainerEntityManagerFactoryBean`].  有关 AspectJ 加载时编织的更多信息,请参阅<<aop-aj-ltw>>.

[[context-introduction]]
==  `ApplicationContext` 的附加功能
正如 <<beans, 前面章节中讨论>>的,`org.springframework.beans.factory` 包提供了管理和操作 bean 的基本功能,包括以编程方式.  `org.springframework.context` 包添加了 `ApplicationContext` 接口,该接口扩展了 `BeanFactory` 接口,此外还扩展了其他接口,
以更面向应用程序框架的方式提供其他功能.  许多人以完全声明的方式使用 {api-spring-framework}/context/ApplicationContext.html[`ApplicationContext`], 甚至不以编程方式创建它,而是依赖于诸如 `ContextLoader` 之类的支持类来自动实例化 `ApplicationContext`,作为 Jakarta EE Web 应用程序的正常启动过程的一部分.

为了增强 `BeanFactory` 的功能,上下文包还提供了以下功能.

* 通过 `MessageSource` 接口访问 i18n 风格的消息.
* 通过 `ResourceLoader` 接口访问 URL 和文件等资源.
* 事件发布,即通过使用 `ApplicationEventPublishe` r接口实现 `ApplicationListener` 接口的 bean .
* 通过 `HierarchicalBeanFactory` 接口,加载多级 contexts,允许关注某一层级 context,比如应用的 Web 层.

[[context-functionality-messagesource]]
=== 使用 `MessageSource` 实现国际化

`ApplicationContext` 接口扩展了一个名为 `MessageSource` 的接口,因此提供了国际化("`i18n`")功能.  Spring还提供了 `HierarchicalMessageSource` 接口,该接口可以分层次地解析消息.  这些接口共同提供了Spring影响消息解析的基础.  这些接口上定义的方法包括:

* `String getMessage(String code, Object[] args, String default, Locale loc)`: 用于从 `MessageSource` 检索消息的基本方法.  如果未找到指定区域设置的消息,则使用默认消息.  传入的任何参数都使用标准库提供的 `MessageFormat` 功能成为替换值.
* `String getMessage(String code, Object[] args, Locale loc)`: 基本上与前一个方法相同,但有一个区别: 不能指定默认消息.  如果找不到该消息,则抛出 `NoSuchMessageException` .
* `String getMessage(MessageSourceResolvable resolvable, Locale locale)`: 前面方法中使用的所有属性也包装在名为 `MessageSourceResolvable` 的类中,您可以将此方法用于此类.

当一个 `ApplicationContext` 被加载时,它会自动搜索在上下文中定义的一个 `MessageSource`, bean 必须包含名称 `messageSource`,如果找到这样的 bean  则将对前面方法的所有调用委派给消息源. 如果没有找到消息源,`ApplicationContext` 会尝试找到一个包含同名 bean 的父对象. 如果有,它使用那个 bean 作为 `MessageSource`.  如果 `ApplicationContext` 找不到消息的任何源,则会实例化空的 `DelegatingMessageSource`,以便能够接受对上面定义的方法的调用.

Spring 提供了三个 `MessageSource` 实现, `ResourceBundleMessageSource`, `ReloadableResourceBundleMessageSource` 和 `StaticMessageSource`,为了做嵌套消息三者都实现了 `HierarchicalMessageSource`.  `StaticMessageSource` 很少使用,但提供了以编程方式向源添加消息.  以下示例显示了 `ResourceBundleMessageSource`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="messageSource"
				class="org.springframework.context.support.ResourceBundleMessageSource">
			<property name="basenames">
				<list>
					<value>format</value>
					<value>exceptions</value>
					<value>windows</value>
				</list>
			</property>
		</bean>
	</beans>
----

该示例假定您在类路径中定义了三个资源包,`format`, `exceptions` 和 `windows`. 任何解析消息的请求都将以标准 JDK 方式处理, 通过 `ResourceBundle` 解析消息. 出于示例的目的,假设上述两个资源包文件的内容如下:

[source,properties,indent=0,subs="verbatim,quotes"]
----
	# in format.properties
	message=Alligators rock!
----

[source,properties,indent=0,subs="verbatim,quotes"]
----
	# in exceptions.properties
	argument.required=The {0} argument is required.
----

下一个示例显示了执行 `MessageSource` 功能的程序.  请记住,所有 `ApplicationContext` 实现也都是 `MessageSource` 实现,因此可以强制转换为 `MessageSource` 接口.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(String[] args) {
		MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
		String message = resources.getMessage("message", null, "Default", Locale.ENGLISH);
		System.out.println(message);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun main() {
		val resources = ClassPathXmlApplicationContext("beans.xml")
		val message = resources.getMessage("message", null, "Default", Locale.ENGLISH)
		println(message)
	}
----

上述程序产生的结果如下:

[literal,subs="verbatim,quotes"]
----
Alligators rock!
----

总而言之,`MessageSource` 在名为 `beans.xml` 的文件中定义,该文件存在于类路径的根目录中. `messageSourcebean` 定义通过其 `basenames` 属性引用许多资源包.
在列表中传递给 `basenames` 属性的三个文件作为类路径根目录下的文件存在,分别称为 `format`.`properties`, `exceptions.properties` 和 `windows.properties`.

下一个示例显示传递给消息查询的参数,这些参数将被转换为 `String` 并插入查找消息中的占位符.

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>

		<!-- this MessageSource is being used in a web application -->
		<bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
			<property name="basename" value="exceptions"/>
		</bean>

		<!-- lets inject the above MessageSource into this POJO -->
		<bean id="example" class="com.something.Example">
			<property name="messages" ref="messageSource"/>
		</bean>

	</beans>
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class Example {

		private MessageSource messages;

		public void setMessages(MessageSource messages) {
			this.messages = messages;
		}

		public void execute() {
			String message = this.messages.getMessage("argument.required",
				new Object [] {"userDao"}, "Required", Locale.ENGLISH);
			System.out.println(message);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class Example {

	lateinit var messages: MessageSource

	fun execute() {
		val message = messages.getMessage("argument.required",
				arrayOf("userDao"), "Required", Locale.ENGLISH)
		println(message)
	}
}
----

调用 `execute()` 方法得到的结果如下:

[literal,subs="verbatim,quotes"]
----
The userDao argument is required.
----

关于国际化 ("`i18n`"),Spring 的各种 `MessageSource` 实现遵循与标准 JDK `ResourceBundle` 相同的区域设置解析和回退规则.
简而言之,继续前面定义的示例 `messageSource`,如果要根据 British(`en-GB`)语言环境解析消息,则应分别创建名为 `format_en_GB.properties`,`exceptions_en_GB.properties` 和 `windows_en_GB.properties` 的文件.

通常,区域设置解析由应用程序的环境配置管理. 在以下示例中,手动指定解析(英国) 消息的区域设置:

[literal,subs="verbatim,quotes"]
----
# in exceptions_en_GB.properties
argument.required=Ebagum lad, the ''{0}'' argument is required, I say, required.
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public static void main(final String[] args) {
		MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
		String message = resources.getMessage("argument.required",
			new Object [] {"userDao"}, "Required", Locale.UK);
		System.out.println(message);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun main() {
		val resources = ClassPathXmlApplicationContext("beans.xml")
		val message = resources.getMessage("argument.required",
				arrayOf("userDao"), "Required", Locale.UK)
		println(message)
	}
----

运行上述程序产生的结果如下:

[literal,subs="verbatim,quotes"]
----
Ebagum lad, the 'userDao' argument is required, I say, required.
----

您还可以使用 `MessageSourceAware` 接口获取对已定义的任何 `MessageSource` 的引用.  在创建和配置 bean 时,应用程序上下文的 `MessageSource` 会注入实现 `MessageSourceAware` 接口的 `ApplicationContext` 中定义的任何 bean .

NOTE: 因为 Spring 的 `MessageSource` 是基于 Java 的 `ResourceBundle` 的，所以没有合并具有相同名称的捆绑包，但只会使用找到的第一个捆绑包。
后面具有相同名称的包将被忽略。

NOTE:: 作为 `ResourceBundleMessageSource` 的替代,Spring 提供了一个 `ReloadableResourceBundleMessageSource` 类.  此变体支持相同的 bundle 文件格式,但比基于标准 JDK 的 `ResourceBundleMessageSource` 实现更灵活.
特别是,它允许从任何 Spring 资源位置(不仅从类路径) 读取文件,并支持 bundle 属性文件的热重新加载(同时在其间有效地缓存它们) .  有关详细信息,请参阅 {api-spring-framework}/context/support/ReloadableResourceBundleMessageSource.html[`ReloadableResourceBundleMessageSource`] javadoc.

[[context-functionality-events]]
=== 标准和自定义事件

`ApplicationContext` 中的事件处理是通过 `ApplicationEvent` 类和 `ApplicationListener` 接口提供的. 如果将实现 `ApplicationListener` 接口的 bean 部署到上下文中,则每次将 `ApplicationEvent` 发布到 `ApplicationContext` 时,都会通知该 bean .  从本质上讲,这是标准的 Observer 设计模式.

TIP: 从 Spring 4.2 开始,事件架构已经得到显着改进,并提供了一个<<context-functionality-events-annotation, 基于注解的模型>> 使其有发布任意事件的能力(即,不一定从 `ApplicationEvent` 扩展的对象)  . 当发布这样的对象时,我们将它包装在一个事件中.

下表描述了 Spring 提供的标准事件:

[[beans-ctx-events-tbl]]
.Built-in Events
[cols="30%,70%"]
|===
| 事件| 	说明

| `ContextRefreshedEvent`
| 初始化或刷新 `ApplicationContext` 时发布(例如,通过使用 `ConfigurableApplicationContext` 接口上的 `refresh()` 方法) .  这里, "`initialized`" 意味着加载所有 bean ,检测并激活 bean 的后置处理器,预先实例化单例,并且可以使用 `ApplicationContext` 对象.
  只要上下文尚未关闭,只要所选的 `ApplicationContext` 实际支持这种 "热" 刷新,就可以多次触发刷新.  例如,`XmlWebApplicationContext` 支持热刷新,但 `GenericApplicationContext` 不支持.

| `ContextStartedEvent`
| 通过使用 `ConfigurableApplicationContext` 接口上的 `start()` 方法启动 `ApplicationContext` 时发布.  通常,此信号用于在显式停止后重新启动 bean ,但它也可用于启动尚未为自动启动配置的组件(例如,在初始化时尚未启动的组件) .

| `ContextStoppedEvent`
| 通过使用 `ConfigurableApplicationContext` 接口上的 `close()` 方法停止 `ApplicationContext` 时发布.  这里, "`stopped`" 表示所有生命周期 bean 都会收到明确的停止信号.  可以通过 `start()` 调用重新启动已停止的上下文.

| `ContextClosedEvent`
| 通过使用 `ConfigurableApplicationContext` 接口上的 `close()` 方法关闭 `ApplicationContext` 时发布.  这里,   "closed"  意味着所有单例 bean 都被销毁.  封闭的环境达到其寿命终结.  它无法刷新或重新启动.

| `RequestHandledEvent`
| 一个特定于Web的事件,告诉所有 bean 已经为 HTTP 请求提供服务.  请求完成后发布此事件.  此事件仅适用于使用 Spring 的 DispatcherServlet 的 Web 应用程序.

| `ServletRequestHandledEvent`
| `RequestHandledEvent` 的子类,添加了特定于 Servlet 的上下文信息.

|===

您还可以创建和发布自己的自定义事件.  以下示例显示了一个扩展 Spring 的 `ApplicationEvent` 基类的简单类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class BlockedListEvent extends ApplicationEvent {

		private final String address;
		private final String content;

		public BlockedListEvent(Object source, String address, String content) {
			super(source);
			this.address = address;
			this.content = content;
		}

		// accessor and other methods...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class BlockedListEvent(source: Any,
						val address: String,
						val content: String) : ApplicationEvent(source)
----

要发布自定义 `ApplicationEvent`,请在 `ApplicationEventPublisher` 上调用 `publishEvent()` 方法.  通常,这是通过创建一个实现 `ApplicationEventPublisherAware` 并将其注册为 Spring  bean 的类来完成的.  以下示例显示了这样一个类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class EmailService implements ApplicationEventPublisherAware {

		private List<String> blockedList;
		private ApplicationEventPublisher publisher;

		public void setBlockedList(List<String> blockedList) {
			this.blockedList = blockedList;
		}

		public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
			this.publisher = publisher;
		}

		public void sendEmail(String address, String content) {
			if (blockedList.contains(address)) {
				publisher.publishEvent(new BlockedListEvent(this, address, content));
				return;
			}
			// send email...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class EmailService : ApplicationEventPublisherAware {

		private lateinit var blockedList: List<String>
		private lateinit var publisher: ApplicationEventPublisher

		fun setBlockedList(blockedList: List<String>) {
			this.blockedList = blockedList
		}

		override fun setApplicationEventPublisher(publisher: ApplicationEventPublisher) {
			this.publisher = publisher
		}

		fun sendEmail(address: String, content: String) {
			if (blockedList!!.contains(address)) {
				publisher!!.publishEvent(BlockedListEvent(this, address, content))
				return
			}
			// send email...
		}
	}
----

在配置时,Spring 容器检测到 `EmailService` 实现 `ApplicationEventPublisherAware` 并自动调用 `setApplicationEventPublisher()`.  实际上,传入的参数是 Spring 容器本身.  您正在通过其 `ApplicationEventPublisher` 接口与应用程序上下文进行交互.

要接收自定义 `ApplicationEvent`,您可以创建一个实现 `ApplicationListener` 的类并将其注册为 Spring bean.  以下示例显示了这样一个类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class BlockedListNotifier implements ApplicationListener<BlockedListEvent> {

		private String notificationAddress;

		public void setNotificationAddress(String notificationAddress) {
			this.notificationAddress = notificationAddress;
		}

		public void onApplicationEvent(BlockedListEvent event) {
			// notify appropriate parties via notificationAddress...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class BlockedListNotifier : ApplicationListener<BlockedListEvent> {

		lateinit var notificationAddres: String

		override fun onApplicationEvent(event: BlockedListEvent) {
			// notify appropriate parties via notificationAddress...
		}
	}
----
请注意,`ApplicationListener` 通常使用自定义事件的类型进行参数化(前面示例中为 `BlockedListEvent`) . 这意味着 `onApplicationEvent()` 方法可以保持类型安全,从而避免任何向下转换的需要.  您可以根据需要注册任意数量的事件监听器,但请注意,默认情况下,事件监听器会同步接收事件.
这意味着 `publishEvent()` 方法将阻塞,直到所有监听器都已完成对事件的处理.  这种同步和单线程方法的一个优点是,当监听器接收到事件时,如果事务上下文可用,它将在发布者的事务上下文内运行. 如果需要另一个事件发布策略,
请参阅 Spring 的 {api-spring-framework}/context/event/ApplicationEventMulticaster.html[`ApplicationEventMulticaster`] 和 {api-spring-framework}/context/event/SimpleApplicationEventMulticaster.html[`SimpleApplicationEventMulticaster`] javadoc 的实现

以下示例显示了用于注册和配置上述每个类的 bean 定义:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="emailService" class="example.EmailService">
		<property name="blockedList">
			<list>
				<value>known.spammer@example.org</value>
				<value>known.hacker@example.org</value>
				<value>john.doe@example.org</value>
			</list>
		</property>
	</bean>

	<bean id="blockedListNotifier" class="example.BlockedListNotifier">
		<property name="notificationAddress" value="blockedlist@example.org"/>
	</bean>
----

总而言之,当调用 `emailService` bean 的 `sendEmail()` 方法时,如果有任何应列入 blocked 的电子邮件消息,则会发布 `BlockedListEvent` 类型的自定义事件.  `blockedListNotifier` bean 注册为 `ApplicationListener` 并接收 `BlockedListEvent` ,此时它可以通知相关方.

NOTE: Spring 的事件机制是为在同一应用程序上下文中的 Spring bean 之间的简单通信而设计的. 但是,对于更复杂的企业集成需求,单独维护的 https://projects.spring.io/spring-integration/[Spring Integration] 项目提供了完整的支持并可用于构建轻量级, https://www.enterpriseintegrationpatterns.com[pattern-oriented](面向模式) ,依赖 Spring 编程模型的事件驱动架构.


[[context-functionality-events-annotation]]
==== 基于注解的事件监听器

从 Spring 4.2 开始,您可以使用 `@EventListener` 注解在托管 bean 的任何 public 方法上注册事件监听器.  `BlockedListNotifier` 可以重写如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class BlockedListNotifier {

		private String notificationAddress;

		public void setNotificationAddress(String notificationAddress) {
			this.notificationAddress = notificationAddress;
		}

		@EventListener
		public void processBlockedListEvent(BlockedListEvent event) {
			// notify appropriate parties via notificationAddress...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class BlockedListNotifier {

		lateinit var notificationAddress: String

		@EventListener
		fun processBlockedListEvent(event: BlockedListEvent) {
			// notify appropriate parties via notificationAddress...
		}
	}
----

方法参数为它监听的事件类型,但这次使用灵活的名称并且没有实现特定的监听器接口. 只要实际事件类型在其实现层次结构中解析通用参数,也可以通过泛型缩小事件类型.

如果您的方法应该监听多个事件,或者您想要根据任何参数进行定义,那么也可以在注解本身上指定事件类型.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})
	public void handleContextStart() {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@EventListener(ContextStartedEvent::class, ContextRefreshedEvent::class)
	fun handleContextStart() {
		// ...
	}
----

还可以通过使用定义 <<expressions, `SpEL` 表达式>>的注解的 condition 属性来添加额外的运行时过滤,该表达式应匹配以实际调用特定事件的方法.

以下示例显示了仅当事件的 `content` 属性等于 `my-event` 时才能重写我们的通知程序以进行调用:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@EventListener(condition = "#blEvent.content == 'my-event'")
	public void processBlockedListEvent(BlockedListEvent blockedListEvent) {
		// notify appropriate parties via notificationAddress...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@EventListener(condition = "#blEvent.content == 'my-event'")
	fun processBlockedListEvent(blockedListEvent: BlockedListEvent) {
		// notify appropriate parties via notificationAddress...
	}
----

每个 `SpEL` 表达式都针对专用上下文进行评估.  下表列出了可用于上下文的项目,以便您可以将它们用于条件事件处理:

[[context-functionality-events-annotation-tbl]]
. 事件 SpEL 可用的元数据
|===
| 名字| 位置| 描述| 例子

| Event
| root object
| 真实的 `ApplicationEvent`.
| `#root.event` or `event`

| Arguments array
| root object
| 用于调用目标的参数(作为数组)
| `#root.args` or `args`; `args[0]` to access the first argument, etc.

| __Argument name__
| evaluation context
| 任何方法参数的名称.  如果由于某种原因,名称不可用(例如,因为没有调试信息) ,参数名称也可以在 `#a<#arg>` 下获得,其中 `#arg` 代表参数索引(从 `0` 开始)
| `#blEvent` 或 `#a0` (你也可以使用 `#p0` 或 `#p<#arg>` 参数作为别名)
|===

请注意,即使您的方法签名实际引用已发布的任意对象,`#root.event` 也允许您访问基础事件.

如果需要发布一个事件作为处理另一个事件的结果,则可以更改方法签名以返回应发布的事件,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@EventListener
	public ListUpdateEvent handleBlockedListEvent(BlockedListEvent event) {
		// notify appropriate parties via notificationAddress and
		// then publish a ListUpdateEvent...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@EventListener
	fun handleBlockedListEvent(event: BlockedListEvent): ListUpdateEvent {
		// notify appropriate parties via notificationAddress and
		// then publish a ListUpdateEvent...
	}
----

NOTE: <<context-functionality-events-async, 异步监听器>>不支持此功能.

这将通过 `handleBlockedListEvent` 方法处理每个 `BlockedListEvent` 并发布一个新的 `ListUpdateEvent`,如果需要发布多个 `Collection` ,则可以返回事件 集合.


[[context-functionality-events-async]]
==== 异步的监听器

如果希望特定监听器异步处理事件,则可以使用<<integration.adoc#scheduling-annotation-support-async, 常规 `@Async` 支持>>..  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@EventListener
	@Async
	public void processBlockedListEvent(BlockedListEvent event) {
		// BlockedListEvent is processed in a separate thread
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@EventListener
	@Async
	fun processBlockedListEvent(event: BlockedListEvent) {
		// BlockedListEvent is processed in a separate thread
	}
----

使用异步事件时请注意以下限制:

* 如果事件监听器抛出 `Exception`,则不会将其传播给调用者. 有关更多详细信息,请参阅 {api-spring-framework}/aop/interceptor/AsyncUncaughtExceptionHandler.html[`AsyncUncaughtExceptionHandler`].
* 此类事件监听器无法发送回复.  如果您需要作为处理结果发送另一个事件,请注入  {api-spring-framework}/context/ApplicationEventPublisher.html[`ApplicationEventPublisher`] 以手动发送事件.


[[context-functionality-events-order]]
==== 监听器的排序

如果需要在另一个监听器之前调用一个监听器,则可以将 `@Order` 注解添加到方法声明中,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@EventListener
	@Order(42)
	public void processBlockedListEvent(BlockedListEvent event) {
		// notify appropriate parties via notificationAddress...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@EventListener
	@Order(42)
	fun processBlockedListEvent(event: BlockedListEvent) {
		// notify appropriate parties via notificationAddress...
	}
----


[[context-functionality-events-generics]]
==== 泛型事件

您还可以使用泛型来进一步定义事件的结构.  考虑使用 `EntityCreatedEvent<T>`,其中 `T` 是创建的实际实体的类型.  例如,您可以创建以下监听器定义以仅接收 `Person` 的 `EntityCreatedEvent`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@EventListener
	public void onPersonCreated(EntityCreatedEvent<Person> event) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@EventListener
	fun onPersonCreated(event: EntityCreatedEvent<Person>) {
		// ...
	}
----

由于泛型擦除,只有此事件符合事件监听器所过滤的通用参数条件那么才会触发相应的处理事件(有点类似于 `class PersonCreatedEvent extends EntityCreatedEvent<Person> { ... }`)

在某些情况下,如果所有事件遵循相同的结构(如上述事件的情况) ,这可能变得相当乏味. 在这种情况下,开发者可以实现 `ResolvableTypeProvider` 来引导框架超出所提供的运行时环境范围.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class EntityCreatedEvent<T> extends ApplicationEvent implements ResolvableTypeProvider {

		public EntityCreatedEvent(T entity) {
			super(entity);
		}

		@Override
		public ResolvableType getResolvableType() {
			return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class EntityCreatedEvent<T>(entity: T) : ApplicationEvent(entity), ResolvableTypeProvider {

		override fun getResolvableType(): ResolvableType? {
			return ResolvableType.forClassWithGenerics(javaClass, ResolvableType.forInstance(getSource()))
		}
	}
----

TIP: 这不仅适用于 `ApplicationEvent` ,也适用于作为事件发送的任意对象.

[[context-functionality-resources]]
=== 通过便捷的方式访问底层资源

为了最佳地使用和理解应用程序上下文,您应该熟悉 Spring 的抽象 `Resource` ,如参考资料中所述<<resources>>.

应用程序上下文是 `ResourceLoader`,可用于加载 `Resource` 对象.  `Resource` 本质上是 JDK `java.net.URL` 类的功能更丰富的版本. 实际上 `Resource` 的实现类中大多含有 `java.net.URL` 的实例.
 `Resource` 几乎能从任何地方透明的获取底层资源,可以是 `classpath` 类路径、文件系统、标准的 URL 资源及变种 URL 资源. 如果资源定位字串是简单的路径, 没有任何特殊前缀,就适合于实际应用上下文类型.

可以配置一个 bean 部署到应用上下文中,用以实现特殊的回调接口,`ResourceLoaderAware` 它会在初始化期间自动回调. 应用程序上下文本身作为 `ResourceLoader` 传入. 可以暴露 `Resource` 的 `type` 属性,这样就可以访问静态资源 静态资源可以像其他 `properties` 那样被注入 `Resource`.
可以使用简单的字串路径指定资源,这需要依赖于特殊的 JavaBean `PropertyEditor`(由上下文自动注册) ,当 bean 部署时候它将转换资源中的字串为实际的资源对象.

提供给 `ApplicationContext` 构造函数的一个或多个位置路径实际上是资源字符串,并且以简单形式对特定上下文实现进行适当处理.  `ClassPathXmlApplicationContext` 将一个简单的定位路径视为类路径位置. 开发者还可以使用带有特殊前缀的定位路径,这样就可以强制从 `classpath` 或者 `URL` 定义加载路径, 而不用考虑实际的上下文类型.

[[context-functionality-startup]]
=== 应用程序启动跟踪

`ApplicationContext` 管理 Spring 应用程序的生命周期， 并提供丰富的编程模型.因此， 复杂的应用程序可以同时拥有
复杂的组件依赖和启动阶段.

使用特定指标跟踪应用程序的启动步骤可以帮助您了解在启动阶段的那块花了一些时间， 它也是了解整体上下文生命周期更好的方法.

`AbstractApplicationContext` (及其子类)配有一个 `ApplicationStartup`， 它收集有关各个启动阶段的 `StartupStep` 数据:

* 应用程序上下文生命周期(基本软件包扫描， 配置类管理)
* bean生命周期 (instantiation, smart initialization, post processing)
* 应用程序事件处理

这是 `AnnotationConfigApplicationContext` 中的检测示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// create a startup step and start recording
	StartupStep scanPackages = this.getApplicationStartup().start("spring.context.base-packages.scan");
	// add tagging information to the current step
	scanPackages.tag("packages", () -> Arrays.toString(basePackages));
	// perform the actual phase we're instrumenting
	this.scanner.scan(basePackages);
	// end the current step
	scanPackages.end();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// create a startup step and start recording
	val scanPackages = this.getApplicationStartup().start("spring.context.base-packages.scan")
	// add tagging information to the current step
	scanPackages.tag("packages", () -> Arrays.toString(basePackages))
	// perform the actual phase we're instrumenting
	this.scanner.scan(basePackages)
	// end the current step
	scanPackages.end()
----

应用程序上下文已经通过多个步骤进行了检测. 记录后， 可以使用特定工具收集， 显示和分析这些启动步骤.
有关现有启动步骤的完整列表， 您可以查看 <<core.appendix.application-startup-steps, 此部分>>.

默认的 `ApplicationStartup`  实现没有做任何操作.这意味着默认情况下， 在应用程序启动期间不会收集任何指标.
Spring Framework 附带了一个用于使用 Java Flight Recorder 跟踪启动步骤的实现:
`FlightRecorderApplicationStartup`. 要使用此实现， 必须配置它的一个实例,创建后立即添加到 `ApplicationContext`.

如果开发人员提供自己的应用程序， 那么他们也可以使用 `ApplicationStartup` 基础结构 `AbstractApplicationContext` 子类， 或者如果他们希望收集更精确的数据.

WARNING: `ApplicationStartup` 只能在应用程序启动期间使用， 用于核心容器；这绝不是 Java  profilers 的替代品， 也不是
metrics libraries， 例如 https://micrometer.io[Micrometer].

要开始收集自定义的 `StartupStep`， 组件可以获取 `ApplicationStartup` 直接从应用程序上下文实例， 使其组件实现 `ApplicationStartupAware`，  或在任何注入点上请求 `ApplicationStartup` 类型.

NOTE: 创建自定义启动步骤时， 开发人员不应使用 `"spring.*"` 命名空间,该名称空间保留给 Spring 内部使用， 并且可能会发生变化.

[[context-create]]
=== 快速对 Web 应用的 ApplicationContext 实例化

开发者可以通过使用 `ContextLoader` 来声明性地创建 `ApplicationContext` 实例,当然也可以通过使用 `ApplicationContext` 的实现来编程实现 `ApplicationContext`.

您可以使用 `ContextLoaderListener` 注册 `ApplicationContext` ,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml</param-value>
	</context-param>

	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>
----

监听器检查 `contextConfigLocation` 参数.  如果参数不存在,则监听器将 `/WEB-INF/applicationContext.xml` 用作默认值.  当参数确实存在时,监听器使用预定义的分隔符(逗号,分号和空格) 分隔 String,并将值用作搜索应用程序上下文的位置.
还支持 Ant 样式的路径模式.  示例是 `/WEB-INF/{asterisk}Context.xml`(对于所有名称以 `Context.xml` 结尾且位于 `WEB-INF` 目录中的文件) 和 `/WEB-INF/**/*Context.xml` (对于所有这样的文件)  `WEB-INF` 的任何子目录中的文件.

[[context-deploy-rar]]
=== 使用 Jakarta EE RAR 文件部署 Spring 的 `ApplicationContext`

可以将 Spring `ApplicationContext` 部署为 RAR 文件,将上下文及其所有必需的 bean 类和库 JAR 封装在 Jakarta EE RAR 部署单元中,这相当于引导一个独立的 `ApplicationContext`.  只是托管在 Jakarta EE 环境中,能够访问 Jakarta EE 服务器设施. 在部署无头 WAR 文件(实际上,没有任何 HTTP 入口点,仅用于在 Jakarta EE 环境中引导 Spring `ApplicationContext` 的 WAR 文件) 的情况下 RAR 部署是更自然的替代方案

RAR 部署非常适合不需要 HTTP 入口点但仅由消息端点和调度作业组成的应用程序上下文. 在这种情况下,Bean 可以使用应用程序服务器资源, 例如 JTA 事务管理器和 JNDI 绑定的 JDBC `DataSource` 和 JMS `ConnectionFactory` 实例,
并且还可以通过 Spring 的标准事务管理和 JNDI 和 JMX 支持设施向平台的JMX服务器注册.  应用程序组件还可以通过 Spring 的 `TaskExecutor` 抽象实现与应用程序服务器的 JCA `WorkManager` 交互

有关 RAR 部署中涉及的配置详细信息,请参阅 {api-spring-framework}/jca/context/SpringContextResourceAdapter.html[`SpringContextResourceAdapter`] 类的javadoc

对于将 Spring ApplicationContext 简单部署为 Jakarta EE RAR 文件:

. 将所有应用程序类打包到一个 RAR 文件(这是一个具有不同文件扩展名的标准JAR文件) .  .
. 将所有必需的库 JAR 添加到 RAR 存档的根目录中.
. 添加 `META-INF/ra.xml` 部署描述符 (如 {api-spring-framework}/jca/context/SpringContextResourceAdapter.html[`SpringContextResourceAdapter` 的 javadoc 所示])  和相应的 Spring XML bean 定义文件(通常是 `META-INF/applicationContext.xml`) .
. 将生成的RAR文件放入应用程序服务器的部署目录中.

NOTE: 这种 RAR 部署单元通常是独立的. 它们不会将组件暴露给外部世界,甚至不会暴露给同一应用程序的其他模块.  与基于 RAR 的 `ApplicationContext` 的交互通常通过与其他模块共享的 JMS 目标进行.  例如,基于 RAR 的 `ApplicationContext` 还可以调度一些作业或对文件系统(等等) 中的新文件作出响应.  如果它需要允许来自外部的同步访问,它可以(例如) 导出RMI端点,这可以由同一台机器上的其他应用程序模块使用.

[[beans-beanfactory]]
== `BeanFactory` API

`BeanFactory` API为 Spring 的 IoC 功能提供了基础.  它的特定契约主要用于与 Spring 的其他部分和相关的第三方框架集成其 `DefaultListableBeanFactory` 实现是更高级别 `GenericApplicationContext` 容器中的密钥委托.

`BeanFactory` 和相关接口(例如 `BeanFactoryAware`, `InitializingBean`,`DisposableBean`) 是其他框架组件的重要集成点.  通过不需要任何注解或甚至反射,它们允许容器与其组件之间的非常有效的交互.  应用程序级 bean 可以使用相同的回调接口,但通常更喜欢通过注解或通过编程配置进行声明性依赖注入.

请注意,核心 `BeanFactory` API 级别及其 `DefaultListableBeanFactory` 实现不会对配置格式或要使用的任何组件注解做出假设.  所有这些风格都通过扩展(例如 `XmlBeanDefinitionReader` 和 `AutowiredAnnotationBeanPostProcessor`) 进行,并作为核心元数据表示在共享 `BeanDefinition` 对象上运行.  这是使 Spring 的容器如此灵活和可扩展的本质.



[[context-introduction-ctx-vs-beanfactory]]
=== 选择 `BeanFactory` 还是 `ApplicationContext`?

本节介绍 `BeanFactory` 和 `ApplicationContext` 容器级别之间的差异以及影响.

您应该使用 `ApplicationContext`,除非您有充分的理由不这样做,使用 `GenericApplicationContext` 及其子类 `AnnotationConfigApplicationContext` 作为自定义引导的常见实现.
这些是 Spring 用于所有常见目的的核心容器的主要入口点: 加载配置文件,触发类路径扫描,以编程方式注册 bean 定义和带注解的类,以及(从 5.0 开始) 注册功能 bean 定义.

因为 `ApplicationContext` 包括 `BeanFactory` 的所有功能,和 `BeanFactory` 相比更值得推荐,除了一些特定的场景,例如在资源受限的设备上运行的内嵌的应用.
在 `ApplicationContext`(例如 `GenericApplicationContext` 实现) 中,按照约定(即通过 bean 名称或 bean 类型 - 特别是后处理器) 检测到几种 bean , 而普通的 `DefaultListableBeanFactory` 对任何特殊 bean 都是不可知的.

对于许多扩展容器功能,例如注解处理和 AOP 代理, <<beans-factory-extension-bpp, `BeanPostProcessor` 的扩展点>>是必不可少的. 如果仅使用普通的 `DefaultListableBeanFactory`,则默认情况下不会检测到并激活此类后置处理器.
 这种情况可能令人困惑,因为您的 bean 配置实际上没有任何问题.  相反,在这种情况下,容器需要至少得多一些额外的处理.

下表列出了 `BeanFactory` 和 `ApplicationContext` 接口和实现提供的功能.

[[context-introduction-ctx-vs-beanfactory-feature-matrix]]
.Feature Matrix
[cols="50%,25%,25%"]
|===
| 特性 | `BeanFactory` | `ApplicationContext`

| Bean实例化/装配
| Yes
| Yes

| 集成生命周期管理
| No
| Yes

| 自动注册 `BeanPostProcessor`
| No
| Yes

| 自动注册 `BeanFactoryPostProcessor`
| No
| Yes

| 便利的 `MessageSource` 访问 (国际化)
| No
| Yes

| 内置 `ApplicationEvent` 发布机制
| No
| Yes
|===

要使用 `DefaultListableBeanFactory` 显式注册 bean 的后置处理器,您需要以编程方式调用 `addBeanPostProcessor`,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
	// populate the factory with bean definitions

	// now register any needed BeanPostProcessor instances
	factory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());
	factory.addBeanPostProcessor(new MyBeanPostProcessor());

	// now start using the factory
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val factory = DefaultListableBeanFactory()
	// populate the factory with bean definitions

	// now register any needed BeanPostProcessor instances
	factory.addBeanPostProcessor(AutowiredAnnotationBeanPostProcessor())
	factory.addBeanPostProcessor(MyBeanPostProcessor())

	// now start using the factory
----

要将 `BeanFactoryPostProcessor` 应用于普通的 `DefaultListableBeanFactory`,需要调用其 `postProcessBeanFactory` 方法,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
	XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
	reader.loadBeanDefinitions(new FileSystemResource("beans.xml"));

	// bring in some property values from a Properties file
	PropertySourcesPlaceholderConfigurer cfg = new PropertySourcesPlaceholderConfigurer();
	cfg.setLocation(new FileSystemResource("jdbc.properties"));

	// now actually do the replacement
	cfg.postProcessBeanFactory(factory);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val factory = DefaultListableBeanFactory()
	val reader = XmlBeanDefinitionReader(factory)
	reader.loadBeanDefinitions(FileSystemResource("beans.xml"))

	// bring in some property values from a Properties file
	val cfg = PropertySourcesPlaceholderConfigurer()
	cfg.setLocation(FileSystemResource("jdbc.properties"))

	// now actually do the replacement
	cfg.postProcessBeanFactory(factory)
----

在这两种情况下,显示注册步骤都不方便,这就是为什么各种 `ApplicationContext` 变体优先于 Spring 支持的应用程序中的普通 `DefaultListableBeanFactory`, 尤其是在典型企业设置中依赖 `BeanFactoryPostProcessor` 和 `BeanPostProcessor` 实例来扩展容器功能时.

[NOTE]
====
`AnnotationConfigApplicationContext` 具有注册的所有常见注解后置处理器,并且可以通过配置注解(例如 `@EnableTransactionManagement`) 在封面下引入其他处理器.  在 Spring 的基于注解的配置模型的抽象级别, bean 的后置处理器的概念变成仅仅是内部容器细节.
====
