[[mvc]]
= Spring Web MVC
:doc-spring-security: {doc-root}/spring-security/site/docs/current/reference

Spring Web MVC是构建在Servlet API上的原始Web框架，从一开始就包含在Spring Framework中。 正式名称  "`Spring Web MVC,`" 来自其源模块(https://github.com/spring-projects/spring-framework/tree/master/spring-webmvc[`spring-webmvc`])的名称，但它通常被称为 "`Spring MVC`".。

与Spring Web MVC并行，Spring Framework 5.0引入了一个响应式栈Web框架，其名称 "`Spring WebFlux,`" 也基于其源模块(https://github.com/spring-projects/spring-framework/tree/master/spring-webflux[`spring-webflux`])。 本节介绍Spring Web MVC。 <<web-reactive.adoc#spring-web-reactive, 下一节>>将介绍Spring WebFlux。.

有关基本信息以及与Servlet容器和Java EE版本范围的兼容性，请参阅Spring Framework https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-Versions[Wiki]。


[[mvc-servlet]]
== DispatcherServlet
[.small]#<<web-reactive.adoc#webflux-dispatcher-handler, WebFlux>>#

Spring MVC和许多其他Web框架一样，围绕前端控制器模式设计，其中核心  `DispatcherServlet` 为请求处理提供共享算法，而实际工作由可配置委托组件执行。 该模型非常灵活，支持多种工作流程。

`DispatcherServlet` 与任何 `Servlet` 一样，需要使用Java配置或 `web.xml` 根据 `Servlet` 规范进行声明和映射。 反过来，`DispatcherServlet` 使用Spring配置来发现请求映射，视图解析，异常处理 <<mvc-servlet-special-bean-types, 等等>>所需的委托组件。

下面的Java配置示例注册并初始化 `DispatcherServlet`，它由Servlet容器自动检测（请参阅<<mvc-container-config>>）：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyWebApplicationInitializer implements WebApplicationInitializer {

		@Override
		public void onStartup(ServletContext servletCxt) {

			// Load Spring web application configuration
			AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();
			ac.register(AppConfig.class);
			ac.refresh();

			// Create and register the DispatcherServlet
			DispatcherServlet servlet = new DispatcherServlet(ac);
			ServletRegistration.Dynamic registration = servletCxt.addServlet("app", servlet);
			registration.setLoadOnStartup(1);
			registration.addMapping("/app/*");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyWebApplicationInitializer : WebApplicationInitializer {

		override fun onStartup(servletCxt: ServletContext) {

			// Load Spring web application configuration
			val ac = AnnotationConfigWebApplicationContext()
			ac.register(AppConfig::class.java)
			ac.refresh()

			// Create and register the DispatcherServlet
			val servlet = DispatcherServlet(ac)
			val registration = servletCxt.addServlet("app", servlet)
			registration.setLoadOnStartup(1)
			registration.addMapping("/app/*")
		}
	}
----

NOTE: 	除了直接使用ServletContext API之外，您还可以扩展 `AbstractAnnotationConfigDispatcherServletInitializer` 并覆盖特定方法（请参阅 <<mvc-servlet-context-hierarchy,上下文层次结构>>下的示例）。

以下 `web.xml` 配置示例注册并初始化 `DispatcherServlet`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
<web-app>

	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>

	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/app-context.xml</param-value>
	</context-param>

	<servlet>
		<servlet-name>app</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value></param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>

	<servlet-mapping>
		<servlet-name>app</servlet-name>
		<url-pattern>/app/*</url-pattern>
	</servlet-mapping>

</web-app>
----

NOTE: Spring Boot遵循不同的初始化顺序。 Spring Boot使用Spring配置来引导自身和嵌入式 `Servlet` 容器，而不是挂钩到 `Servlet` 容器的生命周期。 在Spring配置中检测 `Filter` 和 `Servlet` 声明，并在Servlet容器中注册。 有关更多详细信息，请参阅https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-embedded-container[Spring Boot 文档] 。

[[mvc-servlet-context-hierarchy]]
=== 上下文层次结构

`DispatcherServlet` 需要一个 `WebApplicationContext`（`ApplicationContext` 的扩展）来配置自己。 `WebApplicationContext` 有一个指向 `ServletContext` 的链接以及与之关联的 `Servlet`。
它还绑定到 `ServletContext`，当需要访问它时，应用程序可以使用 `RequestContextUtils` 上的静态方法来查找 `WebApplicationContext`。

对于许多应用程序，拥有一个简单的 `WebApplicationContext` 已经足够了。它也有一个上下文层次结构，其中根 `WebApplicationContext` 在多个 `DispatcherServlet`（或其他 `Servlet`）实例之间共享， 每个实例都有自己的子 `WebApplicationContext` 配置。
有关上下文层次结构功能的更多信息，请参阅 <<core.adoc#context-introduction,`ApplicationContext` 的其他功能>>。

根 `WebApplicationContext` 通常包含bean基础结构，例如需要跨多个 `Servlet` 实例共享的数据存储库和业务服务。 这些bean被有效继承，可以在特定于 `Servlet` 的子 `WebApplicationContext` 中重写（即重新声明），它通常包含给定 `Servlet` 本地的bean。 下图显示了这种关系：

image::images/mvc-context-hierarchy.png[]

以下示例配置 `WebApplicationContext` 层次结构:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

		@Override
		protected Class<?>[] getRootConfigClasses() {
			return new Class<?>[] { RootConfig.class };
		}

		@Override
		protected Class<?>[] getServletConfigClasses() {
			return new Class<?>[] { App1Config.class };
		}

		@Override
		protected String[] getServletMappings() {
			return new String[] { "/app1/*" };
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyWebAppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

		override fun getRootConfigClasses(): Array<Class<*>> {
			return arrayOf(RootConfig::class.java)
		}

		override fun getServletConfigClasses(): Array<Class<*>> {
			return arrayOf(App1Config::class.java)
		}

		override fun getServletMappings(): Array<String> {
			return arrayOf("/app1/*")
		}
	}
----

TIP: 如果不需要应用程序上下文层次结构，则应用程序可以通过 `getRootConfigClasses()` 返回所有配置，并从 `getServletConfigClasses()` 返回 `null`。

以下示例显示了 `web.xml` 配置（和上面效果一样）:

[source,xml,indent=0,subs="verbatim,quotes"]
----
<web-app>

	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>

	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/root-context.xml</param-value>
	</context-param>

	<servlet>
		<servlet-name>app1</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/app1-context.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>

	<servlet-mapping>
		<servlet-name>app1</servlet-name>
		<url-pattern>/app1/*</url-pattern>
	</servlet-mapping>

</web-app>
----

TIP: 	如果不需要应用程序上下文层次结构，则应用程序可以仅配置 "`root`" 上下文，并将 `contextConfigLocation` Servlet参数保留为空。


[[mvc-servlet-special-bean-types]]
=== 特殊的Bean类型
[.small]#<<web-reactive.adoc#webflux-special-bean-types, WebFlux>>#

`DispatcherServlet` 委托特殊bean处理请求并渲染视图。 "`special beans`" 是指实现WebFlux框架的Spring管理的 `Object` 实例。 这些通常带有内置联系，但您可以自定义其属性并扩展或替换它们。


下表列出了 `DispatcherHandler` 检测到的特殊bean:

[[mvc-webappctx-special-beans-tbl]]
[cols="1,2", options="header"]
|===
| Bean 类型| 说明

| `HandlerMapping`
| 将请求映射到处理程序以及用于预处理和后处理的<<mvc-handlermapping-interceptor, 拦截器>>列表。 其映射规则基于某些标准，其细节因 `HandlerMapping` 实现而异。
    两个主要的 `HandlerMapping` 实现是 `RequestMappingHandlerMapping`（它支持 `@RequestMapping` 带注解的方法） 和 `SimpleUrlHandlerMapping` （它维护对处理程序的URI路径模式的显式注册）。

| `HandlerAdapter`
| 无论实际调用处理程序如何，都可以帮助 `DispatcherServlet` 调用映射到请求的处理程序。 例如，调用带有注解的控制器，需要从注解中解析一些信息。 `HandlerAdapter` 的主要目的是保护 `DispatcherServlet` 不受此类细节的影响。

| <<mvc-exceptionhandlers, `HandlerExceptionResolver`>>
| 解决异常的策略，他可以将捕获到的异常映射到处理程序，HTML错误视图或其他目标。 请参阅<<mvc-exceptionhandlers,`HandlerExceptionResolver`>>。

| <<mvc-viewresolver, `ViewResolver`>>
| 将从处理程序返回的逻辑基于 `String` 的视图名称解析为用于呈现给响应的实际 `View`。 请参阅 <<mvc-viewresolver>> 和 <<mvc-view>>。

| <<mvc-localeresolver, `LocaleResolver`>>, <<mvc-timezone, LocaleContextResolver>>
| 解析客户端正在使用的 · 以及可能的时区，以便能够提供国际化视图。 请参阅 <<mvc-localeresolver>>。

| <<mvc-themeresolver, `ThemeResolver`>>
| 解决Web应用程序可以使用的主题 - 例如，提供个性化布局。 见<<mvc-themeresolver>>。

| <<mvc-multipart, `MultipartResolver`>>
| 解析multi-part的请求（例如：浏览器表单文件上载）。请参阅<<mvc-multipart>>。

| <<mvc-flash-attributes, `FlashMapManager`>>
| 存储和检索 `"input"` 和 `"output"` `FlashMap`，可用于将属性从一个请求传递到另一个请求，通常是通过重定向。 请参阅<<mvc-flash-attributes>>。
|===


[[mvc-servlet-config]]
=== Web MVC 配置
[.small]#<<web-reactive.adoc#webflux-framework-config, WebFlux>>#

对于每种类型的 <<mvc-servlet-special-bean-types,特殊bean>>， `DispatcherServlet` 首先会检查 `WebApplicationContext`。如果没有匹配的bean类型，则会退回检查 https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/resources/org/springframework/web/servlet/DispatcherServlet.properties[`DispatcherServlet.properties`]。

在大多数情况下，<<mvc-config>>是最佳起点。 它以Java或XML声明所需的bean，并提供更高级别的配置回调API来自定义它。

NOTE: Spring Boot依赖于MVC Java配置来配置Spring MVC并提供许多额外的便捷选项。

[[mvc-container-config]]
=== Servlet 配置

在Servlet 3.0+环境中，您可以选择以编程方式配置Servlet容器作为替代方法，也可以与 `web.xml` 文件结合使用。 以下示例注册 `DispatcherServlet`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import org.springframework.web.WebApplicationInitializer;

	public class MyWebApplicationInitializer implements WebApplicationInitializer {

		@Override
		public void onStartup(ServletContext container) {
			XmlWebApplicationContext appContext = new XmlWebApplicationContext();
			appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");

			ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet(appContext));
			registration.setLoadOnStartup(1);
			registration.addMapping("/");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.web.WebApplicationInitializer

	class MyWebApplicationInitializer : WebApplicationInitializer {

		override fun onStartup(container: ServletContext) {
			val appContext = XmlWebApplicationContext()
			appContext.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml")

			val registration = container.addServlet("dispatcher", DispatcherServlet(appContext))
			registration.setLoadOnStartup(1)
			registration.addMapping("/")
		}
	}
----

`WebApplicationInitializer` 是Spring MVC提供的一个接口，实现此接口的任何Servlet 3容器都可被检测到并自动初始化。
`AbstractDispatcherServletInitializer` 抽象类实现了 `WebApplicationInitializer` 接口，通过重写方法来指定 `servlet` 映射和 `DispatcherServlet` 配置的地址， 从而更方便的注册 `DispatcherServlet`。

对于使用基于Java的Spring配置的应用程序，建议使用此方法，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

		@Override
		protected Class<?>[] getRootConfigClasses() {
			return null;
		}

		@Override
		protected Class<?>[] getServletConfigClasses() {
			return new Class<?>[] { MyWebConfig.class };
		}

		@Override
		protected String[] getServletMappings() {
			return new String[] { "/" };
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyWebAppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

		override fun getRootConfigClasses(): Array<Class<*>>? {
			return null
		}

		override fun getServletConfigClasses(): Array<Class<*>>? {
			return arrayOf(MyWebConfig::class.java)
		}

		override fun getServletMappings(): Array<String> {
			return arrayOf("/")
		}
	}
----

如果使用基于XML的Spring配置，则应直接从 `AbstractDispatcherServletInitializer` 扩展，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

		@Override
		protected WebApplicationContext createRootApplicationContext() {
			return null;
		}

		@Override
		protected WebApplicationContext createServletApplicationContext() {
			XmlWebApplicationContext cxt = new XmlWebApplicationContext();
			cxt.setConfigLocation("/WEB-INF/spring/dispatcher-config.xml");
			return cxt;
		}

		@Override
		protected String[] getServletMappings() {
			return new String[] { "/" };
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyWebAppInitializer : AbstractDispatcherServletInitializer() {

		override fun createRootApplicationContext(): WebApplicationContext? {
			return null
		}

		override fun createServletApplicationContext(): WebApplicationContext {
			return XmlWebApplicationContext().apply {
				setConfigLocation("/WEB-INF/spring/dispatcher-config.xml")
			}
		}

		override fun getServletMappings(): Array<String> {
			return arrayOf("/")
		}
	}
----

`AbstractDispatcherServletInitializer` 还提供了一种便捷的方法来添加 `Filter` 实例并将它们自动映射到 `DispatcherServlet`，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class MyWebAppInitializer extends AbstractDispatcherServletInitializer {

		// ...

		@Override
		protected Filter[] getServletFilters() {
			return new Filter[] {
				new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyWebAppInitializer : AbstractDispatcherServletInitializer() {

		// ...

		override fun getServletFilters(): Array<Filter> {
			return arrayOf(HiddenHttpMethodFilter(), CharacterEncodingFilter())
		}
	}
----

每个过滤器都根据其具体类型添加默认名称，并自动映射到 `DispatcherServlet`。

`AbstractDispatcherServletInitializer` 的 protected方法 `isAsyncSupported` 提供了一个单独的地址来启用 `DispatcherServlet` 上的异步支持以及映射到它的所有过滤器。 默认情况下，此标志设置为 `true`。

最后，如果您需要进一步自定义 `DispatcherServlet` 本身，则可以覆盖 `createDispatcherServlet` 方法。



[[mvc-servlet-sequence]]
=== Processing
[.small]#<<web-reactive.adoc#webflux-dispatcher-handler-sequence, WebFlux>>#

`DispatcherServlet` 按如下方式处理请求：

* 首先，搜索应用的上下文对象 `WebApplicationContext`，并把它作为一个属性（attribute)绑定到该请求上。以便让控制器和其他组件能使用它。 属性的键名默认为 `DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE`。
* 将locale resolver绑定到请求上，并允许其他组件解析处理请求时使用的语言环境（渲染视图，准备数据等）。 如果您不需要区域解析，则不需要locale resolver。
* 将theme resolver 绑定到请求，以允许视图等组件确定要使用的themes。 如果您不使用themes，则可以忽略它。
* 如果指定multipart 文件处理器，则会检查请求的文件是不是multiparts的， 如果是，请求将包装在 `MultipartHttpServletRequest` 中， 以便其他组件进一步处理。 有关Multipart Resolver的更多信息，请参见 <<mvc-multipart,Multipart Resolver>>。
* 为该请求查找一个合适的处理器。 如果找到处理程序，则与该处理器关联的整条执行链（前处理器、后处理器、控制器等）都会被执行，以完成相应模型的准备或视图的渲染。 或者，对于带注解的控制器，可以显示响应（在 HandlerAdapter中）而不是返回视图。
* 如果处理器返回模型，则渲染视图。 如果没有返回模型（可能是由于前处理器或后处理器拦截请求，可能是出于安全原因），则不会渲染任何视图，因为该请求可能已经完成。

在 `WebApplicationContext` 中声明的 `HandlerExceptionResolver` 用于解决请求处理过程中引发的异常。这些异常解析程序允许使用自定义的逻辑来解决，有关详细信息，请参阅<<mvc-exceptionhandlers,Exceptions>>  。

Spring的 `DispatcherServlet` 也允许处理器返回Servlet API规范中定义的最后修改时间戳（`last-modification-date`）值。确定请求最后修改时间的方式是直截了当的： `DispatcherServlet` 会先查找合适的处理映射来找到请求对应的处理器，然后检测它是否实现了 `LastModified` 接口。
如果是的话，则调用接口的 `long getLastModified(request)` 方法，并将返回的值传回给客户端。

您可以自定义通过 `DispatcherServlet` 的配置。可以在 `web.xml` 文件中，声明元素Servlet的上添加Servlet的初始化参数（`init-param` 元素）。 下表列出了支持的参数：

[[mvc-disp-servlet-init-params-tbl]]
.DispatcherServlet 初始化参数
|===
| 参数| 说明

| `contextClass`
| 实现 `ConfigurableWebApplicationContext` 的类，由此类通过本地配置来初始化 Servlet实例。 默认情况下，使用 `XmlWebApplicationContext`。

| `contextConfigLocation`
|
一个指定了上下文配置文件路径的字符串，并传递给上下文实例（由 `contextClass` 指定） 。该字符串可能包含多个字符串（使用逗号作为分隔符）以支持多个上下文。 对于具有两次定义的bean的多个上下文位置，最新位置优先（即最后加载的为准）。

| `namespace`
| `WebApplicationContext` 的命名空间。 默认为 `[servlet-name]-servlet`。

| `throwExceptionIfNoHandlerFound`
| 当没有找到请求的处理程序时是否抛出 `NoHandlerFoundException`。 然后可以使用 `HandlerExceptionResolver` 捕获异常（例如，使用 `@ExceptionHandler` 控制器方法）并像处理其他任何方法一样处理异常。

  默认情况下，此参数设置为 `false`，在这种情况下，`DispatcherServlet` 将响应状态设置为 `404（NOT_FOUND）`，而不会引发异常。

  请注意，如果配置了 默认servlet处理 ，则始终将未解析的请求转发到<<mvc-default-servlet-handler,默认servlet>>，并且永远不会引发404。
|===



[[mvc-handlermapping-interceptor]]
=== 拦截器

所有 `HandlerMapping` 实现都支持处理拦截器，这些拦截器在需要为特定类型的请求应用一些功能时可能很有用非常有用。
例如，检查用户身份等，`org.springframework.web.servlet` 包中的 `HandlerInterceptor` 实现了三种方法，提供足够的灵活性来执行各种预处理和后处理：

* `preHandle(..)`: 在执行实际处理程序之前
* `postHandle(..)`: 在执行实际处理程序之后
* `afterCompletion(..)`: 完成请求后

`preHandle(..)` 方法返回一个布尔值。 您可以使用此方法来中断或继续执行链的处理。 当此方法返回 `true` 时，处理程序执行链继续。
当它返回 `false` 时，`DispatcherServlet` 假定拦截器本身已处理请求（例如，呈现适当的视图）并且不继续执行执行链中的其他拦截器和实际处理程序。

有关如何配置 <<mvc-config-interceptors,Interceptors>>  的示例，请参阅MVC配置一节中的拦截器。 您还可以使用各个 `HandlerMapping` 实现上的setter方法直接注册它们。

请注意，在 `HandlerAdapter` 和 `postHandle` 之前，响应被写入并提交。 `postHandle` 对于 `@ResponseBody` 和 `ResponseEntity` 方法不太有用， 这意味着对响应进行任何更改都为时已晚.
例如添加额外的header。 对于此类方案，您可以实现 `ResponseBodyAdvice` 并将其声明为 <<mvc-ann-controller-advice,Controller Advice>> bean或直接在 `RequestMappingHandlerAdapter` 上进行配置。

[[mvc-exceptionhandlers]]
=== 异常
[.small]#<<web-reactive.adoc#webflux-dispatcher-exceptions, WebFlux>>#

如果在请求映射期间发生异常或从请求处理程序（例如 `@Controller`）抛出异常， 则 `DispatcherServlet` 委托给 `HandlerExceptionResolver` bean来处理并解决异常，这通常是错误响应。

下表列出了可用的 `HandlerExceptionResolver` 实现：

[cols="1,2", options="header"]
.HandlerExceptionResolver 实现
|===
| `HandlerExceptionResolver` | 描述

| `SimpleMappingExceptionResolver`
| 异常类名称和错误视图名称之间的映射。 用于在浏览器应用程序中呈现错误页面。

| {api-spring-framework}/web/servlet/mvc/support/DefaultHandlerExceptionResolver.html[`DefaultHandlerExceptionResolver`]
| 解决Spring MVC引发的异常并将它们映射到HTTP状态代码。 另请参阅备用 `ResponseEntityExceptionHandler` 和 <<mvc-ann-rest-exceptions,REST API exceptions>>异常。

| `ResponseStatusExceptionResolver`
| 使用 `@ResponseStatus` 注解解析异常，并根据注解中的值将它们映射到HTTP状态代码。

| `ExceptionHandlerExceptionResolver`
| 通过在 `@Controller` 或 `@ControllerAdvice` 类中调用 `@ExceptionHandler` 方法来解决异常。 请参阅 <<mvc-ann-exceptionhandler, @ExceptionHandler methods>>方法。
|===


[[mvc-excetionhandlers-handling]]
==== 解析链

您可以通过在Spring配置中声明多个 `HandlerExceptionResolver` bean并根据需要设置其顺序属性来形成异常解析链。 `order` 属性越高，异常解析器定位的越晚。

`HandlerExceptionResolver` 的约定指定它可以返回:

* 一个指向错误视图的 `ModelAndView`。
* 如果在解析程序中处理异常，则为空的 `ModelAndView`。
* 如果异常仍未解析，则为 `null`，以供后续解析器尝试，如果异常保留在最后，则允许冒泡到 `Servlet` 容器。.

<<mvc-config,MVC Config>>自动声明内置的解析器，用于默认的Spring MVC异常，`@ResponseStatus` 带注解的异常，以及对 `@ExceptionHandler` 方法的支持。 您可以自定义该列表或替换它。

[[mvc-ann-customer-servlet-container-error-page]]
==== 容器错误页面

如果任何 `HandlerExceptionResolver` 仍未解析异常，并且因此将其传播给servlet容器或者如果响应状态设置为错误状态（即4xx，5xx） ，则Servlet容器可以呈现HTML中的默认错误页面。
要自定义容器的默认错误页面，可以在 `web.xml`.中声明错误页面映射。 以下示例显示了如何执行此操作：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<error-page>
		<location>/error</location>
	</error-page>
----

根据前面的示例，当异常冒泡或响应具有错误状态时，Servlet容器会在容器内对配置的URL进行ERROR调度（例如，`/error`）。
然后由 `DispatcherServlet` 处理，可能将其映射到 `@Controller`，可以实现该控件以返回带有模型的错误视图名称或呈现JSON响应，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RestController
	public class ErrorController {

		@RequestMapping(path = "/error")
		public Map<String, Object> handle(HttpServletRequest request) {
			Map<String, Object> map = new HashMap<String, Object>();
			map.put("status", request.getAttribute("javax.servlet.error.status_code"));
			map.put("reason", request.getAttribute("javax.servlet.error.message"));
			return map;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RestController
	class ErrorController {

		@RequestMapping(path = ["/error"])
		fun handle(request: HttpServletRequest): Map<String, Any> {
			val map = HashMap<String, Any>()
			map["status"] = request.getAttribute("javax.servlet.error.status_code")
			map["reason"] = request.getAttribute("javax.servlet.error.message")
			return map
		}
	}
----

TIP: 	Servlet API没有提供在Java中创建错误页面映射的方法。 但是，您可以同时使用 `WebApplicationInitializer` 和简写的 `web.xml`。

[[mvc-viewresolver]]
=== View Resolution
[.small]#<<web-reactive.adoc#webflux-viewresolution, WebFlux>>#

Spring MVC定义了 `ViewResolver` 和 `View` 接口，使您可以在浏览器中呈现模型，而无需将您与特定的视图技术联系起来。 `ViewResolver` 提供视图名称和实际视图之间的映射。
`View` 接口负责准备请求，并将请求的渲染交给某种具体的视图技术实现。

下表提供了有关 `ViewResolver` 层次结构的更多详细信息：

[[mvc-view-resolvers-tbl]]
.ViewResolver 实现
|===
| ViewResolver| 描述

| `AbstractCachingViewResolver`
| `AbstractCachingViewResolver` 的子类缓存它们解析的视图实例。 缓存可提高某些视图技术的性能。 您可以通过将 `cache` 属性设置为 `false`.来关闭缓存。 此外，如果必须在运行时刷新某个视图（例如，修改 `FreeMarker` 模板时），则可以使用 `removeFromCache(String viewName, Locale loc)` 方法。

| `XmlViewResolver`
| 实现 `ViewResolver`，它必须和Spring的XML bean工厂有相同的DTD以。 默认配置文件是 `/WEB-INF/views.xml`。

| `ResourceBundleViewResolver`
|  `ViewResolver` 的实现，它使用由bundle根路径指定的 `ResourceBundle` 中的bean定义作为配置。 对于它应该解析的每个视图，它使用属性 `[viewname].(class)` 的值作为视图类， 并使用属性 `[viewname].url` 的值作为视图URL。 您可以在  <<mvc-view,视图技术>> 一章中找到示例。

| `UrlBasedViewResolver`
| `ViewResolver` 接口的简单实现，它不需要其他任何显式的映射说明，而直接使用URL来解析到逻辑视图名。 如果您的逻辑名称与真正的视图资源的名称匹配，则不需要任何映射。

| `InternalResourceViewResolver`
| `UrlBasedViewResolver` 的便捷子类，支持 `InternalResourceView`（实际上是Servlet和JSP）和子类，如 `JstlView` 和 `TilesView`。 您可以使用 `setViewClass(..)` 为此解析程序生成的所有视图指定视图类。 有关详细信息，请参阅{api-spring-framework}/web/reactive/result/view/UrlBasedViewResolver.html[`UrlBasedViewResolver`] javadoc。

| `FreeMarkerViewResolver`
| `UrlBasedViewResolver` 的便捷子类，支持 `FreeMarkerView` 其自定义子类。

| `ContentNegotiatingViewResolver`
| 实现 `ViewResolver` 接口，该接口根据请求文件名或 `Accept` 头解析视图。 请参阅  <<mvc-multiple-representations,Content Negotiation>>。
|===


[[mvc-viewresolver-handling]]
==== 处理
[.small]#<<web-reactive.adoc#webflux-viewresolution-handling, WebFlux>>#

您可以在视图解析器链中声明多个视图解析器，并在必要时通过设置 `order` 属性来指定排序。 请记住，order属性越高，视图解析器在链中的位置越晚。 .

`ViewResolver` 可以返回 `null` 以指示无法找到该视图。 但是，对于JSP和 `InternalResourceViewResolver`, 确定JSP是否存在的唯一方法是通过 `RequestDispatcher` 执行调度。 因此，您必须始终将 `InternalResourceViewResolver` 配置为视图解析器的整体顺序中的最后一个。

配置视图解析就像将 `ViewResolver` bean添加到Spring配置一样简单。<<mvc-config,MVC Config>>为<<mvc-config-view-resolvers,View 解析器>>提供专用配置API，并添加无逻辑视图控制器（<<mvc-config-view-controller, View Controllers>> ），这些控制器对于没有控制器逻辑的HTML模板渲染非常有用。

[[mvc-redirecting-redirect-prefix]]
==== 重定向
[.small]#<<web-reactive.adoc#webflux-redirecting-redirect-prefix, WebFlux>>#

您可以在视图中使用 `redirect:` 前缀来执行重定向。`UrlBasedViewResolver`（及其子类）将此识别为需要重定向的指令。 视图名称的其余部分是重定向URL。

控制器本身可以根据逻辑视图名称进行操作。 逻辑视图名称（例如 `redirect:/myapp/some/resource`）相对于当前Servlet上下文重定向，而名称如 `redirect:http://myhost.com/some/arbitrary/path`  重定向到绝对URL。

请注意，如果使用 `@ResponseStatus` 注解控制器方法，则注解值优先于 `RedirectView` 设置的响应状态。

[[mvc-redirecting-forward-prefix]]
==== 转发

你也可以在视图名称中使用 `forward:` 前缀，来作为 `UrlBasedViewResolver` 和其子类最终解析的视图名称。 这将创建一个 `InternalResourceView`，它执行 `RequestDispatcher.forward()`。
因此，此前缀对于 `InternalResourceViewResolver` 和 `InternalResourceView`（对于JSP）没有用，但如果您使用其他视图技术时仍希望强制Servlet/JSP引擎处理资源的转发，则它可能会有所帮助。 请注意，您也可以链接多个视图解析器。


[[mvc-multiple-representations]]
==== Content Negotiation
[.small]#<<web-reactive.adoc#webflux-multiple-representations, WebFlux>>#

{api-spring-framework}/web/servlet/view/ContentNegotiatingViewResolver.html[`ContentNegotiatingViewResolver`] 本身不解析视图，而是委托给其他视图解析器，并选择类似于客户端请求的表示的视图。 可以从 `Accept` 头或查询参数（例如， `"/path?format=pdf"`）确定表示。

`ContentNegotiatingViewResolver` 通过将请求的媒体类型与其每个 `ViewResolvers` 关联的 `View` 支持的媒体类型（也称为 `Content-Type`）进行比较，选择适当的 `View` 来处理请求。列表中具有兼容 `Content-Type` 的第一个 `View` 将表示返回给客户端。
如果 `ViewResolver` 链无法提供兼容视图，则会查询通过 `DefaultViews` 属性指定的视图列表。 后一个选项适用于单个视图，它可以呈现当前资源的适当表示，而不管逻辑视图名称如何。 `Accept` 头可以包含通配符（例如 `text/{asterisk}`），在这种情况下，`Content-Type` 为 `text/xml` 的 `View` 是兼容匹配。

有关配置详细信息，请参阅 <<mvc-config,MVC Config>> 下的<<mvc-config-view-resolvers,View 解析器>> 。

[[mvc-localeresolver]]
=== 国际化

正如Spring Web MVC框架所做的那样，Spring架构的大多数部分都支持国际化。 `DispatcherServlet` 允许您使用客户端的语言环境自动解析消息。 这是通过 `LocaleResolver` 对象完成的。

当请求进入时，`DispatcherServlet` 会查找当前语言环境解析器，如果找到，则会尝试使用它来设置语言环境。 您可以通过使用 `RequestContext.getLocale()` 方法，来获取由区域解析器解析到的结果。

除了自动解析语言环境之外，您还可以在处理程序时添加拦截器（有关拦截器的更多信息，请参阅<<mvc-handlermapping-interceptor,Interception>> ），以便于在特定情况下更改语言环境。例如（通过请求中的参数来改变语言环境）

区域解析器和拦截器在 `org.springframework.web.servlet.i18n` 包中定义，并以正常方式在应用程序上下文中进行配置。 Spring中包含以下选择的语言环境解析器。

* <<mvc-timezone>>
* <<mvc-localeresolver-acceptheader>>
* <<mvc-localeresolver-cookie>>
* <<mvc-localeresolver-session>>
* <<mvc-localeresolver-interceptor>>


[[mvc-timezone]]
==== Time Zone

除了获取客户端的区域设置外，了解其时区通常也很有用。 `LocaleContextResolver` 接口提供了 `LocaleResolver` 的扩展，它允许解析器提供更丰富的 `LocaleContext`，其中可能包含时区信息。

当此解析器可用时，可以使用 `RequestContext.getTimeZone()` 方法获取用户的 `TimeZone`。 时区信息由Spring的 `ConversionService` 注册的任何 Date/Time `Converter` 和 `Formatter` 对象自动使用。


[[mvc-localeresolver-acceptheader]]
==== Header 解析器

此区域解析器检查客户端（例如，Web浏览器）发送的请求头中的 `accept-language`。 通常，此字段包含客户端操作系统的区域设置。 请注意，此解析器不支持时区信息。


[[mvc-localeresolver-cookie]]
==== Cookie 解析器

此区域解析器检查客户端上可能存在的 `Cookie`，以查看是否指定了 `Locale` 或 `TimeZone`。 如果是，则使用指定的详细信息。 通过使用此区域解析器的属性，您可以指定cookie的名称以及失效时间。 以下示例定义 `CookieLocaleResolver`：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver">

		<property name="cookieName" value="clientlanguage"/>

		<!-- in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) -->
		<property name="cookieMaxAge" value="100000"/>

	</bean>
----

下表描述了 `CookieLocaleResolver` 的属性：

[[mvc-cookie-locale-resolver-props-tbl]]
.CookieLocaleResolver 属性
[cols="1,1,4"]
|===
| 属性 | 默认值 | 描述

| `cookieName`
| classname + LOCALE
| cookie的名字

| `cookieMaxAge`
| Servlet container default
| Cookie在客户端上持续存在的最长时间。 如果指定 `-1`，则不会保留cookie。 它仅在客户端关闭浏览器之前可用。

| `cookiePath`
| /
| 限制cookie对您网站某个部分的可见性。 当指定了 `cookiePath` 时，cookie仅对该路径及其下方的路径可见。
|===


[[mvc-localeresolver-session]]
==== Session 解析器

您可以使用 `SessionLocaleResolver` 从与用户请求关联的 `Session` 中获取 `Locale` 和 `TimeZone`。 与 `CookieLocaleResolver` 相比，此策略将本地选择的区域设置存储在Servlet容器的 `HttpSession` 中。 因此，这些设置对于每个会话都是临时的，这些设置在会话结束时会丢失。

请注意，与外部会话管理机制没有直接关系，例如Spring Session项目。 此 `SessionLocaleResolver` 根据当前的 `HttpServletRequest` 评估和修改相应的 `HttpSession` 属性。


[[mvc-localeresolver-interceptor]]
==== Locale 拦截器

您可以通过将 `LocaleChangeInterceptor` 添加到其中一个 `HandlerMapping` 定义来启用语言环境的更改。 它会检测请求中的参数并相应地更改语言环境，在程序的应用程序上下文中调用 `LocaleResolver` 上的 `setLocale` 方法。
下一个示例显示，当调用包含名为 `siteLanguage` 的参数的所有`{asterisk}.view` 资源时更改了区域设置。 例如，对URL的请求 `http://www.sf.net/home.view?siteLanguage=nl` 将网站语言更改为荷兰语。 以下示例显示如何拦截区域设置:

[source,xml,indent=0,subs="verbatim"]
----
	<bean id="localeChangeInterceptor"
			class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor">
		<property name="paramName" value="siteLanguage"/>
	</bean>

	<bean id="localeResolver"
			class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/>

	<bean id="urlMapping"
			class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
		<property name="interceptors">
			<list>
				<ref bean="localeChangeInterceptor"/>
			</list>
		</property>
		<property name="mappings">
			<value>/**/*.view=someController</value>
		</property>
	</bean>
----



[[mvc-themeresolver]]
=== 主题

您可以使用Spring Web MVC框架自带的主题来设置应用程序的整体外观，从而增强用户体验。 主题是静态资源的集合，通常是样式表和图像，它们会影响应用程序的视觉样式。


[[mvc-themeresolver-defining]]
==== 定义一个主题

要在Web应用程序中使用主题，必须设置 `org.springframework.ui.context.ThemeSource` 接口的实现。 `WebApplicationContext` 接口扩展了 `ThemeSource`， 但将其职责委托给专用实现。
默认情况下，委托是 `org.springframework.ui.context.support.ResourceBundleThemeSource` 的实现。它从类路径的根目录加载属性文件。
要使用自定义 `ThemeSource` 实现或配置 `ResourceBundleThemeSource` 的名称前缀，可以在应用程序上下文中使用保留名称 `themeSource` 注册bean。 Web应用程序上下文自动检测具有该名称的bean并使用它。

使用 `ResourceBundleThemeSource` 时，主题在简单属性文件中定义。 属性文件列出构成主题的资源，如以下示例所示：

[literal,subs="verbatim,quotes"]
----
styleSheet=/themes/cool/style.css
background=/themes/cool/img/coolBg.jpg
----

属性的键是从视图代码引用主题元素的名称。 对于JSP，通常使用 `spring:theme` 自定义标签执行此操作，该标记与 `spring:message` 标签非常相似。 以下JSP片段使用上一示例中定义的主题来自定义外观：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%>
	<html>
		<head>
			<link rel="stylesheet" href="<spring:theme code='styleSheet'/>" type="text/css"/>
		</head>
		<body style="background=<spring:theme code='background'/>">
			...
		</body>
	</html>
----

默认情况下，`ResourceBundleThemeSource` 使用空的名称前缀。 因此，从类路径的根加载属性文件。 因此，您可以将 `cool.properties` 主题定义放在类路径根目录的目录中（例如，在 `/WEB-INF/classes` 中）。
`ResourceBundleThemeSource` 使用标准的Java资源包加载机制，从而使主题也具有国际化。 例如，我们可以有一个 `/WEB-INF/classes/cool_nl.properties`，它引用一个带有荷兰文本的特殊背景图像。

[[mvc-themeresolver-resolving]]
==== 解析主题

定义主题后，如<<mvc-themeresolver-defining, 上一节所述>>，您可以决定使用哪个主题。 `DispatcherServlet` 查找名为 `themeResolver` 的bean，以找出要使用的 `ThemeResolver` 实现。
主题解析器的工作方式与 `LocaleResolver` 的工作方式大致相同。 它检测用于特定请求的主题，还可以更改请求的主题。 下表描述了Spring提供的主题解析器：

[[mvc-theme-resolver-impls-tbl]]
.ThemeResolver 实现
[cols="1,4"]
|===
| Class | 描述

| `FixedThemeResolver`
| 选择使用 `defaultThemeName`

| `SessionThemeResolver`
| 主题在用户的HTTP会话中维护。 它只需要为每个会话设置一次，但不会在会话之间保留。

| `CookieThemeResolver`
| 所选主题存储在客户端的cookie中。
|===

Spring还提供了一个 `ThemeChangeInterceptor`，它允许通过简单的请求参数对每个请求进行主题更改。


[[mvc-multipart]]
=== Multipart 解析器
[.small]#<<web-reactive.adoc#webflux-multipart, WebFlux>>#

`org.springframework.web.multipart` 包中的 `MultipartResolver` 是一种用于解析包括文件上传在内的多部分请求的策略。 他包含了一个 https://jakarta.apache.org/commons/fileupload[Commons FileUpload] 的实现，另一个基于Servlet 3.0多部分请求解析。

要启用多部分处理，Spring的配置文件中，在 `DispatcherServlet` 配置名称为 `multipartResolver` 的 `MultipartResolver` bean。 `DispatcherServlet` 会自动检测并将其应用于请求中。
当收到内容类型为 `multipart/form-data` 的POST请求时，解析器会解析内容并将当前的 `HttpServletRequest` 包装为 `MultipartHttpServletRequest`，以提供对已解析部分的访问，并将其作为请求参数公开。

[[mvc-multipart-resolver-commons]]
==== Apache Commons `FileUpload`

要使用Apache Commons `FileUpload`，您可以配置名为 `multipartResolver` 的 `CommonsMultipartResolver` 类型的bean。 您还需要添加 `commons-fileupload` 依赖。

[[mvc-multipart-resolver-standard]]
==== Servlet 3.0

需要通过Servlet容器配置启用Servlet 3.0多部分解析:

* 在Java中，在注册Servlet时设置 `MultipartConfigElement`。
* 在 `web.xml` 中，将 `"<multipart-config>"` 部分添加到servlet声明中。

以下示例显示如何在注册Servlet时设置 `MultipartConfigElement`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

		// ...

		@Override
		protected void customizeRegistration(ServletRegistration.Dynamic registration) {

			// Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold
			registration.setMultipartConfig(new MultipartConfigElement("/tmp"));
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class AppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

		// ...

		override fun customizeRegistration(registration: ServletRegistration.Dynamic) {

			// Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold
			registration.setMultipartConfig(MultipartConfigElement("/tmp"))
		}

	}
----

一旦您配置好Servlet 3.0，您就可以添加名为 `multipartResolver` 的 `StandardServletMultipartResolver` 类型的bean。

[[mvc-logging]]
=== 日志
[.small]#<<web-reactive.adoc#webflux-logging, WebFlux>>#

Spring MVC中的DEBUG级别日志记录旨在实现紧凑，简约和人性化。 它侧重于那些一次又一次使用的高价值信息，其他的只有在调试特定问题时才有用。

TRACE级日志记录通常遵循与DEBUG相同的原则（例如，不应该是fire hose），但可以用于调试任何问题。 此外，一些日志消息可能在TRACE与DEBUG中显示不同的详细程度。

良好的日志记录来自使用日志的经验。 如果您发现任何不符合既定目标的事件，请告知我们。

[[mvc-logging-sensitive-data]]
==== 敏感数据
[.small]#<<web-reactive.adoc#webflux-logging-sensitive-data, WebFlux>>#

DEBUG和TRACE日志记录可能会记录敏感信息。 这就是默认情况下屏蔽请求参数和请求头的原因，并且必须通过 `DispatcherServlet` 上的 `enableLoggingRequestDetails` 属性显式启用它们的完整日志记录。

以下示例说明如何使用Java配置执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
public class MyInitializer
		extends AbstractAnnotationConfigDispatcherServletInitializer {

	@Override
	protected Class<?>[] getRootConfigClasses() {
		return ... ;
	}

	@Override
	protected Class<?>[] getServletConfigClasses() {
		return ... ;
	}

	@Override
	protected String[] getServletMappings() {
		return ... ;
	}

	@Override
	protected void customizeRegistration(ServletRegistration.Dynamic registration) {
		registration.setInitParameter("enableLoggingRequestDetails", "true");
	}

}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyInitializer : AbstractAnnotationConfigDispatcherServletInitializer() {

		override fun getRootConfigClasses(): Array<Class<*>>? {
			return ...
		}

		override fun getServletConfigClasses(): Array<Class<*>>? {
			return ...
		}

		override fun getServletMappings(): Array<String> {
			return ...
		}

		override fun customizeRegistration(registration: ServletRegistration.Dynamic) {
			registration.setInitParameter("enableLoggingRequestDetails", "true")
		}
	}
----




[[filters]]
== 过滤器
[.small]#<<web-reactive.adoc#webflux-filters, WebFlux>>#

`spring-web` 模块提供了一些有用的过滤器:

* <<filters-http-put,Form Data（表单数据）>>
* <<filters-forwarded-headers,Forwarded Headers（转发请求头）>>
* <<filters-shallow-etag,Shallow ETag()>>
* <<filters-cors,CORS>>



[[filters-http-put]]
=== 表单数据

浏览器只能通过HTTP GET或HTTP POST提交表单数据，但非浏览器客户端也可以使用HTTP PUT，PATCH和DELETE提交表单数据。 Servlet API要求 `ServletRequest.getParameter{asterisk}()` 方法仅支持HTTP POST的表单字段访问。.

`spring-web` 模块提供 `FormContentFilter` 过滤器来拦截HTTP PUT，PATCH和DELETE请求，请求类型为 `application/x-www-form-urlencoded`， `FormContentFilter` 从请求中读取表单数据， 并包装 `ServletRequest`，然后可以通过 `ServletRequest.getParameter{asterisk}()` 系列方法提供表单数据。

[[filters-forwarded-headers]]
=== 转发请求头
[.small]#<<web-reactive.adoc#webflux-forwarded-headers, WebFlux>>#

当通过代理主机或者端口或者其他方案请求时（例如，负载均衡），这是，从客户端角度看，创建正确的主机，端口或者其他方案成为一项挑战，

https://tools.ietf.org/html/rfc7239[RFC 7239] 定义了代理可以用来提供有关原始请求信息的转发HTTP头。 还有其他非标准头文件，包括 `X-Forwarded-Host`, `X-Forwarded-Port`, `X-Forwarded-Proto`, `X-Forwarded-Ssl`, 和 `X-Forwarded-Prefix`。

`ForwardedHeaderFilter` 是一个Servlet过滤器，它根据 `Forwarded` 头部信息修改请求的主机，端口和方案，然后删除请求头。过滤器依赖于包装请求，并且 ，必须先于其他过滤器（例如 `RequestContextFilter`）进行排序， 应该与修改后的请求而不是原始请求一起使用。

当转发请求头时需要注意的安全事项，因为应用程序无法知道请求头是代理按我们想的那样添加还是由客户端恶意添加，这就是为什么应该将信任边界的代理配置为删除来自外部的不受信任的转发请求头。 您还可以使用 `removeOnly=true` 配置 `ForwardedHeaderFilter`，在这种情况下，它会删除但不使用标头。

为了支持<<mvc-ann-async,异步请求>>并且可以处理错误的情况， 过滤器应使用 `DispatcherType.ASYNC` 和 `DispatcherType.ERROR` 映射。
如果使用Spring Framework的 `AbstractAnnotationConfigDispatcherServletInitializer`（请参阅<<mvc-container-config,Servlet 配置>>）所有过滤器都将自动注册 为 dispatch 类型。 但是，如果通过 `web.xml` 或在Spring Boot中 `FilterRegistrationBean` ,除了 `DispatcherType.REQUEST` 之外，还必须包含 `DispatcherType.ASYNC` 和 `DispatcherType.ERROR`。

[[filters-shallow-etag]]
=== Shallow ETag

`ShallowEtagHeaderFilter` 过滤器通过缓存写入响应的内容并从中计算MD5哈希来创建 "`shallow`" ETag。 客户端下次发送时， 它会执行相同操作，但它也会将计算值与 `If-None-Match` 请求头进行比较，如果两者相等，则返回304（NOT_MODIFIED）。

此策略可以节省网络带宽，但不能节省CPU，因为必须为每个请求计算完整响应。 前面描述的控制器级别的其他策略可以避免计算。 请参阅 <<mvc-caching,HTTP 缓存>>。

此过滤器具有 `writeWeakETag` 参数，该参数将过滤器配置为写入弱ETag，类似于以下内容：`W/"02a2d595e6ed9a0b24f027f2b63b134d6"`（如https://tools.ietf.org/html/rfc7232#section-2.3[RFC 7232 Section 2.3]）。

为了支持<< mvc-ann-async，异步请求>>，此过滤器必须与 `DispatcherType.ASYNC` 映射，以便过滤器可以延迟并成功生成ETag到最后一个异步调度的末尾。 如果使用Spring Framework的 `AbstractAnnotationConfigDispatcherServletInitializer`（请参阅<<mvc-container-config,Servlet 配置>>），则会为所有调度类型自动注册所有过滤器。 但是，如果通过 `web.xml` 或在Spring Boot中通过 `FilterRegistrationBean` 注册过滤器，请确保包括
`DispatcherType.ASYNC`

[[filters-cors]]
=== CORS
[.small]#<<web-reactive.adoc#webflux-filters-cors, WebFlux>>#

Spring MVC通过控制器上的注解为CORS配置提供细粒度的支持。 但是，当与Spring Security一起使用时，我们建议依赖于必须在Spring Security的过滤器链之前配置的内置 `CorsFilter`。

有关更多详细信息，请参阅  <<mvc-cors,CORS>> 和 <<mvc-cors-filter,CORS Filter>> 过滤器部分。

[[mvc-controller]]
== 注解控制器
[.small]#<<web-reactive.adoc#webflux-controller, WebFlux>>#

Spring MVC提供了基于注解的编程模型，其中 `@Controller` 和 `@RestController` 组件使用注解来表示请求映射、请求输入、异常处理等。被注解的控制器拥有灵活的方法签名，并且无需扩展基类或实现特定的接口。以下示例显示了由注解定义的控制器：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class HelloController {

		@GetMapping("/hello")
		public String handle(Model model) {
			model.addAttribute("message", "Hello World!");
			return "index";
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.ui.set

	@Controller
	class HelloController {

		@GetMapping("/hello")
		fun handle(model: Model): String {
			model["message"] = "Hello World!"
			return "index"
		}
	}
----

在前面的示例中，该方法接受 `Model` 并将视图名称作为 `String` 返回，但是存在许多其他选项，本章稍后将对其进行说明。

TIP: 有关 https://spring.io/guides[spring.io]的指南和教程，请使用本节中介绍的基于注解的编程模型。



[[mvc-ann-controller]]
=== Declaration
[.small]#<<web-reactive.adoc#webflux-ann-controller, WebFlux>>#

您可以在Servlet的 `WebApplicationContext` 中使用标准的Spring bean定义来定义控制器bean。`@Controller` 模板允许自动检测， 与Spring支持检测类路径中的 `@Component` 类一样，并会自动注册bean定义。它还充当注解类的模板，表示它充当的是Web组件的角色。

要启用 `@Controller` bean的自动检测，您可以将组件扫描添加到Java配置中，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@ComponentScan("org.example.web")
	public class WebConfig {

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@ComponentScan("org.example.web")
	class WebConfig {

		// ...
	}
----

以下示例显示了与前面示例等效的XML配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:p="http://www.springframework.org/schema/p"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<context:component-scan base-package="org.example.web"/>

		<!-- ... -->

	</beans>
----

`@RestController` 是一个<<core.adoc#beans-meta-annotations, 组合注解>>，它本身由 `@Controller` 和 `@ResponseBody` 元注解组成。 其每个方法都继承类型级别（type-level）的 `@ResponseBody` 注解，因此，直接写入响应主体与视图渲染和使用HTML模板。

[[mvc-ann-requestmapping-proxying]]
==== AOP 代理

在某些情况下，您需要在运行时使用AOP代理装饰控制器。 例如，如果您想在控制器上直接使用 `@Transactional` 注解。 在这种情况下，对于控制器而言，我们建议使用基于类的代理。 这通常也是控制器的默认选择。 但是，如果控制器没有实现Spring Context 回调的接口 （例如 `InitializingBean`, `*Aware` 等）， 则可能需要显式配置基于类的代理。
例如，使用 `<tx:annotation-driven/>`，您可以更改为 `<tx:annotation-driven proxy-target-class="true"/>`。使用 `@EnableTransactionManagement` ，你可以更改为 `@EnableTransactionManagement(proxyTargetClass = true)`

[[mvc-ann-requestmapping]]
=== Request Mapping
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping, WebFlux>>#

`@RequestMapping` 注解用于将请求映射到控制器方法。它具有各种属性，可以通过URL、HTTP方法、请求参数、请求头参数（headers）和媒体类型进行匹配。 可以在类级别使用它来表示共享映射，或在方法级别上用于缩小到特定的端点映射范围。

还有 `@RequestMapping` 的HTTP方法特定的缩写变量:

* `@GetMapping`
* `@PostMapping`
* `@PutMapping`
* `@DeleteMapping`
* `@PatchMapping`

这些简洁的注解是<<mvc-ann-requestmapping-composed,自定义注解>>，因为，大多数的控制器方法应该映射到HTTP方法而不是使用 `@RequestMapping`。默认情况下， `@RequestMapping` 和所有HTTP方法匹配。在类上定义的仍然需要 `@RequestMapping` 来表示共享映射。

以下示例具有类型和方法级别映射:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RestController
	@RequestMapping("/persons")
	class PersonController {

		@GetMapping("/{id}")
		public Person getPerson(@PathVariable Long id) {
			// ...
		}

		@PostMapping
		@ResponseStatus(HttpStatus.CREATED)
		public void add(@RequestBody Person person) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RestController
	@RequestMapping("/persons")
	class PersonController {

		@GetMapping("/{id}")
		fun getPerson(@PathVariable id: Long): Person {
			// ...
		}

		@PostMapping
		@ResponseStatus(HttpStatus.CREATED)
		fun add(@RequestBody person: Person) {
			// ...
		}
	}
----



[[mvc-ann-requestmapping-uri-templates]]
==== URI 模式匹配
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-uri-templates, WebFlux>>#

您可以使用以下全局模式和通配符来映射请求：

* `?` 匹配一个字符
* `*` 匹配路径段一个或多个字符
* `**` 匹配0个或多个路径段

您还可以使用 `@PathVariable` 声明URI变量并访问它们的值，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/owners/{ownerId}/pets/{petId}")
	fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {
		// ...
	}
----


您可以在类和方法级别声明URI变量，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@RequestMapping("/owners/{ownerId}")
	public class OwnerController {

		@GetMapping("/pets/{petId}")
		public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	@RequestMapping("/owners/{ownerId}")
	class OwnerController {

		@GetMapping("/pets/{petId}")
		fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet {
			// ...
		}
	}
----

URI变量会自动转换为适当的类型，或者引发 `TypeMismatchException`。 默认情况下支持简单类型（`int`, `long`, `Date` 等），您也可以注册对任何其他数据类型的支持。 请参见<<mvc-ann-typeconversion,类型转换>> 和 <<mvc-ann-initbinder,DataBinder>>。

你可以显示命名URI 变量(例如, `@PathVariable("customId")` ),但是如果名称是相同的，并且代码是使用调试信息编译的，或者在Java 8中使用 `-parameters` 编译器标记。 则可以保留该详细信息。

语法 `{varName:regex}` 声明一个具有正则表达式的URI变量，其语法为 `{varName:regex}`。例如，给定URL `"/spring-web-3.0.5 .jar"`，以下方法提取名称，版本和文件扩展名:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
	public void handle(@PathVariable String version, @PathVariable String ext) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/{name:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{ext:\\.[a-z]+}")
	fun handle(@PathVariable version: String, @PathVariable ext: String) {
		// ...
	}
----

URI路径模式还可以嵌入 `${…​}`，在启动时通过 `PropertyPlaceHolderConfigurer` 解析本地、系统、环境和其他属性源时解析的占位符。例如，这种模式可以使用基于某些外部配置对基URL进行参数化

NOTE: Spring MVC使用 `PathMatcher` 联系和 `AntPathMatcher` 实现位于 `spring-core` URI路径匹配。


[[mvc-ann-requestmapping-pattern-comparison]]
==== 模式比较
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-pattern-comparison, WebFlux>>#

当多个模式与URL匹配时，必须对它们进行比较以找到最佳匹配。 这是通过使用 `AntPathMatcher.getPatternComparator(String path)` 来完成的，它会查找更具体的模式。

如果URI变量的数量较少且单个通配符计为1且双通配符计为2，那么模式就不那么具体了。如果模式得到的分数相等，那么会选择较长的模式匹配。如果分数和长度都相同，则会选择拥有比通配符更多的URI变量的模式。

默认映射模式(`/{asterisk}{asterisk}`)从评分中排除，并始终排在最后。 此外，前缀模式（例如 `/public/{asterisk}{asterisk}`）被认为比没有双通配符的其他模式更不具体。

有关详细信息，请参阅 {api-spring-framework}/util/AntPathMatcher.html[`AntPathMatcher`] 中的 {api-spring-framework}/util/AntPathMatcher.AntPatternComparator.html[`AntPatternComparator`]。 您可以自定义 {api-spring-framework}/util/PathMatcher.html[`PathMatcher`]  的实现. 请参阅 配置中的  <<mvc-config-path-matching,Path Matching>>


[[mvc-ann-requestmapping-suffix-pattern-match]]
==== 后缀匹配

默认情况下,默认情况下，Spring MVC执行 `.{asterisk}` 后缀模式匹配，以便映射到 `/person` 的控制器也隐式映射到 `/person.*`。这里使用文件扩展名来解释用于响应的请求内容类型（即，而不是 `Accept` 请求头） - 例如，`/person.pdf`，`/person.xml` 等。

当浏览器用于发送难以持续交互的 `Accept` 头时，必须以这种方式使用文件扩展名。目前，这不再是必需的，判断 `Accept` 头应该是首选。

随着时间的推移，文件扩展名的使用已经证明有多种方式存在问题。 当使用URI变量，路径参数和URI编码进行覆盖时，它可能会导致歧义。 有关基于URL的授权和安全性的推理（有关更多详细信息，请参阅下一节）也变得更加困难。

要完全禁用文件扩展名，必须同时设置以下两项:

* `useSuffixPatternMatching(false)`,  <<mvc-config-path-matching, PathMatchConfigurer>>
* `favorPathExtension(false)`,  <<mvc-config-content-negotiation, ContentNegotiationConfigurer>>

基于URL的内容协商仍然有用（例如，在浏览器中输入URL时）。 为此，我们建议使用基于查询参数的策略来避免文件扩展名带来的大多数问题。 或者，如果必须使用文件扩展名，请考虑通过 `ContentNegotiationConfigurer` 的 `mediaTypes` 属性将它们限制为显式注册的扩展名列表。

[[mvc-ann-requestmapping-rfd]]
==== 后缀匹配和RFD

反射文件下载（Reflected file download）攻击与XSS类似，因为它依赖请求输入，例如查询参数、URI变量，并且在响应中被反射。但是，RFD攻击不是将JavaScript插入HTML，而是依赖浏览器切换来执行下载，进而在之后的双击时将响应作为可执行脚本处理。

在Spring MVC中，`@ResponseBody` 和 `ResponseEntity` 方法存在风险，因为它们可以呈现不同的内容类型，客户端可以通过URL路径扩展来请求。 禁用后缀模式匹配并使用路径扩展进行内容协商可降低风险，但不足以防止RFD攻击。

为了防止RFD攻击，在呈现响应主体之前，需要在Spring MVC添加 `Content-Disposition:inline;filename=f.txt` 头用于提供固定和安全的下载文件。只有在URL路径包含的文件扩展名中既不包含白名单，也没有为内容协商显式注册以时，才需要这样做。 但是，在浏览器直接输入URL时，可能会产生副作用。

默认情况下，有许多常见的路径扩展白名单。具有自定义 `HttpMessageConverter` 实现的应用程序可以显式注册内容协商的文件扩展名，以避免为这些扩展添加 `Content-Disposition` 头。 请参阅<<mvc-config-content-negotiation>>

有关RFD的其他建议，请参阅 https://pivotal.io/security/cve-2015-5211[CVE-2015-5211]


[[mvc-ann-requestmapping-consumes]]
==== 消费者媒体类型
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-consumes, WebFlux>>#

您可以根据请求的 `Content-Type` 缩小请求映射范围，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping(path = "/pets", consumes = "application/json") // <1>
	public void addPet(@RequestBody Pet pet) {
		// ...
	}
----
<1> 使用 `consumes` 属性来缩小内容类型的映射。


[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/pets", consumes = ["application/json"]) // <1>
	fun addPet(@RequestBody pet: Pet) {
		// ...
	}
----
<1> 使用 `consumes` 属性来缩小内容类型的映射。

`consumes` 属性还支持否定表达式 - 例如，`!text/plain` 表示除 `text/plain` 之外的任何内容类型。

您可以在类级别声明共享 `consumes` 属性。 但是，与大多数其他请求映射属性不同，在类级别使用时，方法级别会 `consumes` 属性覆盖而不是扩展类级别声明。

TIP: `MediaType` 为常用媒体类型提供常量，例如 `APPLICATION_JSON_VALUE` 和 `APPLICATION_XML_VALUE`。


[[mvc-ann-requestmapping-produces]]
==== 生产者媒体类型
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-produces, WebFlux>>#

您可以根据 `Accept` 请求头和控制器方法生成的内容类型列表来缩小请求映射，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path = "/pets/{petId}", produces = "application/json") // <1>
	@ResponseBody
	public Pet getPet(@PathVariable String petId) {
		// ...
	}
----
<1>  使用 `produces` 属性来缩小内容类型的映射。


[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/pets/{petId}", produces = ["application/json"]) // <1>
	@ResponseBody
	fun getPet(@PathVariable petId: String): Pet {
		// ...
	}
----
<1>  使用 `produces` 属性来缩小内容类型的映射。

媒体类型可以指定字符集。 支持否定表达式 - 例如， `!text/plain` 表示 "text/plain" 以外的任何内容类型。

您可以在类级别声明共享的 `produces` 属性。 但是，与大多数其他请求映射属性不同，在类级别使用时，方法级别会生成属性覆盖，而不是扩展类级别声明。

TIP: `MediaType` 为常用媒体类型提供常量，例如 `APPLICATION_JSON_UTF8_VALUE` 和 `APPLICATION_XML_VALUE`。


[[mvc-ann-requestmapping-params-and-headers]]
==== 参数, 请求头
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-params-and-headers, WebFlux>>#

您可以根据请求参数条件缩小请求映射。 您可以测试是否存在请求参数（`myParam`），缺少一个（`!myParam`）或特定值（`myParam=myValue`）。 以下示例显示如何测试特定值：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path = "/pets/{petId}", params = "myParam=myValue") // <1>
	public void findPet(@PathVariable String petId) {
		// ...
	}
----
<1> 测试 `myParam` 是否等于 `myValue`。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/pets/{petId}", params = ["myParam=myValue"]) // <1>
	fun findPet(@PathVariable petId: String) {
		// ...
	}
----
<1> 测试 `myParam` 是否等于 `myValue`。

您还可以将其与请求头条件一起使用，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path = "/pets", headers = "myHeader=myValue") // <1>
	public void findPet(@PathVariable String petId) {
		// ...
	}
----
<1> 测试 `myParam` 是否等于 `myValue`。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/pets", headers = ["myHeader=myValue"]) // <1>
	fun findPet(@PathVariable petId: String) {
		// ...
	}
----

TIP: 您可以将 `Content-Type` 和 `Accept` 与 `headers` 条件匹配，但最好使用<<mvc-ann-requestmapping-consumes, consumes>>和 <<mvc-ann-requestmapping-produces, produces>>替代。


[[mvc-ann-requestmapping-head-options]]
==== HTTP HEAD, OPTIONS
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-head-options, WebFlux>>#

`@GetMapping` (和 `@RequestMapping(method=HttpMethod.GET)`)一样，为了请求映射的目的，透明地支持HTTP HEAD以进行请求映射。控制器方法无需更改。 在 `javax.servlet.http.HttpServlet` 中应用的响应包确保有 `Content-Length` 头并且设置为写入的字节数，但实际上不会写入响应。

`@GetMapping` (和 `@RequestMapping(method=HttpMethod.GET)`)一样，为了请求映射的目的，被隐式映射到并支持HTTP HEAD，处理HTTP HEAD请求就像它是HTTP GET一样，但不是写入正文，而是计算字节数并设置 `Content-Length` 头。

默认情况下，HTTP OPTIONS通过设置 `Allow` 响应头来为所有具有匹配URL模式的 `@RequestMapping` 方法中列出的HTTP方法列表来处理HTTP选项。

对于没有HTTP方法声明的 `@RequestMapping`，`Allow` 请求头可以设置为 `GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS`。 控制器方法应始终声明支持的HTTP方法（例如，通过使用特定于HTTP方法的变体：`@GetMapping`, `@PostMapping` 等）。

您可以将 `@RequestMapping` 方法显式映射到HTTP HEAD和HTTP OPTIONS，但在常见情况下这不是必需的。


[[mvc-ann-requestmapping-composed]]
==== 自定义注解
[.small]#<<web-reactive.adoc#mvc-ann-requestmapping-head-options, WebFlux>>#

Spring MVC支持使用 <<core.adoc#beans-meta-annotations, 组合注解>>进行请求映射。 这些注解本身是使用 `@RequestMapping` 进行元注解的，并且用于重新声明具有更窄，更具体目的的 `@RequestMapping` 属性的子集（或全部）。

`@GetMapping`, `@PostMapping`, `@PutMapping`, `@DeleteMapping`, 和 `@PatchMapping` 就是组合注解最好的示例， 提供它们是因为.
可以说，大多数控制器方法应该映射到特定的HTTP方法，而不是使用 `@RequestMapping`，默认情况下，它与所有HTTP方法匹配。 如果您需要组合注解的示例，请查看如何声明这些注解。

Spring MVC还支持使用自定义请求匹配逻辑的自定义请求映射属性。这是一个更高级的选项，需要继承 `RequestMappingHandlerMapping` 并覆盖 `getCustomMethodCondition` 方法， 您可以在其中检查自定义属性并返回自己的 `RequestCondition`。

[[mvc-ann-requestmapping-registration]]
==== 显式注册
[.small]#<<web-reactive.adoc#webflux-ann-requestmapping-registration, WebFlux>>#

您可以以编程方式注册处理程序方法，您可以将其用于动态注册或高级情况，例如不同URL下的同一处理程序的不同实例。 以下示例注册处理程序方法：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class MyConfig {

		@Autowired
		public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) // <1>
				throws NoSuchMethodException {

			RequestMappingInfo info = RequestMappingInfo
					.paths("/user/{id}").methods(RequestMethod.GET).build(); // <2>

			Method method = UserHandler.class.getMethod("getUser", Long.class); // <3>

			mapping.registerMapping(info, handler, method); // <4>
		}
	}
----
<1> 为控制器注入目标处理程序和处理程序映射
<2> 准备映射元数据的请求
<3> 获取处理程序方法
<4> 添加注册

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class MyConfig {

		@Autowired
		fun setHandlerMapping(mapping: RequestMappingHandlerMapping, handler: UserHandler) { // <1>
			val info = RequestMappingInfo.paths("/user/{id}").methods(RequestMethod.GET).build() // <2>
			val method = UserHandler::class.java.getMethod("getUser", Long::class.java) // <3>
			mapping.registerMapping(info, handler, method) // <4>
		}
	}
----
<1> 为控制器注入目标处理程序和处理程序映射
<2> 准备映射元数据的请求
<3> 获取处理程序方法
<4> 添加注册



[[mvc-ann-methods]]
=== 程序处理方法
[.small]#<<web-reactive.adoc#webflux-ann-methods, WebFlux>>#

`@RequestMapping` 处理程序方法具有灵活的签名,可以从一系列受支持的控制器方法参数和返回值中进行选择.


[[mvc-ann-arguments]]
==== Method Arguments
[.small]#<<web-reactive.adoc#webflux-ann-arguments, WebFlux>>#

下表显示了受支持的控制器方法参数，任何参数都不支持响应式(Reactive)类型。

JDK 8  `java.util.Optional` 作为方法参数来支持的，它与具有必需属性的注解(例如 `@RequestParam`, `@RequestHeader` 等相结合)。 并且等同于 `required=false`。

[cols="1,2", options="header"]
|===
| 控制器方法参数 | 	描述

| `WebRequest`, `NativeWebRequest`
| 无需直接使用Servlet API即可访问请求参数以及request和session属性。

| `javax.servlet.ServletRequest`, `javax.servlet.ServletResponse`
| 选择任何特定的请求或响应类型 - 例如，`ServletRequest`, `HttpServletRequest` 或Spring的 `MultipartRequest`, `MultipartHttpServletRequest`。

| `javax.servlet.http.HttpSession`
| 强制进行会话。 因此，此类参数永远不可能为 `null`. 请注意，会话访问不是线程安全的。 如果允许多个请求同时访问会话，请考虑将 `RequestMappingHandlerAdapter` 实例的 `synchronizeOnSession` 标志设置为 `true`。

| `javax.servlet.http.PushBuilder`
| Spring4.0 push生成器API用于编程HTTP/2资源推送， 请注意，根据Servlet规范，如果客户端不支持该HTTP/2功能，则注入的 `PushBuilder` 实例可以为 `null`。

| `java.security.Principal`
| 当前经过身份验证的用户 - 如果已知，可能是特定的 `Principal` 实现类。

| `HttpMethod`
| 请求的HTTP方法.

| `java.util.Locale`
| 当前请求区域设置，由最可用的 `LocaleResolver`（实际上是已配置的 `LocaleResolver` 或 `LocaleContextResolver`）确定。

| `java.util.TimeZone` + `java.time.ZoneId`
| 与当前请求关联的时区，由 `LocaleContextResolver` 确定

| `java.io.InputStream`, `java.io.Reader`
| 用于访问Servlet API公开的原始请求主体。

| `java.io.OutputStream`, `java.io.Writer`
| 用于访问Servlet API公开的原始响应主体。

| `@PathVariable`
| 用于访问URI模板变量。 请参阅<<mvc-ann-requestmapping-uri-templates,URI模式>>.

| `@MatrixVariable`
| 用于访问URI路径段中的名称 - 值对。 请参见<<mvc-ann-matrix-variables,矩阵变量>>.

| `@RequestParam`
| 用于访问Servlet请求参数，包括多部分文件。 参数值将转换为声明的方法参数类型。 请参阅 <<mvc-ann-requestparam,@RequestParam>> 以及 <<mvc-multipart-forms,Multipart>>。 请注意，对于简单的参数值，使用 `@RequestParam` 是可选的。 请参阅本表末尾的“任何其他参数”。


| `@RequestHeader`
| 用于访问请求头。 头的值将转换为声明的方法参数类型。 请参阅<<mvc-ann-requestheader,@RequestHeader>>.

| `@CookieValue`
| 用于访问cookie。 Cookie值将转换为声明的方法参数类型。 请参阅<<mvc-ann-cookievalue,@CookieValue>>.

| `@RequestBody`
| 用于访问HTTP请求正文。 通过使用 `HttpMessageConverter` 实现将正文内容转换为声明的方法参数类型。 请参阅 <<mvc-ann-requestbody, @RequestBody>>。

| `HttpEntity<B>`
| 用于访问请求标头和正文。 使用HttpMessageConverter转换正文。 见<<mvc-ann-httpentity,HttpEntity>>.

| `@RequestPart`
| 要访问 `multipart/form-data` 请求中的部件，请使用 `HttpMessageConverter` 转换部件的主体。 见<<mvc-multipart-forms,Multipart>>。

| `java.util.Map`, `org.springframework.ui.Model`, `org.springframework.ui.ModelMap`
| 用于访问HTML控制器中使用的模型，并将其作为视图呈现的一部分暴露给模板。

| `RedirectAttributes`
| 指定在重定向（即，要附加到查询字符串）时使用的属性，以及临时存储的flash属性，直到重定向后的请求为止。 请参阅<<mvc-redirecting-passing-data,重定向属性>> 和<<mvc-flash-attributes,Flash属性>>。

| `@ModelAttribute`
| 用于访问模型中的现有属性（如果不存在则实例化），并应用数据绑定和验证。 请参阅<<mvc-ann-modelattrib-method-args,@ModelAttribute>>以及  <<mvc-ann-modelattrib-methods,Model>>和<<mvc-ann-initbinder,DataBinder>>。

    请注意，使用 `@ModelAttribute` 是可选的（例如，设置其属性）。 请参阅本表末尾的“任何其他参数”。

| `Errors`, `BindingResult`
| 用于访问来自命令对象的验证和数据绑定的错误（即 `@ModelAttribute` 参数）或来自验证 `@RequestBody` 或 `@RequestPart` 参数的错误。 您必须在经过验证的方法参数后立即声明 `Errors` 或 `BindingResult` 参数。

| `SessionStatus` + class-level `@SessionAttributes`
| 用于标记表单处理完成，从而触发通过类级别 `@SessionAttributes` 注解声明的会话属性的清除。 有关更多详细信息，请参阅  <<mvc-ann-sessionattributes,@SessionAttributes>>。

| `UriComponentsBuilder`
| 用于准备相对于当前请求的主机，端口，方案，上下文路径和servlet映射的文字部分的URL。 请参阅<<mvc-uri-building,URI Links>>.

| `@SessionAttribute`
| 用于访问任何会话属性，与由于类级别 `@SessionAttributes` 声明的结束形成对比。 有关更多详细信息，请参阅<<mvc-ann-sessionattribute, @SessionAttribute>>.

| `@RequestAttribute`
| 用于访问请求属性。 有关更多详细信息，请参阅<<mvc-ann-requestattrib,@RequestAttribute>>.

| Any other argument
| 如果方法参数与此表中的任何值不匹配，并且它是一个简单类型（由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty] 确定， 则它被解析为 `@RequestParam`。否则，它将被解析为 `@ModelAttribute`。
|===


[[mvc-ann-return-types]]
==== 返回值
[.small]#<<web-reactive.adoc#webflux-ann-return-types, WebFlux>>#

下表描述了支持的控制器方法返回值。 所有返回值都支持响应式类型。

[cols="1,2", options="header"]
|===
| Controller method return value | Description

| `@ResponseBody`
|  返回值通过 `HttpMessageConverter` 实现转换并写入响应。 请参阅<<mvc-ann-responsebody,@ResponseBody>>.

| `HttpEntity<B>`, `ResponseEntity<B>`
| 指定完整响应（包括HTTP头和主体）的返回值将通过 `HttpMessageConverter` 实现转换并写入响应。 请参阅 <<mvc-ann-responseentity,ResponseEntity>>。

| `HttpHeaders`
| 用于返回带头部信息且没有正文的响应。

| `String`
| 要使用 `ViewResolver` 实现解析的视图名称，并与隐式模型一起使用 - 通过命令对象和 `@ModelAttribute` 方法确定。 处理程序方法还可以通过声明 `Model` 参数以编程方式丰富模型（请参阅<<mvc-ann-requestmapping-registration,显式注册>> ）。

| `View`
| 用于与隐式模型一起呈现的 `View` 实例 - 通过命令对象和 `@ModelAttribute` 方法确定。 处理程序方法还可以通过声明 `Model` 参数以编程方式丰富模型（请参阅<<mvc-ann-requestmapping-registration,显式注册>>）。

| `java.util.Map`, `org.springframework.ui.Model`
| 要添加到隐式模型的属性，通过 `RequestToViewNameTranslator` 隐式确定视图名称。

| `@ModelAttribute`
| 要添加到模型的属性，通过 `RequestToViewNameTranslator` 隐式确定视图名称。

  请注意，`@ModelAttribute` 是可选的。 请参阅本表末尾的“任何其他返回值”。

| `ModelAndView` object
| 要使用的视图和模型属性，以及（可选）响应状态。

| `void`
| 如果具有 `void` 返回类型（或返回值为 `null` ）的方法，如果它还具有 `ServletResponse`，`OutputStream` 参数或 `@ResponseStatus` 注解， 则认为已完全处理该响应。 如果控制器已进行正 `ETag` 或 `lastModified` 时间戳检查，则也是如此（有关详细信息，请参阅<<mvc-caching-etag-lastmodified,Controllers>> ）。
    如果以上都不是真的，则 `void` 返回类型也可以指示REST控制器的“无响应主体”或HTML控制器的默认视图名称选择。

| `DeferredResult<V>`
| 从任何线程异步生成任何前面的返回值 - 例如，由于某些事件或回调。 请参阅<<mvc-ann-async,异步请求>>和 <<mvc-ann-async-deferredresult,DeferredResult>>.

| `Callable<V>`
| 在Spring MVC管理的线程中异步生成上述任何返回值。 请参阅 和 <<mvc-ann-async-callable,Callable>>.

| `ListenableFuture<V>`,
  `java.util.concurrent.CompletionStage<V>`,
  `java.util.concurrent.CompletableFuture<V>`
| 作为替代 `DeferredResult` 的便捷操作（例如，当底层服务返回其中一个时）。

| `ResponseBodyEmitter`, `SseEmitter`
| 使用 `HttpMessageConverter` 实现以异步方式发送对象流以写入响应。 还支持 `ResponseEntity` 的主体。 请参阅<<mvc-ann-async,异步请求>>和<<mvc-ann-async-http-streaming, HTTP Streaming>>.

| `StreamingResponseBody`
| 异步写入响应 `OutputStream`。 还支持 `ResponseEntity` 的主体。 请参阅<<mvc-ann-async,异步请求>>和<<mvc-ann-async-http-streaming, HTTP Streaming>>.

| Reactive types -- Reactor, RxJava, or others through `ReactiveAdapterRegistry`
| 使用 `multi-value` 流（例如，`Flux`, `Observable`）替代 `DeferredResult` 收集到 `List` 中。

 对于流式场景(例如, `text/event-stream`, `application/json+stream`), `SseEmitter` 和 `ResponseBodyEmitter` 使用的是在Spring MVC 管理的线程上执行 `ServletOutputStream` 阻塞I/O，这是 针对每一个 `Write` 的

请参阅<<mvc-ann-async,异步请求>> 和 <<mvc-ann-async-reactive-types,Reactive Types>>.

| Any other return value
| 任何与此表中任何早期值不匹配且返回值为 `String` 或 `void` 的返回值都被视为视图名称（通过 `RequestToViewNameTranslator` 应用默认视图名称选择）， 前提是它不是简单类型，由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty] 确定，简单类型的值仍未解决。
|===


[[mvc-ann-typeconversion]]
==== 类型转换
[.small]#<<web-reactive.adoc#webflux-ann-typeconversion, WebFlux>>#

如果参数声明为 `String` 以外的其他参数，则表示某些带注解的控制器方法参数（例如 `@RequestParam`, `@RequestHeader`, `@PathVariable`, `@MatrixVariable`, 和 `@CookieValue`）可能需要进行类型转换。

对于此类情况，将根据配置的转换器自动应用类型转换。 默认情况下，支持简单类型（`int`, `long`, `Date` 和其他）。 您可以通过 `WebDataBinder`（请参阅<<mvc-ann-initbinder,DataBinder>>）或使用 `FormattingConversionService` 注册 `Formatters` 来自定义类型转换。 请参见 <<core.adoc#format, Spring Field Formatting>>。


[[mvc-ann-matrix-variables]]
==== Matrix Variables
[.small]#<<web-reactive.adoc#webflux-ann-matrix-variables, WebFlux>>#

https://tools.ietf.org/html/rfc3986#section-3.3[RFC 3986] 讨论了路径段中的携带键值对。 在Spring MVC中，我们将那些基于Tim Berners-Lee的 https://www.w3.org/DesignIssues/MatrixURIs.html["`old post`"] 称为 "`matrix variables（矩阵变量）`" ，但它们也可以称为URI路径参数。

矩阵变量可以在任意路径段落中出现，每对矩阵变量之间使用分号隔开，多个值可以用逗号隔开（例如，`/cars;color=red,green;year=2012`）， 也可以通过重复的变量名称指定多个值（例如，`color=red;color=green;color=blue`）。

如果URL有可能会包含矩阵变量，那么在请求路径的映射配置上就需要使用URI模板来体现。这样才能确保请求可以被正确地映射，而不管矩阵变量在URI中是否出现、出现的次序是怎样的等。以下示例使用矩阵变量：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /pets/42;q=11;r=22

	@GetMapping("/pets/{petId}")
	public void findPet(@PathVariable String petId, @MatrixVariable int q) {

		// petId == 42
		// q == 11
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /pets/42;q=11;r=22

	@GetMapping("/pets/{petId}")
	fun findPet(@PathVariable petId: String, @MatrixVariable q: Int) {

		// petId == 42
		// q == 11
	}
----

由于任意路径段落中都可以含有矩阵变量，在某些场景下，开发者需要用更精确的信息来指定矩阵变量的位置。以下示例说明如何执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /owners/42;q=11/pets/21;q=22

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public void findPet(
			@MatrixVariable(name="q", pathVar="ownerId") int q1,
			@MatrixVariable(name="q", pathVar="petId") int q2) {

		// q1 == 11
		// q2 == 22
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /owners/42;q=11/pets/21;q=22

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	fun findPet(
			@MatrixVariable(name = "q", pathVar = "ownerId") q1: Int,
			@MatrixVariable(name = "q", pathVar = "petId") q2: Int) {

		// q1 == 11
		// q2 == 22
	}
----

矩阵变量可以定义为可选，并指定默认值，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /pets/42

	@GetMapping("/pets/{petId}")
	public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {

		// q == 1
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /pets/42

	@GetMapping("/pets/{petId}")
	fun findPet(@MatrixVariable(required = false, defaultValue = "1") q: Int) {

		// q == 1
	}
----

要获取所有矩阵变量，可以使用 `MultiValueMap`，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	public void findPet(
			@MatrixVariable MultiValueMap<String, String> matrixVars,
			@MatrixVariable(pathVar="petId") MultiValueMap<String, String> petMatrixVars) {

		// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
		// petMatrixVars: ["q" : 22, "s" : 23]
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// GET /owners/42;q=11;r=12/pets/21;q=22;s=23

	@GetMapping("/owners/{ownerId}/pets/{petId}")
	fun findPet(
			@MatrixVariable matrixVars: MultiValueMap<String, String>,
			@MatrixVariable(pathVar="petId") petMatrixVars: MultiValueMap<String, String>) {

		// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
		// petMatrixVars: ["q" : 22, "s" : 23]
	}
----

请注意，您需要启用矩阵变量的使用。 在MVC Java配置中，您需要通过<<mvc-config-path-matching,PathMatchConfigurer>>将 `removeSemicolonContent`=false 设置为 `UrlPathHelper`。 在MVC XML命名空间中，您可以设置 `<mvc:annotation-driven enable-matrix-variables="true"/>`。


[[mvc-ann-requestparam]]
==== `@RequestParam`
[.small]#<<web-reactive.adoc#webflux-ann-requestparam, WebFlux>>#

您可以使用 `@RequestParam` 注解将Servlet请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。

以下示例显示了如何执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@RequestMapping("/pets")
	public class EditPetForm {

		// ...

		@GetMapping
		public String setupForm(@RequestParam("petId") int petId, Model model) { <1>
			Pet pet = this.clinic.loadPet(petId);
			model.addAttribute("pet", pet);
			return "petForm";
		}

		// ...

	}
----
<1> 使用 `@RequestParam` 绑定 `petId`。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.ui.set

	@Controller
	@RequestMapping("/pets")
	class EditPetForm {

		// ...

		@GetMapping
		fun setupForm(@RequestParam("petId") petId: Int, model: Model): String { // <1>
			val pet = this.clinic.loadPet(petId);
			model["pet"] = pet
			return "petForm"
		}

		// ...

	}
----
<1> 使用 `@RequestParam` 绑定 `petId`。

若参数使用了该注解，则该参数默认是必须提供的.但您可以通过将 `@RequestParam` 注解的 `required` 属性设置为 `false` 或通过使用 `java.util.Optional` 包装器声明参数来指定方法参数是可选的。

如果目标方法参数类型不是 `String`，则会自动应用类型转换。 请参阅<<mvc-ann-typeconversion,类型转换>>。

将参数类型声明为数组或列表允许为同一参数名称解析多个参数值。

当 `@RequestParam` 注解声明为 `Map<String, String>` 或 `MultiValueMap<String, String>` 时， 如果注解中未指定参数名称，则会使用每个给定参数名称的请求参数值填充映射。

请注意，使用 `@RequestParam` 是可选的（例如，设置其属性）。 默认情况下， 任何属于简单值类型的参数（由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty] 确定）并且未被任何其他参数解析器解析，都被视为使用 `@RequestParam` 进行注解。


[[mvc-ann-requestheader]]
==== `@RequestHeader`
[.small]#<<web-reactive.adoc#webflux-ann-requestheader, WebFlux>>#

您可以使用 `@RequestHeader` 注解将请求标头绑定到控制器中的方法参数。

考虑以下请求，请求头为:

[literal]
[subs="verbatim,quotes"]
----
Host                    localhost:8080
Accept                  text/html,application/xhtml+xml,application/xml;q=0.9
Accept-Language         fr,en-gb;q=0.7,en;q=0.3
Accept-Encoding         gzip,deflate
Accept-Charset          ISO-8859-1,utf-8;q=0.7,*;q=0.7
Keep-Alive              300
----

以下示例获取 `Accept-Encoding` 和 `Keep-Alive` 头的值：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/demo")
	public void handle(
			@RequestHeader("Accept-Encoding") String encoding, // <1>
			@RequestHeader("Keep-Alive") long keepAlive) { // <2>
		//...
	}
----
<1> 获取 `Accept-Encoding` 头部信息
<2> 获取 `Keep-Alive` 头部信息.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/demo")
	fun handle(
			@RequestHeader("Accept-Encoding") encoding: String, // <1>
			@RequestHeader("Keep-Alive") keepAlive: Long) { // <2>
		//...
	}
----
<1> 获取 `Accept-Encoding` 头部信息
<2> 获取 `Keep-Alive` 头部信息.

如果目标方法参数类型不是String，则会自动应用类型转换。 请参阅<<mvc-ann-typeconversion,类型转换>>。

在 `Map<String, String>，MultiValueMap<String, String>` 或 `HttpHeaders` 参数上使用 `@RequestHeader` 注解时，将使用所有请求头值填充映射。

TIP: 内置支持可用于将逗号分隔的字符串转换为字符串或字符串集或类型转换系统已知的其他类型。 例如，使用 `@RequestHeader("Accept")` 注解的方法参数可以是 `String` 类型，也可以是 `String[]` 或 `List<String>`。


[[mvc-ann-cookievalue]]
==== `@CookieValue`
[.small]#<<web-reactive.adoc#webflux-ann-cookievalue, WebFlux>>#

您可以使用 `@CookieValue` 注解将HTTP cookie 的值绑定到控制器中的方法参数。

考虑使用以下cookie的请求:

[literal,subs="verbatim,quotes"]
----
JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84
----

以下示例显示了如何获取cookie值：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/demo")
	public void handle(@CookieValue("JSESSIONID") String cookie) { <1>
		//...
	}
----
<1> 获取 `JSESSIONID` cookie的值


[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/demo")
	fun handle(@CookieValue("JSESSIONID") cookie: String) { // <1>
		//...
	}
----
<1> 获取 `JSESSIONID` cookie的值

如果目标方法参数类型不是String，则会自动应用类型转换。 请参阅<<mvc-ann-typeconversion,类型转换>>。

[[mvc-ann-modelattrib-method-args]]
==== `@ModelAttribute`
[.small]#<<web-reactive.adoc#webflux-ann-modelattrib-method-args, WebFlux>>#

您可以在方法参数上使用 `@ModelAttribute` 注解来从模型访问属性，或者如果不存在则将其实例化。 model属性还覆盖了名称与字段名称匹配的HTTP Servlet请求参数的值。 这称为数据绑定，它使您不必处理解析和转换单个查询参数和表单字段。 以下示例显示了如何执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public String processSubmit(@ModelAttribute Pet pet) { } <1>
----
<1> 绑定一个 `Pet` 的实例。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
fun processSubmit(@ModelAttribute pet: Pet): String { } // <1>
----
<1> 绑定一个 `Pet` 的实例。

上面的 `Pet` 实例解析如下：:

* 它可能来自已经添加的<<mvc-ann-modelattrib-methods,Model>>.
* 它可能因为<<mvc-ann-sessionattributes,@SessionAttributes>>注解的使用已经存在在model中.
* 它可能是由URI模板变量和转换中取得的（下面会详细讲解）.
* 它可能是调用了自身的默认构造器被实例化出来的.
* 他可能从调用具有与Servlet请求参数匹配的参数的 `"primary constructor"`。 参数名称通过JavaBeans `@ConstructorProperties` 或字节码中的运行时保留参数名称确定。

虽然通常使用<<mvc-ann-modelattrib-methods,Model>>来使用属性填充模型，但另一种替代方法是依赖于 `Converter<String, T>` 和URI路径变量。 在以下示例中，model 属性名称 `account` 匹配URI路径变量 `account`，并通过将String字符串传递到已注册的 `Converter<String, Account>` 转换器来加载 `Account` ：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PutMapping("/accounts/{account}")
	public String save(@ModelAttribute("account") Account account) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PutMapping("/accounts/{account}")
	fun save(@ModelAttribute("account") account: Account): String {
		// ...
	}
----

下一步就是数据的绑定，`WebDataBinder` 类能将请求参数，包括字符串的查询参数和表单字段等，通过名称匹配到model的属性上。
成功匹配的字段在需要的时候会进行一次类型转换（从String类型到目标字段的类型），然后被填充到model对应的属性中， 有关数据绑定（和验证）的更多信息，请参阅<<core.adoc#validation, Validation>>。 有关自定义数据绑定的更多信息，请参阅<<mvc-ann-initbinder,DataBinder>>。

数据绑定可能导致错误。 默认情况下，会引发 `BindException` 。 但是，要在控制器方法中检查此类错误，可以在 `@ModelAttribute` 旁边添加一个 `BindingResult` 参数，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) { // <1>
		if (result.hasErrors()) {
			return "petForm";
		}
		// ...
	}
----
<1> 在 `@ModelAttribute` 旁边添加 `BindingResult`。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	fun processSubmit(@ModelAttribute("pet") pet: Pet, result: BindingResult): String { // <1>
		if (result.hasErrors()) {
			return "petForm"
		}
		// ...
	}
----
<1> 在 `@ModelAttribute` 旁边添加 `BindingResult`。

在某些情况下，您可能希望在没有数据绑定的情况下访问 `model` 属性。对于这种情况，您可以将model注入控制器并直接访问它，或者设置 `@ModelAttribute(binding=false)`，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ModelAttribute
	public AccountForm setUpForm() {
		return new AccountForm();
	}

	@ModelAttribute
	public Account findAccount(@PathVariable String accountId) {
		return accountRepository.findOne(accountId);
	}

	@PostMapping("update")
	public String update(@Valid AccountForm form, BindingResult result,
			@ModelAttribute(binding=false) Account account) { // <1>
		// ...
	}
----
<1> 设置 `@ModelAttribute(binding=false)`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ModelAttribute
	fun setUpForm(): AccountForm {
		return AccountForm()
	}

	@ModelAttribute
	fun findAccount(@PathVariable accountId: String): Account {
		return accountRepository.findOne(accountId)
	}

	@PostMapping("update")
	fun update(@Valid form: AccountForm, result: BindingResult,
			   @ModelAttribute(binding = false) account: Account): String { // <1>
		// ...
	}
----
<1> 设置 `@ModelAttribute(binding=false)`.

通过添加 `javax.validation.Valid` 注解或Spring的 `@Validated` 注解（<<core.adoc#validation-beanvalidation, Bean Validation>>和<<core.adoc#validation, Spring validation>>），您可以在数据绑定后自动应用验证。 以下示例显示了如何执行此操作：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
		@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
		public String processSubmit(@Valid @ModelAttribute("pet") Pet pet, BindingResult result) { // <1>
			if (result.hasErrors()) {
				return "petForm";
			}
			// ...
		}
----
<1> 验证 `Pet` 实例.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/owners/{ownerId}/pets/{petId}/edit")
	fun processSubmit(@Valid @ModelAttribute("pet") pet: Pet, result: BindingResult): String { // <1>
		if (result.hasErrors()) {
			return "petForm"
		}
		// ...
	}
----

请注意，使用 `@ModelAttribute` 是可选的（例如，设置其属性）。 默认情况下，任何非简单值类型的参数（由{api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty]确定）并且未被任何其他参数解析器解析，都被视为使用 `@ModelAttribute` 进行注解。

[[mvc-ann-sessionattributes]]
==== `@SessionAttributes`
[.small]#<<web-reactive.adoc#webflux-ann-sessionattributes, WebFlux>>#

`@SessionAttributes` 用于在请求之间的HTTP Servlet会话中存储model属性。 它是一个类型级别的注解，用于声明特定控制器使用的会话属性。 这通常列出model属性的名称或model属性的类型，这些属性应该透明地存储在会话中以供后续访问请求使用。

以下示例使用 `@SessionAttributes` 注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@SessionAttributes("pet") // <1>
	public class EditPetForm {
		// ...
	}
----
<1> 使用 `@SessionAttributes` 注解.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	@SessionAttributes("pet") // <1>
	public class EditPetForm {
		// ...
	}
----
<1> 使用 `@SessionAttributes` 注解.

在第一个请求中，当名称为 `pet` 的model属性添加到模型中时，他会自动保存到HTTP Servlet会话中，并保持不变，直到另一个控制器方法使用 `SessionStatus` 方法参数来清除存储，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@SessionAttributes("pet") // <1>
	public class EditPetForm {

		// ...

		@PostMapping("/pets/{id}")
		public String handle(Pet pet, BindingResult errors, SessionStatus status) {
			if (errors.hasErrors) {
				// ...
			}
				status.setComplete(); // <2>
				// ...
			}
		}
	}
----
<1> 在Servlet会话中存储 `Pet` 值。
<2> 在Servlet会话中清除 `Pet` 值。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
@Controller
@SessionAttributes("pet") // <1>
class EditPetForm {

	// ...

	@PostMapping("/pets/{id}")
	fun handle(pet: Pet, errors: BindingResult, status: SessionStatus): String {
		if (errors.hasErrors()) {
			// ...
		}
		status.setComplete() // <2>
		// ...
	}
}
----
<1> 在Servlet会话中存储 `Pet` 值。
<2> 在Servlet会话中清除 `Pet` 值。


[[mvc-ann-sessionattribute]]
==== `@SessionAttribute`
[.small]#<<web-reactive.adoc#webflux-ann-sessionattribute, WebFlux>>#

如果需要访问已存在的被全局session属性，例如在控制器之外（如通过过滤器）的（可有可无），请在方法参数上使用 `@SessionAttribute` 注解：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RequestMapping("/")
	public String handle(@SessionAttribute User user) { <1>
		// ...
	}
----
<1> 使用 `@SessionAttribute` 注解.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RequestMapping("/")
	fun handle(@SessionAttribute user: User): String { // <1>
		// ...
	}
----

对于需要添加或删除会话属性的用例，请考虑将 `org.springframework.web.context.request.WebRequest` 或 `javax.servlet.http.HttpSession` 注入控制器方法。

作为控制器工作流的一部分，在会话中临时存储模型属性的方法可以使用 `@SessionAttributes`，详情请参阅<<mvc-ann-sessionattributes,@SessionAttributes>>。

[[mvc-ann-requestattrib]]
==== `@RequestAttribute`
[.small]#<<web-reactive.adoc#webflux-ann-requestattrib, WebFlux>>#

与 `@SessionAttribute` 类似，`@RequestAttribute` 注解可用于访问由过滤器（`Filter`）或拦截器（`HandlerInterceptor`）创建的已存在的请求属性:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/")
	public String handle(@RequestAttribute Client client) { // <1>
		// ...
	}
----
<1> 使用 `@RequestAttribute` 注解.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/")
	fun handle(@RequestAttribute client: Client): String { // <1>
		// ...
	}
----
<1> 使用 `@RequestAttribute` 注解.


[[mvc-redirecting-passing-data]]
==== 重定向属性

默认情况下，所有模型属性都被视为在重定向URL中公开为URI模板变量。 在其余属性中，原始类型或集合或基本类型数组的属性将自动附加为查询参数。

如果专门为重定向准备了模型实例，期望的结果则是将原始类型属性作为查询参数。 但是，在带注解的控制器中，为了渲染目的，模型可以包含其他属性（例如，下拉字段值）。
为了避免在URL中出现此类属性的可能性，`@RequestMapping` 方法可以声明 `RedirectAttributes` 类型的参数， 并使用它来指定可供 `RedirectView` 使用的确切属性。 如果方法重定向，则使用 `RedirectAttributes` 的内容。 否则，使用模型的内容。

`RequestMappingHandlerAdapter` 提供了一个名为 `ignoreDefaultModelOnRedirect` 的标志，您可以使用该标志指示如果控制器方法重定向，则永远不应使用默认模型的内容。
相反，控制器方法应声明 `RedirectAttributes` 类型的属性，如果不这样做，则不应将任何属性传递给 `RedirectView`。 MVC命名空间和MVC Java配置都将此标志设置为 `false`，以保持向后兼容性。 但是，对于新应用程序，我们建议将其设置为 `true`。

请注意，扩展重定向URL时，当前请求中的URI模板变量会自动可用，您需要通过 `Model` 或 `RedirectAttributes` 显式添加它们。 以下示例显示如何定义重定向：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/files/{path}")
	public String upload(...) {
		// ...
		return "redirect:files/{path}";
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/files/{path}")
	fun upload(...): String {
		// ...
		return "redirect:files/{path}"
	}
----

将数据传递到重定向目标的另一种方法是使用<<mvc-flash-attributes,flash属性>>。 与其他重定向属性不同，Flash属性保存在HTTP会话中（因此，不会出现在URL中）。 有关更多信息，请参阅 Flash 属性。


[[mvc-flash-attributes]]
==== Flash 属性

Flash属性（flash attributes）提供了一个请求为另一个请求存储有用属性的方法。这在重定向的时候最常使用，比如常见的POST/REDIRECT/GET模式。 Flash属性会在重定向前被暂时地保存起来（通常是保存在session中），重定向后会重新被下一个请求取用并立即从原保存地移除。

为支持flash属性，Spring MVC提供了两个抽象。 `FlashMap` 被用来存储flash属性，而用 `FlashMapManager` 来存储、取回、管理 `FlashMap` 的实例。

对flash属性的支持默认是启用 "`on`" 的，并不需要显式声明，不过没用到它时它绝不会主动地去创建HTTP会话（session）。对于每个请求，框架都会"`input`" 一个 `FlashMap`，里面存储了从上个请求（如果有）保存下来的属性；
同时，每个请求也会 "`output`" `FlashMap`，里面保存了要给下个请求使用的属性。 两个FlashMap实例在Spring MVC应用中的任何地点都可以通过 `RequestContextUtils` 工具类的静态方法取得。

控制器通常不需要直接接触FlashMap。一般是通过 `@RequestMapping` 方法去接受 `RedirectAttributes` 类型的参数，然后直接地往其中添加flash属性。
通过 `RedirectAttributes` 对象添加进去的flash属性会自动被填充到请求的 "`output`" `FlashMap` 对象中去。类似地，重定向后 "`input`" 的 `FlashMap` 属性也会自动被添加到服务重定向URL的控制器参数 `Model` 中去

.匹配请求所使用的flash属性
****
flash属性的概念在其他许多的Web框架中也存在，并且实践证明有时可能会导致并发上的问题。这是因为从定义上讲，flash属性保存的时间是到下个请求接收到之前。 问题在于，`"next"` 请求不一定刚好就是需要重定向到的那个请求，它有可能是其他的异步请求（比如polling请求或者资源请求等）。这会导致flash属性在到达真正的目标请求前就被移除了。

为了减少这个问题发生的可能性，重定向视图 `RedirectView` 会自动为一个 `FlashMap` 实例记录其目标重定向URL的路径和查询参数。然后，默认的 `FlashMapManager` 会在为请求查找其该 "input" 的 `FlashMap` 时，匹配这些信息。

这并不能完全解决重定向的并发问题，但极大程度地减少了这种可能性，因为它可以从重定向URL已有的信息中来做匹配。因此，一般只有在重定向的场景下，才推荐使用flash属性。
****


[[mvc-multipart-forms]]
==== Multipart
[.small]#<<web-reactive.adoc#webflux-multipart-forms, WebFlux>>#

<<mvc-multipart,启用>> `MultipartResolver` 后，将解析具有 `multipart/form-data` 的POST请求的内容，并将其作为常规请求参数进行访问。 以下示例访问一个常规表单字段和一个上载文件：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class FileUploadController {

		@PostMapping("/form")
		public String handleFormUpload(@RequestParam("name") String name,
				@RequestParam("file") MultipartFile file) {

			if (!file.isEmpty()) {
				byte[] bytes = file.getBytes();
				// store the bytes somewhere
				return "redirect:uploadSuccess";
			}
			return "redirect:uploadFailure";
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class FileUploadController {

		@PostMapping("/form")
		fun handleFormUpload(@RequestParam("name") name: String,
							@RequestParam("file") file: MultipartFile): String {

			if (!file.isEmpty) {
				val bytes = file.bytes
				// store the bytes somewhere
				return "redirect:uploadSuccess"
			}
			return "redirect:uploadFailure"
		}
	}
----

将参数类型声明为 `List<MultipartFile>` 允许为同一参数名称解析多个文件。

当 `@RequestParam` 注解声明为 `Map<String, MultipartFile>` 或 `MultiValueMap<String, MultipartFile>` 时，如果注解中未指定参数名称，则会使用每个给定参数名称的多部分文件填充map。

NOTE: 使用Servlet 3.0多部分解析，您也可以将 `javax.servlet.http.Part` 而不是Spring的 `MultipartFile` 声明为方法参数或集合值类型。

您还可以将多部分内容用作绑定到<<mvc-ann-modelattrib-method-args, 命令对象>>的数据的一部分。 例如，前面示例中的表单字段和文件可以是表单对象上的字段，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	class MyForm {

		private String name;

		private MultipartFile file;

		// ...
	}

	@Controller
	public class FileUploadController {

		@PostMapping("/form")
		public String handleFormUpload(MyForm form, BindingResult errors) {
			if (!form.getFile().isEmpty()) {
				byte[] bytes = form.getFile().getBytes();
				// store the bytes somewhere
				return "redirect:uploadSuccess";
			}
			return "redirect:uploadFailure";
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class MyForm(val name: String, val file: MultipartFile, ...)

	@Controller
	class FileUploadController {

		@PostMapping("/form")
		fun handleFormUpload(form: MyForm, errors: BindingResult): String {
			if (!form.file.isEmpty) {
				val bytes = form.file.bytes
				// store the bytes somewhere
				return "redirect:uploadSuccess"
			}
			return "redirect:uploadFailure"
		}
	}
----


还可以在RESTful服务方案中从非浏览器客户端提交多部分请求。 以下示例显示了带有JSON的文件：

[literal,subs="verbatim,quotes"]
----
POST /someUrl
Content-Type: multipart/mixed

--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="meta-data"
Content-Type: application/json; charset=UTF-8
Content-Transfer-Encoding: 8bit

{
	"name": "value"
}
--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp
Content-Disposition: form-data; name="file-data"; filename="file.properties"
Content-Type: text/xml
Content-Transfer-Encoding: 8bit
... File Data ...
----

对于名称为 "meta-data" 的部分，可以通过控制器方法上的 `@RequestParam` `String` metadata参数来获得。
但对于那部分请求体中为JSON格式数据的请求， 可能更想通过接受一个对应的强类型对象，就像 `@RequestBody` 通过 <<integration.adoc#rest-message-conversion, HttpMessageConverter>> 将一般请求的请求体转换成一个对象一样。使用 `@RequestPart` 注解访问多部分：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/")
	public String handle(@RequestPart("meta-data") MetaData metadata,
			@RequestPart("file-data") MultipartFile file) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/")
	fun handle(@RequestPart("meta-data") metadata: MetaData,
			@RequestPart("file-data") file: MultipartFile): String {
		// ...
	}
----

您可以将 `@RequestPart` 与 `javax.validation.Valid` 结合使用，或使用Spring的 `@Validated` 注解，这两种注解都会导致应用标准Bean验证。
默认情况下，验证错误会导致 `MethodArgumentNotValidException`， 并将其转换为400（BAD_REQUEST）响应。 或者，您可以通过 `Errors` 或 `BindingResult` 参数在控制器内本地处理验证错误，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/")
	public String handle(@Valid @RequestPart("meta-data") MetaData metadata,
			BindingResult result) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/")
	fun handle(@Valid @RequestPart("meta-data") metadata: MetaData,
			result: BindingResult): String {
		// ...
	}
----



[[mvc-ann-requestbody]]
==== `@RequestBody`
[.small]#<<web-reactive.adoc#webflux-ann-requestbody, WebFlux>>#

您可以使用 `@RequestBody` 注解通过 <<integration.adoc#rest-message-conversion, `HttpMessageConverter`>> 将请求主体读取并反序列化为 `Object`。 以下示例使用 `@RequestBody` 参数:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(@RequestBody Account account) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(@RequestBody account: Account) {
		// ...
	}
----

您可以使用<<mvc-config,MVC Config >>的<<mvc-config-message-converters,Message Converters>>选项来配置或自定义消息转换。

您可以将 `@RequestBody` 与 `javax.validation.Valid` 或Spring的 `@Validated` 注解结合使用，这两种注解都会导致应用标准Bean验证。
默认情况下，验证错误会导致 `MethodArgumentNotValidException`，并将其转换为400（BAD_REQUEST）响应。 或者，您可以通过 `Errors` 或 `BindingResult` 参数在控制器内本地处理验证错误，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(@Valid @RequestBody Account account, BindingResult result) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(@Valid @RequestBody account: Account, result: BindingResult) {
		// ...
	}
----


[[mvc-ann-httpentity]]
==== HttpEntity
[.small]#<<web-reactive.adoc#webflux-ann-httpentity, WebFlux>>#

`HttpEntity` 与使用 <<mvc-ann-requestbody, `@RequestBody`>> 或多或少有些类似，但它基于一个公开请求头和正文的容器对象。 以下清单显示了一个示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping("/accounts")
	public void handle(HttpEntity<Account> entity) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping("/accounts")
	fun handle(entity: HttpEntity<Account>) {
		// ...
	}
----



[[mvc-ann-responsebody]]
==== `@ResponseBody`
[.small]#<<web-reactive.adoc#webflux-ann-responsebody, WebFlux>>#

您可以在方法上使用 `@ResponseBody` 注解，以通过<<integration.adoc#rest-message-conversion, HttpMessageConverter>>将返回序列化到响应主体。 以下清单显示了一个示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/accounts/{id}")
	@ResponseBody
	public Account handle() {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/accounts/{id}")
	@ResponseBody
	fun handle(): Account {
		// ...
	}
----

类级别也支持 `@ResponseBody` ，在这种情况下，它由所有控制器方法继承。 例如 `@RestController` 的效果，它只不过是一个用 `@Controller` 和 `@ResponseBody` 标记的元注解。

您可以将 `@ResponseBody` 与reactive类型一起使用。 有关更多详细信息，请参阅<<mvc-ann-async,异步请求>>和<<mvc-ann-async-reactive-types,Reactive 类型>>。

您可以使用 <<mvc-config,MVC Config>>的 <<mvc-config-message-converters,Message Converters>> 选项来配置或自定义消息转换。

您可以将 `@ResponseBody` 方法与JSON序列化视图结合使用。 有关详细信息，请参阅<<mvc-ann-jackson,Jackson JSON>> 。


[[mvc-ann-responseentity]]
==== ResponseEntity
[.small]#<<web-reactive.adoc#webflux-ann-responseentity, WebFlux>>#

`ResponseEntity` 与<<mvc-ann-responsebody,@ResponseBody>>类似，但具有状态和响应头。 例如:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/something")
	public ResponseEntity<String> handle() {
		String body = ... ;
		String etag = ... ;
		return ResponseEntity.ok().eTag(etag).build(body);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/something")
	fun handle(): ResponseEntity<String> {
		val body = ...
		val etag = ...
		return ResponseEntity.ok().eTag(etag).build(body)
	}
----

Spring MVC支持使用单值<<mvc-ann-async-reactive-types, reactive type>>异步生成 `ResponseEntity`，and/or 主体的单值和多值reactive类型。


[[mvc-ann-jackson]]
==== Jackson JSON

Spring为Jackson JSON库提供支持。

[[mvc-ann-jsonview]]
===== JSON 序列化视图
[.small]#<<web-reactive.adoc#webflux-ann-jsonview, WebFlux>>#

Spring MVC为https://www.baeldung.com/jackson-json-view-annotation[Jackson的序列化视图]提供内置支持，允许仅渲染Object中所有字段的子集。 为了与 `@ResponseBody` 控制器方法或者返回 `ResponseEntity` 的控制器方法一起使用，可以简单地将 `@JsonView` 注解放在参数上，指定需要使用的视图类或接口即可。如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RestController
	public class UserController {

		@GetMapping("/user")
		@JsonView(User.WithoutPasswordView.class)
		public User getUser() {
			return new User("eric", "7!jd#h23");
		}
	}

	public class User {

		public interface WithoutPasswordView {};
		public interface WithPasswordView extends WithoutPasswordView {};

		private String username;
		private String password;

		public User() {
		}

		public User(String username, String password) {
			this.username = username;
			this.password = password;
		}

		@JsonView(WithoutPasswordView.class)
		public String getUsername() {
			return this.username;
		}

		@JsonView(WithPasswordView.class)
		public String getPassword() {
			return this.password;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RestController
	class UserController {

		@GetMapping("/user")
		@JsonView(User.WithoutPasswordView::class)
		fun getUser() = User("eric", "7!jd#h23")
	}

	class User(
			@JsonView(WithoutPasswordView::class) val username: String,
			@JsonView(WithPasswordView::class) val password: String) {

		interface WithoutPasswordView
		interface WithPasswordView : WithoutPasswordView
	}
----

NOTE: `@JsonView` 允许一组视图类，但每个控制器方法只能指定一个。 如果需要激活多个视图，可以使用复合接口。

对于依赖视图的控制器，只需将序列化视图类添加到model中即可。如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class UserController extends AbstractController {

		@GetMapping("/user")
		public String getUser(Model model) {
			model.addAttribute("user", new User("eric", "7!jd#h23"));
			model.addAttribute(JsonView.class.getName(), User.WithoutPasswordView.class);
			return "userView";
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.ui.set

	@Controller
	class UserController : AbstractController() {

		@GetMapping("/user")
		fun getUser(model: Model): String {
			model["user"] = User("eric", "7!jd#h23")
			model[JsonView::class.qualifiedName] = User.WithoutPasswordView::class.java
			return "userView"
		}
	}
----



[[mvc-ann-modelattrib-methods]]
=== Model
[.small]#<<web-reactive.adoc#webflux-ann-modelattrib-methods, WebFlux>>#

您可以使用 `@ModelAttribute` 注解：

* 在 `@RequestMapping` 方法中的<<mvc-ann-modelattrib-method-args,方法参数>>，用于从 `model` 创建或访问Object并通过 `WebDataBinder` 将其绑定到请求。
* 作为 `@Controller` 或 `@ControllerAdvice` 类中的方法级注解，有助于在任何 `@RequestMapping` 方法调用之前初始化模型。
* 在 `@RequestMapping` 方法上标记其返回值是一个模型属性。

本节讨论 `@ModelAttribute` 注解可被应用在方法或方法参数上 - 前面列表中的第二项。控制器可以包含任意数量的 `@ModelAttribute` 方法。
在同一控制器中的 `@RequestMapping` 方法之前调用所有这些方法。 `@ModelAttribute` 方法也可以通过 `@ControllerAdvice` 在控制器之间共享。 有关更多详细信息，请参阅<<mvc-ann-controller-advice,Controller Advice>>  部分。

`@ModelAttribute` 方法具有灵活的方法签名。 除了与 `@ModelAttribute` 本身或请求体相关的任何内容外，它们支持许多与 `@RequestMapping` 方法相同的参数。

以下示例显示了 `@ModelAttribute` 方法：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ModelAttribute
	public void populateModel(@RequestParam String number, Model model) {
		model.addAttribute(accountRepository.findAccount(number));
		// add more ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ModelAttribute
	fun populateModel(@RequestParam number: String, model: Model) {
		model.addAttribute(accountRepository.findAccount(number))
		// add more ...
	}
----

以下示例仅添加一个属性:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ModelAttribute
	public Account addAccount(@RequestParam String number) {
		return accountRepository.findAccount(number);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ModelAttribute
	fun addAccount(@RequestParam number: String): Account {
		return accountRepository.findAccount(number)
	}
----


NOTE: 如果未明确指定名称，框架将根据属性的类型给予一个默认名称，如 {api-spring-framework}/core/Conventions.html[`Conventions`] 的javadoc中所述。 你可以通过设置 `@ModelAttribute` 注解的值来改变默认值。当向 `Model` 中直接添加属性时，请使用合适的重载方法 `addAttribute`。

`@ModelAttribute` 注解也可以被用在 `@RequestMapping` 方法上，这种情况下，`@RequestMapping` 方法的返回值将会被解释为model的一个属性，而非一个视图名。 此时视图名将以视图命名约定来方式来决议，与返回值为void的方法所采用的处理方法类似。`@ModelAttribute` 还可以自定义模型属性名称，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/accounts/{id}")
	@ModelAttribute("myAccount")
	public Account handle() {
		// ...
		return account;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/accounts/{id}")
	@ModelAttribute("myAccount")
	fun handle(): Account {
		// ...
		return account
	}
----



[[mvc-ann-initbinder]]
=== `DataBinder`
[.small]#<<web-reactive.adoc#webflux-ann-initbinder, WebFlux>>#

`@Controller` 或 `@ControllerAdvice` 类可以使用 `@InitBinder` 方法初始化 `WebDataBinder` 的实例，而这些方法又可以：


* 将请求参数（即表单或查询数据）绑定到模型对象。
* 将基于字符串的请求值（例如请求参数，路径变量，请求头，cookie等）转换为目标类型的控制器方法参数。
* 在呈现HTML表单时将模型对象值格式化为 `String` 值。

`@InitBinder` 方法可以注册特定于控制器的 `java.bean.PropertyEditor` 或Spring `Converter` 和 `Formatter` 组件。 此外，您可以使用<<mvc-config-conversion,MVC config>> 在全局共享的 `FormattingConversionService` 中注册 `Converter` 和 `Formatter` 类型。

`@InitBinder` 方法支持许多与 `@RequestMapping` 方法相同的参数，但 `@ModelAttribute`（命令对象）参数除外。 通常，它们使用 `WebDataBinder` 参数（用于注册）和 `void` 返回值进行声明。 以下清单显示了一个示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class FormController {

		@InitBinder // <1>
		public void initBinder(WebDataBinder binder) {
			SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
			dateFormat.setLenient(false);
			binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
		}

		// ...
	}
----
<1> 定义一个 `@InitBinder` 方法.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class FormController {

		@InitBinder // <1>
		fun initBinder(binder: WebDataBinder) {
			val dateFormat = SimpleDateFormat("yyyy-MM-dd")
			dateFormat.isLenient = false
			binder.registerCustomEditor(Date::class.java, CustomDateEditor(dateFormat, false))
		}

		// ...
	}
----
<1> 定义一个 `@InitBinder` 方法.

或者，当使用基于 `Formatter` 的设置时，您可以通过共享的 `FormattingConversionService` 重复使用相同的方法并注册特定于控制器的 `Formatter` 实现，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class FormController {

		@InitBinder // <1>
		protected void initBinder(WebDataBinder binder) {
			binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd"));
		}

		// ...
	}
----
<1> 使用自定义 formatter 定义一个 Defining an `@InitBinder` 方法.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class FormController {

		@InitBinder // <1>
		protected fun initBinder(binder: WebDataBinder) {
			binder.addCustomFormatter(DateFormatter("yyyy-MM-dd"))
		}

		// ...
	}
----
<1> 使用自定义 formatter 定义一个 Defining an `@InitBinder` 方法.

[[mvc-ann-exceptionhandler]]
=== 异常
[.small]#<<web-reactive.adoc#webflux-ann-controller-exceptions, WebFlux>>#

`@Controller` 和 <<mvc-ann-controller-advice, @ControllerAdvice>> 可以使用 `@ExceptionHandler` 方法来处理来自控制器方法的异常，如下例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class SimpleController {

		// ...

		@ExceptionHandler
		public ResponseEntity<String> handle(IOException ex) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class SimpleController {

		// ...

		@ExceptionHandler
		fun handle(ex: IOException): ResponseEntity<String> {
			// ...
		}
	}
----

该异常可能与顶级异常（即抛出直接 `IOException`）或顶级包装器中的异常（例如，包含在 `IllegalStateException` 内的 `IOException`）相匹配。

对于匹配的异常类型，最好将目标异常声明为方法参数，如前面的示例所示。当多个异常方法匹配时，根(root)异常匹配通常优先于原因(cause )异常匹配。 更具体地说，`ExceptionDepthComparator` 用于根据抛出的异常类型的深度对异常进行排序。

注解声明可以缩小要匹配的异常类型，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExceptionHandler({FileSystemException.class, RemoteException.class})
	public ResponseEntity<String> handle(IOException ex) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExceptionHandler(FileSystemException::class, RemoteException::class)
	fun handle(ex: IOException): ResponseEntity<String> {
		// ...
	}
----

您甚至可以使用特定异常类型列表中的非常通用的参数签名，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@ExceptionHandler({FileSystemException.class, RemoteException.class})
	public ResponseEntity<String> handle(Exception ex) {
		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@ExceptionHandler(FileSystemException::class, RemoteException::class)
	fun handle(ex: Exception): ResponseEntity<String> {
		// ...
	}
----

[NOTE]
====
root 和 cause 异常匹配之间的区别可能是令人惊讶的。

在前面显示的 `IOException` 变体中，通常使用实际的 `FileSystemException` 或 `RemoteException` 实例作为参数调用该方法，因为它们都是从 `IOException` 扩展的。 但是，如果任何此类异常在包装器内传播，而该异常本身就是 `IOException`，则传入的异常实例就是包装器异常。

在 `handle(Exception)` 变体中，行为更简单。 这总是在包装场景中使用包装器异常调用，在这种情况下可以通过 `ex.getCause()` 找到实际匹配的异常。 传入的异常仅在实际的 `FileSystemException` 或 `RemoteException` 实例被抛出为顶级异常时才会发生。
====

我们通常建议您在参数签名中尽可能具体，减少root和cause异常类型之间不匹配的可能性。 考虑将多匹配方法分解为单独的 `@ExceptionHandler` 方法，每个方法通过其签名匹配单个特定异常类型。

在具有多个 `@ControllerAdvice` 组成中，我们建议在 `@ControllerAdvice` 上声明根异常映射，并使用相应的顺序进行优先级排序。
虽然根异常匹配优先于某个原因，但这是在给定控制器或 `@ControllerAdvice` 类的方法中定义的。 这意味着优先级较高的 `@ControllerAdvice` bean上的原因匹配优先于较低优先级的 `@ControllerAdvice` bean上的任何匹配（例如，root）。

最后但同样重要的是， 可以通过 `@ExceptionHandler` 方法的实现，讲异常以原始的形式重新抛出，并提供给特定的异常实例。 这在您仅对根级别匹配或在特定上下文中无法静态确定的匹配中感兴趣的情况下非常有用。 重新抛出的异常通过后续的解析链传播，就好像给定的 `@ExceptionHandler` 方法首先不匹配一样。

Spring MVC中对 `@ExceptionHandler` 方法的支持是基于 `DispatcherServlet` 级别的<<mvc-exceptionhandlers, HandlerExceptionResolver>>机制构建的。


[[mvc-ann-exceptionhandler-args]]
==== 方法参数

`@ExceptionHandler`方法支持以下参数：

[cols="1,2", options="header"]
|===
| 方法参数 | 描述

| Exception type
| 用于访问引发的异常。

| `HandlerMethod`
| 访问控制器方法引发的异常

| `WebRequest`, `NativeWebRequest`
| 无需直接使用Servlet API即可访问请求参数以及请求和会话属性。

| `javax.servlet.ServletRequest`, `javax.servlet.ServletResponse`
| 选择任何特定的请求或响应类型（例如，`ServletRequest` 或 `HttpServletRequest` 或 Spring的 `MultipartRequest` or `MultipartHttpServletRequest`).

| `javax.servlet.http.HttpSession`
| 强制进行会话。 因此，这样的结果永远不会是 `null` 的。请注意，会话访问不是线程安全的。 如果允许多个请求同时访问会话，请考虑将 `RequestMappingHandlerAdapter` 实例的 `synchronizeOnSession` 标志设置为 `true`。

| `java.security.Principal`
| 当前经过身份验证的用户 - 如果已知，可能是特定的 `Principal` 实现类。

| `HttpMethod`
| 请求的HTTP方法。

| `java.util.Locale`
| 当前请求区域设置，由最可用的 `LocaleResolver`（实际上是已配置的 `LocaleResolver` 或 `LocaleContextResolver`）确定。

| `java.util.TimeZone`, `java.time.ZoneId`
| 与当前请求关联的时区，由 `LocaleContextResolver` 确定。

| `java.io.OutputStream`, `java.io.Writer`
| 用于访问Servlet API公开的原始响应主体。

| `java.util.Map`, `org.springframework.ui.Model`, `org.springframework.ui.ModelMap`
| 用于访问模型以获取错误响应。 总是为空.

| `RedirectAttributes`
| 指定在重定向的情况下使用的属性 - （将附加到查询字符串）和临时存储的flash属性，直到重定向后的请求为止。 请参阅  <<mvc-redirecting-passing-data,Redirect 属性>>和 <<mvc-flash-attributes, Flash 属性>>。

| `@SessionAttribute`
| 用于访问任何会话属性，与由于类级别 `@SessionAttributes` 声明的结束形成对比。 有关更多详细信息，请参阅<<mvc-ann-sessionattribute,@SessionAttribute>>。

| `@RequestAttribute`
| 用于访问请求属性。 有关更多详细信息，请参阅<<mvc-ann-requestattrib,@RequestAttribute>>。

|===


[[mvc-ann-exceptionhandler-return-values]]
==== 返回值

`@ExceptionHandler` 方法支持以下返回值:

[cols="1,2", options="header"]
|===
| Return value | Description

| `@ResponseBody`
| 返回值通过 `HttpMessageConverter` 实现转换并写入响应。 请参阅<<mvc-ann-responsebody,@ResponseBody>>

| `HttpEntity<B>`, `ResponseEntity<B>`
| 指定完整响应（包括HTTP头和主体）的返回值将通过 `HttpMessageConverter` 实现转换并写入响应。 请参阅<<mvc-ann-responseentity,ResponseEntity>>。

| `String`
| 要使用 `ViewResolver实现解析的视图名称`，并与隐式模型一起使用 - 通过命令对象和 @ModelAttribute方法确定。 处理程序方法还可以通过声明 `Model` 参数以编程方式丰富模型（请参阅 <<mvc-ann-requestmapping-registration,显式注册>>）。

| `View`
| 用于与隐式模型一起呈现的View实例 - 通过命令对象和 `@ModelAttribute` 方法确定。 处理程序方法还可以通过声明 `Model` 参数以编程方式丰富模型（请参阅 <<mvc-ann-requestmapping-registration,显式注册>>）。

| `java.util.Map`, `org.springframework.ui.Model`
| 要添加到隐式模型的属性，通过 `RequestToViewNameTranslator` 隐式确定视图名称。

| `@ModelAttribute`
| 要添加到模型的属性，通过隐式确定视图名称。

 请注意，@ModelAttribute是可选的。 请参阅本表末尾的“任何其他返回值”。

| `ModelAndView` object
| 要使用的视图和模型属性，以及（可选）响应状态。

| `void`
| 如果具有 `void` 返回类型（或返回值为 `null` ）的方法，如果它还具有 `ServletResponse`，`OutputStream` 参数或 `@ResponseStatus` 注解， 则认为已完全处理该响应。 如果控制器已进行正 `ETag` 或 `lastModified` 时间戳检查，则也是如此（有关详细信息，请参阅<<mvc-caching-etag-lastmodified,Controllers>>）。

  如果以上都不是真的，则void返回类型也可以指示REST控制器的“无响应主体”或HTML控制器的默认视图名称选择。

| Any other return value
| 任何与此表中任何早期值不匹配且返回值为 `String` 或 `void` 的返回值都被视为视图名称（通过 `RequestToViewNameTranslator` 应用默认视图名称选择）， 前提是它不是简单类型，由 {api-spring-framework}/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-[BeanUtils#isSimpleProperty] 确定，简单类型的值仍未解决。
|===


[[mvc-ann-rest-exceptions]]
==== REST API 异常
[.small]#<<web-reactive.adoc#webflux-ann-rest-exceptions, WebFlux>>#

REST服务的一个常见要求是在响应正文中包含错误详细信息。 Spring Framework不会自动执行此操作，因为响应正文中的错误详细信息的表示是特定于应用程序的。 但是，`@RestController` 可以使用带有 `ResponseEntity` 返回值的 `@ExceptionHandler` 方法来设置响应的状态和正文。 这些方法也可以在 `@ControllerAdvice` 类中声明，以全局应用它们。

在响应主体中实现具有错误详细信息的全局异常处理的应用程序应考虑扩展{api-spring-framework}/web/servlet/mvc/method/annotation/ResponseEntityExceptionHandler.html[`ResponseEntityExceptionHandler`]， 它提供对Spring MVC引发的异常的处理，并提供钩子来定制响应主体。要使用它，请创建 `ResponseEntityExceptionHandler` 的子类，使用 `@ControllerAdvice` 注解它，覆盖必要的方法，并将其声明为Spring bean。

[[mvc-ann-controller-advice]]
=== Controller Advice
[.small]#<<web-reactive.adoc#webflux-ann-controller-advice, WebFlux>>#

通常，在 `@Controller` 类上声明 `@ExceptionHandler`, `@InitBinder`, 和 `@ModelAttribute` 注解。 如果您希望此类方法更全局地应用（跨控制器），则可以在标有 `@ControllerAdvice` 或 `@RestControllerAdvice` 的类中声明它们。

`@ControllerAdvice` `@Component` 注解，这意味着可以通过组件扫描将这些类注册为Spring bean。 `@RestControllerAdvice` 也是一个用 `@ControllerAdvice` 和 `@ResponseBody` 标记的元注解，这实际上意味着 `@ExceptionHandler` 方法通过消息转换（与视图分辨率或模板渲染相对）呈现给响应主体。

在启动时， `@RequestMapping` 和 `@ExceptionHandler` 方法的基础结构类检测 `@ControllerAdvice` 类型的Spring bean，然后在运行时应用它们的方法。
全局 `@ExceptionHandler` 方法（来自 `@ControllerAdvice`）在本地方法之后（来自 `@Controller`）应用。 相比之下，全局 `@ModelAttribute` 和 `@InitBinder` 方法在本地方法之前应用。

默认情况下，`@ControllerAdvice` 方法适用于每个请求（即所有控制器），但您可以通过使用注解上的属性将其缩小到控制器的子集，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Target all Controllers annotated with @RestController
	@ControllerAdvice(annotations = RestController.class)
	public class ExampleAdvice1 {}

	// Target all Controllers within specific packages
	@ControllerAdvice("org.example.controllers")
	public class ExampleAdvice2 {}

	// Target all Controllers assignable to specific classes
	@ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class})
	public class ExampleAdvice3 {}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Target all Controllers annotated with @RestController
	@ControllerAdvice(annotations = [RestController::class])
	class ExampleAdvice1

	// Target all Controllers within specific packages
	@ControllerAdvice("org.example.controllers")
	class ExampleAdvice2

	// Target all Controllers assignable to specific classes
	@ControllerAdvice(assignableTypes = [ControllerInterface::class, AbstractController::class])
	class ExampleAdvice3
----

前面示例中的选择器在运行时进行评估，如果广泛使用，可能会对性能产生负面影响。 有关更多详细信息，请参阅{api-spring-framework}/web/bind/annotation/ControllerAdvice.html[`@ControllerAdvice`] javadoc 。

include::webmvc-functional.adoc[leveloffset=+1]

[[mvc-uri-building]]
== URI 链接
[.small]#<<web-reactive.adoc#webflux-uri-building, WebFlux>>#

本部分介绍了Spring框架中可用于URI的各种选项。

include::web-uris.adoc[leveloffset=+2]



[[mvc-servleturicomponentsbuilder]]
=== 相对请求

您可以使用 `ServletUriComponentsBuilder` 创建相对于当前请求的URI，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	HttpServletRequest request = ...

	// Re-uses host, scheme, port, path and query string...

	ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromRequest(request)
			.replaceQueryParam("accountId", "{id}").build()
			.expand("123")
			.encode();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val request: HttpServletRequest = ...

	// Re-uses host, scheme, port, path and query string...

	val ucb = ServletUriComponentsBuilder.fromRequest(request)
			.replaceQueryParam("accountId", "{id}").build()
			.expand("123")
			.encode()
----

您可以创建相对于上下文路径的URI，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Re-uses host, port and context path...

	ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromContextPath(request)
			.path("/accounts").build()
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Re-uses host, port and context path...

	val ucb = ServletUriComponentsBuilder.fromContextPath(request)
			.path("/accounts").build()
----

您可以创建相对于Servlet的URI（例如 `/main/{asterisk}`），如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Re-uses host, port, context path, and Servlet prefix...

	ServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromServletMapping(request)
			.path("/accounts").build()
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Re-uses host, port, context path, and Servlet prefix...

	val ucb = ServletUriComponentsBuilder.fromServletMapping(request)
			.path("/accounts").build()
----

NOTE: 从5.1开始，`ServletUriComponentsBuilder` 会忽略来自 `Forwarded` 和 `X-Forwarded-*` 头部的信息，这些头部信息指定了客户端发起的地址。 考虑使用<<filters-forwarded-headers, `ForwardedHeaderFilter`>>来提取和使用或丢弃此类请求头。

[[mvc-links-to-controllers]]
=== 控制器链接

Spring MVC也提供了构造指定控制器方法链接的机制。 例如，以下MVC控制器允许创建链接：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	@RequestMapping("/hotels/{hotel}")
	public class BookingController {

		@GetMapping("/bookings/{booking}")
		public ModelAndView getBooking(@PathVariable Long booking) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	@RequestMapping("/hotels/{hotel}")
	class BookingController {

		@GetMapping("/bookings/{booking}")
		fun getBooking(@PathVariable booking: Long): ModelAndView {
			// ...
		}
	}
----

您可以通过引用方法名字的办法来准备一个链接，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	UriComponents uriComponents = MvcUriComponentsBuilder
		.fromMethodName(BookingController.class, "getBooking", 21).buildAndExpand(42);

	URI uri = uriComponents.encode().toUri();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val uriComponents = MvcUriComponentsBuilder
		.fromMethodName(BookingController::class.java, "getBooking", 21).buildAndExpand(42)

	val uri = uriComponents.encode().toUri()
----

在前面的示例中，为方法参数准备了填充值（在本例中，long值：`21`），以用于填充路径变量并插入到URL中。此外，我们提供了值42，来填充任何剩余的URI变量，比如从类层级的请求映射中继承来的 `hotel` 变量。 如果方法还有更多的参数，你可以为那些不需要参与URL构造的变量赋予null值。通常，只有 `@PathVariable` 和 `@RequestParam` 参数与构造URL有关。

还有其他使用 `MvcUriComponentsBuilder` 的方法。例如，例如可以通过类似mock掉测试对象的方法，用代理来避免直接通过名字引用一个控制，如以下示例所示（该示例假定静态导入 `MvcUriComponentsBuilder.on`）：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	UriComponents uriComponents = MvcUriComponentsBuilder
		.fromMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);

	URI uri = uriComponents.encode().toUri();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val uriComponents = MvcUriComponentsBuilder
		.fromMethodCall(on(BookingController::class.java).getBooking(21)).buildAndExpand(42)

	val uri = uriComponents.encode().toUri()
----

NOTE: 当控制器方法签名可用于 `fromMethodCall` 的链接创建时，其设计受到限制。 除了需要适当的参数签名外，返回类型还存在技术限制（即，为链接生成器调用生成运行时代理），因此返回类型不得为最终值。 特别是，视图名称的通用 `String` 返回类型在这里不起作用。 您应该改用 `ModelAndView` 甚至普通对象（具有 `String` 返回值）。

较早的示例在 `MvcUriComponentsBuilder` 中使用静态方法。 在内部，它们依靠 `ServletUriComponentsBuilder` 从当前请求的方案，主机，端口，上下文路径和Servlet路径准备基本URL。 在大多数情况下，此方法效果很好。 但是，有时可能不足。 例如，您可能不在请求的上下文之内（例如，准备链接的批处理过程），或者您可能需要插入路径前缀（例如，从请求路径中删除且需要重新设置的语言环境前缀）。 插入链接）。

在这种情况下，可以使用静态的 `fromXxx` 重载方法，这些方法接受 `UriComponentsBuilder` 以使用基本URL。 或者，您可以使用基本URL创建 `MvcUriComponentsBuilder` 的实例，然后使用基于实例的 `withXxx` 方法。 例如，以下清单使用 `withMethodCall`：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	UriComponentsBuilder base = ServletUriComponentsBuilder.fromCurrentContextPath().path("/en");
	MvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo(base);
	builder.withMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);

	URI uri = uriComponents.encode().toUri();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val base = ServletUriComponentsBuilder.fromCurrentContextPath().path("/en")
	val builder = MvcUriComponentsBuilder.relativeTo(base)
	builder.withMethodCall(on(BookingController::class.java).getBooking(21)).buildAndExpand(42)

	val uri = uriComponents.encode().toUri()
----

NOTE: 从5.1开始，`ServletUriComponentsBuilder` 会忽略来自 `Forwarded` 和 `X-Forwarded-*` 头部的信息，这些头部信息指定了客户端发起的地址。 考虑使用<<filters-forwarded-headers, `ForwardedHeaderFilter`>>来提取和使用或丢弃此类请求头。

[[mvc-links-to-controllers-from-views]]
=== 链接到视图

在Thymeleaf，FreeMarker或JSP之类的视图中，您可以通过引用每个请求映射的隐式或显式分配的名称来构建到带注解的控制器的链接。 考虑以下示例：


[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RequestMapping("/people/{id}/addresses")
	public class PersonAddressController {

		@RequestMapping("/{country}")
		public HttpEntity<PersonAddress> getAddress(@PathVariable String country) { ... }
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RequestMapping("/people/{id}/addresses")
	class PersonAddressController {

		@RequestMapping("/{country}")
		fun getAddress(@PathVariable country: String): HttpEntity<PersonAddress> { ... }
	}
----

给定前面的控制器，可以按照以下方式准备来自JSP的链接，如下所示：

[source,jsp,indent=0,subs="verbatim,quotes"]
----
<%@ taglib uri="http://www.springframework.org/tags" prefix="s" %>
...
<a href="${s:mvcUrl('PAC#getAddress').arg(0,'US').buildAndExpand('123')}">Get Address</a>
----

前面的示例依赖于Spring标签库中声明的 `mvcUrl` 函数（即 `META-INF/spring.tld`），但可以很容易地定义自定义函数或使用自定义标签文件。

这是如何工作的，在启动时，每个 `HandlerMethodMappingNamingStrategy`  都通过 `@RequestMapping` 分配一个默认名称，其默认实现使用类的大写字母和方法名称（例如，`ThingController` 中的 `getThing` 方法变为 "TC＃getThing"）。
如果名称冲突，则可以使 `用@RequestMapping（name =".."）` 分配显式名称或实现自己的 `HandlerMethodMappingNamingStrategy`。

[[mvc-ann-async]]
== 异步请求
[.small]#<<mvc-ann-async-vs-webflux, Compared to WebFlux>>#

Spring MVC与Servlet 3.0异步请求<<mvc-ann-async-processing,处理>>具有广泛的集成：

* 在控制器方法中返回<<mvc-ann-async-deferredresult, `DeferredResult`>>和<<mvc-ann-async-callable, `Callable`>>，并为单个异步返回值提供基本支持。
* 控制器可以<<mvc-ann-async-http-streaming,stream>>多个值，包括<<mvc-ann-async-sse, SSE>>和 <<mvc-ann-async-output-stream, 原始数据>>。
* 控制器可以使用reactive clients 并返回<<mvc-ann-async-reactive-types, reactive types>>以进行响应处理。

[[mvc-ann-async-deferredresult]]
=== `DeferredResult`
[.small]#<<mvc-ann-async-vs-webflux, Compared to WebFlux>>#

一旦在Servlet容器中<<mvc-ann-async-configuration, 启用>>了异步请求处理功能，控制器方法就可以使用 `DeferredResult` 包装任何受支持的控制器方法返回值，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/quotes")
	@ResponseBody
	public DeferredResult<String> quotes() {
		DeferredResult<String> deferredResult = new DeferredResult<String>();
		// Save the deferredResult somewhere..
		return deferredResult;
	}

	// From some other thread...
	deferredResult.setResult(result);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/quotes")
	@ResponseBody
	fun quotes(): DeferredResult<String> {
		val deferredResult = DeferredResult<String>()
		// Save the deferredResult somewhere..
		return deferredResult
	}

	// From some other thread...
	deferredResult.setResult(result)
----

控制器可以从不同的线程异步生成返回值 - 例如，响应外部事件（JMS消息），计划任务或其他事件。



[[mvc-ann-async-callable]]
=== `Callable`
[.small]#<<mvc-ann-async-vs-webflux, Compared to WebFlux>>#

控制器可以使用 `java.util.concurrent.Callable` 包装任何支持的返回值，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@PostMapping
	public Callable<String> processUpload(final MultipartFile file) {

		return new Callable<String>() {
			public String call() throws Exception {
				// ...
				return "someView";
			}
		};
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@PostMapping
	fun processUpload(file: MultipartFile) = Callable<String> {
		// ...
		"someView"
	}
----

然后可以通过配置的<<mvc-ann-async-configuration-spring-mvc, configured>> `TaskExecutor`运行给定任务来获取返回值。

[[mvc-ann-async-processing]]
=== Processing
[.small]#<<mvc-ann-async-vs-webflux, Compared to WebFlux>>#

以下是Servlet异步请求处理的简要概述:

* Servlet请求 `ServletRequest` 可以通过调用 `request.startAsync()` 方法而进入异步模式。这样做的主要结果就是该Servlet以及所有的过滤器都可以结束，但其响应（response）会留待异步处理结束后再返回调用。
* `request.startAsync()` 方法会返回一个 `AsyncContext` 对象 ，可用它对异步处理进行进一步的控制和操作。比如说它也提供了一个与转向（forward）很相似的 `dispatch` 方法，只不过它允许应用恢复Servlet容器的请求处理进程。
* `ServletRequest` 提供了获取当前 `DispatcherType` 的方式，后者可以用来区别当前处理的是原始请求、异步分发请求、转向、或是其他类型的请求分发类型。

`DeferredResult` 处理的工作方式如下：

* 控制器先返回一个 `DeferredResult` 对象，并把它存取在内存（队列或列表等）中以便存取。
* Spring MVC调用 `request.startAsync()` 方法，开始进行异步处理。
* `DispatcherServlet` 和所有过滤器都退出Servlet容器线程，但此时方法的响应对象仍未返回。
* 由处理该请求的线程对 `DeferredResult` 进行设值，然后SpringM VC会重新把请求分派回Servlet容器，恢复处理。
* `DispatcherServlet` 再次被调用, 恢复对该异步返回结果的处理。

`Callable` 处理的工作方式如下：

* 控制器先返回一个 `Callable` 对象.
* Spring MVC调用 `request.startAsync()` 方法，开始进行异步处理，并把该 `Callable` 对象提交给另一个独立线程的 Actuator  `TaskExecutor` 处理。
* `DispatcherServlet` 和所有过滤器都退出Servlet容器线程，但此时方法的响应对象仍未返回。
* `Callable` 对象最终产生一个返回结果，此时Spring MVC会重新把请求分派回Servlet容器，恢复处理。
* `DispatcherServlet` 再次被调用,恢复对 `Callable` 异步处理所返回结果的处理。

有关更多背景知识，您还可以阅读在Spring MVC 3.2中引入了异步请求处理支持的 https://spring.io/blog/2012/05/07/spring-mvc-3-2-preview-introducing-servlet-3-async-support[博客文章]。

[[mvc-ann-async-exceptions]]
==== 异常处理

若方法返回的是一个 `DeferredResult` 对象，你可以选择调Exception实例的 `setResult` 方法还是 `setErrorResult` 方法。在这两种情况下，Spring MVC都会将请求发送回Servlet容器以完成处理。 然后将其视为控制器方法返回给定值或者就好像它产生了给定的异常一样。 然后异常通过常规异常处理机制（例如，调用 `@ExceptionHandler` 方法）。更具体地说呢，当 `Callable` 抛出异常时，Spring MVC会把一个 `Exception` 对象分派给Servlet容器进行处理，而不是正常返回方法的返回值，然后容器恢复对此异步请求异常的处理。

当您使用 `Callable` 时，会出现类似的处理逻辑，主要区别在于从 `Callable` 返回结果，或者由它引发异常。

[[mvc-ann-async-interception]]
==== 拦截

处理器拦截器 `HandlerInterceptor` 可以实现 `AsyncHandlerInterceptor` 接口拦截异步请求，因为在异步请求开始时，被调用的回调方法是该接口的 `afterConcurrentHandlingStarted` 方法，而非一般的 `postHandle` 和 `afterCompletion` 方法。

如果需要与异步请求处理的生命流程有更深入的集成，比如需要处理timeout的事件等。则 `HandlerInterceptor` 需要注册 `CallableProcessingInterceptor` 或 `DeferredResultProcessingInterceptor` 拦截器， 具体的细节可以参考 {api-spring-framework}/web/servlet/AsyncHandlerInterceptor.html[`AsyncHandlerInterceptor`] 类的Java文档

`DeferredResult` 类还提供了 `onTimeout(Runnable)` 和 `onCompletion(Runnable)` 等回调， 具体的细节可以参考 {api-spring-framework}/web/context/request/async/DeferredResult.html[javadoc of `DeferredResult`] 类的Java文档 `Callable` 可以替代 `WebAsyncTask`，它公开了超时和完成回调的其他方法。

[[mvc-ann-async-vs-webflux]]
==== 与WebFlux相比

Servlet API最初是为通过Filter-Servlet链进行一次传递而构建的。 Servlet 3.0中添加了异步请求处理，使应用程序可以退出Filter-Servlet链，但保留响应以进行进一步处理。 Spring MVC异步支持围绕该机制构建。
当控制器返回 `DeferredResult` 时，退出Filter-Servlet链，并释放Servlet容器线程。 稍后，在设置 `DeferredResult` 时，将进行 `ASYNC` 调度（到相同的URL），在此期间，控制器将再次映射，但不是调用它，而是使用 `DeferredResult` 值（就像控制器返回了它）来恢复处理。

相比之下，Spring WebFlux既不是基于Servlet API构建的，也不需要这种异步请求处理功能，因为它在设计上是异步的。 异步处理已内置在所有框架协定中，并在请求处理的所有阶段得到内在支持。

从编程模型的角度来看，Spring MVC和Spring WebFlux都支持异步和<<mvc-ann-async-reactive-types,响应类型>> 作为控制器方法中的返回值。 Spring MVC甚至支持流式传输，包括反应性背压。 但是，与WebFlux不同，WebFlux依赖于非阻塞 I/O，并且每次写入都不需要额外的线程，
因此对响应的单个写入仍然处于阻塞状态（并在单独的线程上执行）。

另一个基本区别是，Spring MVC在控制器方法参数中不支持异步或响应类型（例如，`@RequestBody`，`@RequestPart` 等），也没有对异步和响应类型作为模型属性的任何显式支持。 Spring WebFlux确实支持所有这些。

[[mvc-ann-async-http-streaming]]
=== HTTP 流
[.small]#<<web-reactive.adoc#webflux-codecs-streaming, WebFlux>>#

您可以将 `DeferredResult` 和 `Callable` 用于单个异步返回值。 如果要生成多个异步值并将其写入响应，该怎么办？ 本节介绍如何执行此操作。

[[mvc-ann-async-objects]]
==== Objects

您可以使用 `ResponseBodyEmitter` 返回值来生成对象流，其中每个对象都使用 <<integration.adoc#rest-message-conversion, `HttpMessageConverter`>>  进行序列化并写入响应，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/events")
	public ResponseBodyEmitter handle() {
		ResponseBodyEmitter emitter = new ResponseBodyEmitter();
		// Save the emitter somewhere..
		return emitter;
	}

	// In some other thread
	emitter.send("Hello once");

	// and again later on
	emitter.send("Hello again");

	// and done at some point
	emitter.complete();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/events")
	fun handle() = ResponseBodyEmitter().apply {
		// Save the emitter somewhere..
	}

	// In some other thread
	emitter.send("Hello once")

	// and again later on
	emitter.send("Hello again")

	// and done at some point
	emitter.complete()
----

`ResponseBodyEmitter` 也可以被放到 `ResponseEntity` 体里面使用，这可以对响应状态和响应头做一些定制。

当 `emitter` 抛出 `IOException` 时（例如，如果远程客户端消失），应用程序不负责清理连接，不应调用 `emitter.complete` 或 `emitter.completeWithError`。 相反，servlet容器会自动启动 `AsyncListener` 错误通知，其中Spring MVC进行 `completeWithError` 调用。 反过来，此调用会对应用程序执行一次最终 `ASYNC` 调度，在此期间，Spring MVC将调用已配置的异常解析程序并完成请求。

[[mvc-ann-async-sse]]
==== SSE

`SseEmitter` （`ResponseBodyEmitter` 的子类）为https://www.w3.org/TR/eventsource/[Server-Sent Events]提供支持，其中从服务器发送的事件根据W3C SSE规范进行格式化。 要从控制器生成SSE流，请返回 `SseEmitter`，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping(path="/events", produces=MediaType.TEXT_EVENT_STREAM_VALUE)
	public SseEmitter handle() {
		SseEmitter emitter = new SseEmitter();
		// Save the emitter somewhere..
		return emitter;
	}

	// In some other thread
	emitter.send("Hello once");

	// and again later on
	emitter.send("Hello again");

	// and done at some point
	emitter.complete();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/events", produces = [MediaType.TEXT_EVENT_STREAM_VALUE])
	fun handle() = SseEmitter().apply {
		// Save the emitter somewhere..
	}

	// In some other thread
	emitter.send("Hello once")

	// and again later on
	emitter.send("Hello again")

	// and done at some point
	emitter.complete()
----

虽然SSE是流式传输到浏览器的主要选项，但请注意Internet Explorer不支持Server-Sent Events。 考虑将Spring的<<web.adoc#websocket, WebSocket messaging>> 传递与针对各种浏览器的 <<web.adoc#websocket-fallback, SockJS fallback>>传输（包括SSE）一起使用。

有关异常处理的说明，另请参见 <<mvc-ann-async-objects, 上一节>> 。

[[mvc-ann-async-output-stream]]
==== Raw Data

有时，跳过消息转换的阶段，直接把数据写回响应的输出流 `OutputStream` 可能更有效，比如文件下载这样的场景，这可以通过返回一个 `StreamingResponseBody` 类型的对象来实现，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/download")
	public StreamingResponseBody handle() {
		return new StreamingResponseBody() {
			@Override
			public void writeTo(OutputStream outputStream) throws IOException {
				// write...
			}
		};
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/download")
	fun handle() = StreamingResponseBody {
		// write...
	}
----

`StreamingResponseBody` 也可以被放到 `ResponseEntity` 体里面使用，这可以对响应状态和响应头做一些定制。

[[mvc-ann-async-reactive-types]]
=== Reactive Types（响应式类型）
[.small]#<<web-reactive.adoc#webflux-codecs-streaming, WebFlux>>#

如果使用 `spring-webflux` 中的响应式 `WebClient`，或其他客户端（也可以阅读WebFlux部分中的<<web-reactive.adoc#webflux-reactive-libraries, Reactive Libraries>> ），又或者是带响应式支持的数据存储，开发者可以直接从Spring MVC控制器方法返回响应式类型。

Reactive 返回值的处理方式如下:

* 如果返回类型有 `single-value` 流的语义，如 `Mono`(Reactor) 或 `Single`(RxJava)，那么它是适配并等效于 `DeferredResult`。
* 如果返回类型有multi-value流的语义，如 `Flux` (Reactor)或 `Observable` (RxJava)，并且如果媒体类型也表示为流，（例如，`application/stream+json` 或 `text/event-stream`）。 则它是适配并等效于使用 `ResponseBodyEmitter` 或 `SseEmitter`。还可以返回 `Flux<ServerSentEvent>` 或 `Observable<ServerSentEvent>`。
* 如果返回类型multi-value流的语义，但媒体类型并不表示为流。例如 `application/json`，则它是适配并等效于使用 `DeferredResult<List<?>>`。

TIP: 	Spring MVC对使用中的响应式库进行了适配 – 例如，预计有多少值，这是在 `spring-core` 包的 {api-spring-framework}/core/ReactiveAdapterRegistry.html[`ReactiveAdapterRegistry`]  的帮助下完成的。 它为响应式和异步类型提供可插拔的支持。注册表内置了对RxJava的支持，但其他可以注册。

对于流式传输到响应，支持响应式响应，但是对响应的写入仍然是阻塞的，并且通过<<mvc-ann-async-configuration-spring-mvc, configured>> `TaskExecutor`在单独的线程上执行， 以避免阻塞上游源（例如从 `WebClient` 返回的 `Flux`）。
默认情况下，`SimpleAsyncTaskExecutor` 用于阻塞写入，但在加载时不适用。 如果计划使用响应类型进行流式处理，则应使用<<mvc-ann-async-configuration-spring-mvc, MVC configuration>>来配置任务执行程序。

[[mvc-ann-async-disconnects]]
=== 断开
[.small]#<<web-reactive.adoc#webflux-codecs-streaming, WebFlux>>#

当远程客户端消失时，Servlet API不提供任何通知。 因此，在通过stream传输到响应时，无论是通过<<mvc-ann-async-sse, SseEmitter>>还是 <<mvc-ann-async-reactive-types, reactive types>>，定期发送数据都很重要， 因为如果客户端断开连接，写入将失败。 发送可以采用空（仅限注解）SSE事件或另一方必须解释为心跳并忽略的任何其他数据的形式。

或者，考虑使用具有内置心跳机制的Web消息传递解决方案（例如基于<<websocket-stomp,  WebSocket的STOMP>>或具有<<websocket-fallback, SockJS>>的WebSocket）。

[[mvc-ann-async-configuration]]
=== 配置
[.small]#<<mvc-ann-async-vs-webflux, Compared to WebFlux>>#

必须在Servlet容器级别启用异步请求处理功能。 MVC配置还公开了异步请求的几个选项。

[[mvc-ann-async-configuration-servlet3]]
==== Servlet  容器

Filter和Servlet声明具有 `asyncSupported` 标志，需要将其设置为 `true` 以启用异步请求处理。 此外，应声明 `Filter` 映射以处理 `ASYNC` `javax.servlet.DispatchType`。

在Java配置中，当您使用 `AbstractAnnotationConfigDispatcherServletInitializer` 初始化Servlet容器时，这将自动完成。

在web.xml 配置中，您可以将 `<async-supported>true</async-supported>` 添加到 `DispatcherServlet` 和 `Filter` 声明，并添加 `<dispatcher>ASYNC</dispatcher>` 以过滤映射。

[[mvc-ann-async-configuration-spring-mvc]]
==== Spring MVC

MVC配置公开以下与异步请求处理相关的选项：

* Java configuration: 在 `WebMvcConfigurer` 上使用 `configureAsyncSupport` 回调。
* XML namespace: 使用 `<mvc:annotation-driven>` 下的 `<async-support>` 元素。

您可以配置以下内容：

* 异步请求的默认超时值（如果未设置）取决于底层Servlet容器。
* `AsyncTaskExecutor` 用于在使用<<mvc-ann-async-reactive-types,Reactive Types>> 进行流式处理时阻止写入，以及用于执行从控制器方法返回的 `Callable` 实例。 如果您使用reactive types进行流式传输或者具有返回 `Callable` 的控制器方法， 我们强烈建议您配置此属性，因为默认情况下，它是 `SimpleAsyncTaskExecutor`。
* `DeferredResultProcessingInterceptor` 实现和 `CallableProcessingInterceptor` 实现。

请注意，您还可以在 `DeferredResult`， `ResponseBodyEmitter` 和 `SseEmitter` 上设置默认超时值。 对于 `Callable`，您可以使用 `WebAsyncTask` 来提供超时值。

include::webmvc-cors.adoc[leveloffset=+1]




[[mvc-web-security]]
== Web 安全
[.small]#<<web-reactive.adoc#webflux-web-security, WebFlux>>#

https://projects.spring.io/spring-security/[Spring Security]项目为保护Web应用程序免受恶意攻击提供支持。 请参阅Spring Security参考文档，包括：

* {doc-spring-security}/html5/#mvc[Spring MVC Security]
* {doc-spring-security}/html5/#test-mockmvc[Spring MVC Test Support]
* {doc-spring-security}/html5/#csrf[CSRF protection]
* {doc-spring-security}/html5/#headers[Security Response Headers]

https://hdiv.org/[HDIV] 是另一个与Spring MVC集成的Web安全框架。

[[mvc-caching]]
== HTTP 缓存
[.small]#<<web-reactive.adoc#webflux-caching, WebFlux>>#

HTTP缓存可以显着提高Web应用程序的性能。HTTP缓存围绕 `Cache-Control` 响应头，随后是条件请求头（例如 `Last-Modified` 和 `ETag`）。 HTTP的响应头 `Cache-Control` 主要帮助私有缓存（比如浏览器端缓存）和公共缓存（比如代理端缓存）了解它们应该如果缓存HTTP响应。
如果内容未更改，则 `ETag` 头用于生成条件请求， 该条件请求可能导致304（NOT_MODIFIED）没有正文。可以认为它是 `Last-Modified` 头的一个更精细的后续版本。


本节介绍Spring Web MVC中可用的与HTTP缓存相关的选项。



[[mvc-caching-cachecontrol]]
=== `CacheControl`
[.small]#<<web-reactive.adoc#webflux-caching-cachecontrol, WebFlux>>#

{api-spring-framework}/http/CacheControl.html[`CacheControl`] 支持配置与 `Cache-Control` 头相关的设置，并在许多地方被接受为参数：

* {api-spring-framework}/web/servlet/mvc/WebContentInterceptor.html[`WebContentInterceptor`]
* {api-spring-framework}/web/servlet/support/WebContentGenerator.html[`WebContentGenerator`]
* <<mvc-caching-etag-lastmodified>>
* <<mvc-caching-static-resources>>

虽然 https://tools.ietf.org/html/rfc7234#section-5.2.2[RFC 7234] 描述了 `Cache-Control` 响应头的所有可能的指令，但 `CacheControl` 类型采用面向用例的方法，该方法侧重于常见场景：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// Cache for an hour - "Cache-Control: max-age=3600"
	CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);

	// Prevent caching - "Cache-Control: no-store"
	CacheControl ccNoStore = CacheControl.noStore();

	// Cache for ten days in public and private caches,
	// public caches should not transform the response
	// "Cache-Control: max-age=864000, public, no-transform"
	CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic();
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// Cache for an hour - "Cache-Control: max-age=3600"
	val ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS)

	// Prevent caching - "Cache-Control: no-store"
	val ccNoStore = CacheControl.noStore()

	// Cache for ten days in public and private caches,
	// public caches should not transform the response
	// "Cache-Control: max-age=864000, public, no-transform"
	val ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform().cachePublic()
----

`WebContentGenerator` 还接受一个更简单的 `cachePeriod` 属性（以秒为单位定义），其工作方式如下：

* A `-1` 值不会生成 `Cache-Control` 的响应头。
* A `0` 值将防止缓存使用 `'Cache-Control:no-store'` 指令.
* An `n > 0` 一个大于0的值将缓存给定的响应在 `n` 秒使用 `'Cache-Control:max-age=n'`



[[mvc-caching-etag-lastmodified]]
=== Controllers
[.small]#<<web-reactive.adoc#webflux-caching-etag-lastmodified, WebFlux>>#

控制器可以添加对HTTP缓存的显式支持。 我们建议这样做，因为资源的 `lastModified` 或 `ETag` 值需要先计算才能与条件请求头进行比较。 控制器可以向 `ResponseEntity` 添加 `ETag` 头和 `Cache-Control` 设置，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@GetMapping("/book/{id}")
	public ResponseEntity<Book> showBook(@PathVariable Long id) {

		Book book = findBook(id);
		String version = book.getVersion();

		return ResponseEntity
				.ok()
				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
				.eTag(version) // lastModified is also available
				.body(book);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@GetMapping("/book/{id}")
	fun showBook(@PathVariable id: Long): ResponseEntity<Book> {

		val book = findBook(id);
		val version = book.getVersion()

		return ResponseEntity
				.ok()
				.cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))
				.eTag(version) // lastModified is also available
				.body(book)
	}
----

如果与条件请求头的比较表明内容未更改，则前面的示例发送带有空响应体的304（NOT_MODIFIED）响应。 否则，`ETag` 和 `Cache-Control` 头将添加到响应中。

您还可以对控制器中的条件请求头进行检查，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@RequestMapping
	public String myHandleMethod(WebRequest webRequest, Model model) {

		long eTag = ... // <1>

		if (request.checkNotModified(eTag)) {
			return null; // <2>
		}

		model.addAttribute(...); // <3>
		return "myViewName";
	}
----
<1> 特定于应用的计算。
<2> 响应已设置为304（NOT_MODIFIED） - 无需进一步处理。
<3> 继续请求处理。

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@RequestMapping
	fun myHandleMethod(webRequest: WebRequest, model: Model): String? {

		val eTag: Long = ... // <1>

		if (request.checkNotModified(eTag)) {
			return null // <2>
		}

		model[...] = ... // <3>
		return "myViewName"
	}
----
<1> 特定于应用的计算。
<2> 响应已设置为304（NOT_MODIFIED） - 无需进一步处理。
<3> 继续请求处理。

有三种变体可用于检查针对 `eTag` 值，`lastModified` 值或两者的条件请求。 对于条件 `GET` 和 `HEAD` 请求， 您可以将响应设置为304（NOT_MODIFIED）。对于 `POST`, `PUT`, 和 `DELETE`，您可以将响应设置为409（PRECONDITION_FAILED），以防止并发修改。

[[mvc-caching-static-resources]]
=== Static Resources
[.small]#<<web-reactive.adoc#webflux-caching-static-resources, WebFlux>>#

您应该使用 `Cache-Control` 和条件响应头来提供静态资源，以获得最佳性能。 请参阅有关<<mvc-config-static-resources,配置静态资源>>的部分。

[[mvc-httpcaching-shallowetag]]
=== `ETag` 过滤器

您可以使用 `ShallowEtagHeaderFilter` 添加从响应内容计算的 "`shallow`" `eTag` 值，从而节省带宽但不节省CPU时间。 见  <<filters-shallow-etag,Shallow ETag>>。

include::webmvc-view.adoc[leveloffset=+1]




[[mvc-config]]
== MVC 配置
[.small]#<<web-reactive.adoc#webflux-config, WebFlux>>#

MVC Java配置和MVC命名空间提供了适用于大多数应用程序的默认配置以及配置API来对其进行自定义。

有关配置API中没有的高级自定义设置请参阅<<mvc-config-advanced-java,高级 Java 配置>> 和 <<mvc-config-advanced-xml,高级 XML 配置>>.

您无需了解MVC Java配置和MVC命名空间创建的基础bean。 如果您想了解更多信息，请参阅<<mvc-servlet-special-bean-types,特殊Bean类型>>和 <<mvc-servlet-config,Web MVC配置>>。


[[mvc-config-enable]]
=== 启用 MVC 配置
[.small]#<<web-reactive.adoc#webflux-config-enable, WebFlux>>#

在Java配置中，您可以使用 `@EnableWebMvc` 注解启用MVC配置，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig {
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig
----

在XML配置中，您可以使用 `<mvc:annotation-driven>` 元素来启用MVC配置，如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:mvc="http://www.springframework.org/schema/mvc"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/mvc
			https://www.springframework.org/schema/mvc/spring-mvc.xsd">

		<mvc:annotation-driven/>

	</beans>
----

前面的示例注册了许多Spring MVC <<mvc-servlet-special-bean-types, 基础结构bean>>，并适应类路径上可用的依赖（例如，JSON，XML等的有效负载转换器）。

[[mvc-config-customize]]
=== MVC 配置 API
[.small]#<<web-reactive.adoc#webflux-config-customize, WebFlux>>#

在Java配置中，您可以实现 `WebMvcConfigurer` 接口，如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		// Implement configuration methods...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {
		// Implement configuration methods...
	}
----

在XML中，您可以检查 `<mvc:annotation-driven/>` 的属性和子元素。 您可以查看 https://schema.spring.io/mvc/spring-mvc.xsd[Spring MVC XML schema] 或使用IDE的代码完成功能来发现可用的属性和子元素。

[[mvc-config-conversion]]
=== 类型转换
[.small]#<<web-reactive.adoc#webflux-config-conversion, WebFlux>>#

数字的 `Number` 类型和日期 `Date` 类型的格式化是默认安装了的，包括 `@NumberFormat` 注解和 `@DateTimeFormat` 注解，如果类路径中存在Joda-Time，则还会安装对Joda-Time格式库的完全支持。

在Java配置中，您可以注册自定义格式化程序和转换器，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void addFormatters(FormatterRegistry registry) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun addFormatters(registry: FormatterRegistry) {
			// ...
		}
	}
----

以下示例显示如何在XML中实现相同的配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:mvc="http://www.springframework.org/schema/mvc"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/mvc
			https://www.springframework.org/schema/mvc/spring-mvc.xsd">

		<mvc:annotation-driven conversion-service="conversionService"/>

		<bean id="conversionService"
				class="org.springframework.format.support.FormattingConversionServiceFactoryBean">
			<property name="converters">
				<set>
					<bean class="org.example.MyConverter"/>
				</set>
			</property>
			<property name="formatters">
				<set>
					<bean class="org.example.MyFormatter"/>
					<bean class="org.example.MyAnnotationFormatterFactory"/>
				</set>
			</property>
			<property name="formatterRegistrars">
				<set>
					<bean class="org.example.MyFormatterRegistrar"/>
				</set>
			</property>
		</bean>

	</beans>
----

NOTE: 	有关何时使用<<core.adoc#format-FormatterRegistrar-SPI, the `FormatterRegistrar` SPI>>实现的更多信息，请参阅 FormatterRegistrar SPI和 `FormattingConversionServiceFactoryBean`。

[[mvc-config-validation]]
=== 验证
[.small]#<<web-reactive.adoc#webflux-config-validation, WebFlux>>#

默认情况下，如果类路径上存在<<core.adoc#validation-beanvalidation-overview, Bean Validation>> (例如Hibernate Validator），则 `LocalValidatorFactoryBean` 将注册为全局 <<core.adoc#validator, Validator>> 。 以便与 `@Valid` 和 `Validated` 一起使用并在控制器方法参数上进行验证。

在Java配置中，您可以自定义全局Validator实例，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public Validator getValidator() {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun getValidator(): Validator {
			// ...
		}
	}
----

以下示例显示如何在XML中实现相同的配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:mvc="http://www.springframework.org/schema/mvc"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/mvc
			https://www.springframework.org/schema/mvc/spring-mvc.xsd">

		<mvc:annotation-driven validator="globalValidator"/>

	</beans>
----

请注意，您还可以在本地注册 `Validator` 实现，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Controller
	public class MyController {

		@InitBinder
		protected void initBinder(WebDataBinder binder) {
			binder.addValidators(new FooValidator());
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Controller
	class MyController {

		@InitBinder
		protected fun initBinder(binder: WebDataBinder) {
			binder.addValidators(FooValidator())
		}
	}
----

TIP: 如果需要在某处注入 `LocalValidatorFactoryBean`，请创建一个bean并使用 `@Primary` 标记它，以避免与MVC配置中声明的那个冲突。

[[mvc-config-interceptors]]
=== 拦截器

在Java配置中，注册拦截器应用于传入的请求。如以下示例所示：

[source,java,indent=0,subs="verbatim",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void addInterceptors(InterceptorRegistry registry) {
			registry.addInterceptor(new LocaleChangeInterceptor());
			registry.addInterceptor(new ThemeChangeInterceptor()).addPathPatterns("/**").excludePathPatterns("/admin/**");
			registry.addInterceptor(new SecurityInterceptor()).addPathPatterns("/secure/*");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun addInterceptors(registry: InterceptorRegistry) {
			registry.addInterceptor(LocaleChangeInterceptor())
			registry.addInterceptor(ThemeChangeInterceptor()).addPathPatterns("/**").excludePathPatterns("/admin/**")
			registry.addInterceptor(SecurityInterceptor()).addPathPatterns("/secure/*")
		}
	}
----

以下示例显示如何在XML中实现相同的配置：

[source,xml,indent=0,subs="verbatim"]
----
	<mvc:interceptors>
		<bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"/>
		<mvc:interceptor>
			<mvc:mapping path="/**"/>
			<mvc:exclude-mapping path="/admin/**"/>
			<bean class="org.springframework.web.servlet.theme.ThemeChangeInterceptor"/>
		</mvc:interceptor>
		<mvc:interceptor>
			<mvc:mapping path="/secure/*"/>
			<bean class="org.example.SecurityInterceptor"/>
		</mvc:interceptor>
	</mvc:interceptors>
----



[[mvc-config-content-negotiation]]
=== 内容类型
[.small]#<<web-reactive.adoc#webflux-config-content-negotiation, WebFlux>>#

您可以配置Spring MVC如何根据请求确定所请求的媒体类型（例如，`Accept` 头，URL路径扩展，查询参数等）。

默认情况下，首先检查URL路径扩展 - 将 `json`, `xml`, `rss`, 和 `atom` 注册为已知扩展（取决于类路径依赖性）。 第二个检查 `Accept` 头。

将这些默认值更改为只接受 `Accept` 头，并且如果必须使用基于内容类型解析，请考虑路径扩展上的查询参数策略。 有关更多详细信息，请参阅 <<mvc-ann-requestmapping-suffix-pattern-match,后缀匹配>> 和 <<mvc-ann-requestmapping-rfd,后缀匹配以及RFD>>。

在Java配置中，您可以自定义请求的内容类型解析，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
			configurer.mediaType("json", MediaType.APPLICATION_JSON);
			configurer.mediaType("xml", MediaType.APPLICATION_XML);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureContentNegotiation(configurer: ContentNegotiationConfigurer) {
			configurer.mediaType("json", MediaType.APPLICATION_JSON)
			configurer.mediaType("xml", MediaType.APPLICATION_XML)
		}
	}
----


以下示例显示如何在XML中实现相同的配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:annotation-driven content-negotiation-manager="contentNegotiationManager"/>

	<bean id="contentNegotiationManager" class="org.springframework.web.accept.ContentNegotiationManagerFactoryBean">
		<property name="mediaTypes">
			<value>
				json=application/json
				xml=application/xml
			</value>
		</property>
	</bean>
----



[[mvc-config-message-converters]]
=== 消息转换
[.small]#<<web-reactive.adoc#webflux-config-message-codecs, WebFlux>>#

使用MVC Java编程配置方式时，如果想替换Spring MVC提供的默认转换器，完全定制自己的 `HttpMessageConverter` ，这可以通过覆写 {api-spring-framework}/web/servlet/config/annotation/WebMvcConfigurer.html#configureMessageConverters-java.util.List-[`configureMessageConverters()`] 方法来实现。
如果只是想自定义，或者想在默认转换器之外再添加其他的转换器，那么可以通过覆写 {api-spring-framework}/web/servlet/config/annotation/WebMvcConfigurer.html#extendMessageConverters-java.util.List-[`extendMessageConverters()`] 方法来实现。

以下示例使用自定义的 `ObjectMapper` 而不是默认的 `ObjectMapper` 添加XML和Jackson JSON转换器：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfiguration implements WebMvcConfigurer {

		@Override
		public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
			Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder()
					.indentOutput(true)
					.dateFormat(new SimpleDateFormat("yyyy-MM-dd"))
					.modulesToInstall(new ParameterNamesModule());
			converters.add(new MappingJackson2HttpMessageConverter(builder.build()));
			converters.add(new MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build()));
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfiguration : WebMvcConfigurer {

		override fun configureMessageConverters(converters: MutableList<HttpMessageConverter<*>>) {
			val builder = Jackson2ObjectMapperBuilder()
					.indentOutput(true)
					.dateFormat(SimpleDateFormat("yyyy-MM-dd"))
					.modulesToInstall(ParameterNamesModule())
			converters.add(MappingJackson2HttpMessageConverter(builder.build()))
			converters.add(MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build()))
----

在上面的例子中，{api-spring-framework}/http/converter/json/Jackson2ObjectMapperBuilder.html[`Jackson2ObjectMapperBuilder`] 用于为 `MappingJackson2HttpMessageConverter` 和 `MappingJackson2XmlHttpMessageConverter` 转换器创建公共的配置，比如启用tab缩进、
定制的日期格式，并注册了模块 https://github.com/FasterXML/jackson-module-parameter-names[`jackson-module-parameter-names`] 用于获取参数名（Java 8新增的特性）。

该builder会使用以下的默认属性对Jackson进行配置

* https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/DeserializationFeature.html#FAIL_ON_UNKNOWN_PROPERTIES[`DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES`] 被禁用。
* https://fasterxml.github.io/jackson-databind/javadoc/2.6/com/fasterxml/jackson/databind/MapperFeature.html#DEFAULT_VIEW_INCLUSION[`MapperFeature.DEFAULT_VIEW_INCLUSION`] 被禁用。

同时，如果检测到在classpath路径下存在这些模块，该builder也会自动地注册它们。

* https://github.com/FasterXML/jackson-datatype-joda[jackson-datatype-joda]: 支持Joda-Time类型。
* https://github.com/FasterXML/jackson-datatype-jsr310[jackson-datatype-jsr310]: 支持Java 8日期和时间API类型。
* https://github.com/FasterXML/jackson-datatype-jdk8[jackson-datatype-jdk8]: 支持其他Java 8类型，例如 `Optional`。
* https://github.com/FasterXML/jackson-module-kotlin[`jackson-module-kotlin`]: 支持Kotlin类和数据类。

NOTE: 除了 https://search.maven.org/#search%7Cga%7C1%7Ca%3A%22jackson-dataformat-xml%22[`jackson-dataformat-xml`] 之外，使用Jackson XML支持启用缩进还需要https://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.codehaus.woodstox%22%20AND%20a%3A%22woodstox-core-asl%22[`woodstox-core-asl`]依赖性。


* https://github.com/zalando/jackson-datatype-money[jackson-datatype-money]: 支持 `javax.money` 类型（非官方模块）。
* https://github.com/FasterXML/jackson-datatype-hibernate[jackson-datatype-hibernate]: 支持特定于Hibernate的类型和属性（包括延迟加载方面）。

以下示例显示如何在XML中实现相同的配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:annotation-driven>
		<mvc:message-converters>
			<bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">
				<property name="objectMapper" ref="objectMapper"/>
			</bean>
			<bean class="org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter">
				<property name="objectMapper" ref="xmlMapper"/>
			</bean>
		</mvc:message-converters>
	</mvc:annotation-driven>

	<bean id="objectMapper" class="org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean"
		  p:indentOutput="true"
		  p:simpleDateFormat="yyyy-MM-dd"
		  p:modulesToInstall="com.fasterxml.jackson.module.paramnames.ParameterNamesModule"/>

	<bean id="xmlMapper" parent="objectMapper" p:createXmlMapper="true"/>
----



[[mvc-config-view-controller]]
=== 视图控制器

以下的一段代码相当于定义 `ParameterizableViewController` 视图控制器的快捷方式，该控制器会立即将请求转发（forwards）给视图。请确保仅在以下情景下才使用这个类：当控制器除了将视图渲染到响应中外不需要执行任何逻辑时。

以下Java配置示例将对 `/` 的请求转发给名为 `home` 的视图:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void addViewControllers(ViewControllerRegistry registry) {
			registry.addViewController("/").setViewName("home");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun addViewControllers(registry: ViewControllerRegistry) {
			registry.addViewController("/").setViewName("home")
		}
	}
----

以下示例与前面的示例实现相同的功能，但使用XML，通过使用 `<mvc:view-controller>` 元素:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:view-controller path="/" view-name="home"/>
----



[[mvc-config-view-resolvers]]
=== View 解析器
[.small]#<<web-reactive.adoc#webflux-config-view-resolvers, WebFlux>>#

MVC提供的配置简化了视图解析器的注册工作

以下Java配置示例使用JSP和Jackson作为JSON呈现的默认视图来配置内容协商视图解析：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.enableContentNegotiation(new MappingJackson2JsonView());
			registry.jsp();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			registry.enableContentNegotiation(MappingJackson2JsonView())
			registry.jsp()
		}
	}
----

以下示例显示如何在XML中实现相同的配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:view-resolvers>
		<mvc:content-negotiation>
			<mvc:default-views>
				<bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/>
			</mvc:default-views>
		</mvc:content-negotiation>
		<mvc:jsp/>
	</mvc:view-resolvers>
----

但请注意，FreeMarker，Tiles，Groovy Markup和脚本模板也需要配置底层视图技术。

MVC命名空间提供专用元素。 以下示例适用于FreeMarker：

[source,xml,indent=0,subs="verbatim,quotes"]
----

	<mvc:view-resolvers>
		<mvc:content-negotiation>
			<mvc:default-views>
				<bean class="org.springframework.web.servlet.view.json.MappingJackson2JsonView"/>
			</mvc:default-views>
		</mvc:content-negotiation>
		<mvc:freemarker cache="false"/>
	</mvc:view-resolvers>

	<mvc:freemarker-configurer>
		<mvc:template-loader-path location="/freemarker"/>
	</mvc:freemarker-configurer>

----

在Java配置中，您可以添加相应的 `Configurer` bean，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			registry.enableContentNegotiation(new MappingJackson2JsonView());
			registry.freeMarker().cache(false);
		}

		@Bean
		public FreeMarkerConfigurer freeMarkerConfigurer() {
			FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
			configurer.setTemplateLoaderPath("/freemarker");
			return configurer;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureViewResolvers(registry: ViewResolverRegistry) {
			registry.enableContentNegotiation(MappingJackson2JsonView())
			registry.freeMarker().cache(false)
		}

		@Bean
		fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply {
			setTemplateLoaderPath("/freemarker")
		}
	}
----



[[mvc-config-static-resources]]
=== 静态资源
[.small]#<<web-reactive.adoc#webflux-config-static-resources, WebFlux>>#

此选项提供了一种从 {api-spring-framework}/core/io/Resource.html[`Resource`] 库位置列表中使用静态资源的便捷方法

在下面的示例中，给定以 `/resources` 开头的请求，相对路径用于在Web应用程序根目录下或在或在 `/static` 下的类路径上查找和提供相对于 `/public` 的静态资源。 资源的有效期为1年，以确保最大程度地使用浏览器缓存，并减少浏览器发出的HTTP请求。如果返回 304状态代码，`Last-Modified` 头也会计算到。

以下清单显示了如何使用Java配置执行此操作:

[source,java,indent=0,subs="verbatim",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/resources/**")
				.addResourceLocations("/public", "classpath:/static/")
				.setCachePeriod(31556926);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public", "classpath:/static/")
					.setCachePeriod(31556926)
		}
	}
----

以下示例显示如何在XML中实现相同的配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:resources mapping="/resources/**"
		location="/public, classpath:/static/"
		cache-period="31556926" />
----

查看<<mvc-caching-static-resources, 静态资源的HTTP缓存支持>>.

资源处理还支持一系列 {api-spring-framework}/web/servlet/resource/ResourceResolver.html[`ResourceResolver`]  实现 和 {api-spring-framework}/web/servlet/resource/ResourceTransformer.html[`ResourceTransformer`]  实现, 可用于创建用于使用优化资源的工具

`VersionResourceResolver` 可用于基于内容、固定应用程序版本或其他的MD5哈希计算的版本化资源url。`ContentVersionStrategy`(MD5 hash)方法是一个很好的选择， 有一些值得注意的例外，例如与模块加载器一起使用的JavaScript资源。

以下示例显示如何在Java配置中使用 `VersionResourceResolver`：

[source,java,indent=0,subs="verbatim",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public/")
					.resourceChain(true)
					.addResolver(new VersionResourceResolver().addContentVersionStrategy("/**"));
		}
	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun addResourceHandlers(registry: ResourceHandlerRegistry) {
			registry.addResourceHandler("/resources/**")
					.addResourceLocations("/public/")
					.resourceChain(true)
					.addResolver(VersionResourceResolver().addContentVersionStrategy("/**"))
		}
	}
----

以下示例显示如何在XML中实现相同的配置：

[source,xml,indent=0,subs="verbatim"]
----
<mvc:resources mapping="/resources/**" location="/public/">
	<mvc:resource-chain resource-cache="true">
		<mvc:resolvers>
			<mvc:version-resolver>
				<mvc:content-version-strategy patterns="/**"/>
			</mvc:version-resolver>
		</mvc:resolvers>
	</mvc:resource-chain>
</mvc:resources>
----

您可以使用 `ResourceUrlProvider` 来重写URL并应用完整的解析器和转换器链，例如插入版本。MVC配置提供了 `ResourceUrlProvider` bean，因此可以将其注入到其他用户。 您还可以使用 `ResourceUrlEncodingFilter` 的Thymeleaf、jsp、FreeMarker和其他依赖于 `HttpServletResponse#encodeURL` 的URL标记来做重写转换。

请注意，当同时使用 `EncodedResourceResolver`（例如，用于提供gzipped或brotli编码的资源）和 `VersionedResourceResolver` 时，必须按此顺序注册它们。 这可确保始终基于未编码的文件可靠地计算基于内容的版本。

https://www.webjars.org/documentation[WebJars] 也支持使用 `WebJarsResourceResolver` 和自动注册，当 `org.webjars:webjars-locator` 存在于类路径中时。解析器可以重写URL来包含jar的版本，也可以与传入的URL匹配，而不需要版本 。 例如， `/jquery/jquery.min.js` 到 `/jquery/1.2.0/jquery.min.js`。

[[mvc-default-servlet-handler]]
=== 默认 Servlet

这些配置允许将 `DispatcherServlet` 映射到 `/` 路径（也即覆盖了容器默认Servlet的映射），但依然保留容器默认的Servlet以处理静态资源的请求。这可以通过配置一个URL映射到 `/**`  的处理器 `DefaultServletHttpRequestHandler` 来实现，并且该处理器在其他所有URL映射关系中优先级应该是最低的。

该处理器会将所有请求转发（forward）到默认的Servlet，因此需要保证它在所有URL处理器映射 `HandlerMappings` 的最后。如果你是通过 `<mvc:annotation-driven>` 的方式进行配置， 或自定义 `HandlerMapping` 实例，那么需要确保该处理器 `order` 属性的值比 `DefaultServletHttpRequestHandler` 的次序值 `Integer.MAX_VALUE` 小。

以下示例显示如何使用默认设置启用该功能：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
			configurer.enable();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureDefaultServletHandling(configurer: DefaultServletHandlerConfigurer) {
			configurer.enable()
		}
	}
----

以下示例显示如何在XML中实现相同的配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:default-servlet-handler/>
----

不过需要注意，覆写了 `/` 的Servlet映射后，默认Servlet的 `RequestDispatcher` 就必须通过名字而非路径来取得了。 `DefaultServletHttpRequestHandler` 会尝试在容器初始化的时候自动检测默认Servlet， 这里它使用的是一份主流Servlet容器（包括Tomcat, Jetty, GlassFish, JBoss, Resin, WebLogic, and WebSphere）已知的名称列表。如果默认Servlet被配置了一个其他的名字，或者使用了一个列表里未提供默认Servlet名称的容器，那么默认Servlet的名称必须被显式指定，正如下面代码所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
			configurer.enable("myCustomDefaultServlet");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configureDefaultServletHandling(configurer: DefaultServletHandlerConfigurer) {
			configurer.enable("myCustomDefaultServlet")
		}
	}
----


以下示例显示如何在XML中实现相同的配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:default-servlet-handler default-servlet-name="myCustomDefaultServlet"/>
----



[[mvc-config-path-matching]]
=== 路径匹配
[.small]#<<web-reactive.adoc#webflux-config-path-matching, WebFlux>>#

您可以自定义与路径匹配和URL处理相关的选项。 有关各个选项的详细信息，请参阅 {api-spring-framework}/web/servlet/config/annotation/PathMatchConfigurer.html[`PathMatchConfigurer`]  javadoc.

以下示例显示如何在Java配置中自定义路径匹配：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	@EnableWebMvc
	public class WebConfig implements WebMvcConfigurer {

		@Override
		public void configurePathMatch(PathMatchConfigurer configurer) {
			configurer
				.setUseSuffixPatternMatch(true)
				.setUseTrailingSlashMatch(false)
				.setUseRegisteredSuffixPatternMatch(true)
				.setPathMatcher(antPathMatcher())
				.setUrlPathHelper(urlPathHelper())
				.addPathPrefix("/api",
						HandlerTypePredicate.forAnnotation(RestController.class));
		}

		@Bean
		public UrlPathHelper urlPathHelper() {
			//...
		}

		@Bean
		public PathMatcher antPathMatcher() {
			//...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	@EnableWebMvc
	class WebConfig : WebMvcConfigurer {

		override fun configurePathMatch(configurer: PathMatchConfigurer) {
			configurer
				.setUseSuffixPatternMatch(true)
				.setUseTrailingSlashMatch(false)
				.setUseRegisteredSuffixPatternMatch(true)
				.setPathMatcher(antPathMatcher())
				.setUrlPathHelper(urlPathHelper())
				.addPathPrefix("/api",
						HandlerTypePredicate.forAnnotation(RestController::class.java))
		}

		@Bean
		fun urlPathHelper(): UrlPathHelper {
			//...
		}

		@Bean
		fun antPathMatcher(): PathMatcher {
			//...
		}
	}
----

以下示例显示如何在XML中实现相同的配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<mvc:annotation-driven>
		<mvc:path-matching
			suffix-pattern="true"
			trailing-slash="false"
			registered-suffixes-only="true"
			path-helper="pathHelper"
			path-matcher="pathMatcher"/>
	</mvc:annotation-driven>

	<bean id="pathHelper" class="org.example.app.MyPathHelper"/>
	<bean id="pathMatcher" class="org.example.app.MyPathMatcher"/>
----



[[mvc-config-advanced-java]]
=== 高级 Java 配置
[.small]#<<web-reactive.adoc#webflux-config-advanced-java, WebFlux>>#

`@EnableWebMvc` 导入 `DelegatingWebMvcConfiguration`, 其中

* 为Spring MVC应用程序提供了默认的Spring配置
* 检测到并委派到 `WebMvcConfigurer` 的自定义该配置

对于高级模式，请删除 `@EnableWebMvc` 并直接从 `DelegatingWebMvcConfiguration` 继承 ，而不是实现 `WebMvcConfigurer`，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class WebConfig extends DelegatingWebMvcConfiguration {

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class WebConfig : DelegatingWebMvcConfiguration() {

		// ...
	}
----

可以在 `WebConfig` 中保留现有的方法，但现在也可以重写基类中的bean声明，并且在类路径上仍然可以有任意数量的其他 `WebMvcConfigurer` 。

[[mvc-config-advanced-xml]]
=== 高级 XML 配置

MVC命名空间没有高级模式，如果需要自定义无法更改的bean上的属性，可以使用 `ApplicationContext` 的 `BeanPostProcessor` 生命周期挂钩，如以下示例所示：

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Component
	public class MyPostProcessor implements BeanPostProcessor {

		public Object postProcessBeforeInitialization(Object bean, String name) throws BeansException {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class MyPostProcessor : BeanPostProcessor {
		
		override fun postProcessBeforeInitialization(bean: Any, name: String): Any {
			// ...
		}
	}
----

请注意，`MyPostProcessor` 需要用XML显式声明为bean，或通过 `<component-scan/>` 声明检测。

[[mvc-http2]]
== HTTP/2
[.small]#<<web-reactive.adoc#webflux-http2, WebFlux>>#

Servlet 4容器需要支持HTTP/2，Spring Framework 5与Servlet API 4兼容。从编程模型的角度来看，应用程序不需要特定的任何操作。 但是，存在与服务器配置相关的注意事项。 有关更多详细信息，请参阅 https://github.com/spring-projects/spring-framework/wiki/HTTP-2-support[ HTTP/2 wiki 页面]。

Servlet API确实公开了一个与HTTP/2相关的构造。 您可以使用 `javax.servlet.http.PushBuilder` 主动将资源推送到客户端，并且它被支持作为 `@RequestMapping` 方法的<<mvc-ann-arguments, 方法参数>>。