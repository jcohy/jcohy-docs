[[websocket]]
= WebSockets
:doc-spring-security: {doc-root}/spring-security/site/docs/current/reference
[.small]#<<web-reactive.adoc#webflux-websocket, WebFlux>>#

这一部分介绍Spring框架在Web应用程序中对WebSocket消息传递的支持，通过SockJS的WebSocket仿真，包括使用STOMP作为应用程序级WebSocket的子协议的发布 - 订阅消息传递。

include::websocket-intro.adoc[leveloffset=+1]




[[websocket-server]]
== WebSocket API
[.small]#<<web-reactive.adoc#webflux-websocket-server, WebFlux>>#

Spring Framework提供了一个WebSocket API，您可以使用它来编写处理WebSocket消息的客户端和服务器端应用程序。

[[websocket-server-handler]]
=== `WebSocketHandler`
[.small]#<<web-reactive.adoc#webflux-websocket-server-handler, WebFlux>>#

创建WebSocket服务器与实现 `WebSocketHandler` 或继承 `TextWebSocketHandler` 或 `BinaryWebSocketHandler` 一样简单以下示例使用 `TextWebSocketHandler`：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import org.springframework.web.socket.WebSocketHandler;
	import org.springframework.web.socket.WebSocketSession;
	import org.springframework.web.socket.TextMessage;

	public class MyHandler extends TextWebSocketHandler {

		@Override
		public void handleTextMessage(WebSocketSession session, TextMessage message) {
			// ...
		}

	}
----

有专门的WebSocketJava配置和XML命名空间支持，用于将上述WebSocket处理程序映射到特定的URL。如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import org.springframework.web.socket.config.annotation.EnableWebSocket;
	import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
	import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Override
		public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
			registry.addHandler(myHandler(), "/myHandler");
		}

		@Bean
		public WebSocketHandler myHandler() {
			return new MyHandler();
		}

	}
----

以下示例显示了与前面示例等效的XML配置：

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:handlers>
			<websocket:mapping path="/myHandler" handler="myHandler"/>
		</websocket:handlers>

		<bean id="myHandler" class="org.springframework.samples.MyHandler"/>

	</beans>
----

以上是在Spring MVC应用程序中使用的，应包含在 <<mvc-servlet, `DispatcherServlet`>> 的配置中。但是，Spring的WebSocket支持不依赖于Spring MVC， 在 {api-spring-framework}/web/socket/server/support/WebSocketHttpRequestHandler.html[`WebSocketHttpRequestHandler`] 的帮助下，将 `WebSocketHandler` 集成到其他HTTP服务环境中是相对简单的。

当直接或间接使用 `WebSocketHandler` API时，例如 通过<<websocket-stomp,STOMP>>消息传递，由于基础标准WebSocket会话（JSR-356）不允许并发发送，因此应用程序必须同步消息的发送。 一种选择是用 {api-spring-framework}/web/socket/handler/ConcurrentWebSocketSessionDecorator.html[`ConcurrentWebSocketSessionDecorator`] 包装 `WebSocketSession`。

[[websocket-server-handshake]]
=== WebSocket 握手
[.small]#<<web-reactive.adoc#webflux-websocket-server-handshake, WebFlux>>#

自定义初始 `HTTPWebSocket` 握手请求的最简单的方法是通过 `HandshakeInterceptor`，它公开 "`before`" 和 "`after`" 的握手方法。 此类拦截器可用于阻止握手或使任何属性用于 `WebSocketSession`。例如，有一个内置的拦截器用于将HTTP会话属性传递给 `WebSocket` 会话：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Override
		public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
			registry.addHandler(new MyHandler(), "/myHandler")
				.addInterceptors(new HttpSessionHandshakeInterceptor());
		}

	}
----

以下示例显示了与前面示例等效的XML配置：

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:handlers>
			<websocket:mapping path="/myHandler" handler="myHandler"/>
			<websocket:handshake-interceptors>
				<bean class="org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor"/>
			</websocket:handshake-interceptors>
		</websocket:handlers>

		<bean id="myHandler" class="org.springframework.samples.MyHandler"/>

	</beans>
----

更高级的选项是继承执行WebSocket握手步骤的 `DefaultHandshakeHandler`，包括验证客户端来源、协商协议和其他操作。如果应用程序需要配置自定义 `RequestUpgradeStrategy`，以便适应WebSocket服务器引擎和尚未受支持的版本(有关此主题的更多信息，请参阅<<websocket-server-deployment,部署>>）， 则可能还需要使用此选项。Java配置和XML命名空间都可以配置自定义的 `HandshakeHandler`。

TIP: Spring提供了 `WebSocketHandlerDecorator` 基类，可用于用附加行为装饰 `WebSocketHandler`。在使用WebSocket的Java配置或XML命名空间时，默认情况下提供和添加日志记录和异常处理实现。 `ExceptionWebSocketHandlerDecorator` 捕获所有 `WebSocketHandler` 方法产生异常，并关闭具有指示服务器错误状态为 `1011` 的WebSocket会话。

[[websocket-server-deployment]]
=== 部署

Spring WebSocket API很容易集成到Spring MVC应用程序中，`DispatcherServlet` 既服务于HTTP WebSocket握手，也提供其他HTTP请求。通过调用 `WebSocketHttpRequestHandler` 也很容易集成到其他HTTP处理方案中。 这很方便易懂。 但是，在JSR-356运行时，需要特别注意。

Java WebSocket API(JSR-356)提供了两种部署机制。第一种是在启动时包含Servlet容器类路径扫描(Servlet 3功能)，另一个是在Servlet容器初始化时使用注册API。这两种机制都不能为所有http处理使用单一的“前端控制器”， 包括WebSocket握手和所有其他HTTP请求，例如Spring MVC的 `DispatcherServlet`。

这是JSR-356的一个重要限制，Spring的WebSocket支持解决了服务器特定的 `RequestUpgradeStrategy` 实现，即使在JSR-356运行时运行也是如此。 目前，Tomcat，Jetty，GlassFish，WebLogic，WebSphere和Undertow（以及WildFly）都有这样的策略。

NOTE: 	在Java WebSocket API中已经有解决上面限制的方法，并且遵循 https://github.com/eclipse-ee4j/websocket-api/issues/211[eclipse-ee4j/websocket-api#211] 中的规定。 还要注意的是，Tomcat和Jetty已经提供了本地的API替代品，可以实现这一点，Jetty也是如此。 我们希望更多服务器能够做到这一点。

第二个考虑因素是，具有JSR-356支持的Servlet容器将执行 `ServletContainerInitializer` (SCI)扫描，从而在某些情况下大大降低应用程序启动速度。如果在升级到带有JSR-356支持的Servlet容器版本后观察到了显著的影响， 则应该可以通过在 `web.xml` 中使用 `<absolute-ordering />` 元素来有选择地启用或禁用web片段(和SCI扫描)。

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<web-app xmlns="http://java.sun.com/xml/ns/javaee"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://java.sun.com/xml/ns/javaee
			https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
		version="3.0">

		<absolute-ordering/>

	</web-app>
----

然后，可以按名称有选择地启用web片段，例如Spring自定义的 `SpringServletContainerInitializer`，它为Servlet 3 Java初始化API提供支持。 以下示例显示了如何执行此操作：

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<web-app xmlns="http://java.sun.com/xml/ns/javaee"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="
			http://java.sun.com/xml/ns/javaee
			https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
		version="3.0">

		<absolute-ordering>
			<name>spring_web</name>
		</absolute-ordering>

	</web-app>
----



[[websocket-server-runtime-configuration]]
=== 服务器配置
[.small]#<<web-reactive.adoc#webflux-websocket-server-config, WebFlux>>#

每个底层的WebSocket引擎都公开了控制运行时特性的配置属性，如消息缓冲区大小、空闲超时和其他设置。

对于Tomcat Tomcat, WildFly, 和 GlassFish,可以将 `ServletServerContainerFactoryBean` 添加到WebSocket Java配置中。如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Bean
		public ServletServerContainerFactoryBean createWebSocketContainer() {
			ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();
			container.setMaxTextMessageBufferSize(8192);
			container.setMaxBinaryMessageBufferSize(8192);
			return container;
		}

	}
----

以下示例显示了与前面示例等效的XML配置：

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<bean class="org.springframework...ServletServerContainerFactoryBean">
			<property name="maxTextMessageBufferSize" value="8192"/>
			<property name="maxBinaryMessageBufferSize" value="8192"/>
		</bean>

	</beans>
----

NOTE: 对于客户端WebSocket配置，您应该使用 `WebSocketContainerFactoryBean`（XML）或 `ContainerProvider.getWebSocketContainer()` （Java配置）。

对于Jetty，您需要提供预配置的Jetty `WebSocketServerFactory` 并通过WebSocket Java配置将其插入Spring的 `DefaultHandshakeHandler`。 以下示例显示了如何执行此操作：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Override
		public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
			registry.addHandler(echoWebSocketHandler(),
				"/echo").setHandshakeHandler(handshakeHandler());
		}

		@Bean
		public DefaultHandshakeHandler handshakeHandler() {

			WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);
			policy.setInputBufferSize(8192);
			policy.setIdleTimeout(600000);

			return new DefaultHandshakeHandler(
					new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));
		}

	}
----

以下示例显示了与前面示例等效的XML配置：

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:handlers>
			<websocket:mapping path="/echo" handler="echoHandler"/>
			<websocket:handshake-handler ref="handshakeHandler"/>
		</websocket:handlers>

		<bean id="handshakeHandler" class="org.springframework...DefaultHandshakeHandler">
			<constructor-arg ref="upgradeStrategy"/>
		</bean>

		<bean id="upgradeStrategy" class="org.springframework...JettyRequestUpgradeStrategy">
			<constructor-arg ref="serverFactory"/>
		</bean>

		<bean id="serverFactory" class="org.eclipse.jetty...WebSocketServerFactory">
			<constructor-arg>
				<bean class="org.eclipse.jetty...WebSocketPolicy">
					<constructor-arg value="SERVER"/>
					<property name="inputBufferSize" value="8092"/>
					<property name="idleTimeout" value="600000"/>
				</bean>
			</constructor-arg>
		</bean>

	</beans>
----



[[websocket-server-allowed-origins]]
=== Allowed Origins（允许来源）
[.small]#<<web-reactive.adoc#webflux-websocket-server-cors, WebFlux>>#

在Spring 4.1.55版本之后，WebSocket和SockJS的默认行为是仅接受同源请求。也可以允许所有或指定的来源列表。此检查主要是为浏览器客户端设计的。没有什么能阻止其他类型的客户端修改 `Origin` 头值（有关更多详细信息，请参阅 https://tools.ietf.org/html/rfc6454[RFC 6454: The Web Origin Concept] ）。

三种可能的行为是:

 * 仅允许同源请求（默认）：在此模式下，启用SockJS时，Iframe HTTP响应头 `X-Frame-Options` 设置为 `SAMEORIGIN`，并禁用JSONP传输，因为它不允许检查源的的请求。 因此，启用此模式时不支持IE6和IE7。
 * 允许指定的来源列表：每个允许的来源必须以 `http://` 或 `https://` 开头。 在此模式下，启用SockJS时，将禁用IFrame传输。 因此，启用此模式时，不支持IE6到IE9。
 * 允许所有来源：要启用此模式，您应提供 `*` 作为允许的原始值。 在此模式下，所有传输都可用。

您可以配置WebSocket和SockJS允许的源，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import org.springframework.web.socket.config.annotation.EnableWebSocket;
	import org.springframework.web.socket.config.annotation.WebSocketConfigurer;
	import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;

	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Override
		public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
			registry.addHandler(myHandler(), "/myHandler").setAllowedOrigins("https://mydomain.com");
		}

		@Bean
		public WebSocketHandler myHandler() {
			return new MyHandler();
		}

	}
----

以下示例显示了与前面示例等效的XML配置：

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:handlers allowed-origins="https://mydomain.com">
			<websocket:mapping path="/myHandler" handler="myHandler" />
		</websocket:handlers>

		<bean id="myHandler" class="org.springframework.samples.MyHandler"/>

	</beans>
----




[[websocket-fallback]]
== SockJS回调选项

在公共Internet上，受控制之外的限制性代理可能会阻止WebSocket交互，因为它们未配置为传递 `Upgrade` 头，或者因为它们关闭看似空闲的长期连接。

此问题的解决方案是WebSocket仿真 - 即，首先尝试使用WebSocket，然后依靠基于HTTP的技术来模拟WebSocket交互并公开相同的应用程序级API。

在Servlet技术栈上，Spring Framework为SockJS协议提供服务器（以及客户端）支持。

[[websocket-fallback-sockjs-overview]]
=== 简介

SockJS的目标是让应用程序使用WebSocket的API，但在运行时需要回退到非WebSocket的替代方案，即无需更改应用程序代码。

SockJS包括:

* https://github.com/sockjs/sockjs-protocol[SockJS 协议] 定义了 https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html[测试的执行形式]
* https://github.com/sockjs/sockjs-client/[SockJS JavaScript 客户端] -- 一个用于浏览器的客户端库
* SockJS服务器实现是Spring框架中的 `spring-websocket` 模块.
* spring-websocket4.1之后的版本还提供了一个SockJS的Java客户端

SockJS是为在浏览器中使用而设计的。使用各种技术来支持广泛的浏览器版本会有很大的不同。有关SockJS传输类型和浏览器的完整列表，请参阅https://github.com/sockjs/sockjs-client/[SockJS client]页面。 传输分为三大类：WebSocket，HTTP Streaming和HTTP Long Polling。 有关这些类别的概述，请参阅此 https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/[this blog post]。

SockJS客户端首先发送 `GET/info` 以从服务器获取基本信息。 之后，它必须决定使用什么传输。 如果可能，使用WebSocket。 如果没有，在大多数浏览器中，至少有一个HTTP流选项。 如果不是，则使用HTTP（长）轮询。

所有传输请求都具有以下URL结构：


----
https://host:port/myApp/myEndpoint/{server-id}/{session-id}/{transport}
----

where:

* `{server-id}` 用于集群中的路由请求并且不在其他地方使用
* `{session-id}` 将属于SockJS会话的HTTP请求关联起来
* `{transport}` 指定传输的类型(例如，`websocket`, `xhr-streaming` 等等).

WebSocket传输只需要HTTP请求来执行WebSocket握手，此后所有消息都在该套接字上交换。

HTTP传输需要更多请求， Ajax/XHR streaming依赖于一个长时间运行的服务器消息请求和对客户机到服务器消息的其他HTTP POST请求。长轮询也是类似的，只是它在每次服务器发送后结束当前请求。

SockJS添加最小的消息帧，例如服务器最初发送字母 `o`("`open`" 帧)，消息的格式会是 `a["message1","message2"]`（JSON编码的数组），字母 `h`("`heartbeat`"  帧)， 如果在默认的25秒内没有消息流，将发送字母 `c`（"`close`"  帧）用于关闭会话。

要了解更多信息，请在浏览器中运行示例并观察HTTP请求。SockJS客户端允许修复传输列表，因此可以一次查看每个传输。SockJS客户端还提供了一个调试标志，它在浏览器控制台中启用有用的消息。 在服务器端启用 `org.springframework.web.socket` 的 `TRACE` 日志记录。有关更多详细信息，请参阅SockJS协议 https://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html[narrated test]。

[[websocket-fallback-sockjs-enable]]
=== 开启 SockJS

您可以通过Java配置启用SockJS，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocket
	public class WebSocketConfig implements WebSocketConfigurer {

		@Override
		public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
			registry.addHandler(myHandler(), "/myHandler").withSockJS();
		}

		@Bean
		public WebSocketHandler myHandler() {
			return new MyHandler();
		}

	}
----

以下示例显示了与前面示例等效的XML配置：

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:handlers>
			<websocket:mapping path="/myHandler" handler="myHandler"/>
			<websocket:sockjs/>
		</websocket:handlers>

		<bean id="myHandler" class="org.springframework.samples.MyHandler"/>

	</beans>
----

前面的示例用于Spring MVC应用程序，应该包含在 <<mvc-servlet, `DispatcherServlet`>> 的配置中。 但是，Spring的WebSocket和SockJS支持并不依赖于Spring MVC。 在 {api-spring-framework}/web/socket/sockjs/support/SockJsHttpRequestHandler.html[`SockJsHttpRequestHandler`] 的帮助下，将其集成到其他HTTP服务环境中相对简单。

在浏览器端，应用程序可以使用 https://github.com/sockjs/sockjs-client/[`sockjs-client`]（版本1.0.x）来模拟W3C WebSocket API，并与服务器进行通信，根据它所运行的浏览器选择最佳传输选项。 查看 https://github.com/sockjs/sockjs-client/[sockjs-client] 页和浏览器支持的传输类型列表。客户端还提供了几个配置选项，例如指定要包含哪些传输。

[[websocket-fallback-xhr-vs-iframe]]
=== IE 8 和 9

Internet Explorer 8和9仍在使用中。 他们是拥有SockJS的关键原因。 本节介绍在这些浏览器中运行的重要注意事项。

SockJS客户端通过使用Microsoft的 https://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx[`XDomainRequest`]。在IE 8和9中支持Ajax/XHR流。 能够做到跨域工作，但不支持发送cookie。对于Java应用程序来说，cookie通常是必不可少的。但是，由于SockJS客户端可以与许多服务器类型一起使用(不仅仅是Java），所以需要知道cookie是否重要。 如果是这样，SockJS客户端更喜欢Ajax/XHR流，否则它依赖于iframe-based技术。

来自SockJS客户端的第一个 `/info` 请求是对可能影响客户选择传输的信息的请求。其中一个细节是服务器应用程序是否依赖于cookie，例如用于身份验证或使用粘性会话进行群集。 Spring的SockJS支持包括一个称为 `sessionCookieNeeded` 的属性。
默认情况下，它是启用的，因为大多数Java应用程序都依赖 `JSESSIONID` cookie。如果应用程序不需要它，可以关闭此选项，SockJS客户端应在IE 8和9中选择 `xdr-streaming`。

如果您确实使用基于iframe的传输，请记住，可以通过将HTTP响应标头 `X-Frame-Options` 设置为 `DENY`，`SAMEORIGIN` 或 `ALLOW-FROM <origin>` 来指示浏览器阻止在给定页面上使用IFrames。 这用于防止 https://www.owasp.org/index.php/Clickjacking[点击劫持]。

[NOTE]
====

Spring Security 3.2+ 版本为每个响应提供 `X-Frame-Options` 的设置。默认情况下，Spring Security Java配置将其设置为 `DENY`。 在3.2中，Spring Security XML命名空间默认情况下不设置该头，但可以配置为执行此操作。 将来，它可以默认设置它。

有关如何配置 `X-Frame-Options` 头设置的详细信息，请参阅Spring Security文档的 {doc-spring-security}/htmlsingle/#headers[默认的安全头]。 您还可以查看 https://jira.spring.io/browse/SEC-2501[SEC-2501]的其他背景信息。
====

如果您的应用程序添加了 `X-Frame-Options` 响应头（其实应该这样做），并且是依赖 iframe-based 传输的，则需要将标头设置为 `SAMEORIGIN` 或 `ALLOW-FROM <origin>`。 随着Spring SockJS的支持也需要知道SockJS客户端的位置，因为它是从iframe加载的。默认情况下，iframe被设置为从CDN位置下载SockJS客户端。最好将此选项配置为来自应用程序相同的URL源。

以下示例显示了如何在Java配置中执行此操作：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/portfolio").withSockJS()
					.setClientLibraryUrl("http://localhost:8080/myapp/js/sockjs-client.js");
		}

		// ...

	}
----

XML命名空间通过 `<websocket:sockjs>` 元素提供了类似的选项。

NOTE: 在初始开发期间，请启用SockJS客户端开发模式，以防止浏览器缓存否则将被缓存的SockJS请求（如iframe）。 有关如何启用它的详细信息，请参阅https://github.com/sockjs/sockjs-client/[SockJS client] 页面。

[[websocket-fallback-sockjs-heartbeat]]
=== 心跳

SockJS协议要求服务器发送心跳消息以防止代理结束了连接。Spring SockJS配置有一个称为 `heartbeatTime` 的属性，可用于自定义频率。默认情况下，如果没有在该连接上发送其他消息，它会在25秒后发送心跳。这25秒的值符合以下 https://tools.ietf.org/html/rfc6202[IETF推荐]  公共互联网应用程序的设置。

NOTE: 在WebSocket/SockJS中使用STOMP时，如果STOMP的客户端和服务器忽略心跳的交互，SockJS的心跳可以被关闭。

Spring SockJS还允许配置 `TaskScheduler` 用于设置计划心跳任务。任务计划程序由具有默认设置的线程池支持，该线程池基于可用处理器的数量。应用程序应考虑根据特定需要而自定义设置。

[[websocket-fallback-sockjs-servlet3-async]]
=== 客户端断开连接

HTTP流和HTTP长轮询SockJS传输要求连接保持比通常更长时间的停留，有关这些技术的概述，请参阅此https://spring.io/blog/2012/05/08/spring-mvc-3-2-preview-techniques-for-real-time-updates/[博客文章].

在Servlet容器中，这个功能是通过Servlet 3异步支持完成的，它允许退出Servlet容器线程处理请求并继续从另一个线程写入响应。

一个特殊的问题是，Servlet API不会为已断开的客户端发送通知。请参看 https://github.com/eclipse-ee4j/servlet-api/issues/44[eclipse-ee4j/servlet-api#44]。 但是，Servlet容器在随后尝试写入响应时引发异常。由于Spring的SockJS服务支持服务器发送的心跳(默认情况下是每隔25秒就发一次)，这意味着在该时间段内或更早地发送消息时，通常会检测到客户端断开。

NOTE: 	有时候客户端的断开连接会导致服务端发生网络IO故障，从而记录了不必要的堆栈跟踪日志。Spring尽最大努力识别出代表客户端断开连接(特定于每台服务器)的网络故障， 并使用 `AbstractSockJsSession` 中定义的专用日志类别 `DISCONNECTED_CLIENT_LOG_CATEGORY` 记录最少的消息。如果需要查看堆栈跟踪，请将该日志类别设置为 `TRACE`。


[[websocket-fallback-cors]]
=== SockJS 和 CORS

如果允许 cross-origin 请求(请参阅第 <<websocket-server-allowed-origins, Allowed Origins>>), 则SockJS协议使用CORS在XHR流和轮询传输中进行跨域支持。因此，除非检测到响应中存在CORS头， 否则会自动添加CORS头。因此，如果应用程序已经配置为提供CORS支持，例如通过Servlet过滤器，Spring的 `SockJsService` 将跳过此部分。

也可以通过在Spring的SockJsService中设置 `suppressCors` 属性来禁用这些CORS头的添加。

以下是SockJS的默认头信息列表和默认值：

* `Access-Control-Allow-Origin`: 初始化来自请求头中 `Origin` 的值
* `Access-Control-Allow-Credentials`: 始终设置为 `true`
* `Access-Control-Request-Headers`: 初始化值来自相同的请求头
* `Access-Control-Allow-Methods`: HTTP方法传输支持(见 `TransportType` 的枚举).
* `Access-Control-Max-Age`: 设置为31536000 (1 年).

对于实现可以看 `AbstractSockJsService` 中的 `addCorsHeaders` 方法，也可以看 `TransportType` 枚举类的源代码。

或者, 如果CORS配置允许它考虑排除URL与SockJS终端前缀，从而让Spring的 `SockJsService` 处理它。


[[websocket-fallback-sockjs-client]]
=== `SockJsClient`

提供SockJS的Java客户端版本，方便在不使用浏览器的情况下连接到远程SockJS端点。当需要通过公用网络(即网络代理可能不使用WebSocket协议)在两个服务器之间进行双向通信时，这一点尤其有用。 SockJS Java客户端对于测试目的也非常有用，例如模拟大量并发用户。

SockJS的Java客户端支持 `websocket`, `xhr-streaming`, 和 `xhr-polling` 传输.，其余的部分只在浏览器中使用才有意义。

`WebSocketTransport` 可以配置为:


* JSR356运行时中的 `StandardWebSocketClient`.
* `JettyWebSocketClient` 使用Jetty9本地的WebSocket的API
* Spring `WebSocketClient` 的任何实现.

根据定义，`XhrTransport` 支持 `xhr-streaming` 和 `xhr-polling`，因为从客户端的角度来看，除了用于连接服务器的URL之外没有其他区别。 目前有两种实现方式：


* `RestTemplateXhrTransport` 使用Spring 的 `RestTemplate` 进行HTTP请求。
* `JettyXhrTransport` 使用Jetty的 `HttpClient` 进行HTTP请求。

以下示例显示如何创建SockJS客户端并连接到SockJS端点：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
  List<Transport> transports = new ArrayList<>(2);
  transports.add(new WebSocketTransport(new StandardWebSocketClient()));
  transports.add(new RestTemplateXhrTransport());

  SockJsClient sockJsClient = new SockJsClient(transports);
  sockJsClient.doHandshake(new MyWebSocketHandler(), "ws://example.com:8080/sockjs");
----

NOTE: SockJS使用JSON格式的数组进行消息传递。 默认情况下，使用Jackson 2并且需要在类路径上。 或者，您可以配置 `SockJsMessageCodec` 的自定义实现并在 `SockJsClient` 上配置它。

要使用 `SockJsClient` 模拟大量并发用户，您需要配置底层HTTP客户端（用于XHR传输）以允许足够数量的连接和线程。 以下示例显示了如何使用Jetty执行此操作：


[source,java,indent=0]
[subs="verbatim,quotes"]
----
HttpClient jettyHttpClient = new HttpClient();
jettyHttpClient.setMaxConnectionsPerDestination(1000);
jettyHttpClient.setExecutor(new QueuedThreadPool(1000));
----

以下示例显示了您应该考虑自定义的服务器端SockJS相关属性（请参阅javadoc以获取详细信息）：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	public class WebSocketConfig extends WebSocketMessageBrokerConfigurationSupport {

		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/sockjs").withSockJS()
				.setStreamBytesLimit(512 * 1024) <1>
				.setHttpMessageCacheSize(1000) <2>
				.setDisconnectDelay(30 * 1000); <3>
		}

		// ...
	}
----
<1> 将 `streamBytesLimit` 属性设置为512KB（默认值为128KB- `128 * 1024`）。
<2> 将 `httpMessageCacheSize` 属性设置为 1000（默认值为 `100`）。
<3> 将断开连接延迟属性设置为 `30` 秒（默认值为5秒- `5 * 1000`）。

[[websocket-stomp]]
== STOMP

WebSocket协议定义了两种类型的消息,即文本和二进制,但它们的内容是未定义的。预计客户端和服务器可能会同意使用协议(即更高级别的消息传递协议）。虽然使用协议与WebSocket是完全分离的， 无论哪种方式客户端和服务器将需要协商好用某种协议，以帮助解析消息。

[[websocket-stomp-overview]]
=== 概述

https://stomp.github.io/stomp-specification-1.2.html#Abstract[STOMP] (是一种简单的面向文本的消息传递协议) ，最初是为Ruby、Python和Perl等脚本语言创建的，用于连接企业消息代理。 它旨在解决常用的消息传递模式的一个子集。STOMP可以用于任何可靠的双工流网络协议，如TCP和WebSocket。虽然STOMP是一种面向文本的协议，但消息的类型可以是文本或二进制。

STOMP基于HTTP帧模型协议的，STOMP的帧结构如下

----
COMMAND
header1:value1
header2:value2

Body^@
----

客户端可以使用 `SEND` 或 `SUBSCRIBE` 命令来发送或订阅消息，并且通过 `destination` 的头部信息描述消息的内容将由谁来接收。这是一个简单的发布/订阅策略，可用于通过代理向其他连接的客户端发送消息，或向服务器发送消息以请求执行某些工作。

当使用Spring来支持的STOMP时，Spring WebSocket的应用在客户端中扮演着STOMP代理的角色。消息被路由到 `@Controller` 的消息处理方法或一个简单的内存代理，它跟踪订阅并向订阅用户广播消息。 还可以配置Spring与专门的STOMP代理(如RabbitMQ，ActiveMQ等)的实际广播的消息。在这种情况下，Spring维护到代理的TCP连接，将消息中继到它，并将消息从它传递到连接的WebSocket客户端。因此，Spring Web应用程序可以依赖统一的HTTP安全性、通用验证和熟悉的编程模型消息处理工作。

下面是一个客户端订阅接收股票报价的示例，服务器可能会周期性地发出此消息，例如通过 `SimpMessagingTemplate` 向代理发送邮件的计划任务：

----
SUBSCRIBE
id:sub-1
destination:/topic/price.stock.*

^@
----

下面是一个客户端发送贸易请求的示例，服务器可以通过 `@MessageMapping` 方法处理该交易请求：

----
SEND
destination:/queue/trade
content-type:application/json
content-length:44

{"action":"BUY","ticker":"MMM","shares",44}^@
----

执行后，服务器可以向客户端广播交易确认消息和详细信息。

在STOMP规范中故意将目的地的含义保持不透明。 它可以是任何字符串，完全取决于STOMP服务器来定义它们支持的目标的语义和语法。 然而，很常见的是，但是目的地是类似路径的字符串，其中 `/topic/..` 意味着发布 - 订阅（一对多）和 `/queue/` 意味着点对点（一对一）消息交流。

STOMP服务器可以使用 `MESSAGE` 命令向所有订户广播消息。以下是向已订阅的客户端发送股票报价的服务器示例:

----
MESSAGE
message-id:nxahklf6-1
subscription:sub-1
destination:/topic/price.stock.MMM

{"ticker":"MMM","price":129.45}^@
----

服务器无法发送未经请求的消息。 来自服务器的所有消息必须响应特定的客户端订阅，并且服务器消息的 `subscription-id` 头必须与客户端订阅的 `id` 头匹配。

上面的概述目的是对STOMP协议有一个基本的理解。 我们建议查看完整的https://stomp.github.io/stomp-specification-1.2.html[协议规范] 。

[[websocket-stomp-benefits]]
=== 优点

使用STOMP作为子协议，Spring Framework和Spring Security提供了比使用原始WebSocket更丰富的编程模型。关于HTTP与原始TCP以及它如何让Spring MVC和其他Web框架提供丰富的功能，可以做出同样的观点。 以下是一系列好处：

* 无需自定义消息的格式
* 可以使用STOMP客户端，包括Spring Framework中的 <<websocket-stomp-client, Java client>>
* 您可以（可选）使用消息代理（例如RabbitMQ，ActiveMQ等）来管理订阅和广播消息。
* 可以在任意数量的 `@Controller` 实例中组织应用程序逻辑，并且可以基于STOMP目标头将消息路由到它们，而不是使用给定连接的单个 `WebSocketHandler` 处理原始WebSocket消息。
* 您可以使用Spring Security根据STOMP目标和消息类型保护消息。



[[websocket-stomp-enable]]
===  启用STOMP

`spring-messaging` 和 `spring-websocket` 模块提供STOMP over WebSocket支持。 一旦有了这些依赖，就可以通过带有 <<websocket-fallback>> 的WebSocket公开STOMP端点，如下例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
	import org.springframework.web.socket.config.annotation.StompEndpointRegistry;

	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/portfolio").withSockJS();  // <1>
		}

		@Override
		public void configureMessageBroker(MessageBrokerRegistry config) {
			config.setApplicationDestinationPrefixes("/app"); // <2>
			config.enableSimpleBroker("/topic", "/queue"); // <3>
		}
	}
----

<1> `/portfolio` 是WebSocket（或SockJS）客户端为WebSocket握手需要连接的端点的HTTP URL.
<2> 目标头以 `/app` 开头的STOMP消息将路由到 `@Controller` 类中的 `@MessageMapping` 方法。
<3> 	使用内置消息代理进行订阅和广播，并将目标头以 `/topic` or `/queue` 开头的消息路由到代理。

以下示例显示了与前面示例等效的XML配置：

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:message-broker application-destination-prefix="/app">
			<websocket:stomp-endpoint path="/portfolio">
				<websocket:sockjs/>
			</websocket:stomp-endpoint>
			<websocket:simple-broker prefix="/topic, /queue"/>
		</websocket:message-broker>

	</beans>
----

NOTE: 对于内置的简单代理，`/topic` 和 `/queue` 前缀没有任何特殊含义。 它们仅仅是区分pub-sub和点对点消息传递的惯例（即，许多订阅者与一个消费者）。 使用外部代理时，请检查代理的STOMP页面，以了解它支持的STOMP目标和前缀类型。

要从浏览器连接，对于SockJS，您可以使用 https://github.com/sockjs/sockjs-client[`sockjs-client`]。对于STOMP，许多应用程序使用了 https://github.com/jmesnil/stomp-websocket[jmesnil/stomp-websocket]库（也称为stomp.js），它是功能完备的，已经在生产中使用多年但不再维护。 目前，https://github.com/JSteunou/webstomp-client[JSteunou/webstomp-client] 是该库中最积极维护和不断发展的继任者。 以下示例代码基于它：

[source,javascript,indent=0]
[subs="verbatim,quotes"]
----
	var socket = new SockJS("/spring-websocket-portfolio/portfolio");
	var stompClient = webstomp.over(socket);

	stompClient.connect({}, function(frame) {
	}
----

或者，如果通过WebSocket连接（没有SockJS），则可以使用以下代码：

[source,javascript,indent=0]
[subs="verbatim,quotes"]
----
	var socket = new WebSocket("/spring-websocket-portfolio/portfolio");
	var stompClient = Stomp.over(socket);

	stompClient.connect({}, function(frame) {
	}
----

注意上面的 `stompClient` 不需要指定 `login` 和 `passcode` 的头信息。即使是这样，它们也会在服务器端被忽略，或者被重写。有关身份验证的详细信息，请参阅 <<websocket-stomp-handle-broker-relay-configure,Connecting to a Broker>>和<<websocket-stomp-authentication,身份验证>>。

有关更多示例代码，请参阅

* https://spring.io/guides/gs/messaging-stomp-websocket/[Using WebSocket to build an
interactive web application] -- 入门指南。
* https://github.com/rstoyanchev/spring-websocket-portfolio[Stock Portfolio] -- 一个示例应用程序。



[[websocket-stomp-server-config]]
=== WebSocket 服务器

要配置基础WebSocket服务器，应用<<websocket-server-runtime-configuration,服务器配置>>中的信息。但是对于Jetty，您需要通过 `StompEndpointRegistry` 设置 `HandshakeHandler` 和 `WebSocketPolicy`：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/portfolio").setHandshakeHandler(handshakeHandler());
		}

		@Bean
		public DefaultHandshakeHandler handshakeHandler() {

			WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);
			policy.setInputBufferSize(8192);
			policy.setIdleTimeout(600000);

			return new DefaultHandshakeHandler(
					new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));
		}
	}
----



[[websocket-stomp-message-flow]]
=== 消息流

一旦暴露了STOMP端点，Spring应用程序就成为连接客户端的STOMP代理。 本节介绍服务器端的消息流。

`spring-messaging` 模块包含对源自 https://spring.io/spring-integration[Spring Integration] 的消息传递应用程序的基础支持，后来被提取并整合到Spring Framework中，以便在许多 https://spring.io/projects[Spring projects]和应用程序场景中得到更广泛的使用。 以下列表简要介绍了一些可用的消息传递抽象：


* {api-spring-framework}/messaging/Message.html[Message]: 携带有头和负载的消息
* {api-spring-framework}/messaging/MessageHandler.html[MessageHandler]: 消息处理协议
* {api-spring-framework}/messaging/MessageChannel.html[MessageChannel]: 发送消息的协议，使发件人和接收方弱耦合
* {api-spring-framework}/messaging/SubscribableChannel.html[SubscribableChannel]: 继承自 `MessageChannel` 并且发送消息给注册的 `MessageHandler` 订阅者
* {api-spring-framework}/messaging/support/ExecutorSubscribableChannel.html[ExecutorSubscribableChannel]: 使用 `Executor` 传递消息的 `SubscribableChannel`。

Java配置（即 `@EnableWebSocketMessageBroker`）和XML命名空间配置（即 `<websocket:message-broker>`）都使用前面的组件来组装消息工作流。 下图显示了启用简单内置消息代理时使用的组件：

image::images/message-flow-simple-broker.png[]

上图显示了三个消息通道：

* `clientInboundChannel`: 用于传递来自WebSocket客户端的消息
* `clientOutboundChannel`: 用于传递给WebSocket客户端的消息
* `brokerChannel`: 用于从应用程序中向代理发送消息

下图显示了配置外部代理（例如RabbitMQ）以管理订阅和广播消息时使用的组件：

image::images/message-flow-broker-relay.png[]

这两个图之间的主要区别在于使用 "`broker relay`" 通过TCP将消息传递到外部STOMP代理，以及将消息从代理传递到订阅的客户端。

当从WebSocket连接接收消息时，它们被解码为STOMP帧，变为Spring消息表示，并发送到 `clientInboundChannel` 以进行进一步处理。 例如， 目标标头以 `/app` 开头的STOMP消息可以路由到带注解的控制器中的 `@MessageMapping` 方法，而 `/topic` 和 `/queue` 消息可以直接路由到消息代理。

带注解的 `@Controller` 可以处理由客户端通过 `brokerChannel` 发送到服务端的消息，并且通过 `clientOutboundChannel` 将消息广播给匹配的订阅者。 同一个控制器也可以响应HTTP请求执行相同操作，因此客户端可以执行HTTP POST，然后 `@PostMapping` 方法可以向消息代理发送消息以向订阅的客户端广播。

我们可以通过一个简单的例子来追踪流程。 请考虑以下示例，该示例设置服务器：


[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/portfolio");
		}

		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.setApplicationDestinationPrefixes("/app");
			registry.enableSimpleBroker("/topic");
		}
	}

	@Controller
	public class GreetingController {

		@MessageMapping("/greeting") {
		public String handle(String greeting) {
			return "[" + getTimestamp() + ": " + greeting;
		}
	}
----

上面的示例支持以下流程：

. 客户端需要连接到 `http://localhost:8080/portfolio`，一旦建立了WebSocket连接，STOMP帧就开始在其上流动。
. 客户端发送SUBSCRIBE帧，其目标头为 `/topic/greeting`。 收到并解码后，消息将发送到 `clientInboundChannel` ，然后路由到存储客户端订阅的消息代理。
. 客户端向 `/app/greeting` 发送aSEND帧。 `/app` 前缀有助于将其路由到带注解的控制器。 除去 `/app` 前缀后，目标的剩余 `/greeting` 部分将映射到 `GreetingController` 中的 `@MessageMapping` 方法。
. 从 `GreetingController` 返回的值变为Spring消息，其中有效负载基于返回值和 `/topic/greeting` 的默认目标头（从 `/app` 替换为 `/topic` ）。生成的消息将发送到 `brokerChannel` 并由消息代理处理。
. 消息代理找到所有匹配的订阅者，并通过 `clientOutboundChannel` 向每个订阅者发送一个MESSAGE帧，消息被编码为STOMP帧并在WebSocket连接上发送。

下一节提供了有关注解方法的更多详细信息，包括支持的参数类型和返回值。

[[websocket-stomp-handle-annotations]]
=== 注解控制器

应用程序可以使用带注解的 `@Controller` 类来处理来自客户端的消息。 这些类可以声明 `@MessageMapping`, `@SubscribeMapping`, 和 `@ExceptionHandler` 方法，如以下主题中所述：

* <<websocket-stomp-message-mapping>>
* <<websocket-stomp-subscribe-mapping>>
* <<websocket-stomp-exception-handler>>


[[websocket-stomp-message-mapping]]
==== `@MessageMapping`

您可以使用 `@MessageMapping` 注解将方法映射到消息目标。 它在方法级别和类型级别受支持。 在类型级别，`@MessageMapping` 用于表示控制器中所有方法的共享映射。

默认目的地的匹配是Ant风格的使用斜线分隔(例如， `/thing*`, `/thing/**`),他们可以包含模板变量(例如, `/thing/{id}`)。可以通过 `@DestinationVariable` 的注解方法参数引用。 应用程序还可以切换到以点为分隔符的映射目标约定，如<<websocket-stomp-destination-separator,点作为分隔符>>中所述。

===== 支持以下方法参数

下表描述了方法参数：

[cols="1,2", options="header"]
|===
| 方法参数 | 描述

| `Message`
| 用于访问完整的消息。

| `MessageHeaders`
| 用于访问Message中的头部信息。

| `MessageHeaderAccessor`, `SimpMessageHeaderAccessor`, and `StompHeaderAccessor`
| 通过类型化方法访问头部信息

| `@Payload`
| 用于访问消息的负载,，由已配置的 `MessageConverter` 转换（例如，从JSON）。

由于默认情况下是假定的，因此不需要注解的存在。

您可以使用 `@javax.validation.Valid` 或Spring的 `@Validated` 注解有效负载参数，以自动验证Payload参数。

| `@Header`
| 用于访问特定header值 - 以及使用 -- `org.springframework.core.convert.converter.Converter` 进行类型转换（如有必要）。

| `@Headers`
| 用于访问消息中的所有标头。 此参数必须可分配给 `java.util.Map`.

| `@DestinationVariable`
| 用于访问从消息目标提取的模板变量。根据需要将值转换为声明的方法参数类型。

| `java.security.Principal`
| 反射在WebSocket HTTP握手时登录的用户

|===

===== 返回值

默认的情况下，`@MessageMapping` 方法的返回值是用 `MessageConverter` 转换的，并作为新消息的正文。默认情况下将其发送到与客户端消息具有相同目标的 `brokerChannel`， 但默认情况下使用前缀 `/topic`。

您可以使用 `@SendTo` 和 `@SendToUser` 注解来自定义输出消息的目标。 `@SendTo` 用于自定义目标目的地或指定多个目的地。`@SendToUser` 用于将输出消息定向到仅与输入消息关联的用户。 请参阅<<websocket-stomp-user-destination,User Destinations>>。

您可以在同一方法上同时使用 `@SendTo` 和 `@SendToUser`，并且在类级别都支持它们，在这种情况下，它们充当类中方法的默认值。 但是，请记住，任何方法级别的 `@SendTo` 或 `@SendToUser` 注解都会覆盖类级别的任何此类注解。

消息可以异步处理，`@MessageMapping` 方法可以返回 `ListenableFuture`, `CompletableFuture`, 或 `CompletionStage`。

请注意，`@SendTo` 和 `@SendToUser` 仅仅是一种便利，相当于使用 `SimpMessagingTemplate` 发送消息。 如有必要，对于更高级的方案， `@MessageMapping` 方法可以直接使用 `SimpMessagingTemplate`。 这可以代替返回值，或者可能另外返回值。 请参阅<<websocket-stomp-handle-send,发送消息>>。

[[websocket-stomp-subscribe-mapping]]
==== `@SubscribeMapping`

`@SubscribeMapping` 类似于 `@MessageMapping`，但仅将映射缩小为订阅消息。它支持与 `@MessageMapping` 相同的<<websocket-stomp-message-mapping, 方法参数>> 。 但是对于返回值，默认情况下，消息将直接发送到客户端（通过 `clientOutboundChannel`，以响应订阅）而不是发送到代理（通过 `brokerChannel`，作为匹配订阅的广播）。 添加 `@SendTo` 或 `@SendToUser` 会覆盖此行为并发送给代理。

什么时候有用？ 假设代理映射到 `/topic` 和 `/queue`，而应用程序控制器映射到 `/app`。 在此设置中，代理将所有订阅存储到 `/topic` 和 `/queue`，用于重复广播，并且不需要应用程序参与。
客户端还可以订阅某个 `/app` 目的地，并且控制器可以返回响应于该订阅的值而不涉及代理而不再存储或使用订阅（实际上是一次性请求 - 回复交换）。 一个用例是在启动时使用初始数据填充UI。

什么时候这没用？ 不要尝试将代理和控制器映射到相同的目标前缀，除非您由于某种原因希望两者都独立处理消息（包括订阅）。 入站消息是并行处理的。 无法保证代理或控制器是否首先处理给定的消息。
如果在存储订阅并准备好广播时通知目标，则客户端应该在服务器支持时询问收据（简单代理不支持）。 例如，使用Java <<websocket-stomp-client, STOMP client>>，您可以执行以下操作来添加收据:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Autowired
	private TaskScheduler messageBrokerTaskScheduler;

	// During initialization..
	stompClient.setTaskScheduler(this.messageBrokerTaskScheduler);

	// When subscribing..
	StompHeaders headers = new StompHeaders();
	headers.setDestination("/topic/...");
	headers.setReceipt("r1");
	FrameHandler handler = ...;
	stompSession.subscribe(headers, handler).addReceiptTask(() -> {
		// Subscription ready...
	});
----

服务器端选项是在 `brokerChannel` 上 <<websocket-stomp-interceptors, 注册>> `ExecutorChannelInterceptor` ，并在处理完消息（包括订阅）后实现调用的 `afterMessageHandled` 方法。


[[websocket-stomp-exception-handler]]
==== `@MessageExceptionHandler`

应用程序可以使用 `@MessageExceptionHandler` 方法来处理来自 `@MessageMapping` 方法的异常。 如果要访问异常实例，可以在注解本身或通过方法参数声明异常。 以下示例通过方法参数声明异常：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Controller
	public class MyController {

		// ...

		@MessageExceptionHandler
		public ApplicationError handleException(MyException exception) {
			// ...
			return appError;
		}
	}
----

`@MessageExceptionHandler` 方法支持灵活的方法签名，并支持与<<websocket-stomp-message-mapping, `@MessageMapping`>> 方法相同的方法参数类型和返回值。

通常，`@MessageExceptionHandler` 方法适用于声明它们的@Controller类（或类层次结构）。 如果您希望此类方法更全局地应用（跨控制器）， 则可以在标有 `@ControllerAdvice` 的类中声明它们。 这与Spring MVC中提供的<<web.adoc#mvc-ann-controller-advice, 类似支持>>相当。

[[websocket-stomp-handle-send]]
=== 发送消息

如果要将消息从应用程序的任何组件发送到已连接的客户端，该怎么办？任何应用程序的组件都可以向 `brokerChannel` 发送消息。最简单的方法是 `SimpMessagingTemplate` 注入，并使用它来发送消息。通常，它使用类型注入是如此方便的。如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Controller
	public class GreetingController {

		private SimpMessagingTemplate template;

		@Autowired
		public GreetingController(SimpMessagingTemplate template) {
			this.template = template;
		}

		@RequestMapping(path="/greetings", method=POST)
		public void greet(String greeting) {
			String text = "[" + getTimestamp() + "]:" + greeting;
			this.template.convertAndSend("/topic/greetings", text);
		}

	}
----

但是，如果存在相同类型的另一个bean，您还可以通过其名称（`brokerMessagingTemplate`）对其进行限定。

[[websocket-stomp-handle-simple-broker]]
=== 简单的消息代理

内置的简单消息代理处理来自客户端的订阅请求，首先会将它们存储在内存中，然后将消息广播到具有匹配目的地的已连接客户端。代理支持类似路径的目的地，包括对Ant样式的目的地模式的订阅。

NOTE: 	应用程序还可以使用点分隔（而不是斜线分隔）目标。 请查阅<<websocket-stomp-destination-separator,点作为分隔符>>。

如果配置了任务调度程序，则简单代理支持 https://stomp.github.io/stomp-specification-1.2.html#Heart-beating[STOMP 心跳]。 为此，您可以声明自己的调度程序或使用内部自动声明和使用的调度程序。 以下示例显示如何声明自己的调度程序：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

	private TaskScheduler messageBrokerTaskScheduler;

	@Autowired
	public void setMessageBrokerTaskScheduler(TaskScheduler taskScheduler) {
		this.messageBrokerTaskScheduler = taskScheduler;
	}

	@Override
	public void configureMessageBroker(MessageBrokerRegistry registry) {

		registry.enableSimpleBroker("/queue/", "/topic/")
				.setHeartbeatValue(new long[] {10000, 20000})
				.setTaskScheduler(this.messageBrokerTaskScheduler);

		// ...
	}
}
----



[[websocket-stomp-handle-broker-relay]]
=== 全功能的消息代理

简单的代理作为入门级别功能强大，但只是STOMP命令支持的一个子集(如没有ack，接收者等)，依赖于一个简单的消息循环发送，这不适合集群。作为一种替代方法，应用程序可以升级到使用功能完备的消息代理。

请参阅STOMP文档以了解您选择的消息代理（例如https://www.rabbitmq.com/stomp.html[RabbitMQ]，https://activemq.apache.org/stomp.html[ActiveMQ]等），安装代理，并在启用STOMP支持的情况下运行它。 然后，您可以在Spring配置中启用STOMP代理中继（而不是简单代理）。

以下示例配置启用功能齐全的代理：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint("/portfolio").withSockJS();
		}

		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.enableStompBrokerRelay("/topic", "/queue");
			registry.setApplicationDestinationPrefixes("/app");
		}

	}
----

以下示例显示了与前面示例等效的XML配置：

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:message-broker application-destination-prefix="/app">
			<websocket:stomp-endpoint path="/portfolio" />
				<websocket:sockjs/>
			</websocket:stomp-endpoint>
			<websocket:stomp-broker-relay prefix="/topic,/queue" />
		</websocket:message-broker>

	</beans>
----

上面配置中的 STOMP broker relay 在spring的 {api-spring-framework}/messaging/MessageHandler.html[`MessageHandler`] 处理请求通过转发他们给外部的消息代理。为了这么做需要建立TCP连接到消息代理，，转发所有的消息给代理并且转发所有的接收到的来自消息代理发送给客户端的内容(通过她们的WebSocket会话)。本质上对于传递消息在两个目的地之间，它扮演 “relay”角色


NOTE: 将 `io.projectreactor.netty:reactor-netty` 和 `io.netty:netty-all` 依赖添加到项目中以进行TCP连接管理。

此外，应用组件（例如HTTP请求处理方法、业务服务等）也可以发送消息给消息代理。如<<websocket-stomp-handle-send,发送消息>>中所述，以向订阅的WebSocket客户端广播消息。

实际上，代理中继实现了强健且可伸缩的消息广播

[[websocket-stomp-handle-broker-relay-configure]]
=== 连接到消息代理

STOMP代理中继会对代理维持单一的 "`system`" 级TCP连接。此连接仅用于来自服务器端应用程序的消息，而不用于接收消息。可以配置此连接的STOMP证书，即STOMP帧的 `login` 和 `passcode` 头， 这在XML命名空间和Java配置中都作为 `systemLogin` 和 `systemPasscode` 属性公开，默认值是 `guest` 和 `guest`。

STOMP代理中继还为每个连接的WebSocket客户端创建一个单独的TCP连接，可以将STOMP证书配置为代表客户端创建的所有TCP连接使用。这在XML命名空间和Java配置中都作为 `clientLogin` 和 `clientPasscode` 属性公开，默认值是 `guest` 和 `guest`。


NOTE: STOMP代理中继总是在每个连接帧前设置 `login` 和 `passcode` 头，它转发给代理客户端。因此，WebSocket客户端无需设置这些标头，它们也将被忽略。 正如<<websocket-stomp-authentication,身份验证>>部分所述，WebSocket客户端应依赖HTTP身份验证来保护WebSocket端点并建立客户端标识。

STOMP代理也能与消息代理在 "`system`" 级的TCP连接上发送和接收心跳，可以配置发送和接收心跳的间隔（默认是每10秒），如果与代理的连接丢失，代理中继将继续每5秒尝试重新连接，直到成功。

当与代理的“system”级连接丢失并重新建立时，Springbean可以实现 `ApplicationListener<BrokerAvailabilityEvent>` 以接收通知。例如，当没有 active 的 "`system`" 级连接时，股票报价服务广播股票行情可以停止尝试发送消息。

默认情况下，STOMP代理中继始终连接，并在连接丢失时根据需要重新连接到同一主机和端口。 如果您希望提供多个地址，则在每次尝试连接时，您都可以配置地址供应商，而不是固定的主机和端口。 以下示例显示了如何执行此操作：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {

	// ...

	@Override
	public void configureMessageBroker(MessageBrokerRegistry registry) {
		registry.enableStompBrokerRelay("/queue/", "/topic/").setTcpClient(createTcpClient());
		registry.setApplicationDestinationPrefixes("/app");
	}

	private ReactorNettyTcpClient<byte[]> createTcpClient() {
		return new ReactorNettyTcpClient<>(
				client -> client.addressSupplier(() -> ... ),
				new StompReactorNettyCodec());
	}
}
----

您还可以使用 `virtualHost` 属性配置STOMP代理中继。这个属性的值将被设置为每个CONNECT 帧的 `host` 头信息，并且在云环境中是可能很有用，尤其是建立TCP连接的实际主机与提供基于云的STOMP服务的主机不同的时候。

[[websocket-stomp-destination-separator]]
=== 点作为分隔符

当消息路由到 `@MessageMapping` 方法时，它们与 `AntPathMatcher` 匹配。 默认情况下，模式应使用斜杠（`/`）作为分隔符。 这是Web应用程序中的一个很好的约定，类似于HTTP URL。 但是，如果您更习惯于消息传递约定，则可以切换到使用点（`.`）作为分隔符。

以下示例显示了如何在Java配置中执行此操作：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		// ...

		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.setPathMatcher(new AntPathMatcher("."));
			registry.enableStompBrokerRelay("/queue", "/topic");
			registry.setApplicationDestinationPrefixes("/app");
		}
	}
----

以下示例显示了与前面示例等效的XML配置：

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
			xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			xmlns:websocket="http://www.springframework.org/schema/websocket"
			xsi:schemaLocation="
					http://www.springframework.org/schema/beans
					https://www.springframework.org/schema/beans/spring-beans.xsd
					http://www.springframework.org/schema/websocket
					https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:message-broker application-destination-prefix="/app" path-matcher="pathMatcher">
			<websocket:stomp-endpoint path="/stomp"/>
			<websocket:stomp-broker-relay prefix="/topic,/queue" />
		</websocket:message-broker>

		<bean id="pathMatcher" class="org.springframework.util.AntPathMatcher">
			<constructor-arg index="0" value="."/>
		</bean>

	</beans>
----

之后，控制器可以使用点 (`.)`作为 `@MessageMapping` 方法中的分隔符，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Controller
	@MessageMapping("red")
	public class RedController {

		@MessageMapping("blue.{green}")
		public void handleGreen(@DestinationVariable String green) {
			// ...
		}
	}
----

客户现在可以向 `/app/red.blue.green123` 发送消息。.

在前面的示例中，我们没有更改 "`broker relay`" 上的前缀，因为它们完全依赖于外部消息代理。 请参阅您使用的代理的STOMP文档页面，以查看它为目标标头支持的约定。

另一方面，"简单代理"确实依赖于配置的 `PathMatcher`，因此，如果切换分隔符，则该更改也适用于代理以及代理将目标从消息与预订中的模式匹配的方式。


[[websocket-stomp-authentication]]
=== 身份验证

WebSocket每一次STOMP的消息传递会话都是从HTTP请求开始的，可以是升级版的WebSockets(即WebSocket握手)的请求，或者是SockJS回调的一系列SockJS HTTP传输请求的情况。

许多Web应用程序已经有身份验证和授权来保护HTTP请求。通常，用户通过Spring安全性(如登录页、HTTP基本身份验证或其他机制)进行身份验证。经过身份验证的用户的安全上下文保存在HTTP会话中，并与同一cookie会话中的后续请求相关联。

因此，对于WebSocket握手或SockJS HTTP传输请求，通常会有通过HttpServletRequest#getUserPrincipal()访问的经过身份验证的用户。Spring会自动将该用户与为其创建的WebSocket或SockJS会话关联，随后用在该用户的所有STOMP消息的会话传输过程的头部。

简而言之，典型的Web应用程序除了已经为安全性做的事情之外，不需要做任何事情。用户在HTTP请求级别进行身份验证，通过基于cookie 的HTTP会话维护的安全上下文，然后与为该用户创建的WebSocket或SockJS会话关联，并通过应用程序在每个消息流中标记用户的头信息。

请注意，STOMP协议在CONNECT帧上有 `login` 和 `passcode` 头。这些都是最初的设计并且仍然现在有些还是需要的，例如为了能在TCP中传输STOMP。然而，对于WebSocket上的STOMP在默认情况下，Spring会忽略STOMP协议级别的授权头，并假定用户已经在HTTP传输级别进行了身份验证，并希望WebSocket或SockJS会话包含经过身份验证的用户。

NOTE: 	Spring Security提供 https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#websocket[WebSocket子协议授权]，该授权使用 `ChannelInterceptor` 根据其中的用户头来授权消息。 此外，Spring Session提供了https://docs.spring.io/spring-session/docs/current/reference/html5/#websocket[WebSocket 集成]，可确保在WebSocket会话仍处于 active 状态时用户HTTP会话不会过期。

[[websocket-stomp-authentication-token-based]]
=== 基于token的验证

https://github.com/spring-projects/spring-security-oauth[Spring Security OAuth]为基于令牌的安全性(包括JSON Web Token(JWT))提供支持。您可以将其用作Web应用程序中的身份验证机制，包括STOMP over WebSocket交互，如上一节所述（即通过基于cookie的会话维护身份）。

同时，cookie会话并不总是最适合的，例如在不希望维护服务器端会话的应用程序中，或者在移动应用程序中，通常使用报头进行身份验证。

WebSocket 协议, https://tools.ietf.org/html/rfc6455#section-10.5[WebSocket protocol, RFC 6455] 没有规定服务器在WebSocket握手期间可以对客户端进行身份验证的任何特定方式。但是在实践中， 浏览器客户端只能使用标准的身份验证报头(即基本的HTTP身份验证)或cookie，例如不能提供自定义的标头。同样，SockJS JavaScript客户端不提供使用SockJS传输请求发送HTTP标头的方法。 请参阅 sockjs-client issue 196。相反，它确实允许发送可用于发送令牌的查询参数，但这有其自身的缺点（例如，令牌可能无意中使用服务器日志中的URL记录）。

NOTE: 上述限制适用于基于浏览器的客户端，并且不适用于支持使用WebSocket和SockJS请求发送报头的Spring Java的STOMP客户端。

因此，希望避免使用了cookie的应用程序在HTTP协议级别可能没有任何适合的身份验证供选择。与其使用cookie，他们可能更愿意在STOMP消息协议级别对头信息进行身份验证，两个简单的步骤可完成这个工作：

. 使STMOP客户端在连接时传递身份验证头
. 使用 `ChannelInterceptor` 方法处理身份验证头

下一个示例使用服务器端配置来注册自定义身份验证拦截器。请注意，拦截器只需要在连接消息上进行身份验证并设置用户头。Spring将注意到并保存经过身份验证的用户，并将其与同一会话中的后续STOMP消息相关联。以下示例显示如何注册自定义身份验证拦截器：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class MyConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void configureClientInboundChannel(ChannelRegistration registration) {
			registration.interceptors(new ChannelInterceptor() {
				@Override
				public Message<?> preSend(Message<?> message, MessageChannel channel) {
					StompHeaderAccessor accessor =
							MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);
					if (StompCommand.CONNECT.equals(accessor.getCommand())) {
						Authentication user = ... ; // access authentication header(s)
						accessor.setUser(user);
					}
					return message;
				}
			});
		}
	}
----

还要注意，在使用Spring Security对消息的授权时，目前需要确保在Spring安全之前做好了身份验证的 `ChannelInterceptor` 配置，最好通过在自己的 `WebSocketMessageBrokerConfigurer` 实现中声明自定义拦截器来实现，该实现使用 `@Order(Ordered.HIGHEST_PRECEDENCE + 99)` 进行标记。


[[websocket-stomp-user-destination]]
=== 用户的目的地

应用程序可以发送针对特定用户的消息，Spring的STOMP支持可识别以 `/user/` 为前缀的目标。 例如，客户端可能订阅 `/user/queue/position-updates` 目的地。 此目标由 `UserDestinationMessageHandler` 处理，并转换为用户会话唯一的目标（例如 `/queue/position-updates-user123`）。 这为订阅通用命名的目的地提供了方便，同时确保与订阅同一目的地的其他用户没有冲突，以便每个用户都能接收到唯一的库存位置更新。

在发送方，可以将消息发送到目的地，例如 `/user/{username}/queue/position-updates`，，然后由 `UserDestinationMessageHandler` 将其转换为一个或多个目的地，每个目的地对应于与用户相关联的每个会话。 这允许应用程序中的任何组件发送针对特定用户的消息，而不必知道比其名称和通用目的地更重要的内容。也可以通过注解和消息传递模板来支持这一点。

消息处理方法可以向与通过 `@SendToUser` 注解处理的消息相关的用户发送消息(也支持在类级别上共享一个公共目的地)。如以下示例所示:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Controller
	public class PortfolioController {

		@MessageMapping("/trade")
		@SendToUser("/queue/position-updates")
		public TradeResult executeTrade(Trade trade, Principal principal) {
			// ...
			return tradeResult;
		}
	}
----

如果用户有多个会话，默认情况下，所有会话都已预订 到给定目标的目标。。但是，有时可能需要只针对发送所处理消息的会话。您可以通过将 `broadcast` 属性设置为 `false` 来执行此操作，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Controller
	public class MyController {

		@MessageMapping("/action")
		public void handleAction() throws Exception{
			// raise MyBusinessException here
		}

		@MessageExceptionHandler
		@SendToUser(destinations="/queue/errors", broadcast=false)
		public ApplicationError handleException(MyBusinessException exception) {
			// ...
			return appError;
		}
	}
----

NOTE: 虽然用户目的地通常意味着是一个经过身份验证的用户，但这不需要严格执行。未与经过身份验证的用户关联的WebSocket会话也可以订阅用户目的地。在这种情况下， `@SendToUser` 注解的行为将与 `broadcast=false` 效果完全相同，即只针对发送所处理消息的会话。

您可以从任何应用程序组件向用户目标发送消息，例如，注入由Java配置或XML命名空间创建的 `SimpMessagingTemplate`。 （如果需要使用 `@Qualifier` 进行限定，则bean名称为 `"brokerMessagingTemplate"`。）以下示例说明了如何执行此操作：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
@Service
public class TradeServiceImpl implements TradeService {

	private final SimpMessagingTemplate messagingTemplate;

	@Autowired
	public TradeServiceImpl(SimpMessagingTemplate messagingTemplate) {
		this.messagingTemplate = messagingTemplate;
	}

	// ...

	public void afterTradeExecuted(Trade trade) {
		this.messagingTemplate.convertAndSendToUser(
				trade.getUserName(), "/queue/position-updates", trade.getResult());
	}
}
----

NOTE: 在使用具有外部消息代理的用户目的地时，请查看有关如何管理非 active 队列的代理文档，以便在用户会话结束时删除所有唯一的用户队列。例如，当您使用目的地（例如 `/exchange/amq.direct/position-updates`）时，RabbitMQ会创建自动删除队列。
因此，在这种情况下，客户端可以订阅 `/user/exchange/amq.direct/position-updates`。 同样，ActiveMQ具有用于清除非 active 目的地的 https://activemq.apache.org/delete-inactive-destinations.html[配置选项]。


在多服务器方案中，用户目标可能仍未解决，因为用户已连接到其他服务器。在这种情况下，您可以将目的地配置为广播未解析的消息，以便让其他服务器有机会尝试。 这可以通过Java配置中的 `MessageBrokerRegistry` 的 `userDestinationBroadcast` 属性和XML中 `message-broker` 元素的 `user-destination-broadcast` 属性来完成。

[[websocket-stomp-ordered-messages]]
===  消息顺序

来自代理的消息将发布到 `clientOutboundChannel`，从那里将它们写入WebSocket会话。 由于通道由 `ThreadPoolExecutor` 支持，因此消息在不同的线程中处理，并且客户端接收的结果顺序可能与发布的确切顺序不匹配。

如果这是一个问题，请启用 `setPreservePublishOrder` 标志，如以下示例所示:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class MyConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		protected void configureMessageBroker(MessageBrokerRegistry registry) {
			// ...
			registry.setPreservePublishOrder(true);
		}

	}
----

以下示例显示了与前面示例等效的XML配置：

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:message-broker preserve-publish-order="true">
			<!-- ... -->
		</websocket:message-broker>

	</beans>
----

设置标志后，同一客户端会话中的消息将一次发布到 `clientOutboundChannel`，以便保证发布顺序。 请注意，这会导致较小的性能开销，因此只有在需要时才应启用它。



[[websocket-stomp-appplication-context-events]]
=== 事件

发布了几个 `ApplicationContext` 事件，可以通过实现Spring的 `ApplicationListener` 接口来接收它们：

* `BrokerAvailabilityEvent`: 表明代理何时可用/不可用。当 "`simple`" 的代理在启动时立即可用，并且在应用程序运行时保持不变。STOMP "broker relay" 可能会失去与完整功能代理的连接（例如代理重新启动）。代理中继会启动重新连接逻辑，并将在重新连接后重建与代理的 "`system`" 级连接。 因此，只要状态从连接变为断开连接，就会发布此事件，反之亦然。
使用SimpMessagingTemplate的组件应订阅此事件，并避免在代理不可用时发送消息。在任何情况下，它们应该准备在发送消息时处理MessageDeliveryException。
* `SessionConnectEvent`: 在收到新的STOMP CONNECT时发布，表示新客户端会话的开始。该事件包含表示连接的消息，包括会话ID，用户信息（如果有）以及客户端发送的任何自定义标头。 这对于跟踪客户端会话很有用。 订阅此事件的组件可以使用 `SimpMessageHeaderAccessor` 或 `StompMessageHeaderAccessor` 包装所包含的消息。
* `SessionConnectedEvent`: 在 `SessionConnectEvent` 之后不久发布，当代理已发送STOMP CONNECTED帧以响应CONNECT时。 此时，可以认为STOMP会话已完全建立。
* `SessionSubscribeEvent`:  在收到新的STOMP SUBSCRIBE时发布。
* `SessionUnsubscribeEvent`: 在收到新的STOMP UNSUBSCRIBE时发布。
* `SessionDisconnectEvent`: 当STOMP会话结束后被发布。DISCONNECT是客户端发送的，也可能是在关闭WebSocket会话时自动生成的。在某些情况下，此事件可能会在每个会话中发布一次以上。对于多个断开事件，组件功能应该是幂等的。

NOTE: 当您使用功能齐全的代理时，如果代理暂时不可用，STOMP "代理中继" 会自动重新连接 "`system`"  连接。 但是，客户端连接不会自动重新连接。 假设启用了心跳，客户端通常会注意到代理在10秒内没有响应。 客户端需要实现自己的重新连接逻辑。

[[websocket-stomp-interceptors]]
=== 拦截

<<websocket-stomp-appplication-context-events,Events>> 为STOMP连接的生命周期提供通知，但不为每个客户端消息提供通知。 应用程序还可以注册 `ChannelInterceptor` 来拦截任何消息以及处理链的任何部分。 以下示例显示如何拦截来自客户端的入站邮件：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void configureClientInboundChannel(ChannelRegistration registration) {
			registration.interceptors(new MyChannelInterceptor());
		}
	}
----

自定义 `ChannelInterceptor` 可以使用 `StompHeaderAccessor` 或 `SimpMessageHeaderAccessor` 来访问有关消息的信息，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	public class MyChannelInterceptor implements ChannelInterceptor {

		@Override
		public Message<?> preSend(Message<?> message, MessageChannel channel) {
			StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message);
			StompCommand command = accessor.getStompCommand();
			// ...
			return message;
		}
	}
----

应用程序还可以实现 `ExecutorChannelInterceptor`，它是 `ChannelInterceptor` 的子接口，在处理消息的线程中具有回调。 虽然为发送到通道的每个消息调用一次 `ChannelInterceptor`，但 `ExecutorChannelInterceptor` 在订阅来自通道的消息的每个 `MessageHandler` 的线程中提供挂钩。

请注意，与前面描述的 `SesionDisconnectEvent` 一样，DISCONNECT 消息可以来自客户端，也可以在WebSocket会话关闭时自动生成。 在某些情况下，拦截器可能会为每个会话多次拦截此消息。 对于多个断开连接事件，组件应该是幂等的。

[[websocket-stomp-client]]
=== STOMP 客户端

Spring在WebSocket客户端和TCP客户端上分别提供了STOMP

开始创建和配置 `WebSocketStompClient`, 如下所示:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	WebSocketClient webSocketClient = new StandardWebSocketClient();
	WebSocketStompClient stompClient = new WebSocketStompClient(webSocketClient);
	stompClient.setMessageConverter(new StringMessageConverter());
	stompClient.setTaskScheduler(taskScheduler); // for heartbeats
----

在前面的示例中，您可以将 `StandardWebSocketClient` 替换为 `SockJsClient`，因为它也是 `WebSocketClient` 的实现。 `SockJsClient` 可以使用WebSocket或基于HTTP的传输作为后备。 有关更多详细信息，请参阅<<websocket-fallback-sockjs-client,SockJsClient>>。

接下来，您可以建立连接并为STOMP会话提供处理程序，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	String url = "ws://127.0.0.1:8080/endpoint";
	StompSessionHandler sessionHandler = new MyStompSessionHandler();
	stompClient.connect(url, sessionHandler);
----

当会话准备好使用时，将通知处理程序，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
public class MyStompSessionHandler extends StompSessionHandlerAdapter {

	@Override
	public void afterConnected(StompSession session, StompHeaders connectedHeaders) {
		// ...
	}
}
----

建立会话后，可以发送任何有效负载并使用配置的 `MessageConverter` 进行序列化，如以下示例所示:

[source,java,indent=0]
[subs="verbatim,quotes"]
----
session.send("/topic/something", "payload");
----

也可以订阅目的地，. `subscribe` 方法需要处理订阅消息的处理程序，并返回可用于取消订阅的 `Subscription` 句柄。 对于每个收到的消息，处理程序可以指定要对其进行反序列化的目标对象类型，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
session.subscribe("/topic/something", new StompFrameHandler() {

	@Override
	public Type getPayloadType(StompHeaders headers) {
		return String.class;
	}

	@Override
	public void handleFrame(StompHeaders headers, Object payload) {
		// ...
	}

});
----

启用STOMP的心跳，需配置 `WebSocketStompClient` 与 `TaskScheduler`，并可选择自定义心跳间隔，10秒的写不 active 会导致心跳发送和10秒的读取不 active 将会关闭连接。

NOTE: 	当使用 `WebSocketStompClient` 进行性能测试以模拟来自同一台计算机的数千个客户端时，请考虑关闭心跳，因为每个连接都计划自己的心跳任务，而对于在同一台计算机上运行的大量客户端来说，这不是最优化的。

STOMP协议还支持回执，在处理发送或订阅后，客户端必须添加一个 `receipt` 头，服务器在该报头中响应回执帧。为了支持这一点， `StompSession` 提供了 `setAutoReceipt(boolean)`，会在每个后续发送或订阅中添加 `receipt` 头。
另外，也可以手动向 `StompHeaders` 添加 `receipt` 头。发送和订阅返回 `Receiptable` 的实例，可用于注册回执成功和失败回调。对于此功能，客户端必须配置 `TaskScheduler`，并且设置为回执到期前的时间(默认情况下为15秒)。


请注意， `StompSessionHandler` 本身是一个 `StompFrameHandler`，它允许它在处理消息的 `handleException` 回调之外处理ERROR帧，以及 `handleTransportError` 传输级别错误(包括 `ConnectionLostException`)

[[websocket-stomp-websocket-scope]]
=== WebSocket 范围

每个WebSocket会话都有一个属性映射表。这个表被附加为传入客户端消息的标头，并且可以从控制器方法访问，如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
@Controller
public class MyController {

	@MessageMapping("/action")
	public void handle(SimpMessageHeaderAccessor headerAccessor) {
		Map<String, Object> attrs = headerAccessor.getSessionAttributes();
		// ...
	}
}
----

也可以在 `websocket` 范围内声明Spring管理的bean。WebSocket 范围的bean可以被注入到控制器和任何在 `clientInboundChannel` 上注册的通道拦截器。这些都是典型的单例和比任何单个WebSocket会话的存活时间都要长。因此，将需要对WebSocket范围的bean使用作用范围代理模式。如以下示例所示：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Component
	@Scope(scopeName = "websocket", proxyMode = ScopedProxyMode.TARGET_CLASS)
	public class MyBean {

		@PostConstruct
		public void init() {
			// Invoked after dependencies injected
		}

		// ...

		@PreDestroy
		public void destroy() {
			// Invoked when the WebSocket session ends
		}
	}

	@Controller
	public class MyController {

		private final MyBean myBean;

		@Autowired
		public MyController(MyBean myBean) {
			this.myBean = myBean;
		}

		@MessageMapping("/action")
		public void handle() {
			// this.myBean from the current WebSocket session
		}
	}
----

与任何自定义作用范围一样，Spring在第一次从控制器访问时初始化一个新的 `MyBean` 实例，并将该实例存储在WebSocket会话属性中。随后返回同一实例，直到会话结束。WebSocket范围的bean将具有所有的Spring生命周期方法调用，如上面的示例所示。

[[websocket-stomp-configuration-performance]]
=== 性能

在性能方面没有一个办法是可以解决任何问题的。许多因素都会影响性能，包括消息的大小、分卷、应用方法执行以及是否阻塞，外部因素例如网络速度等等。本节的目标是提供可用配置选项的概述，以及有关如何推理、缩放的一些想法。

在消息传递应用程序消息中，通过通道来传递由线程池支持的异步执行。配置此类应用程序需要对通道和消息流有很好的了解。因此，建议查看<<websocket-stomp-message-flow,消息流>>。

一个明显需要重点配置的是两个线程池，`clientInboundChannel` 和 `clientOutboundChannel`。默认情况下，两者都配置为可用处理器数量的两倍。

如果注解方法处理消息是绑定主CPU的话，那么 `clientInboundChannel` 的线程数应该与处理器数量保持接近。如果他们所做的工作是更多的IO绑定，需要阻塞或等待数据库或其他外部系统，那么线程池的大小将需要增加。

[NOTE]
====

`ThreadPoolExecutor` 有三个重要的属性: 核心的线程大小,最大的线程大小和阻塞队列（可用于执行任务的容量）

一个常见的混淆点是，配置核心池大小(如10)和最大池大小(例如20)会导致线程池中有10个至20个的线程。实际上，如果容量是保留在其默认值为 `Integer.MAX_VALUE` 后，线程池将永远不会增加超过核心池大小，因为所有其他任务都在排队了。

请参阅 `ThreadPoolExecutor` 的javadoc以了解这些属性如何工作并理解各种排队策略。
====

在 `clientOutboundChannel` 方面, 这是所有关于向WebSocket客户端发送消息的内容。如果客户端处于快速网络中，则线程数应保持在可用处理器数量附近。如果它们速度慢或带宽低，则会花费更长的时间来消耗消息并给线程池带来负担。因此，增加线程池的大小将是必要的。

虽然 `clientInboundChannel` 的工作负载可以预测 - 毕竟，它基于应用程序的工作 - 如何配置"clientOutboundChannel" 更难，因为它基于应用程序无法控制的因素。因此，有两个与发送消息相关的附加属性： `sendTimeLimit` 和 `sendBufferSizeLimit`。这些用于配置在向客户端发送消息时允许发送的时间以及可以缓冲多少数据。

一般的想法是，在任何给定的时间，只有一个线程可以用来发送到客户端。同时，所有附加消息都得到缓冲，可以使用这些属性来决定允许发送消息的时间长度以及在平均时间内可以缓冲多少数据。有关重要的其他详细信息，请参阅XML架构的javadoc和文档。

以下示例显示了可能的配置：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void configureWebSocketTransport(WebSocketTransportRegistration registration) {
			registration.setSendTimeLimit(15 * 1000).setSendBufferSizeLimit(512 * 1024);
		}

		// ...

	}
----

以下示例显示了与前面示例等效的XML配置：

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:message-broker>
			<websocket:transport send-timeout="15000" send-buffer-size="524288" />
			<!-- ... -->
		</websocket:message-broker>

	</beans>
----

上面显示的WebSocket传输配置也可用于配置传入的STOMP消息的允许的最大大小配置。虽然理论上WebSocket的消息可以是几乎无限大，但在实践中WebSocket服务器通常会强加限制。 例如，在Tomcat是8k、在Jetty中是64k。因为这个原因，STOMP客户端（例如JavaScript https://github.com/JSteunou/webstomp-client[webstomp-client]等）可以将更大的STOMP信息分割为16k一个片，并将它们作为多个WebSocket消息发送，从而要求服务器进行缓冲和组装。

Spring的STOMP-over-WebSocket支持实现了这一点，因此应用程序可以配置STOMP消息的最大大小，而不管WebSocket服务器特定的消息大小。 请记住，必要时会自动调整WebSocket消息大小，以确保它们至少可以携带16K WebSocket消息。

以下示例显示了一种可能的配置：

[source,java,indent=0]
[subs="verbatim,quotes"]
----
	@Configuration
	@EnableWebSocketMessageBroker
	public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {

		@Override
		public void configureWebSocketTransport(WebSocketTransportRegistration registration) {
			registration.setMessageSizeLimit(128 * 1024);
		}

		// ...

	}
----

以下示例显示了与前面示例等效的XML配置：

[source,xml,indent=0]
[subs="verbatim,quotes,attributes"]
----
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:websocket="http://www.springframework.org/schema/websocket"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/websocket
			https://www.springframework.org/schema/websocket/spring-websocket.xsd">

		<websocket:message-broker>
			<websocket:transport message-size="131072" />
			<!-- ... -->
		</websocket:message-broker>

	</beans>
----

关于伸缩性的一个重要问题是使用多个应用程序实例。目前，简单的代理是不可能做到的。但是，当使用功能完备的代理(如RabbitMQ)时，每个应用程序实例连接到代理，并且从一个应用程序实例广播的消息可以通过代理广播到通过任何其他应用程序实例连接的WebSocket客户端。



[[websocket-stomp-stats]]
=== 监控

当使用 `@EnableWebSocketMessageBroker` 或 `<websocket:message-broker>` 关键架构组件时，将自动收集统计信息和计数器，以便对应用程序的内部状态提供重要的参考。 该配置还声明了一个类型为 `WebSocketMessageBrokerStats` 的bean，它在一个位置收集所有可用信息。默认情况下，会每隔 `30` 分钟记录一次日志到 `INFO`。可以通过Spring的 `MBeanExporter` 将此bean导出到JMX，以便在运行时查看，例如通过JDK的 `jconsole`。下面是可用信息的摘要

Client WebSocket Sessions（客户端WebSocket会话）::
	Current（当前）::: 当前有多少客户端会话已通过WebSocketvsHTTPstreaming和pollingSockJS会话
	Total（总共）::: 已建立的总会话数
	Abnormally Closed（非正常关闭）:::
		Connect Failures（连接失败）:::: 这些会话已经建立，但在60秒内没有收到任何消息后被关闭。这通常是代理或网络的问题。
		Send Limit Exceeded（发送限制）:::: 在超过配置的发送超时或可能与慢速客户端发生的发送缓冲区限制后，会话关闭(请参阅上一节)
		Transport Errors（传输错误）:::: 在传输错误(如无法读取或写入WebSocket连接或HTTP请求/响应)后关闭会话。
	STOMP Frames（STOMP帧）::: CONNECT、CONNECTED和DISCONNECT帧的总数目表明有多少客户端在STOMP级别上连接。请注意，当会话异常关闭或客户端关闭而不发送断开连接帧时，断开连接计数可能会较低。
STOMP Broker Relay（STOMP消息代理回复）::
	TCP Connections（TCP连接数）::: 指示将代表客户端WebSocket会话的TCP连接设置为代理的数量。这应该等于客户端WebSocket会话数+额外的共享的"系统"级连接，用于从应用程序内发送消息。
	STOMP Frames（STOMP帧）::: 代表客户端转发到或从代理接收的CONNECT、CONNECTED和DISCONNECT的帧总数。请注意，无论客户端WebSocket会话是如何关闭的，断开连接帧都将发送到代理。因此，较低的断开连接帧计数是指代理正在主动关闭连接，可能是由于没有及时到达的心跳、无效的输入帧或其他。
Client Inbound Channel（客户端输入channel）:: 线程池的统计数据支持 `clientInboundChannel` 提供对传入消息处理的健康的检测。在这里排队的任务是指应用程序可能太慢，无法处理消息。如果有i/o绑定任务(如慢速数据库查询、对第三方RESTAPI的HTTP请求等），请考虑增加线程池大小。
Client Outbound Channel（客户端输出channel）:: 线程池的统计数据支持 `clientOutboundChannel` 提供对向客户端广播消息的健康状况的检测。在这里排队的任务的问题可能是客户端太慢，无法使用消息。解决这一问题的一种方法是增加线程池的大小，以适应预期的并发慢速客户端的数量。另一个选项是减少发送超时和发送缓冲区大小限制(请参阅上一节)。
SockJS Task Scheduler（SockJS的任务计划）:: 用于发送心跳的SockJS任务计划程序的线程池的统计信息。请注意，当心跳在STOMP级别上协商时，SockJS心跳将被禁用。



[[websocket-stomp-testing]]
=== 测试

使用Spring的WebSocket支持来测试应用程序有两种主要方法。第一种是编写服务器端测试，以验证控制器的功能及其注解的消息处理方法。第二个是编写涉及运行客户端和服务器的完整的端到终端测试。

这两种方法不是互斥的。相反，它们在总体测试策略中有一席之地。服务器端测试更加集中，更易于编写和维护。另一方面，端对点的集成测试更完整，更多，但它们也更多地涉及编写和维护

最简单的服务器端测试形式是编写控制器单元测试。但是，这是不用够的，因为控制器的大部分内容取决于它的注解。纯单元测试根本无法测试。

理想中的控制器应该在运行时调用，就像测试控制器使用Spring MVC测试框架处理HTTP请求的方法一样。即不运行Servlet容器，而是依赖于Spring框架来调用带注解的控制器。就像Spring MVC测试这里有两种可能的选择，要么使用 "基于上下文" 或 "单独" 设置。

* 在SpringTestContext框架的帮助下加载实际的Spring配置，将 `clientInboundChannel` 作为测试字段，并使用它发送要由控制器方法处理的消息。

* 手动设置调用控制器(即 `SimpAnnotationMethodMessageHandler`)所需的最低Spring框架基础结构，并直接向控制器传递消息。

这两种设置方案都在https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web[股票投资组合]示例应用程序的测试中演示

第二种方法是创建端到端的集成测试。为此，需要在嵌入式模式下运行WebSocket服务器，并将其作为WebSocket客户端发送包含STOMP帧的WebSocket消息。 https://github.com/rstoyanchev/spring-websocket-portfolio/tree/master/src/test/java/org/springframework/samples/portfolio/web[股票投资组合]的应用程序的测试还演示了这种方法，它使用Tomcat作为嵌入式WebSocket服务器和简单的STOMP客户端进行测试。