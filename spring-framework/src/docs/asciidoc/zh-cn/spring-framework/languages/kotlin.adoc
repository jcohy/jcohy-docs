[[kotlin]]
= Kotlin

https://kotlinlang.org[Kotlin] 是针对JVM(和其他平台)的静态类型化语言，它允许编写简洁而优雅的代码，同时提供与Java中编写的现有库的非常好的 https://kotlinlang.org/docs/reference/java-interop.html[互操作性] 。

Spring Framework为Kotlin提供了一流的支持，使开发人员可以编写Kotlin应用程序，就像Spring Framework是本地Kotlin框架一样。

用Kotlin构建Spring应用程序的最简单方法是利用Spring Boot及其 https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-kotlin.html[专用的Kotlin支持]。 这个 https://spring.io/guides/tutorials/spring-boot-kotlin/[全面的教程]将教您如何使用 https://start.spring.io/#!language=kotlin&type=gradle-project[start.spring.io]使用Kotlin构建Spring Boot应用程序。

从Spring Framework 5.2开始，除了Java之外，Kotlin还提供了参考文档的大多数代码示例。

了解Spring和Kotlin的最简单方法是遵循这个全面的教程。 如果您需要支持，请随意加入 https://slack.kotlinlang.org/[Kotlin Slack] 的 #spring频道或使用 `spring` 和 `kotlin` 作为标签在 https://stackoverflow.com/questions/tagged/spring+kotlin[Stackoverflow] 上提问。

[[kotlin-requirements]]
== 要求

Spring Framework支持Kotlin 1.3+并且需要 https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-stdlib[`kotlin-stdlib`]（或其变体之一， 例如 https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-stdlib-jdk8[`kotlin-stdlib-jdk8`] ）
和 https://bintray.com/bintray/jcenter/org.jetbrains.kotlin%3Akotlin-reflect[`kotlin-reflect`]存在于类路径中。 如果您在 https://start.spring.io/#!language=kotlin&type=gradle-project[start.spring.io]上引导Kotlin项目，则默认提供它们。

[[kotlin-extensions]]
== 扩展

Kotlin https://kotlinlang.org/docs/reference/extensions.html[扩展] 提供了继承现有类和其他功能的能力。Spring框架Kotlin API利用这些扩展为现有的Spring API添加新的Kotlin特定的方便支持。

Spring Framework {doc-root}/spring-framework/docs/{spring-version}/kdoc-api/spring-framework/[Spring Framework KDoc API] 列表与API文档列出了所有的Kotlin扩展和DSL可用的情况

NOTE: 请记住，必须导入Kotlin扩展才能使用。。这意味着，如果导入 `org.springframework.context.support.registerBean`，则 `GenericApplicationContext.registerBean` 扩展就可用。这样看来，与静态导入类似，IDE在大多数情况下应该建议自动导入。

例如, https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters[Kotlin 具体化类型参数] 为JVM https://docs.oracle.com/javase/tutorial/java/generics/erasure.html[泛型类型擦除] 提供了一种变通方法，
Spring框架提供了一些扩展以利用此功能。这样为Spring WebFlux中的 `WebClient` 和更多其他的API提供更好的Kotlin API `RestTemplate`。

NOTE: 其他的库，如Reactor和Spring Data也提供了Kotlin扩展的API，从而整体提高了Kotlin开发经验。

要在Java中检索 `User` 对象列表，通常会编写以下内容:

[source,java,indent=0]
----
	Flux<User> users  = client.get().retrieve().bodyToFlux(User.class)
----

使用Kotlin和Spring Framework扩展，您可以编写以下内容：

[source,kotlin,indent=0]
----
	val users = client.get().retrieve().bodyToFlux<User>()
	// or (both are equivalent)
	val users : Flux<User> = client.get().retrieve().bodyToFlux()
----

与在Java中一样，Kotlin中的 `users` 是强类型的，但Kotlin的聪明类型推断允许更短的语法。

[[kotlin-null-safety]]
== Null安全

Kotlin的一个关键特性是 https://kotlinlang.org/docs/reference/null-safety.html[null-safety]，它在编译时干净地处理 `null` 值，而不是在运行时撞上著名的 `NullPointerException` 异常。
这使得应用程序通过可空性声明更安全并表达"有价值或无价值"语义，而无需支付包装器的成本，例如 `Optional`。（Kotlin允许使用具有可空值的功能构造。请参阅此https://www.baeldung.com/kotlin-null-safety[综合指南以了解Kotlin null安全性]。）

虽然Java不允许在其类型系统中表示 null 安全，但Spring框架现在通过在 `org.springframework.lang` 包中声明的工具友好注解，为整个<<core#null-safety, Spring框架API提供了null安全>>。
默认情况下，Kotlin中使用的Java API中的类型被识别为可轻松进行null检查的 https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types[平台类型]。 https://kotlinlang.org/docs/reference/java-interop.html#jsr-305-support[Kotlin支持JSR 305注解]， Spring可空性注解为Kotlin开发人员提供了整个Spring框架API的 null安全，其优点是在编译时处理 `null` 的相关问题。

NOTE: 像Reactor或Spring Data这样的库提供了利用此功能的null安全api

JSR 305检查可以通过添加 `-Xjsr305` 编译器标志来配置，其中有以下选项：`-Xjsr305={strict|warn|ignore}`.

对于kotlin 1.1+, 默认行为与 `-Xjsr305=warn` 一致。`strict` 的值应该被认为是实验性的(Spring API的null声明在小版本之间可能会发生变化，将来可能会增加更多的检查)。

NOTE: 泛型类型参数、varargs和数组元素为null性不受支持，但应在即将发布的版本中添加此功能。请参阅 https://github.com/Kotlin/KEEP/issues/79[此讨论]以获取最新信息。

[[kotlin-classes-interfaces]]
== 类和接口

Spring框架支持各种Kotlin构造，如通过主构造函数、不可变类数据绑定和具有默认值的函数可选参数来实例化Kotlin类。

Kotlin参数名称是通过专用的 `KotlinReflectionParameterNameDiscoverer` 识别的，它允许在编译过程中不需要启用Java 8 `-parameters` 的编译器标志即可查找接口方法参数名称。

Jackson Kotlin 模块，用于序列化/反序列化JSON数据的，如果类路径中引入了会自动注册，如果Jackson 和Kotlin被检测到缺少  https://github.com/FasterXML/jackson-module-kotlin[Jackson Kotlin模块]模块时会在日志中打印警告信息。

您可以将配置类声明为 https://kotlinlang.org/docs/reference/nested-classes.html[顶级或嵌套但不是内部]，因为后者需要引用外部类。

[[kotlin-annotations]]
== 注解

Spring框架还利用  https://kotlinlang.org/docs/reference/null-safety.html[Kotlin null-safety] 来确定是否需要HTTP参数，而不必显式定义 `required` 属性。这意味着 `@RequestParam name: String?` 将被视为不需要的，相反 `@RequestParam name: String` 则是需要的。Spring Messaging `@Header` 也支持此功能。

以类似的方式，使用 `@Autowired`, `@Bean`, 或 `@Inject` 的Spring bean注入使用此信息来确定是否需要bean。

例如,  `@Autowired lateinit var thing: Thing`  意味着必须在应用程序上下文中注册Thing类型的bean。而 `@Autowired lateinit var thing: Thing?`，如果这样的bean不存在，则不会引发错误。

按照相同的原则，`@Bean fun play(toy: Toy, car: Car?) = Baz(toy, Car)`， `Toy` 类型的bean必须在应用程序上下文中注册，而类型为 `Car` 的bean可能不存在。 相同的行为适用于自动装配的构造函数参数。

NOTE: 	如果对具有属性或主构造函数参数的类使用bean验证，则可能需要使用 https://kotlinlang.org/docs/reference/annotations.html#annotation-use-site-targets[annotation use-site targets]，例如 `@field:NotNull` 或 `@get:Size(min=5, max=15)`，如 https://stackoverflow.com/a/35853200/1092077[this Stack Overflow response].

[[kotlin-bean-definition-dsl]]
== Bean定义DSL

Spring 5介绍了使用lambda在功能上注册bean的新方法，作为XML或JavaConfig( `@Configuration` 和 `@Bean`)的替代方法。简而言之，它可以使用lambda作为 `FactoryBean` 注册bean。这种机制非常有效，因为它不需要任何反射或CGLIB代理。

例如，在Java中，您可以编写以下内容：

[source,java,indent=0]
----
	class Foo {}

	class Bar {
		private final Foo foo;
		public Bar(Foo foo) {
			this.foo = foo;
		}
	}

	GenericApplicationContext context = new GenericApplicationContext();
	context.registerBean(Foo.class);
	context.registerBean(Bar.class, () -> new Bar(context.getBean(Foo.class)));
----

在Kotlin中，使用reified类型参数和 `GenericApplicationContext` Kotlin扩展，您可以编写以下内容：

[source,kotlin,indent=0]
----
	class Foo

	class Bar(private val foo: Foo)

	val context = GenericApplicationContext().apply {
		registerBean<Foo>()
		registerBean { Bar(it.getBean()) }
	}
----
====

当 `Bar` 类只有一个构造函数时，您甚至可以只指定bean类，
构造函数参数将按类型自动关联：

====
[source,kotlin,indent=0]
----
	val context = GenericApplicationContext().apply {
		registerBean<Foo>()
		registerBean<Bar>()
	}
----

为了使用更具声明性的方法和更简洁的语法，Spring框架提供了 {doc-root}/spring-framework/docs/{spring-version}/kdoc-api/spring-framework/org.springframework.context.support/-bean-definition-dsl/[Kotlin bean定义的DSL]，它通过简洁的声明性API声明了 `ApplicationContextInitializer`，能够处理配置文件和 `Environment` 自定义bean的注册方式。在以下示例中注意：

* 类型推断通常可以避免为 `ref("bazBean")` 之类的bean引用指定类型。
* 在此示例中，可以使用Kotlin顶级函数通过可调用引用（如  `bean(::myRouter)` ）声明bean。
* 当指定  `bean<Bar>()` 或 `bean(::myRouter)` 时，参数将按类型自动关联
* 仅当 `foobar` 配置文件处于活动状态时，才会注册 `FooBar` bean

[source,kotlin,indent=0]
----
	class Foo
	class Bar(private val foo: Foo)
	class Baz(var message: String = "")
	class FooBar(private val baz: Baz)

	val myBeans = beans {
		bean<Foo>()
		bean<Bar>()
		bean("bazBean") {
			Baz().apply {
				message = "Hello world"
			}
		}
		profile("foobar") {
			bean { FooBar(ref("bazBean")) }
		}
		bean(::myRouter)
	}

	fun myRouter(foo: Foo, bar: Bar, baz: Baz) = router {
		// ...
	}
----

NOTE: 该DSL是编程的，这意味着它允许通过 `if` 表达式，`for` 循环或任何其他Kotlin构造对bean进行自定义注册逻辑。

然后，您可以使用此 `beans()` 函数在应用程序上下文中注册bean，如以下示例所示：

[source,kotlin,indent=0]
----
	val context = GenericApplicationContext().apply {
		myBeans.initialize(this)
		refresh()
	}
----


NOTE: 	Spring Boot是基于Java配置的，https://github.com/spring-projects/spring-boot/issues/8115[并且不提供对函数式bean定义的特定支持]。但是可以通过Spring Boot的 `ApplicationContextInitializer` 支持在实验中使用函数式bean定义，请参阅 https://stackoverflow.com/questions/45935931/how-to-use-functional-bean-definition-kotlin-dsl-with-spring-boot-and-spring-w/46033685#46033685[Stack Overflow answer]获取更多的细节和最新的信息。另请参阅在 https://github.com/spring-projects/spring-fu[Spring Fu incubator] 中开发的实验性Kofu DSL。

[[kotlin-web]]
== Web

=== Router DSL

Spring Framework现在附带了三种 Kotlin路由DSL，它允许您使用 WebFlux functional API编写干净且惯用的Kotlin代码，如以下示例所示：

* WebMvc.fn DSL with {doc-root}/spring-framework/docs/{spring-version}/kdoc-api/spring-framework/org.springframework.web.servlet.function/router.html[router { }]
* WebFlux.fn <<web-reactive#webflux-fn, Reactive>> DSL with {doc-root}/spring-framework/docs/{spring-version}/kdoc-api/spring-framework/org.springframework.web.reactive.function.server/router.html[router { }]
* WebFlux.fn <<Coroutines>> DSL with {doc-root}/spring-framework/docs/{spring-version}/kdoc-api/spring-framework/org.springframework.web.reactive.function.server/co-router.html[coRouter { }]

这些DSL使您可以编写干净且惯用的Kotlin代码来构建 `RouterFunction` 实例，如以下示例所示：

[source,kotlin,indent=0]
----
@Configuration
class RouterRouterConfiguration {

	@Bean
	fun mainRouter(userHandler: UserHandler) = router {
		accept(TEXT_HTML).nest {
			GET("/") { ok().render("index") }
			GET("/sse") { ok().render("sse") }
			GET("/users", userHandler::findAllView)
		}
		"/api".nest {
			accept(APPLICATION_JSON).nest {
				GET("/users", userHandler::findAll)
			}
			accept(TEXT_EVENT_STREAM).nest {
				GET("/users", userHandler::stream)
			}
		}
		resources("/**", ClassPathResource("static/"))
	}
}
----

NOTE: 这个DSL是程序化的，这意味着它允许通过 `if` 表达式， `for` 循环或任何其他Kotlin结构自定义bean的注册逻辑。 当您需要根据动态数据（例如，从数据库）注册路由时，这可能很有用。

有关具体示例，请参阅  https://github.com/mixitconf/mixit/[MiXiT project]

=== MockMvc DSL

通过 `MockMvc` Kotlin扩展提供了Kotlin DSL，以提供更加惯用的Kotlin API并允许更好的发现性（不使用静态方法）。

[source,kotlin,indent=0]
----
val mockMvc: MockMvc = ...
mockMvc.get("/person/{name}", "Lee") {
	secure = true
	accept = APPLICATION_JSON
	headers {
		contentLanguage = Locale.FRANCE
	}
	principal = Principal { "foo" }
}.andExpect {
	status { isOk }
	content { contentType(APPLICATION_JSON) }
	jsonPath("$.name") { value("Lee") }
	content { json("""{"someBoolean": false}""", false) }
}.andDo {
	print()
}
----

=== Kotlin 模板脚本

Spring Framework提供了一个 https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/view/script/ScriptTemplateView.html[`ScriptTemplateView`]，它支持  https://www.jcp.org/en/jsr/detail?id=223[JSR-223] 通过使用脚本引擎来呈现模板。

通过利用 `kotlin-script-runtime` 和 `scripting-jsr223-embedded` 的依赖关系，可以使用此类功能来使用 https://github.com/Kotlin/kotlinx.html[kotlinx.html] DSL或Kotlin多行插值 `String` 渲染基于Kotlin的模板。

`build.gradle.kts`
[source,kotlin,indent=0]
----
dependencies {
	compile("org.jetbrains.kotlin:kotlin-script-runtime:${kotlinVersion}")
	runtime("org.jetbrains.kotlin:kotlin-scripting-jsr223-embeddable:${kotlinVersion}")
}
----

通常使用 `ScriptTemplateConfigurer` 和 `ScriptTemplateViewResolver` Bean进行配置。

`KotlinScriptConfiguration.kt`
[source,kotlin,indent=0]
----
@Configuration
class KotlinScriptConfiguration {

    @Bean
	fun kotlinScriptConfigurer() = ScriptTemplateConfigurer().apply {
		engineName = "kotlin"
		setScripts("scripts/render.kts")
		renderFunction = "render"
		isSharedEngine = false
	}

    @Bean
    fun kotlinScriptViewResolver() = ScriptTemplateViewResolver().apply {
        setPrefix("templates/")
        setSuffix(".kts")
    }
}
----

有关更多详细信息，请参见 https://github.com/sdeleuze/kotlin-script-templating[kotlin-script-templating] 示例项目。

== Coroutines

Kotlin https://kotlinlang.org/docs/reference/coroutines-overview.html[Coroutines] 是Kotlin轻量级线程，允许以命令式方式编写非阻塞代码。 在语言方面，挂起函数为异步操作提供了一种抽象，而在库方面，https://github.com/Kotlin/kotlinx.coroutines[kotlinx.coroutines] 提供了诸如 https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html[`async { }`] 之类的函数以及诸如 https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html[`Flow`] 之类的类型。

Spring Framework在以下范围内提供对 Coroutines 的支持：

* https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/index.html[Deferred] and https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html[Flow] return values support in Spring WebFlux annotated `@Controller`
* Spring WebFlux中带有 `@Controller` 注解的暂停功能支持
* WebFlux {doc-root}/spring-framework/docs/{spring-version}/kdoc-api/spring-framework/org.springframework.web.reactive.function.client/index.html[客户端] 和  {doc-root}/spring-framework/docs/{spring-version}/kdoc-api/spring-framework/org.springframework.web.reactive.function.server/index.html[服务端]功能API的扩展。
* WebFlux.fn {doc-root}/spring-framework/docs/{spring-version}/kdoc-api/spring-framework/org.springframework.web.reactive.function.server/co-router.html[coRouter { }] DSL
* RSocket `@MessageMapping` 注解方法中的暂停功能和 `Flow` 支持
* {doc-root}/spring-framework/docs/{spring-version}/kdoc-api/spring-framework/org.springframework.messaging.rsocket/index.html[`RSocketRequester`] 的扩展

=== 依赖

当 `kotlinx-coroutines-core` 和 `kotlinx-coroutines-reactor` 依赖项位于类路径中时，将启用 Coroutines 支持：

`build.gradle.kts`
[source,kotlin,indent=0]
----
dependencies {

	implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:${coroutinesVersion}")
	implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor:${coroutinesVersion}")
}
----

支持 `1.3.0` 及更高版本。

=== Reactive 如何转换为 Coroutines?

对于返回值，以下是从 Reactive 到 Coroutines API的转换：

* `fun handler(): Mono<Void>` 变成 `suspend fun handler()`
* `fun handler(): Mono<T>` 变成 `suspend fun handler(): T` 或 `suspend fun handler(): T?` 取决于 `Mono` 是否可以为空（具有更静态键入的优势）
* `fun handler(): Flux<T>` 变成 `fun handler(): Flow<T>`

对于输入参数：

* 如果不需要懒加载，则 `fun handler(mono: Mono<T>)` 变成 `fun handler(value: T)` 因为可以调用挂起函数来获取value参数。
* 如果需要懒加载, 则 `fun handler(mono: Mono<T>)` 变成 `fun handler(supplier: suspend () -> T)` 或 `fun handler(supplier: suspend () -> T?)`

在 Coroutines 中， https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/index.html[`Flow`] 和 `Flux` 是等效的, 适用于热流或冷流，有限流或无限流，主要区别如下：

* `Flow` 是基于推式的 `Flux` 是推拉式混合的
* 背压通过暂停功能实现
* `Flow` 只有一个暂停的 https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/collect.html[收集方法] 并且运算符被实现为 https://kotlinlang.org/docs/reference/extensions.html[扩展]借助 Coroutines，操作员易于实施
* https://github.com/Kotlin/kotlinx.coroutines/tree/master/kotlinx-coroutines-core/common/src/flow/operators[Operators are easy to implement] thanks to Coroutines
* 扩展允许向 `Flow` 添加自定义运算符
* 收集操作正在暂停功能
* https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html[`map` operator] 支持异步操作（不需要 `flatMap`），因为它需要一个暂停函数参数

通过阅读有关 https://spring.io/blog/2019/04/12/going-reactive-with-spring-coroutines-and-kotlin-flow[Spring，Coroutines和Kotlin Flow Reactive]的博客文章，了解更多详细信息，包括如何与Coroutines并发运行代码。

=== Controllers

这是一个 Controllers @RestController的示例。

[source,kotlin,indent=0]
----
@RestController
class CoroutinesRestController(client: WebClient, banner: Banner) {

	@GetMapping("/suspend")
	suspend fun suspendingEndpoint(): Banner {
		delay(10)
		return banner
	}

	@GetMapping("/flow")
	fun flowEndpoint() = flow {
		delay(10)
		emit(banner)
		delay(10)
		emit(banner)
	}

	@GetMapping("/deferred")
	fun deferredEndpoint() = GlobalScope.async {
		delay(10)
		banner
	}

	@GetMapping("/sequential")
	suspend fun sequential(): List<Banner> {
		val banner1 = client
				.get()
				.uri("/suspend")
				.accept(MediaType.APPLICATION_JSON)
				.awaitExchange()
				.awaitBody<Banner>()
		val banner2 = client
				.get()
				.uri("/suspend")
				.accept(MediaType.APPLICATION_JSON)
				.awaitExchange()
				.awaitBody<Banner>()
		return listOf(banner1, banner2)
	}

	@GetMapping("/parallel")
	suspend fun parallel(): List<Banner> = coroutineScope {
		val deferredBanner1: Deferred<Banner> = async {
			client
					.get()
					.uri("/suspend")
					.accept(MediaType.APPLICATION_JSON)
					.awaitExchange()
					.awaitBody<Banner>()
		}
		val deferredBanner2: Deferred<Banner> = async {
			client
					.get()
					.uri("/suspend")
					.accept(MediaType.APPLICATION_JSON)
					.awaitExchange()
					.awaitBody<Banner>()
		}
		listOf(deferredBanner1.await(), deferredBanner2.await())
	}

	@GetMapping("/error")
	suspend fun error() {
		throw IllegalStateException()
	}

	@GetMapping("/cancel")
	suspend fun cancel() {
		throw CancellationException()
	}

}
----

还支持使用 `@Controller` 进行视图渲染。

[source,kotlin,indent=0]
----
@Controller
class CoroutinesViewController(banner: Banner) {

	@GetMapping("/")
	suspend fun render(model: Model): String {
		delay(10)
		model["banner"] = banner
		return "index"
	}
}
----

=== WebFlux.fn

这是通过  {doc-root}/spring-framework/docs/{spring-version}/kdoc-api/spring-framework/org.springframework.web.reactive.function.server/co-router.html[coRouter { }]  DSL和相关处理程序定义的 Coroutines 路由器的示例。

[source,kotlin,indent=0]
----
@Configuration
class RouterConfiguration {

	@Bean
	fun mainRouter(userHandler: UserHandler) = coRouter {
		GET("/", userHandler::listView)
		GET("/api/user", userHandler::listApi)
	}
}
----

[source,kotlin,indent=0]
----
class UserHandler(builder: WebClient.Builder) {

	private val client = builder.baseUrl("...").build()

	suspend fun listView(request: ServerRequest): ServerResponse =
			ServerResponse.ok().renderAndAwait("users", mapOf("users" to
			client.get().uri("...").awaitExchange().awaitBody<User>()))

	suspend fun listApi(request: ServerRequest): ServerResponse =
				ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).bodyAndAwait(
				client.get().uri("...").awaitExchange().awaitBody<User>())
}
----

=== 事务

从Spring Framework 5.2开始，通过Reactive事务管理的程序化变体支持协同程序上的事务。

对于挂起函数，提供了 `TransactionalOperator.executeAndAwait` 扩展。

[source,kotlin,indent=0]
----
    import org.springframework.transaction.reactive.executeAndAwait

    class PersonRepository(private val operator: TransactionalOperator) {

        suspend fun initDatabase() = operator.executeAndAwait {
            insertPerson1()
            insertPerson2()
        }

        private suspend fun insertPerson1() {
            // INSERT SQL statement
        }

        private suspend fun insertPerson2() {
            // INSERT SQL statement
        }
    }
----

对于Kotlin `Flow`，提供了  `Flow<T>.transactional`  扩展。

[source,kotlin,indent=0]
----
    import org.springframework.transaction.reactive.transactional

    class PersonRepository(private val operator: TransactionalOperator) {

        fun updatePeople() = findPeople().map(::updatePerson).transactional(operator)

        private fun findPeople(): Flow<Person> {
            // SELECT SQL statement
        }

        private suspend fun updatePerson(person: Person): Person {
            // UPDATE SQL statement
        }
    }
----


[[kotlin-spring-projects-in-kotlin]]
== Kotlin中的Spring项目

本节提供了一些在Kotlin中开发Spring项目的具体提示和建议。

=== 默认不可变

默认情况下, https://discuss.kotlinlang.org/t/classes-final-by-default/166[Kotlin中的所有类都是 `final`] 的。类上的open 修饰符与Java的 `final` 相反：它允许其他人从这个类继承。这也适用于成员函数，因为它们需要被标记为  `open` ，才能被重写。

虽然Kotlin的JVM友好设计通常与Spring无缝对接，但如果不考虑这一事实，则此特定的Kotlin功能可能会阻止应用程序启动。这是因为Spring bean通常使用CGLIB来代理 ， 例如 `@Configuration` 类。
解决方法是在由CGLIB代理的Spring bean的每个类和成员函数上添加一个 open 关键字（例如 `@Configuration` 类），这种设计可能很快就成为Kotlin的累赘，并且违反了保持代码简洁和可预测的Kotlin原则。



NOTE: 也可以通过使用 `@Configuration（proxyBeanMethods = false）` 避免在配置上使用CGLIB代理，有关更多详细信息，请参见 {api-spring-framework}/context/annotation/Configuration.html#proxyBeanMethods--[`proxyBeanMethods` Javadoc] 。

幸运的是，Kotlin现在提供了 https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-spring-compiler-plugin[`kotlin-spring`] 插件（`kotlin-allopen` 插件的预配置版本），它可以自动打开类及其成员函数，用于使用以下注解之一进行注解或元注解的类型：

* `@Component`
* `@Async`
* `@Transactional`
* `@Cacheable`

元注解的支持意味着使用 `@Configuration`, `@Controller`, `@RestController`, `@Service`, 或 `@Repository` 注解的类型会自动设置为open，因为这些都是 `@Component` 注解的元注解。

默认情况下，https://start.spring.io/#!language=kotlin&type=gradle-project[start.spring.io]  是启用 `open` 的，因此在实践中，将能够编写自定义Kotlin bean而无需像在Java中那样添加额外的 `open` 关键字。

=== 使用不可变的类实例进行持久化

在Kotlin中，将主构造函数声明为只读属性是非常方便和最佳的做法，如下面的示例所示：

[source,kotlin,indent=0]
----
	class Person(val name: String, val age: Int)
----

您可以选择添加 https://kotlinlang.org/docs/reference/data-classes.html[ `data` ] 关键字，以使编译器自动从主构造函数中声明的所有属性派生以下成员：

* `equals()` 和 `hashCode()`
* `"User(name=John, age=42)"` 的 `toString()` 方法
* 按照其声明顺序与属性相对应的 `component()`函数
* `copy()` 方法

如下面的示例所示，即使 `Person` 属性是只读的，也允许轻松更改单个属性：

[source,kotlin,indent=0]
----
	data class Person(val name: String, val age: Int)

	val jack = Person(name = "Jack", age = 1)
	val olderJack = jack.copy(age = 2)
----

但是一些像JPA这样的持久化技术需要默认的构造函数，这妨碍了这种设计。幸运的是，现在有解决办法这种 https://stackoverflow.com/questions/32038177/kotlin-with-jpa-default-constructor-hell["`default constructor hell`"]， 因为Kotlin提供了一个 https://kotlinlang.org/docs/reference/compiler-plugins.html#kotlin-jpa-compiler-plugin[`kotlin-jpa`] 插件，生成在JPA注解上合成无参数的构造器。

如果您需要将此类机制用于其他持久性技术，则可以配置 https://kotlinlang.org/docs/reference/compiler-plugins.html#how-to-use-no-arg-plugin[`kotlin-noarg`] 插件。

NOTE: 从Kay发布系列开始，Spring Data支持Kotlin不可变类实例，如果模块使用Spring Data对象映射（如MongoDB，Redis，Cassandra等），则不需要 `kotlin-noarg` 插件。

=== 依赖注入

我们的建议是尝试和支持使用 `val` 只读的构造函数注入(如果可能的话)https://kotlinlang.org/docs/reference/properties.html[properties]，如下所示:

[source,kotlin,indent=0]
----
	@Component
	class YourBean(
		private val mongoTemplate: MongoTemplate,
		private val solrClient: SolrClient
	)
----

NOTE: 具有单个构造函数的类的参数会自动自动装配，这就是为什么在上面显示的示例中不需要显式的 `@Autowired` 构造函数 的原因。

如果确实需要使用字段注入，则可以使用 `lateinit var` 构造，如以下示例所示：

[source,kotlin,indent=0]
----
	@Component
	class YourBean {

		@Autowired
		lateinit var mongoTemplate: MongoTemplate

		@Autowired
		lateinit var solrClient: SolrClient
	}
----

=== 注入配置属性

在Java中，您可以使用注解（例如  `@Value("${property}")`）注入配置属性。 但是，在Kotlin中，`$` 是一个用于 https://kotlinlang.org/docs/reference/idioms.html#string-interpolation[字符串插值] 的保留字符。

因此，如果您希望在Kotlin中使用 `@Value` 注解，则需要通过编写 `@Value("\${property}")` 来转义 `$` 字符。

NOTE: 如果使用Spring Boot，则可能应该使用 https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-typesafe-configuration-properties[`@ConfigurationProperties`] 而不是 `@Value` 注解。

或者，您可以通过声明以下配置Bean来自定义属性占位符前缀：

[source,kotlin,indent=0]
----
	@Bean
	fun propertyConfigurer() = PropertySourcesPlaceholderConfigurer().apply {
		setPlaceholderPrefix("%{")
	}
----

现有的代码(如Spring Boot actuators 或  `@LocalServerPort`)都使用 `${...}` 语法，可以使用配置bean进行定制。如以下示例所示：

[source,kotlin,indent=0]
----
	@Bean
	fun kotlinPropertyConfigurer() = PropertySourcesPlaceholderConfigurer().apply {
		setPlaceholderPrefix("%{")
		setIgnoreUnresolvablePlaceholders(true)
	}

	@Bean
	fun defaultPropertyConfigurer() = PropertySourcesPlaceholderConfigurer()
----


=== 检查异常

Java和https://kotlinlang.org/docs/reference/exceptions.html[Kotlin异常处理]非常接近，主要区别在于Kotlin将所有异常视为未经检查的异常。 但是，当使用代理对象（例如，用 `@Transactional` 注解的类或方法）时，默认情况下，引发的检查异常将包装在 `UndeclaredThrowableException` 中。

为了像在Java中一样抛出原始异常，应该使用 https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-throws/index.html[`@Throws`] 注解方法，以明确指定抛出的已检查异常（例如 `@Throws(IOException::class)`）。

=== 注解数组属性

Kotlin注解大多与Java相似，但数组属性(在Spring中广泛使用着)的表现方式不同。正如 https://kotlinlang.org/docs/reference/annotations.html[Kotlin 文档]  中所解释的，与其他属性不同，`value` 属性名称可以省略，当它是数组属性时，它被指定为 `vararg` 参数。

要理解这意味着什么，请考虑 `@RequestMapping`（这是最广泛使用的Spring注解之一）作为示例。 此Java注解声明如下：

[source,java,indent=0]
----
	public @interface RequestMapping {

		@AliasFor("path")
		String[] value() default {};

		@AliasFor("value")
		String[] path() default {};

		RequestMethod[] method() default {};

		// ...
	}
----

`@RequestMapping` 的典型用例是将处理程序方法映射到特定的路径和方法。在Java中，可以为注解数组属性指定单个值，并将其自动转换为数组。

这就是为什么可以写
`@RequestMapping(value = "/toys", method = RequestMethod.GET)` 或
`@RequestMapping(path = "/toys", method = RequestMethod.GET)`.

然而, 在Kotlin 中, 你必须编写 `@RequestMapping("/toys", method = [RequestMethod.GET])`
或 `@RequestMapping(path = ["/toys"], method = [RequestMethod.GET])` (方括号需要使用命名数组属性指定).

这种特殊方法属性的解决方法（最常见的方法）是使用快捷方式注解，例如 `@GetMapping`, `@PostMapping` 等。

NOTE: 提醒：如果未指定 `@RequestMapping` `method` 属性，则将匹配所有HTTP方法，而不仅仅是 `GET` 方法。

=== 测试

本节介绍了Kotlin和Spring Framework的结合测试。推荐的测试框架是 https://junit.org/junit5/[JUnit 5]，以及用于模拟的 https://mockk.io/[Mockk] 。

NOTE: 如果您使用的是Spring Boot，请参阅此https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-kotlin-testing[相关文档]。

==== 构造器注入

如 <<testing#testcontext-junit-jupiter-di#spring-web-reactive, 专用部分中>>所述，JUnit 5允许构造函数注入bean，这对于Kotlin来说非常有用，以便使用 `val` 而不是 `lateinit var`。 您可以使用 {api-spring-framework}/test/context/TestConstructor.html[`@TestConstructor(autowire = true)`] 启用所有参数的自动装配。

====
[source,kotlin,indent=0]
----
@SpringJUnitConfig(TestConfig::class)
@TestConstructor(autowire = true)
class OrderServiceIntegrationTests(val orderService: OrderService,
                                   val customerService: CustomerService) {

    // tests that use the injected OrderService and CustomerService
}
----
====

==== `PER_CLASS` 生命周期

Kotlin允许您在反引号 (``)之间指定有意义的测试函数名称。从 https://junit.org/junit5/[JUnit 5]开始，Kotlin 测试类可以使用 `@TestInstance(TestInstance.Lifecycle.PER_CLASS)` 注解来启用测试类的单个实例化。 从而允许使用 `@BeforeAll` 和 `@AfterAll` 非静态方法的注解，这种特征很适合Kotlin。

现在，由于 `junit-platform.properties` 文件带有 `junit.jupiter.testinstance.lifecycle.default = per_class` 属性，您现在可以将默认行为更改为 `PER_CLASS` 。

以下示例 `@BeforeAll` 和 `@AfterAll` 对非静态方法的注解:

[source,kotlin,indent=0]
----
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class IntegrationTests {

  val application = Application(8181)
  val client = WebClient.create("http://localhost:8181")

  @BeforeAll
  fun beforeAll() {
    application.start()
  }

  @Test
  fun `Find all users on HTML page`() {
    client.get().uri("/users")
        .accept(TEXT_HTML)
        .retrieve()
        .bodyToMono<String>()
        .test()
        .expectNextMatches { it.contains("Foo") }
        .verifyComplete()
  }

  @AfterAll
  fun afterAll() {
    application.stop()
  }
}
----

==== 类似规范的测试

您可以使用JUnit 5和Kotlin创建类似规范的测试。 以下示例显示了如何执行此操作：

[source,kotlin,indent=0]
----
class SpecificationLikeTests {

  @Nested
  @DisplayName("a calculator")
  inner class Calculator {
     val calculator = SampleCalculator()

     @Test
     fun `should return the result of adding the first number to the second number`() {
        val sum = calculator.sum(2, 4)
        assertEquals(6, sum)
     }

     @Test
     fun `should return the result of subtracting the second number from the first number`() {
        val subtract = calculator.subtract(4, 2)
        assertEquals(2, subtract)
     }
  }
}
----

[[kotlin-webtestclient-issue]]
==== Kotlin中的 `WebTestClient` 类型推断问题

由于 https://youtrack.jetbrains.com/issue/KT-5464[类型推断问题]，您必须使用Kotlin `expectBody` 扩展（例如 `expectBody<String>().isEqualTo("toys")` ），因为它为Java API提供了Kotlin问题的解决方法。

另请参阅相关的 https://jira.spring.io/browse/SPR-16057[SPR-16057] 问题。

[[kotlin-getting-started]]
== 入门

本节描述了开始结合Kotlin和Spring Framework的项目的最快方法是 https://spring.io/guides/tutorials/spring-boot-kotlin/[使用特定教程].

=== `start.spring.io`

在Kotlin中启动新的Spring Framework 5项目的最简单方法是在 https://start.spring.io/#!language=kotlin&type=gradle-project[start.spring.io]上创建一个新的Spring Boot 2项目。

=== 选择 Web 风格

Spring框架现在带有两个不同的Web堆栈：<<web#mvc, Spring MVC>>和 <<web-reactive#spring-web-reactive, Spring WebFlux>>。

如果您要创建处理延迟，长期连接，流传输方案的应用程序，或者要使用网络功能的Kotlin DSL，建议使用Spring WebFlux。

对于其他用例，尤其是在使用阻塞技术（例如JPA，Spring MVC及其基于注解的编程模型）的情况下，建议选择。

[[kotlin-resources]]
== 资源

对于学习如何使用Kotlin和Spring Framework构建应用程序的人们，我们建议使用以下资源：

* https://kotlinlang.org/docs/reference/[Kotlin language reference]
* https://slack.kotlinlang.org/[Kotlin Slack] (with a dedicated #spring channel)
* https://stackoverflow.com/questions/tagged/spring+kotlin[Stackoverflow, with `spring` and `kotlin` tags]
* https://try.kotlinlang.org/[Try Kotlin in your browser]
* https://blog.jetbrains.com/kotlin/[Kotlin blog]
* https://kotlin.link/[Awesome Kotlin]

=== 示例

以下Github项目提供了示例，您可以从中学习甚至扩展：

* https://github.com/sdeleuze/spring-boot-kotlin-demo[spring-boot-kotlin-demo]: Regular Spring Boot and Spring Data JPA project
* https://github.com/mixitconf/mixit[mixit]: Spring Boot 2, WebFlux, and Reactive Spring Data MongoDB
* https://github.com/sdeleuze/spring-kotlin-functional[spring-kotlin-functional]: Standalone WebFlux and functional bean definition DSL
* https://github.com/sdeleuze/spring-kotlin-fullstack[spring-kotlin-fullstack]: WebFlux Kotlin fullstack example with Kotlin2js for frontend instead of JavaScript or TypeScript
* https://github.com/spring-petclinic/spring-petclinic-kotlin[spring-petclinic-kotlin]: Kotlin version of the Spring PetClinic Sample Application
* https://github.com/sdeleuze/spring-kotlin-deepdive[spring-kotlin-deepdive]: A step-by-step migration guide for Boot 1.0 and Java to Boot 2.0 and Kotlin
* https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-kotlin-samples/spring-cloud-gcp-kotlin-app-sample[spring-cloud-gcp-kotlin-app-sample]: Spring Boot with Google Cloud Platform Integrations

=== 问题

以下列表对与Spring和Kotlin支持有关的未决问题进行了分类：

* Spring Framework
** https://github.com/spring-projects/spring-framework/issues/20606[Unable to use WebTestClient with mock server in Kotlin]
** https://github.com/spring-projects/spring-framework/issues/20496[Support null-safety at generics, varargs and array elements level]
* Kotlin
** https://youtrack.jetbrains.com/issue/KT-6380[Parent issue for Spring Framework support]
** https://youtrack.jetbrains.com/issue/KT-5464[Kotlin requires type inference where Java doesn't]
** https://youtrack.jetbrains.com/issue/KT-20283[Smart cast regression with open classes]
** https://youtrack.jetbrains.com/issue/KT-14984[Impossible to pass not all SAM argument as function]
** https://youtrack.jetbrains.com/issue/KT-15125[Support JSR 223 bindings directly via script variables]
** https://youtrack.jetbrains.com/issue/KT-6653[Kotlin properties do not override Java-style getters and setters]
