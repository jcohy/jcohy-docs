= BLPOP

**语法**

[source,text]
----
BLPOP key [key ...] timeout
----

**可用版本**：2.0.0

**时间复杂度**：O(N)，其中 N 是提供的 key 的数量。

**ACL 类别**：**@write, @list, @slow, @blocking**

BLPOP 是阻止列表弹出原语。 它是 LPOP 的阻塞版本，因为当没有可以从任何给定列表中弹出的元素时，它会阻塞连接。 从第一个非空列表的头部弹出一个元素，并按照给出的顺序检查给定的 key。

== 非阻塞行为

当 BLPOP 被调用时，如果给定 key 内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字 key 一起，组成结果返回给调用者。

当存在多个给定 key 时， BLPOP 按给定 key 参数排列的先后顺序，依次检查各个列表。 我们假设 key list1 不存在，而 list2 和 list3 都是非空列表。考虑以下的命令：

[source,text]
----
BLPOP list1 list2 list3 0
----

BLPOP 保证从存储在 list2 的列表中返回一个元素（因为按顺序检查 list1、list2 和 list3 时它是第一个非空列表）。

== 阻塞行为

如果指定的 key 都不存在，则 BLPOP 会阻止连接，直到另一个客户端对其中一个 key 执行 LPUSH 或 RPUSH 操作。

一旦列表之一出现新数据，那么这个命令会解除阻塞状态，并且返回 key 和弹出的元素值。

当 BLPOP 命令引起客户端阻塞并且设置了一个非零的超时参数 timeout 的时候，如果指定的超时已过期，仍没有出现一个针对某一特定 key 的 push 操作，则客户端将解除阻塞并返回 nil multi-bulk 值。

timeout 参数表示的是一个指定阻塞的最大秒数的双精度值。当 timeout 为 0 是表示永久阻塞。

== 什么 key 会先被处理？是什么客户端？什么元素？优先顺序细节。

* 当客户端为多个 key 尝试阻塞的时候，若至少存在一个 key 拥有元素，那么返回的键值对(key/element pair)就是从左到右数第一个拥有一个或多个元素的key。 在这种情况下客户端不会被阻塞。比如对于这个例子 `BLPOP key1 key2 key3 key4 0`，假设 key2 和 key4 都非空， 那么就会返回 key2 里的一个元素。
* 当多个客户端为同一个 key 阻塞的时候，第一个被处理的客户端是等待最长时间的那个（即第一个因为该 key 而阻塞的客户端）。 一旦一个客户端解除阻塞那么它就不会保持任何优先级，当它因为下一个 `BLPOP` 命令而再次被阻塞的时候，会在处理完那些 被同个 key 阻塞的客户端后才处理它（即从第一个被阻塞的处理到最后一个被阻塞的）。
* 当一个客户端同时被多个 key 阻塞时，若多个 key 的元素同时可用（可能是因为事务或者某个 Lua 脚本向多个 list 添加元素），那么客户端会解除阻塞，并使用第一个接收到 push 操作的 key（假设它拥有足够的元素为我们的客户端服务，因为有可能存在其他客户端同样是被这个key阻塞着）。
从根本上来说，在执行完每个命令之后，Redis 会把一个所有 key 都获得数据并且至少使一个客户端阻塞了的 list 运行一次。 这个 list 按照新数据的接收时间进行整理，即是从第一个接收数据的 key 到最后一个。在处理每个 key 的时候，只要这个 key 里有元素， Redis 就会对所有等待这个 key 的客户端按照 “先进先出”(FIFO) 的顺序进行服务。若这个 key 是空的，或者没有客户端在等待这个 key， 那么将会去处理下一个从之前的命令或事务或脚本中获得新数据的 key，如此等等。

== 当多个元素被 push 进入一个 list 时 BLPOP 的行为

有时候一个 list 会在同一概念的命令的情况下接收到多个元素：

* 像 LPUSH mylist a b c 这样的可变 push 操作。
* 在对一个向同一个 list 进行多次 push 操作的 MULTI 块执行完 EXEC 语句后。
* 使用 Redis 2.6 或者更新的版本执行一个 Lua 脚本。

当多个元素被 push 进入一个被客户端阻塞着的 list 的时候，Redis 2.4 和 Redis 2.6 或者更新的版本所采取行为是不一样的。

对于 Redis 2.6 来说，所采取的行为是先执行多个 push 命令，然后在执行了这个命令之后再去服务被阻塞的客户端。看看下面命令顺序。

[source,text]
----
Client A:   BLPOP foo 0
Client B:   LPUSH foo a b c
----

如果使用 Redis 2.6 或更高版本的服务器发生上述情况，客户端 A 将收到 c 元素，因为在 LPUSH 命令之后列表包含 c、b、a，因此从左侧取出元素意味着返回 c。

相反，Redis 2.4 以不同的方式工作：客户端在推送操作的上下文中提供服务，因此只要 LPUSH foo a b c 开始将第一个元素推送到列表，它将被传递到客户端 A，客户端 A 将收到 ( 第一个元素被推）。

在将数据复制或保存到 AOF 文件中时，Redis 2.4 的行为会产生很多问题，因此 Redis 2.6 中引入了更通用且语义上更简单的行为来防止出现问题。

请注意，出于同样的原因，Lua 脚本或 MULTI/EXEC 块可能会将元素推送到列表中，然后删除该列表。 在这种情况下，被阻止的客户端将根本不会得到服务，并且只要在执行单个命令、事务或脚本后列表中不存在任何数据，就会继续被阻止。

== MULTI/EXEC 事务中的 BLPOP

BLPOP 可以与流水线（pipeline,发送多个命令并且批量读取回复）一起使用，特别是当它是流水线里的最后一个命令的时候，这种设定更加有意义。

在 MULTI/EXEC 块内使用 BLPOP 没有多大意义，因为它需要阻塞整个服务器才能原子执行该块，而这又不允许其他客户端执行推送操作。 因此，当列表为空时，MULTI/EXEC 内的 BLPOP 的行为是返回 nil 多批量回复，这与达到超时时发生的情况相同。

如果您喜欢科幻小说，请想象时间在 MULTI/EXEC 块内以无限速度流动......

== 返回值

https://redis.io/docs/reference/protocol-spec/#resp-arrays[数组]:

* 如果列表为空或超时，返回一个 nil。
* 返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。

== 示例

[source,text]
----
redis> DEL list1 list2
(integer) 0
redis> RPUSH list1 a b c
(integer) 3
redis> BLPOP list1 list2 0
1) "list1"
2) "a"
----

== 可靠的队列

当 BLPOP 返回一个元素给客户端的时候，它也从 list 中把该元素移除。这意味着该元素就只存在于客户端的上下文中：如果客户端在处理这个返回元素的过程崩溃了，那么这个元素就永远丢失了。

在一些我们希望是更可靠的消息传递系统中的应用上，这可能会导致一些问题。在这种时候，请查看 `BRPOPLPUSH` 命令，这是 BLPOP 的另一种形式，它会在把返回元素传给客户端之前先把该元素加入到一个目标 list 中。

== 模式：事件通知

用来阻塞 list 的操作有可能是不同的阻塞原语。 比如在某些应用里，你也许会为了等待新元素进入 Redis Set 而阻塞队列，直到有个新元素加入到 Set 中，这样就可以在不轮询的情况下获得元素。 这就要求要有一个 SPOP 的阻塞版本，而这事实上并不可用。但是我们可以通过阻塞 list 操作轻易完成这个任务。

消费者会做的：

[source,text]
----
LOOP forever
    WHILE SPOP(key) returns elements
        ... process elements ...
    END
    BRPOP helper_key
END
----

在生产者方面，我们将简单地使用：

[source,text]
----
MULTI
SADD key element
LPUSH helper_key x
EXEC
----

== 历史

* 从 Redis 版本 6.0.0 开始： timeout 被解释为双精度（double）而不是整数。