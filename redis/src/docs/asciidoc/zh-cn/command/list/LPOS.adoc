= LPOS

**语法**

[source,text]
----
LPOS key element [RANK rank] [COUNT num-matches] [MAXLEN len]
----

**可用版本**：6.0.6

**时间复杂度**：O(N)，其中 N 是列表中元素的数量，用于平均情况。当搜索靠近列表头部或尾部的元素时，或者当提供 MAXLEN 选项时，该命令可能会在恒定时间内运行。

**ACL 类别**：**@read, @list, @slow**

该命令返回 Redis 列表中匹配元素的索引。 默认情况下，当没有给出任何选项时，它将从头到尾扫描列表，寻找 "element" 的第一个匹配项。 如果找到该元素，则返回其索引（列表中从零开始的位置）。 否则，如果未找到匹配项，则返回 nil。

[source,text]
----
> RPUSH mylist a b c 1 2 3 c c
> LPOS mylist c
2
----

带参数的命令可以有更多的功能。 `RANK` 选项指定要返回的第一个元素的 "rank"，以防存在多个匹配项。 那么 rank 为 1 表示返回第一个匹配项，2 表示返回第二个匹配项，依此类推。

例如，在上面的示例中，元素 "c" 出现多次，如果我想要第二个匹配的索引，我会写：

[source,text]
----
> LPOS mylist c RANK 2
6
----

也就是说，"c" 第二次出现在位置 6。 RANK 参数的负 "rank" 告诉 LPOS 反转搜索方向，从尾部开始到头部。

所以，我们想说，给我从列表尾部开始的第一个元素：

[source,text]
----
> LPOS mylist c RANK -1
7
----

需要注意的是返回的索引还是从列表头开始，从零开始计数。即考虑从索引 0 处的列表头部开始的第一个元素，索引 1 处的下一个元素，依此类推。 这基本上意味着无论 rank 是正数还是负数，返回的索引都是稳定的。

有时我们不仅想返回第 N 个匹配元素，还想返回所有前 N 个匹配元素的位置。 这可以使用 COUNT 选项来实现。

[source,text]
----
> LPOS mylist c COUNT 2
[2,6]
----

我们可以将 `COUNT` 和 `RANK` 结合起来，这样 `COUNT` 将尝试返回指定数量的匹配项，但从第 N 个匹配项开始，如 `RANK` 选项指定的那样。

[source,text]
----
> LPOS mylist c RANK -1 COUNT 2
[7,6]
----

当使用 `COUNT` 时，可以指定 0 作为匹配项的数量，以此告诉命令我们希望找到的所有匹配项作为索引数组返回。 这比给出一个非常大的 COUNT 选项更好，因为它更通用。

[source,text]
----
> LPOS mylist c COUNT 0
[2,6,7]
----

当使用 `COUNT` 并且未找到匹配项时，将返回一个空数组。 但是，当未使用 `COUNT` 并且没有匹配项时，该命令将返回 `nil`。

最后，`MAXLEN` 选项告诉命令仅将提供的元素与给定的最大列表项数进行比较。 因此，例如指定 MAXLEN 1000 将确保该命令仅执行 1000 次比较，从而有效地在列表的子集上运行算法（第一部分或最后一部分取决于我们使用正排序或负排序的事实）。
这对于限制命令的最大复杂性很有用。 当我们期望很早找到匹配项，但希望确保万一情况并非如此时，该命令不会花费太多时间来运行，这也很有用。

当使用 `MAXLEN` 时，可以指定 0 作为最大比较次数，以此告诉命令我们想要无限次比较。 这比提供非常大的 `MAXLEN` 选项更好，因为它更通用。

== 返回值

该命令返回表示匹配元素的整数，如果没有匹配则返回 nil。 但是，如果给出 `COUNT` 选项，该命令将返回一个数组（如果没有匹配则为空）。

== 示例

[source,text]
----
redis> RPUSH mylist a b c d 1 2 3 4 3 3 3
(integer) 11
redis> LPOS mylist 3
(integer) 6
redis> LPOS mylist 3 COUNT 0 RANK 2
1) (integer) 8
2) (integer) 9
3) (integer) 10
redis>
----
