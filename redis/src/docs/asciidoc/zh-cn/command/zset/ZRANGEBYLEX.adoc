= ZRANGEBYLEX

NOTE: 从 Redis 版本 6.2.0 开始，此命令被视为已弃用。 迁移或编写新代码时，可以将其替换为带有 BYLEX 参数的 ZRANGE。

**语法**

[source,text]
----
ZRANGEBYLEX key min max [LIMIT offset count]
----

**可用版本**：2.8.9

**时间复杂度**：O(log(N)+M)，其中N是排序集合中的元素数量，M是返回的元素数量。如果M是常数(例如，总是要求具有LIMIT的前10个元素)，则可以认为它是O(log(N))。

**ACL 类别**：**@read, @sortedset, @slow**


当排序集中的所有元素都以相同的分数插入时，为了强制按字典顺序排序，此命令返回排序集中 key 处的所有元素，其值介于 min 和 max 之间。

如果排序集中的元素具有不同的分数，则返回的元素是未指定的。

使用 `memcmp()` C 函数逐字节比较时，元素被认为是从低字符串到高字符串排序。 如果公共部分相同，则较长的字符串被认为大于较短的字符串。

可选的 LIMIT 参数可用于仅获取匹配元素的范围（类似于 SQL 中的 SELECT LIMIT offset、count）。 -count 返回偏移量中的所有元素。
请记住，如果偏移量很大，则需要先遍历排序集以查找偏移量元素，然后才能返回要返回的元素，这可能会增加 O(N) 时间复杂度。

== 如何指定间隔

有效的 `start` 和 `stop` 必须以 `(` 或 `[` 开头，以便指定范围项分别是独占还是包含。 `start` 和 `stop` 的 `+` 或 `-` 特殊值具有特殊含义或正无限和负无限字符串，
例如，如果所有元素具有相同的分数，则命令 `ZRANGEBYLEX myzset - +` 保证返回排序集中的所有元素。

== 字符串比较的详细信息

字符串作为字节的二进制数组进行比较。 由于 ASCII 字符集的指定方式，这意味着通常也具有以明显的字典方式比较普通 ASCII 字符的效果。 但是，如果使用非纯 ASCII 字符串（例如 utf8 字符串），则情况并非如此。

然而，用户可以对编码字符串应用转换，以便插入排序集中的元素的第一部分将根据用户特定应用程序的需要进行比较。 例如，如果我想添加将以不区分大小写的方式进行比较的字符串，但我仍然想在查询时检索真实的大小写，我可以通过以下方式添加字符串：

[source,text]
----
ZADD autocomplete 0 foo:Foo 0 bar:BAR 0 zap:zap
----

由于每个元素中的第一个标准化部分（冒号字符之前），我们强制进行给定的比较，但是在使用 ZRANGEBYLEX 查询范围之后，应用程序可以向用户显示字符串的第二部分（冒号之后）。

比较的二进制性质允许使用排序集作为通用索引，例如元素的第一部分可以是 64 位大端数：由于大端数在初始位置具有最高有效字节，因此二进制 比较将匹配数字的数值比较。 这可用于实现 64 位值的范围查询。 如下例所示，在前 8 个字节之后，我们可以存储实际索引的元素的值。

== 返回值

https://redis.io/docs/reference/protocol-spec/#resp-arrays[数组]： 指定分数范围内的元素列表。

== 示例

[source,text]
----
redis> ZADD myzset 0 a 0 b 0 c 0 d 0 e 0 f 0 g
(integer) 7
redis> ZRANGEBYLEX myzset - [c
1) "a"
2) "b"
3) "c"
redis> ZRANGEBYLEX myzset - (c
1) "a"
2) "b"
redis> ZRANGEBYLEX myzset [aaa (g
1) "b"
2) "c"
3) "d"
4) "e"
5) "f"
redis>
----
