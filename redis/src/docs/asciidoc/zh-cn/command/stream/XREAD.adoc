= XREAD

**语法**

[source,text]
----
XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id
  [id ...]
----

**可用版本**：5.0.0

**时间复杂度**：

**ACL 类别**：**@read, @stream, @slow, @blocking**

从一个或多个流中读取数据，仅返回 ID 大于调用者报告的最后接收到的 ID 的条目。 该命令有一个选项，可以在项目不可用时阻止，其方式与 BRPOP 或 BZPOPMIN 等类似。

请注意，在阅读本页之前，如果您是流的新手，我们建议您阅读我们对 https://redis.io/docs/data-types/streams/[Redis Streams] 的介绍。

== 非阻塞使用

如果不使用 BLOCK 选项，则该命令是同步的，并且可以被认为与 XRANGE 有点相关：它将返回流内的一系列项目，但是即使我们只考虑同步使用，它与 XRANGE 相比也有两个基本区别：

* 如果我们想同时读取多个键，则可以使用多个流调用此命令。 这是 XREAD 的一个关键功能，因为特别是在使用 BLOCK 进行阻止时，能够通过单个连接监听多个键是一个重要的功能。
* 虽然 XRANGE 返回 ID 范围内的项目，但 XREAD 更适合从第一个条目开始消耗流，该条目比我们迄今为止看到的任何其他条目都大。 因此，对于每个流，我们传递给 XREAD 的是我们从该流接收到的最后一个元素的 ID。

例如，如果我有两个流 mystream 和 writers，并且我想从这两个流包含的第一个元素开始读取数据，我可以像下面的示例一样调用 XREAD。

注意：我们在示例中使用 COUNT 选项，以便对于每个流，调用最多返回每个流两个元素。

[source,text]
----
> XREAD COUNT 2 STREAMS mystream writers 0-0 0-0
1) 1) "mystream"
   2) 1) 1) 1526984818136-0
         2) 1) "duration"
            2) "1532"
            3) "event-id"
            4) "5"
            5) "user-id"
            6) "7782813"
      2) 1) 1526999352406-0
         2) 1) "duration"
            2) "812"
            3) "event-id"
            4) "9"
            5) "user-id"
            6) "388234"
2) 1) "writers"
   2) 1) 1) 1526985676425-0
         2) 1) "name"
            2) "Virginia"
            3) "surname"
            4) "Woolf"
      2) 1) 1526985685298-0
         2) 1) "name"
            2) "Jane"
            3) "surname"
            4) "Austen"
----

STREAMS 选项是强制性的，并且必须是最终选项，因为此类选项以以下格式获取可变长度的参数：

[source,text]
----
STREAMS key_1 key_2 key_3 ... key_N ID_1 ID_2 ID_3 ... ID_N
----

因此，我们从键列表开始，然后继续使用所有关联的 ID，代表我们为该流收到的最后一个 ID，以便该调用只会为我们提供来自同一流的更大 ID。

例如，在上面的示例中，我们收到的流 mystream 的最后一个项目的 ID 为 1526999352406-0，而流 writers 的最后项目的 ID 为 1526985685298-0。

要继续迭代这两个流，我将调用：

[source,text]
----
> XREAD COUNT 2 STREAMS mystream writers 1526999352406-0 1526985685298-0
1) 1) "mystream"
   2) 1) 1) 1526999626221-0
         2) 1) "duration"
            2) "911"
            3) "event-id"
            4) "7"
            5) "user-id"
            6) "9488232"
2) 1) "writers"
   2) 1) 1) 1526985691746-0
         2) 1) "name"
            2) "Toni"
            3) "surname"
            4) "Morrison"
      2) 1) 1526985712947-0
         2) 1) "name"
            2) "Agatha"
            3) "surname"
            4) "Christie"
----

等等。 最终，该调用不会返回任何项目，而只是一个空数组，然后我们知道没有更多内容可以从流中获取（并且我们必须重试该操作，因此该命令也支持阻塞模式）。

== ID 不完整

使用不完整的 ID 是有效的，就像它对 XRANGE 有效一样。 然而，这里 ID 的序列部分（如果丢失）始终被解释为零，因此命令：

[source,text]
----
> XREAD COUNT 2 STREAMS mystream writers 0 0
----

完全等于:

[source,text]
----
> XREAD COUNT 2 STREAMS mystream writers 0-0 0-0
----

== 数据阻塞

在同步形式中，只要有更多可用项目，该命令就可以获取新数据。 然而，在某些时候，我们将不得不等待数据生产者使用 XADD 将新条目推送到我们正在使用的流中。 为了避免以固定或自适应间隔进行轮询，如果命令无法返回任何数据，则能够根据指定的流和 ID 进行阻塞，并在请求的键之一接受数据后自动解除阻塞。

重要的是要理解，此命令会扇出到所有正在等待相同范围 ID 的客户端，因此每个消费者都将获得数据的副本，这与使用阻止列表弹出操作时发生的情况不同。

为了阻止，使用 BLOCK 选项，以及我们想要在超时之前阻止的毫秒数。 通常，Redis 阻塞命令会以秒为单位超时，但是此命令会超时，即使通常服务器的超时分辨率接近 0.1 秒。 这次在某些用例中可以阻塞更短的时间，并且如果服务器内部随着时间的推移而改进，则超时的解决方案可能会得到改善。

当传递 BLOCK 命令，但至少在传递的流之一中有数据要返回时，该命令将同步执行，就像缺少 BLOCK 选项一样。

这是阻塞调用的示例，其中该命令稍后返回空回复，因为超时已过而没有新数据到达：

[source,text]
----
> XREAD BLOCK 1000 STREAMS mystream 1526999626221-0
(nil)
----

== 特殊的 $ID。

当阻塞时，有时我们希望只接收从阻塞那一刻起通过 XADD 添加到流中的条目。 在这种情况下，我们对已添加条目的历史不感兴趣。 对于此用例，我们必须检查流顶部元素 ID，并在 XREAD 命令行中使用此类 ID。 这并不干净，需要调用其他命令，因此可以使用特殊的 $ ID 来向流发出信号，表明我们只需要新内容。

理解这一点非常重要：您应该仅在第一次调用 XREAD 时使用 $ID。 稍后，ID 应该是流中最后报告的项目之一，否则您可能会错过在其间添加的所有条目。

这是在消费者愿意仅使用新条目的第一次迭代中典型的 XREAD 调用的样子：

[source,text]
----
> XREAD BLOCK 5000 COUNT 100 STREAMS mystream $
----

一旦我们得到一些答复，下一个调用将是这样的：

[source,text]
----
> XREAD BLOCK 5000 COUNT 100 STREAMS mystream 1526999644174-3
----

等等。

== 如何为单个流上阻塞的多个客户端提供服务

列表或排序集上的阻止列表操作具有弹出行为。 基本上，元素会从列表或排序集中删除，以便返回给客户端。 在这种情况下，您希望以公平的方式消耗项目，具体取决于在给定密钥上阻塞的客户端到达的时间。 通常，Redis 在此用例中使用 FIFO 语义。

但请注意，对于流来说，这不是问题：当为客户端提供服务时，流条目不会从流中删除，因此一旦 XADD 命令向流提供数据，每个等待的客户端都会得到服务。

== 返回值

https://redis.io/docs/reference/protocol-spec/#resp-arrays[数组]: 该命令返回结果数组：返回数组的每个元素都是由两个元素组成的数组，其中包含键名称和为该键报告的条目。 报告的条目是完整的流条目，具有 ID 以及所有字段和值的列表。 字段和值保证按照 XADD 添加的顺序进行报告。

当使用 BLOCK 时，超时时返回空回复。

强烈建议阅读 Redis Streams 介绍，以便更多地了解流的整体行为和语义。
