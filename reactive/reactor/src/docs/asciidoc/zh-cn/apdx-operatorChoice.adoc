[[which-operator]]
= 我需要哪个操作符?

TIP: 在这一节,如果一个操作符是专属于 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux] 或
https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono] 的,那么会给它注明前缀和链接,
例如 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromArray-T:A-[Flux#fromArray].
公共的操作符没有前缀，并提供了两种实现的链接，例如：`just` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-[Flux] | link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-[Mono]).
如果一个具体的用例涉及多个操作符的组合,这里以方法调用的方式展现, 会以一个点(`.`)开头,并将参数置于圆括号内,
比如:  `.methodCall(parameter)`.

//TODO flux:  publishOn/subscribeOn/cancelOn
//transformDeferred/transform, repeatWhen, sort, startWith
//TODO Mono.sequenceEqual

我想搞定:

* <<which.create>>

* <<which.values>>

* <<which.filtering>>

* <<which.peeking>>

* <<which.errors>>

* <<which.time>>

* <<which.window>>

* <<which.blocking>>

* <<which.multicasting>>

[[which.create]]
== 创建一个新序列,它...

* 发出一个 `T`,我已经有了:: `just` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-[Mono])
** 基于一个 https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html[Optional<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#justOrEmpty-java.util.Optional-[Mono#justOrEmpty(Optional<T>)]
** ...基于一个可能为 `null` 的 `T`: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#justOrEmpty-T-[Mono#justOrEmpty(T)]
* 发出一个 `T`,且还是由: `just` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-[Mono]) 方法返回
** ...但是 "延迟" 创建的: 使用 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromSupplier-java.util.function.Supplier-[Mono#fromSupplier] 或用 `defer` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defer-java.util.function.Supplier-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defer-java.util.function.Supplier-[Mono]) 包装 `just` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-[Mono])
* 发出许多 `T`,这些元素我可以明确列举出来:: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-[Flux#just(T...)]
* 基于迭代数据结构:
** 一个数组: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromArray-T:A-[Flux#fromArray]
** 一个集合或 iterable: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromIterable-java.lang.Iterable-[Flux#fromIterable]
** 一个 Integer 的 range: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#range-int-int-[Flux#range]
** 一个 https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html[Stream] 提供给每一个订阅: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromStream-java.util.function.Supplier-[Flux#fromStream(Supplier<Stream>)]
*  基于一个参数值给出的源:
** 一个 https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html[Supplier<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromSupplier-java.util.function.Supplier-[Mono#fromSupplier]
** 一个任务: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromCallable-java.util.concurrent.Callable-[Mono#fromCallable], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromRunnable-java.lang.Runnable-[Mono#fromRunnable]
** 一个 https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html[CompletableFuture<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromFuture-java.util.concurrent.CompletableFuture-[Mono#fromFuture]
* 直接完成: `empty` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#empty--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#empty--[Mono])
* 立即生成错误: `error` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.lang.Throwable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.lang.Throwable-[Mono])
** ...但是 "懒" 的方式生成 https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html[Throwable]: `error(Supplier<Throwable>)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.util.function.Supplier-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.util.function.Supplier-[Mono])
* 什么都不做: `never` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#never--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#never--[Mono])
* 订阅时才决定: `defer` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defer-java.util.function.Supplier-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defer-java.util.function.Supplier-[Mono])
* 依赖一个可回收的资源: `using` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-[Mono])
* 可编程地生成事件(可以使用状态):
** 同步且逐个的: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#generate-java.util.concurrent.Callable-java.util.function.BiFunction-[Flux#generate]
** 异步(也可同步)的,每次尽可能多发出元素: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#create-java.util.function.Consumer-[Flux#create]
(https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#create-java.util.function.Consumer-[Mono#create] 也是异步的,只不过只能发一个)

[[which.values]]
== 对序列进行转化

* 我想转化一个序列:
** 1 对 1 地转化(比如字符串转化为它的长度): `map` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#map-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#map-java.util.function.Function-[Mono])
*** ...类型转化: `cast` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cast-java.lang.Class-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#cast-java.lang.Class-[Mono])
*** ...为了获得每个元素的序号: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#index--[Flux#index]
** 1 对 n 地转化(如字符串转化为一串字符): `flatMap` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMap-java.util.function.Function-[Mono]) + use a factory method
** 1 对 n 地转化可自定义转化方法和/或状态: `handle` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#handle-java.util.function.BiConsumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#handle-java.util.function.BiConsumer-[Mono])
** 对每一个元素执行一个异步操作(如对 url 执行 http 请求): `flatMap` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMap-java.util.function.Function-[Mono]) + an async https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true[Publisher]-returning method
*** ...忽略一些数据: 在 flatMap lambda 中根据条件返回一个 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#empty--[Mono.empty()].
*** ...保留原来的序列顺序: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-[Flux#flatMapSequential] (对每个元素的异步任务会立即执行,但会将结果按照原序列顺序排序)
*** ...当 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono] 元素的异步任务会返回多个元素的序列时: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMapMany-java.util.function.Function-[Mono#flatMapMany]

* 我想添加一些数据元素到一个现有的序列:
** 在开头添加: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#startWith-T%2E%2E%2E-[Flux#startWith(T...)]
** 在最后添加: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concatWithValues-T%2E%2E%2E-[Flux#concatWithValues(T...)]

* 我想将 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux] 转化为集合(以下都是针对 `Flux#` 的):
** 转化为 List: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectList--[collectList], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectSortedList--[collectSortedList]
** 转化为 Map: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectMap-java.util.function.Function-[collectMap], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectMultimap-java.util.function.Function-[collectMultiMap]
** 转化为任意容器: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collect-java.util.stream.Collector-[collect]
** 计数: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#count--[count]
** reduce 算法(将上个元素的reduce结果与当前元素值作为输入执行 reduce 方法,如 sum): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#reduce-A-java.util.function.BiFunction-[reduce]
*** ...将每次 的结果立即发出: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#scan-A-java.util.function.BiFunction-[scan]
** 转化为一个 boolean 值:
*** 对所有元素判断都为 true (AND): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#all-java.util.function.Predicate-[all]
*** 对至少一个元素判断为 true (OR): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#any-java.util.function.Predicate-[any]
*** 判断序列是否有元素(不为空): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#hasElements--[hasElements] _(there is a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono] equivalent in https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#hasElement--[hasElement])_
*** 判断序列中是否有匹配的元素: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#hasElement-T-[hasElement(T)]


* 我想合并 publishers...
** 按序连接: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concat-org.reactivestreams.Publisher%2E%2E%2E-[Flux#concat] or `.concatWith(other)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concatWith-org.reactivestreams.Publisher-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#concatWith-org.reactivestreams.Publisher-[Mono])
*** ...即使有错误,也会等所有的  publishers 连接完成: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concatDelayError-org.reactivestreams.Publisher-[Flux#concatDelayError]
*** ...按订阅顺序连接(这里的合并仍然可以理解成序列的连接): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#mergeSequential-int-org.reactivestreams.Publisher%2E%2E%2E-[Flux#mergeSequential]
** 按元素发出的顺序合并(无论哪个序列的,元素先到先合并): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#merge-int-org.reactivestreams.Publisher%2E%2E%2E-[Flux#merge] / `.mergeWith(other)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#mergeWith-org.reactivestreams.Publisher-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#mergeWith-org.reactivestreams.Publisher-[Mono])
*** ...元素类型会发生变化: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zip-java.util.function.Function-org.reactivestreams.Publisher%2E%2E%2E-[Flux#zip] / https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zipWith-org.reactivestreams.Publisher-[Flux#zipWith]
** 将元素组合:
*** 2 个 Monos 组成 1 个 https://projectreactor.io/docs/core/release/api/reactor/util/function/Tuple2.html[Tuple2]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#zipWith-reactor.core.publisher.Mono-[Mono#zipWith]
*** n 个 Monos 的元素都发出来后组成一个 Tuple: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#zip-java.util.function.Function-reactor.core.publisher.Mono%2E%2E%2E-[Mono#zip]
** 在终止信号出现时 "采取行动":
*** 在 Mono 终止时转换为一个 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono<Void>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#and-org.reactivestreams.Publisher-[Mono#and]
*** 当 n 个 Mono 都终止时返回: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#when-java.lang.Iterable-[Mono#when]
*** 在任意容器类型中:
**** 每个序列都发出一个元素时: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zip-java.util.function.Function-org.reactivestreams.Publisher%2E%2E%2E-[Flux#zip] (up to the smallest cardinality)
**** 任何一个序列发出元素时: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#combineLatest-java.util.function.Function-int-org.reactivestreams.Publisher%2E%2E%2E-[Flux#combineLatest]
** 只取各个序列的第一个元素...
*** produces a _value_ (`onNext`): `firstWithValue` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#firstWithValue-java.lang.Iterable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#firstWithValue-java.lang.Iterable-[Mono])
*** produces _any signal_: `firstWithSignal` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#firstWithSignal-java.lang.Iterable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#firstWithSignal-java.lang.Iterable-[Mono])
** 由一个序列触发(类似于 flatMap,不过 "喜新厌旧"): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchMap-java.util.function.Function-[switchMap] (each source element is mapped to a Publisher)
** 由每个新序列开始时触发(也是 "喜新厌旧" 风格): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchOnNext-org.reactivestreams.Publisher-[switchOnNext]

* 我想重复一个序列: `repeat` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#repeat--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#repeat--[Mono])
** ...但是以一定的间隔重复: `Flux.interval(duration).flatMap(tick -> myExistingPublisher)`

* 我有一个空序列,但是...
** 我想要一个默认值来代替: `defaultIfEmpty` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defaultIfEmpty-T-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defaultIfEmpty-T-[Mono])
** 我想要一个默认值的序列来代替: `switchIfEmpty` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchIfEmpty-org.reactivestreams.Publisher-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#switchIfEmpty-reactor.core.publisher.Mono-[Mono])

* 我有一个序列,但是我对序列的元素值不感兴趣: `ignoreElements` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ignoreElements--[Flux.ignoreElements()]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ignoreElement--[Mono.ignoreElement()])
** ...并且我希望用 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono<Void>] 来表示序列已经结束: `then` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#then--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#then--[Mono])
** ...并且我想在序列结束后等待另一个任务完成: `thenEmpty` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#thenEmpty-org.reactivestreams.Publisher-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenEmpty-org.reactivestreams.Publisher-[Mono])
** ...并且我想在序列结束之后返回一个 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#then-reactor.core.publisher.Mono-[Mono#then(mono)]
** ...并且我想在序列结束之后返回一个值: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenReturn-V-[Mono#thenReturn(T)]
** ...并且我想在序列结束之后返回一个 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux]: `thenMany` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#thenMany-org.reactivestreams.Publisher-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenMany-org.reactivestreams.Publisher-[Mono])

* 我有一个 Mono 但我想延迟完成...
** ...使用一个函数式来定义如何获取其他 publisher: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delayUntil-java.util.function.Function-[Mono#delayUntil(Function)]

* 我想基于一个递归的生成序列的规则扩展每一个元素, 然后合并为一个序列发出...
** ...广度优先: `expand(Function)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#expand-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#expand-java.util.function.Function-[Mono])
** ...深度优先: `expandDeep(Function)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#expandDeep-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#expandDeep-java.util.function.Function-[Mono])

[[which.peeking]]
== "窥视"(只读)序列

* 在不对序列造成改变的情况下,我想:
** 得到通知或执行一些操作:
*** 发出元素: `doOnNext` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnNext-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnNext-java.util.function.Consumer-[Mono])
*** 序列完成: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnComplete-java.lang.Runnable-[Flux#doOnComplete], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnSuccess-java.util.function.Consumer-[Mono#doOnSuccess] (includes the result, if any)
*** 因错误终止: `doOnError` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnError-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnError-java.util.function.Consumer-[Mono])
*** 取消: `doOnCancel` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnCancel-java.lang.Runnable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnCancel-java.lang.Runnable-[Mono])
*** "start": `doFirst` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFirst-java.lang.Runnable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFirst-java.lang.Runnable-[Mono])
**** this is tied to https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true#subscribe(org.reactivestreams.Subscriber)[Publisher#subscribe(Subscriber)]
*** post-subscription : `doOnSubscribe` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnSubscribe-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnSubscribe-java.util.function.Consumer-[Mono])
**** `Subscription` acknowledgment after `subscribe`
**** this is tied to https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true#onSubscribe(org.reactivestreams.Subscription)[Subscriber#onSubscribe(Subscription)]
*** 请求时: `doOnRequest` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnRequest-java.util.function.LongConsumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnRequest-java.util.function.LongConsumer-[Mono])
*** 完成或错误终止: `doOnTerminate` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnTerminate-java.lang.Runnable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnTerminate-java.lang.Runnable-[Mono])
**** 但是在终止信号向下游传递 之后: `doAfterTerminate` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doAfterTerminate-java.lang.Runnable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doAfterTerminate-java.lang.Runnable-[Mono])
*** 所有类型的信号 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Signal.html[Signal]: `doOnEach` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnEach-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnEach-java.util.function.Consumer-[Mono])
*** 所有结束的情况 (complete, error, cancel): `doFinally` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFinally-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFinally-java.util.function.Consumer-[Mono])
** 记录日志: `log` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#log--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#log--[Mono])

* 我想知道所有的事件:
** 每一个事件都体现为一个  https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Signal.html[Signal] 对象:
*** 执行 callback: `doOnEach` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnEach-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnEach-java.util.function.Consumer-[Mono])
*** 每个元素转化为: `materialize` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#materialize--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#materialize--[Mono])
**** ...在转化回元素: `dematerialize` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#dematerialize--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#dematerialize--[Mono])
** 转化为一行日志: `log` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#log--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#log--[Mono])

[[which.filtering]]
== 过滤序列

* 我想过滤一个序列:
** 基于给定的判断条件: `filter` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#filter-java.util.function.Predicate-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#filter-java.util.function.Predicate-[Mono])
*** ...异步地进行判断: `filterWhen` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#filterWhen-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#filterWhen-java.util.function.Function-[Mono])
** 仅限于指定类型的对象: `ofType` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ofType-java.lang.Class-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ofType-java.lang.Class-[Mono])
** 忽略所有元素: `ignoreElements` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ignoreElements--[Flux.ignoreElements()]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ignoreElement--[Mono.ignoreElement()])
** 去重:
*** 对于整个序列: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#distinct--[Flux#distinct]
*** 去掉连续重复的元素: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#distinctUntilChanged--[Flux#distinctUntilChanged]

* 我只想要一部分序列:
** 只要 N 个元素:
*** 从序列的第一个元素开始算: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-long-[Flux#take(long, true)]
**** ...取一段时间内发出的元素: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-long-boolean-[Flux#take(long, false)]
**** ...based on a duration: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-java.time.Duration-[Flux#take(Duration)]
**** ...只取第一个元素放到 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#next--[Flux#next()]
*** 从序列的最后一个元素倒数: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeLast-int-[Flux#takeLast]
*** 直到满足某个条件 (inclusive): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeUntil-java.util.function.Predicate-[Flux#takeUntil] (predicate-based), https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeUntilOther-org.reactivestreams.Publisher-[Flux#takeUntilOther] (companion publisher-based)
*** 直到满足某个条件 (exclusive): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeWhile-java.util.function.Predicate-[Flux#takeWhile]
** 最多只取 1 个元素:
*** 给定序号: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#elementAt-int-[Flux#elementAt]
*** 最后一个: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeLast-int-[.takeLast(1)]
**** ...如果为序列空则发出错误信号: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#last--[Flux#last()]
**** ...如果序列为空则返回默认值: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#last-T-[Flux#last(T)]
** 跳过一些元素:
*** 从序列的第一个元素开始跳过: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skip-long-[Flux#skip(long)]
**** ...跳过一段时间内发出的元素: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skip-java.time.Duration-[Flux#skip(Duration)]
*** 跳过最后的 n 个元素: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipLast-int-[Flux#skipLast]
*** 直到满足某个条件 (inclusive): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipUntil-java.util.function.Predicate-[Flux#skipUntil] (predicate-based), https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipUntilOther-org.reactivestreams.Publisher-[Flux#skipUntilOther] (companion publisher-based)
*** 直到满足某个条件 (exclusive): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipWhile-java.util.function.Predicate-[Flux#skipWhile]
** 采样:
*** 给定采样周期: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sample-java.time.Duration-[Flux#sample(Duration)]
**** 取采样周期里的第一个元素而不是最后一个: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sampleFirst-java.time.Duration-[sampleFirst]
*** by a publisher-based window: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sample-org.reactivestreams.Publisher-[Flux#sample(Publisher)]
*** based on a publisher "timing out": https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sampleTimeout-java.util.function.Function-[Flux#sampleTimeout] (每一个元素会触发一个 publisher, 如果这个 publisher 不被下一个元素触发的 publisher 覆盖就发出这个元素)

* 我只想要一个元素(如果多于一个就返回错误)...
** 如果序列为空,发出错误信号: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#single--[Flux#single()]
** 如果序列为空,发出一个默认值: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#single-T-[Flux#single(T)]
** 如果序列为空就返回一个空序列: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#singleOrEmpty--[Flux#singleOrEmpty]

[[which.errors]]
== 错误处理

* 我想创建一个错误序列: `error` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.lang.Throwable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.lang.Throwable-[Mono])...
** ...替换一个完成的 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux]: `.concat(Flux.error(e))`
** ...替换一个完成的 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono]: `.then(Mono.error(e))`
** ...如果元素超时未发出: `timeout` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timeout-java.time.Duration-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timeout-java.time.Duration-[Mono])
** ...lazily: `error(Supplier<Throwable>)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.util.function.Supplier-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.util.function.Supplier-[Mono])

* 我想要类似 try/catch 的表达方式:
** 抛出异常: `error` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.lang.Throwable-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.lang.Throwable-[Mono])
** 捕获异常:
*** 然后返回默认值: `onErrorReturn` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorReturn-java.lang.Class-T-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorReturn-java.lang.Class-T-[Mono])
*** 包装异常后 (ie. complete): `onErrorComplete` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorComplete-java.lang.Class-T-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorComplete-java.lang.Class-T-[Mono])
*** 然后返回一个 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux] 或 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono]: `onErrorResume` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorResume-java.lang.Class-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorResume-java.lang.Class-java.util.function.Function-[Mono])
*** 包装异常后再抛出: `.onErrorMap(t -> new RuntimeException(t))` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorMap-java.util.function.Function-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorMap-java.util.function.Function-[Mono])
** finally 代码块: `doFinally` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFinally-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFinally-java.util.function.Consumer-[Mono])
** Java 7 之后的 try-with-resources 写法: `using` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-[Mono]) factory method

* 我想从错误中恢复...
** 返回一个默认的:
*** 的值: `onErrorReturn` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorReturn-java.lang.Class-T-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorReturn-java.lang.Class-T-[Mono])
*** to a completion ("swallowing" the error): `onErrorComplete` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorComplete-java.lang.Class-T-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorComplete-java.lang.Class-T-[Mono])
*** to a https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true[Publisher] or https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono], possibly different ones depending on the error: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorResume-java.lang.Class-java.util.function.Function-[Flux#onErrorResume] and https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorResume-java.lang.Class-java.util.function.Function-[Mono#onErrorResume]
** 重试...
*** ...with a simple policy (max number of attempts): `retry()` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retry--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retry--[Mono]), `retry(long)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retry-long-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retry-long-[Mono])
*** ...由一个用于伴随 Flux 触发: `retryWhen` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retryWhen-reactor.util.retry.Retry-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retryWhen-reactor.util.retry.Retry-[Mono])
*** ...using a standard backoff strategy (exponential backoff with jitter): `retryWhen(Retry.backoff(...))` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retryWhen-reactor.util.retry.Retry-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retryWhen-reactor.util.retry.Retry-[Mono]) (see also other factory methods in https://projectreactor.io/docs/core/release/api/reactor/util/retry/Retry.html[Retry])

* 我想处理回压错误(向上游发出"MAX”的 request,如果下游的 request 比较少,则应用策略)...
** 抛出 https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalStateException.html?is-external=true[IllegalStateException]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureError--[Flux#onBackpressureError]
** 丢弃策略: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureDrop--[Flux#onBackpressureDrop]
*** ...但是不丢弃最后一个元素: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureLatest--[Flux#onBackpressureLatest]
** 缓存策略(有限或无限): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureBuffer--[Flux#onBackpressureBuffer]
*** ...当有限的缓存空间用满则应用给定策略: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureBuffer-int-reactor.core.publisher.BufferOverflowStrategy-[Flux#onBackpressureBuffer] 带有策略 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/BufferOverflowStrategy.html[BufferOverflowStrategy]

[[which.time]]
== 基于时间的操作

* I want to associate emissions with a timing measured...
** ...with best available precision and versatility of provided data: `timed` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timed--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timed--[Mono])
*** https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#elapsed--[Timed<T>#elapsed()] for https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true[Duration] since last `onNext`
*** https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#timestamp--[Timed<T>#timestamp()] for https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html?is-external=true[Instant] representation of the epoch timestamp (milliseconds resolution)
*** https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#elapsedSinceSubscription--[Timed<T>#elapsedSinceSubcription()] for https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true[Duration] since subscription (rather than last onNext)
*** can have nanoseconds resolution for elapsed https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true[Duration]s
** ...as a (legacy) https://projectreactor.io/docs/core/release/api/reactor/util/function/Tuple2.html[Tuple2<Long, T>]...
*** since last onNext: `elapsed` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#elapsed--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#elapsed--[Mono])
*** since the dawn of time (well, computer time): `timestamp` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timestamp--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timestamp--[Mono])


* I want my sequence to be interrupted if there is too much delay between emissions: `timeout` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timeout-java.time.Duration-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timeout-java.time.Duration-[Mono])

* I want to get ticks from a clock, regular time intervals: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#interval-java.time.Duration-[Flux#interval]

* I want to emit a single `0` after an initial delay: static https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delay-java.time.Duration-[Mono.delay].

* I want to introduce a delay:
** between each onNext signal: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delayElement-java.time.Duration-[Mono#delayElement], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#delayElements-java.time.Duration-[Flux#delayElements]
** before the subscription happens: `delaySubscription` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#delaySubscription-java.time.Duration-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delaySubscription-java.time.Duration-[Mono])

[[which.window]]
== 拆分 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux]

* 我想将一个 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux<T>] 拆分为一个 `Flux<Flux<T>>`:
** 以个数为界: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-int-[window(int)]
*** ...会出现重叠或丢弃的情况: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-int-int-[window(int, int)]
** 以时间为界: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-java.time.Duration-[window(Duration)]
*** ...会出现重叠或丢弃的情况: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-java.time.Duration-java.time.Duration-[window(Duration, Duration)]
** 以个数或时间为界: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowTimeout-int-java.time.Duration-[windowTimeout(int, Duration)]
** 基于对元素的判断条件: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowUntil-java.util.function.Predicate-[windowUntil]
*** ...…触发判断条件的元素会分到下一波 (`cutBefore` variant): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowUntil-java.util.function.Predicate-boolean-[.windowUntil(predicate, true)]
*** ...满足条件的元素在一波,直到不满足条件的元素发出开始下一波: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowWhile-java.util.function.Predicate-[windowWhile] (non-matching elements are not emitted)
** 通过另一个 Publisher 的每一个 onNext 信号来拆分序列: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-org.reactivestreams.Publisher-[window(Publisher)], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowWhen-org.reactivestreams.Publisher-java.util.function.Function-[windowWhen]

* 我想将一个 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux<T>] 的元素拆分到集合...
** 拆分为一个一个的 https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true[List]:
*** 以个数为界: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-[buffer(int)]
**** ...会出现重叠或丢弃的情况: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-int-[buffer(int, int)]
*** 以时间为界: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-java.time.Duration-java.time.Duration-[buffer(Duration)]
**** ...会出现重叠或丢弃的情况: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-java.time.Duration-java.time.Duration-[buffer(Duration, Duration)]
*** 以个数或时间为界: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferTimeout-int-java.time.Duration-[bufferTimeout(int, Duration)]
*** 基于对元素的判断条件: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferUntil-java.util.function.Predicate-[bufferUntil(Predicate)]
**** ...触发判断条件的元素会分到下一个 buffer: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferUntil-java.util.function.Predicate-boolean-[.bufferUntil(predicate, true)]
**** ...满足条件的元素在一个 buffer,直到不满足条件的元素发出开始下一 buffer: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferWhile-java.util.function.Predicate-[bufferWhile(Predicate)]
*** 通过另一个 Publisher 的每一个 onNext 信号来拆分序列: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-org.reactivestreams.Publisher-[buffer(Publisher)], https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferWhen-org.reactivestreams.Publisher-java.util.function.Function-[bufferWhen]
** into an arbitrary "collection" type `C`: use variants like https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-java.util.function.Supplier-[buffer(int, Supplier<C>)]

* 我想将 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux<T>] 中具有共同特征的元素分组到子 Flux: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#groupBy-java.util.function.Function-[groupBy(Function<T,K>)]
TIP: 注意返回值是 `Flux<GroupedFlux<K, T>>`, 每一个 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/GroupedFlux.html[GroupedFlux] 具有相同的 key 值 `K` ,可以通过  https://projectreactor.io/docs/core/release/api/reactor/core/publisher/GroupedFlux.html#key--[key()] 方法获取.

[[which.blocking]]
== 回到同步的世界

注意:所有这些方法除了 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#toFuture--[Mono#toFuture] 将抛出 https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html?is-external=true[UnsupportedOperatorException]，如果从标记为“非阻塞”(默认情况下 https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html#parallel--[parallel()] 和 https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html#single--[single()] )的 https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Scheduler.html[Scheduler] 内调用.

* 我有一个 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux<T>] ,我想:
** 在拿到第一个元素前阻塞: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockFirst--[Flux#blockFirst]
*** ...并给出超时时限: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockFirst-java.time.Duration-[Flux#blockFirst(Duration)]
** 在拿到最后一个元素前阻塞(如果序列为空则返回 null): https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockLast--[Flux#blockLast]
*** ...并给出超时时限: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockLast-java.time.Duration-[Flux#blockLast(Duration)]
** 同步地转换为 https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html?is-external=true[Iterable<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#toIterable--[Flux#toIterable]
** 同步地转换为 Java 8 https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html[Stream<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#toStream--[Flux#toStream]

* 我有一个 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html[Mono<T>] ,我想:
** 在拿到元素前阻塞: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#block--[Mono#block]
*** ...并给出超时时限: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#block-java.time.Duration-[Mono#block(Duration)]
** 转换为 https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html[CompletableFuture<T>]: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#toFuture--[Mono#toFuture]

[[which.multicasting]]
== 将 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux] 传播给多个 to several https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true[Subscribers]

* 我想将多个 https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true[Subscriber] 连接到一个 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html[Flux]:
** 并决定何时使用 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#connect--[connect()] 触发: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#publish--[publish()] (returns a https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html[ConnectableFlux])
** 立即触发 (之后的 subscribers 只能看到之后的数据): `share()` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#share--[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#share--[Mono])
** 注册足够的订阅者后建立永久连接: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#autoConnect-int-[.publish().autoConnect(n)]
** 当订阅者低于或高于一定的阀值后自动连接或取消: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#refCount-int-[.publish().refCount(n)]
*** ...但在取消之前让新订阅者有机会进来: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#refCount-int-java.time.Duration-[.publish().refCount(n, Duration)]

* 我想缓存来自 https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true[Publisher] 的数据并将其重播给以后的 subscribers:
** 最多 `n` 个元素: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-int-[cache(int)]
** 缓存在 https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true[Duration] (Time-To-Live)内看到的最新元素 : `cache(Duration)` (https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-java.time.Duration-[Flux]|link:https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#cache-java.time.Duration-[Mono])
*** ...但保留不超过 `n` 个元素: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-int-java.time.Duration-[cache(int, Duration)]
** 但没有立即触发源: https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#replay--[Flux#replay] (返回一个 https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html[ConnectableFlux])