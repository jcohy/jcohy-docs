[[servlet-authentication-jdbc]]
= JDBC Authentication

Spring Security 的 `JdbcDaoImpl` 实现了  <<servlet-authentication-userdetailsservice,UserDetailsService>> ,以提供对使用 JDBC 检索的基于用户名/密码的身份验证的支持.
 `JdbcUserDetailsManager` 扩展了 `JdbcDaoImpl` 以通过 `UserDetailsManager` 接口提供对 `UserDetails` 的管理.  当配置为  <<servlet-authentication-unpwd-input,接受 username/password>>进行身份验证时,Spring Security 使用基于 `UserDetails` 的身份验证.

在以下各节中,我们将讨论:

* Spring Security JDBC 身份验证使用的默认 <<servlet-authentication-jdbc-schema,架构>>
* <<servlet-authentication-jdbc-datasource,设置数据源>>
* <<servlet-authentication-jdbc-bean,JdbcUserDetailsManager Bean>>

[[servlet-authentication-jdbc-schema]]
== 默认架构

Spring Security 为基于 JDBC 的身份验证提供默认查询.  本节提供了与默认查询一起使用的相应默认架构.  您将需要调整架构,以将所有自定义项与查询和正在使用的数据库方言进行匹配.

[[servlet-authentication-jdbc-schema-user]]
=== User Schema

`JdbcDaoImpl` 需要使用表来加载用户的密码,帐户状态(启用或禁用) 和权限列表(角色) .

[NOTE]
====
默认架构也作为名为 `org/springframework/security/core/userdetails/jdbc/users.ddl` 的类路径资源暴露 .
====

.Default User Schema
====
[source,sql]
----
create table users(
	username varchar_ignorecase(50) not null primary key,
	password varchar_ignorecase(500) not null,
	enabled boolean not null
);

create table authorities (
	username varchar_ignorecase(50) not null,
	authority varchar_ignorecase(50) not null,
	constraint fk_authorities_users foreign key(username) references users(username)
);
create unique index ix_auth_username on authorities (username,authority);
----
====

Oracle 是一种流行的数据库选择,但是需要稍微不同的架构.

.Default User Schema for Oracle Databases
====
[source,sql]
----
CREATE TABLE USERS (
    USERNAME NVARCHAR2(128) PRIMARY KEY,
    PASSWORD NVARCHAR2(128) NOT NULL,
    ENABLED CHAR(1) CHECK (ENABLED IN ('Y','N') ) NOT NULL
);


CREATE TABLE AUTHORITIES (
    USERNAME NVARCHAR2(128) NOT NULL,
    AUTHORITY NVARCHAR2(128) NOT NULL
);
ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_UNIQUE UNIQUE (USERNAME, AUTHORITY);
ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_FK1 FOREIGN KEY (USERNAME) REFERENCES USERS (USERNAME) ENABLE;
----
====

[[servlet-authentication-jdbc-schema-group]]
=== Group Schema

如果您的应用程序利用组,则需要提供组架构.

.Default Group Schema
====
[source,sql]
----
create table groups (
	id bigint generated by default as identity(start with 0) primary key,
	group_name varchar_ignorecase(50) not null
);

create table group_authorities (
	group_id bigint not null,
	authority varchar(50) not null,
	constraint fk_group_authorities_group foreign key(group_id) references groups(id)
);

create table group_members (
	id bigint generated by default as identity(start with 0) primary key,
	username varchar(50) not null,
	group_id bigint not null,
	constraint fk_group_members_group foreign key(group_id) references groups(id)
);
----
====

[[servlet-authentication-jdbc-datasource]]
== 设置数据源

在配置 `JdbcUserDetailsManager` 之前,我们必须创建一个数据源.  在我们的示例中,我们将设置一个使用 <<servlet-authentication-jdbc-schema,默认用户架构>> 初始化的 https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html#jdbc-embedded-database-support[嵌入式 DataSource]  .

.Embedded Data Source
====
.Java
[source,java,role="primary"]
----
@Bean
DataSource dataSource() {
	return new EmbeddedDatabaseBuilder()
		.setType(H2)
		.addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION)
		.build();
}
----

.XML
[source,xml,role="secondary"]
----
<jdbc:embedded-database>
	<jdbc:script location="classpath:org/springframework/security/core/userdetails/jdbc/users.ddl"/>
</jdbc:embedded-database>
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun dataSource(): DataSource {
    return EmbeddedDatabaseBuilder()
        .setType(H2)
        .addScript(JdbcDaoImpl.DEFAULT_USER_SCHEMA_DDL_LOCATION)
        .build()
}
----
====

在生产环境中,您将要确保设置与外部数据库的连接.

[[servlet-authentication-jdbc-bean]]
== JdbcUserDetailsManager Bean

在此示例中,我们使用  <<authentication-password-storage-boot-cli,Spring Boot CLI>> 对 `password` 的密码进行编码,并获得  `+{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW+` 密码.  有关如何存储密码的更多详细信息,请参见 <<authentication-password-storage,PasswordEncoder>> 部分.

.JdbcUserDetailsManager
====

.Java
[source,java,role="primary",attrs="-attributes"]
----
@Bean
UserDetailsManager users(DataSource dataSource) {
	UserDetails user = User.builder()
		.username("user")
		.password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
		.roles("USER")
		.build();
	UserDetails admin = User.builder()
		.username("admin")
		.password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
		.roles("USER", "ADMIN")
		.build();
	JdbcUserDetailsManager users = new JdbcUserDetailsManager(dataSource);
	users.createUser(user);
	users.createUser(admin);
}
----

.XML
[source,xml,role="secondary",attrs="-attributes"]
----
<jdbc-user-service>
	<user name="user"
		password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
		authorities="ROLE_USER" />
	<user name="admin"
		password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
		authorities="ROLE_USER,ROLE_ADMIN" />
</jdbc-user-service>
----

.Kotlin
[source,kotlin,role="secondary",attrs="-attributes"]
----
@Bean
fun users(dataSource: DataSource): UserDetailsManager {
    val user = User.builder()
            .username("user")
            .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
            .roles("USER")
            .build();
    val admin = User.builder()
            .username("admin")
            .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
            .roles("USER", "ADMIN")
            .build();
    val users = JdbcUserDetailsManager(dataSource)
    users.createUser(user)
    users.createUser(admin)
    return users
}
----
====
