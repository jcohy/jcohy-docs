[[servlet-csrf]]
= Servlet 环境的跨站点请求伪造(CSRF)

本部分讨论了 Spring Security 对 Servlet 环境的<<csrf,跨站点请求伪造(CSRF) >>支持.

[[servlet-csrf-using]]
== 使用 Spring Security 保护 CSRF
下面描述了如何使用 Spring Security 防御 CSRF 的步骤:

* <<servlet-csrf-idempotent,使用正确的 HTTP 动词>>
* <<servlet-csrf-configure,配置防御 CSRF>>
* <<servlet-csrf-include,包括 CSRF 令牌>>

[[servlet-csrf-idempotent]]
=== 使用正确的HTTP动词
防御 CSRF 攻击的第一步是确保您的网站使用正确的 HTTP 动词.  <<csrf-protection-idempotent,安全方法必须是幂等的>>中对此进行了详细介绍.

[[servlet-csrf-configure]]
=== 配置防御 CSRF
下一步是在您的应用程序中配置 Spring Security 的防御 CSRF.  默认情况下,Spring Security 的对 CSRF 的防御处于启用状态,但是您可能需要自定义配置.  以下是一些常见的自定义项.

[[servlet-csrf-configure-custom-repository]]
==== 自定义 CsrfTokenRepository

默认情况下,Spring Security 使用 `HttpSessionCsrfTokenRepository` 将所需的 CSRF 令牌存储在 `HttpSession` 中.  在某些情况下,用户需要配置自定义 `CsrfTokenRepository`.  例如,可能需要将 `CsrfToken` 持久保存在 `cookie` 中以<<servlet-csrf-include-ajax-auto,支持 JavaScript 的应用程序>>.

默认情况下,`CookieCsrfTokenRepository` 将写入名为 `XSRF-TOKEN` 的 `cookie`,并从名为 `X-XSRF-TOKEN` 的请求头或 HTTP 参数 为 `_csrf` 中读取它.  这些默认值来自 https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection[AngularJS]

您可以使用以下命令以 XML 配置 `CookieCsrfTokenRepository`:

.使用 XML 配置将 CSRF 令牌存储在 Cookie 中
====
[source,xml]
----
<http>
	<!-- ... -->
	<csrf token-repository-ref="tokenRepository"/>
</http>
<b:bean id="tokenRepository"
	class="org.springframework.security.web.csrf.CookieCsrfTokenRepository"
	p:cookieHttpOnly="false"/>
----
====

[NOTE]
====
该示例显式设置 `cookieHttpOnly=false`.  这是允许 JavaScript(即 AngularJS) 可以从 cookie 中读取他需要的东西.  如果不需要直接使用 JavaScript 读取 cookie 的功能,建议省略 `cookieHttpOnly = false` 以提高安全性.
====


您可以使用以下命令在 Java 配置中配置 `CookieCsrfTokenRepository`:

.Store CSRF Token in a Cookie
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			.csrf(csrf -> csrf
				.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
			);
	}
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
       http {
            csrf {
                csrfTokenRepository = CookieCsrfTokenRepository.withHttpOnlyFalse()
            }
        }
    }
}
----
====

[NOTE]
====
该示例显式设置 `cookieHttpOnly=false`.  这是允许 JavaScript(即 AngularJS) 可以从 cookie 中读取他需要的东西.  如果不需要直接使用 JavaScript 读取 cookie 的功能,建议省略 `cookieHttpOnly = false` (通过使用新的 `CookieCsrfTokenRepository()` 代替) 以提高安全性.
====

[[servlet-csrf-configure-disable]]
==== 禁用 CSRF 防御
默认情况下,CSRF 保护处于启用状态. 但是,如果对<<csrf-when,您的应用程序有意义>>,则禁用 CSRF 防御很简单.

下面的XML配置将禁用 CSRF 保护.


.禁用CSRF XML配置
====
[source,xml]
----
<http>
	<!-- ... -->
	<csrf disabled="true"/>
</http>
----
====

下面的 Java 配置将禁用 CSRF 保护.

.Disable CSRF
====
.Java
[source,java,role="primary"]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			.csrf(csrf -> csrf.disable());
	}
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Configuration
@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
       http {
            csrf {
                disable()
            }
        }
    }
}
----
====

[[servlet-csrf-include]]
=== 包括CSRF令牌
为了使<<csrf-protection-stp,同步器令牌模式>>免受 CSRF 攻击,我们必须在 HTTP 请求中包括实际的 CSRF 令牌.  这必须包含在请求的一部分(即表单参数,HTTP header 等) 中,浏览器不会自动将其包含在 HTTP 请求中.

Spring Security 的 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/csrf/CsrfFilter.html[CsrfFilter]  暴露了一个 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/csrf/CsrfToken.html[CsrfToken] 作为名为 `_csrf` 的 `HttpServletRequest` 属性.  这意味着任何视图技术都可以访问 `CsrfToken` 以将期望的令牌暴露为<<servlet-csrf-include-form-attr,form>>或<<servlet-csrf-include-ajax-meta-attr,meta tag>>.
幸运的是,下面列出了一些集成,这些集成使<<servlet-csrf-include-form,form>> 中的令牌和<<servlet-csrf-include-ajax,ajax>> 请求的包含变得更加容易.

[[servlet-csrf-include-form]]
==== Form URL Encoded
为了 post HTML 表单,CSRF 令牌必须作为隐藏域包含在表单中. 例如,呈现的 HTML 可能如下所示:

.CSRF Token HTML
====
[source,html]
----
<input type="hidden"
	name="_csrf"
	value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
----
====

接下来,我们将讨论将 CSRF 令牌作为隐藏域包含在内的各种方式.

[[servlet-csrf-include-form-auto]]
===== 自动包含 CSRF 令牌

Spring Security 的 CSRF 支持通过其 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/servlet/support/csrf/CsrfRequestDataValueProcessor.html[CsrfRequestDataValueProcessor]与 Spring 的 https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/support/RequestDataValueProcessor.html[RequestDataValueProcessor] 集成.
这意味着,如果您利用 Spring 的 https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view-jsp-formtaglib[Spring’s form tag library],https://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#integration-with-requestdatavalueprocessor[Thymeleaf] 或与 `RequestDataValueProcessor` 集成的任何其他视图技术,则具有不安全的 HTTP 方法(即发布) 的表单将自动包含实际的 CSRF  令牌.


[[servlet-csrf-include-form-tag]]
===== csrfInput Tag

如果您使用的是 JSP,则可以使用 Spring 的 https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view-jsp-formtaglib[Spring’s form tag library]..  但是,如果这不是一个选择,则还可以轻松地将标记包含在 <<taglibs-csrfinput,csrfInput>> 标签中.

[[servlet-csrf-include-form-attr]]
===== CsrfToken 请求属性

如果在请求中包括实际 CSRF 令牌的 <<servlet-csrf-include,其他选项>>不起作用,则可以利用 `CsrfToken` 作为名为 `_csrf` 的 `HttpServletRequest` 属性<<servlet-csrf-include,暴露>>的事实.

下面显示了使用 JSP 进行此操作的示例:

.带有请求属性的表单中的 CSRF 令牌
====
[source,xml]
----
<c:url var="logoutUrl" value="/logout"/>
<form action="${logoutUrl}"
	method="post">
<input type="submit"
	value="Log out" />
<input type="hidden"
	name="${_csrf.parameterName}"
	value="${_csrf.token}"/>
</form>
----
====

[[servlet-csrf-include-ajax]]
==== Ajax 和 JSON 请求
如果使用的是 JSON,则无法在 HTTP 参数内提交 CSRF 令牌.  相反,您可以在 HTTP 头中提交令牌.

在以下各节中,我们将讨论在基于 JavaScript 的应用程序中将 CSRF 令牌作为 HTTP 请求头包括在内的各种方式.

[[servlet-csrf-include-ajax-auto]]
===== 自动包含

可以轻松<<servlet-csrf-configure-custom-repository,配置>> Spring Security 将期望的 CSRF 令牌存储在 cookie 中.  通过将期望的 CSRF 存储在 cookie 中,像 https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection[AngularJS]  这样的 JavaScript 框架将自动在 HTTP 请求头中包含实际的 CSRF 令牌.

[[servlet-csrf-include-ajax-meta]]
===== Meta tags

在<<servlet-csrf-include-form-auto,Cookie 中暴露 CSRF>> 的另一种方式是将 CSRF 令牌包含在您的元标记中.  HTML 可能看起来像这样:

.CSRF meta tag HTML
====
[source,html]
----
<html>
<head>
	<meta name="_csrf" content="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
	<meta name="_csrf_header" content="X-CSRF-TOKEN"/>
	<!-- ... -->
</head>
<!-- ... -->
----
====

一旦元标记包含 CSRF 令牌,JavaScript 代码就会读取元标记并将 CSRF 令牌作为 header 包含在内. 如果您使用的是 jQuery,则可以通过以下方式完成:

.AJAX send CSRF Token
====
[source,javascript]
----
$(function () {
	var token = $("meta[name='_csrf']").attr("content");
	var header = $("meta[name='_csrf_header']").attr("content");
	$(document).ajaxSend(function(e, xhr, options) {
		xhr.setRequestHeader(header, token);
	});
});
----
====

[[servlet-csrf-include-ajax-meta-tag]]
====== csrfMeta 标签

如果您使用的是 JSP,则将 CSRF 令牌写入 meta 标记的一种简单方法是利用  <<taglibs-csrfmeta,csrfMeta>> 标签.

[[servlet-csrf-include-ajax-meta-attr]]
====== CsrfToken 请求属性

如果在请求中包括实际 CSRF 令牌的 <<servlet-csrf-include,其他选项>>  不起作用,则可以利用 `CsrfToken` 作为名为 `_csrf` 的 `HttpServletRequest` 属性<<servlet-csrf-include,暴露>>的事实. 下面显示了使用 JSP 进行此操作的示例:

.CSRF meta tag JSP
====
[source,html]
----
<html>
<head>
	<meta name="_csrf" content="${_csrf.token}"/>
	<!-- default header name is X-CSRF-TOKEN -->
	<meta name="_csrf_header" content="${_csrf.headerName}"/>
	<!-- ... -->
</head>
<!-- ... -->
----
====

[[servlet-csrf-considerations]]
== CSRF 注意事项
实施针对 CSRF 攻击的防护时,需要考虑一些特殊注意事项.  本节讨论与 Servlet 环境有关的那些注意事项.  请参阅 <<csrf-considerations,CSRF 注意事项>> 一节,以进行更一般的讨论.

[[servlet-considerations-csrf-login]]
=== 登录

<<csrf-considerations-login,要求 CSRF 进行登录>> 请求很重要,以防止伪造登录尝试.  Spring Security 的 servlet 支持是开箱即用的.

[[servlet-considerations-csrf-logout]]
=== 注销

<<csrf-considerations-logout,要求 CSRF 进行注销>>请求很重要,以防止伪造注销尝试.  如果启用了 CSRF 保护(默认) ,Spring Security 的 `LogoutFilter` 仅处理 HTTP POST.  这样可以确保注销需要 CSRF 令牌,并且恶意用户不能强制注销用户.

最简单的方法是使用表单注销.  如果您确实需要链接,则可以使用 JavaScript 来使链接执行 POST(即可能以隐藏形式) .  对于禁用了JavaScript 的浏览器,您可以选择使该链接将用户带到将执行 POST 的注销确认页面.

如果您确实想在注销时使用 HTTP GET,则可以这样做,但是请记住,通常不建议这样做.  例如,以下 Java 配置将使用 URL `/logout` 通过任何 HTTP 方法请求注销:

.Log out with HTTP GET
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			.logout(logout -> logout
				.logoutRequestMatcher(new AntPathRequestMatcher("/logout"))
			);
	}
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
       http {
            logout {
                logoutRequestMatcher = AntPathRequestMatcher("/logout")
            }
        }
    }
}
----
====

[[servlet-considerations-csrf-timeouts]]
=== CSRF 和 Session 超时

默认情况下,Spring Security 将 CSRF 令牌存储在 `HttpSession` 中.  这可能会导致会话到期的情况,这意味着没有期望的 CSRF 令牌进行验证.

我们已经讨论了会话超时的<<csrf-considerations-login,一般解决方案>> .  本节讨论与 Servlet 支持有关的 CSRF 超时的细节.

更改期望的  CSRF 令牌在 cookie 中的存储很简单.  有关详细信息,请参阅  <<servlet-csrf-configure-custom-repository,自定义 CsrfTokenRepository>>部分.

如果令牌确实过期,则可能需要通过指定自定义 `AccessDeniedHandler` 来定制令牌的处理方式.  自定义 `AccessDeniedHandler` 可以按照您喜欢的任何方式处理 `InvalidCsrfTokenException`.  有关如何自定义 `AccessDeniedHandler` 的示例,请参阅所提供的<<nsa-access-denied-handler,xml>>和 https://github.com/spring-projects/spring-security/blob/3.2.0.RC1/config/src/test/java/org/springframework/security/config/annotation/web/configurers/NamespaceHttpAccessDeniedHandlerTests.java#L64[Java configuration] 链接.

[[servlet-csrf-considerations-multipart]]
=== Multipart (文件上传)
我们 <<csrf-considerations-multipart,已经讨论>> 了如何保护分段请求(文件上传) 免受 CSRF 攻击如何导致 https://en.wikipedia.org/wiki/Chicken_or_the_egg[鸡和蛋的问题] . 本节讨论如何实现将 CSRF 令牌放置在 Servlet 应用程序的 <<servlet-csrf-considerations-multipart-body,body>>和<<servlet-csrf-considerations-multipart-url,url>> 中.

[NOTE]
====
有关在 Spring 中使用多部分表单的更多信息,请参见 https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web.html#mvc-multipart[1.1.11. Multipart Resolver]和 https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html[MultipartFilter javadoc].
====

[[servlet-csrf-considerations-multipart-body]]
==== 将 CSRF 令牌放入 body

我们<<csrf-considerations-multipart-body,已经讨论>> 了将 CSRF 令牌放入正文的权衡. 在本节中,我们将讨论如何配置Spring Security 从主体读取 CSRF.

为了从主体读取 CSRF 令牌,在 Spring Security 过滤器之前指定 `MultipartFilter`.  在 Spring Security 过滤器之前指定 `MultipartFilter` 意味着没有授权可以调用 `MultipartFilter`,这意味着任何人都可以在您的服务器上放置临时文件.
但是,只有授权用户才能提交由您的应用程序处理的文件.  通常,这是推荐的方法,因为临时文件上传对大多数服务器的影响应该忽略不计.

// FIXME: Document Spring Boot

为了确保在使用 Java 配置的 Spring Security 过滤器之前指定了 `MultipartFilter`,用户可以如下所示覆盖 `beforeSpringSecurityFilterChain`:

.Initializer MultipartFilter
====
.Java
[source,java,role="primary"]
----
public class SecurityApplicationInitializer extends AbstractSecurityWebApplicationInitializer {

	@Override
	protected void beforeSpringSecurityFilterChain(ServletContext servletContext) {
		insertFilters(servletContext, new MultipartFilter());
	}
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
class SecurityApplicationInitializer : AbstractSecurityWebApplicationInitializer() {
    override fun beforeSpringSecurityFilterChain(servletContext: ServletContext?) {
        insertFilters(servletContext, MultipartFilter())
    }
}
----
====

为了确保在具有 XML 配置的 Spring Security 过滤器之前指定 `MultipartFilter`,用户可以确保将 `MultipartFilter` 的 `<filter-mapping>` 元素放在 `web.xml` 中的 `springSecurityFilterChain` 之前,如下所示:

.web.xml - MultipartFilter
====
[source,xml]
----
<filter>
	<filter-name>MultipartFilter</filter-name>
	<filter-class>org.springframework.web.multipart.support.MultipartFilter</filter-class>
</filter>
<filter>
	<filter-name>springSecurityFilterChain</filter-name>
	<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
	<filter-name>MultipartFilter</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>
<filter-mapping>
	<filter-name>springSecurityFilterChain</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>
----
====

[[servlet-csrf-considerations-multipart-url]]
==== 将 CSRF Token 放在 URL 中

如果不允许未经授权的用户上传临时文件,则可以选择将 `MultipartFilter` 放在 Spring Security 过滤器之后,并将 CSRF 作为查询参数包括在表单的 `action` 属性中.  由于 `CsrfToken` 是作为 `HttpServletRequest` <<servlet-csrf-include,请求属性>> 暴露的,因此我们可以使用它来创建带有 CSRF 令牌的操作.  带有 jsp 的示例如下所示

.CSRF Token in Action
====
[source,html]
----
<form method="post"
	action="./upload?${_csrf.parameterName}=${_csrf.token}"
	enctype="multipart/form-data">
----
====

[[servlet-csrf-considerations-override-method]]
=== HiddenHttpMethodFilter
我们 <<csrf-considerations-multipart-body,已经讨论>> 了将 CSRF 令牌放入正文中的取舍.

在 Spring 的 Servlet 支持中,使用 https://docs.spring.io/spring-framework/docs/5.2.x/javadoc-api/org/springframework/web/filter/reactive/HiddenHttpMethodFilter.html[HiddenHttpMethodFilter] 覆盖 HTTP 方法. 有关更多信息,请参见参考文档的 https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web.html#mvc-rest-method-conversion[HTTP Method Conversion]  部分.
