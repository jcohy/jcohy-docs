[[servlet-httpfirewall]]
= HttpFirewall
Spring Security 在多个区域中针对传入的请求对您定义的模式进行测试,以便确定应如何处理请求.  当 `FilterChainProxy` 决定请求应通过哪个过滤器链,以及 `FilterSecurityInterceptor` 决定将哪些安全性约束应用于请求时,会发生这种情况.
 根据定义的模式进行测试时,重要的是要了解该机制是什么以及使用了哪个 `URL` 值.

Servlet 规范为 `HttpServletRequest` 定义了一些属性,可以通过 `getter` 方法访问这些属性,我们可能希望将这些属性匹配. 这些是 `contextPath`,`servletPath`,`pathInfo` 和 `queryString`.  Spring Security 只对保护应用程序中的路径感兴趣,因此 `contextPath` 被忽略.
不幸的是,servlet 规范没有确切定义特定请求 `URI` 的 `ServletPath` 和 `pathInfo` 的值. 例如,URL 的每个路径段都可以包含 https://www.ietf.org/rfc/rfc2396.txt[RFC 2396] footnote:[当浏览器不支持cookie且将 `jsessionid` 参数附加到分号后的URL时,您可能已经看到了. 但是,RFC允许这些参数出现在URL的任何路径段中]  中定义的参数. 规范没有明确说明是否应将这些参数包含在 `servletPath` 和 `pathInfo` 值中,并且行为在不同的 servlet 容器之间有所不同.
存在以下危险: 当将应用程序部署在不从这些值中剥离路径参数的容器中时,攻击者可能会将其添加到请求的 URL 中,从而导致模式匹配意外成功或失败. footnote:[一旦请求离开 `FilterChainProxy`,原始值将被返回,因此对于应用程序仍然可用. ]. 传入 URL 中的其他变体也是可能的.
例如,它可能包含路径遍历序列(例如  `/../`) 或多个正斜杠(`//`) ,这也可能导致模式匹配失败. 一些容器在执行 servlet 映射之前将它们标准化,但其他容器则没有. 为了避免此类问题,`FilterChainProxy` 使用 `HttpFirewall` 策略检查并包装请求.
默认情况下,未规范化的请求将自动被拒绝,并且出于匹配目的,将删除路径参数和重复的斜杠.  footnote:[因此,例如,原始请求路径 `/secure;hack=1/somefile.html;hack=2` 将作为  `/secure/somefile.html` 返回.  ].
因此,必须使用 `FilterChainProxy` 来管理安全过滤器链. 请注意,`servletPath` 和 `pathInfo` 值由容器解码,因此您的应用程序不应具有任何包含分号的有效路径,因为将出于匹配目的而删除这些部分.

如上所述,默认策略是使用 Ant 样式的路径进行匹配,这对于大多数用户而言可能是最佳选择.  该策略在 `AntPathRequestMatcher` 类中实现,该类使用 Spring 的 `AntPathMatcher` 对连接的 `ServletPath` 和 `pathInfo` 进行模式的不区分大小写的匹配,而忽略了 `queryString`.

如果由于某种原因需要更强大的匹配策略,则可以使用正则表达式.  然后,该策略实现是 `RegexRequestMatcher`.  有关更多信息,请参见 Javadoc.

实际上,我们建议您在服务层使用方法安全性来控制对应用程序的访问,并且不要完全依赖于在 Web 应用程序级别定义的安全性约束的使用.  URL 会发生变化,很难考虑应用程序可能支持的所有可能的 URL 以及如何处理请求.
 您应该尝试限制自己使用一些简单易懂的简单蚂蚁路径.  始终尝试使用 "deny-by-default" 方法,在此方法中,您最后定义了一个全包通配符(/** 或 **) ,并拒绝访问.


在服务层定义的安全性更加健壮,更难绕开,因此您应始终利用 Spring Security 的方法安全性选项.

`HttpFirewall` 还通过拒绝HTTP响应头中的换行符来防止 https://www.owasp.org/index.php/HTTP_Response_Splitting[HTTP Response Splitting] .

默认情况下,使用 `StrictHttpFirewall`.  此实现拒绝看起来是恶意的请求.  如果对您的要求过于严格,则可以自定义拒绝哪些类型的请求.  但是,重要的是要知道这样做可以使您的应用程序容易受到攻击.  例如,如果您希望利用 Spring MVC 的矩阵变量,则可以使用以下配置:

.允许矩阵变量
====
.Java
[source,java,role="primary"]
----
@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    firewall.setAllowSemicolon(true);
    return firewall;
}
----

.XML
[source,xml,role="secondary"]
----
<b:bean id="httpFirewall"
    class="org.springframework.security.web.firewall.StrictHttpFirewall"
    p:allowSemicolon="true"/>

<http-firewall ref="httpFirewall"/>
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    firewall.setAllowSemicolon(true)
    return firewall
}
----
====

`StrictHttpFirewall` 提供允许的有效 HTTP 方法的列表,这些方法可防止 https://owasp.org/www-community/attacks/Cross_Site_Tracing[跨站点跟踪(XST) ] 和 https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/02-Configuration_and_Deployment_Management_Testing/06-Test_HTTP_Methods[HTTP 动词篡改].
默认的有效方法是  "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", 和 "PUT"..  如果您的应用程序需要修改有效方法,则可以配置自定义 `StrictHttpFirewall` bean.  例如,以下内容仅允许 HTTP "GET" 和 "POST" 方法:

.只允许 GET & POST
====
.Java
[source,java,role="primary"]
----
@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    firewall.setAllowedHttpMethods(Arrays.asList("GET", "POST"));
    return firewall;
}
----

.XML
[source,xml,role="secondary"]
----
<b:bean id="httpFirewall"
      class="org.springframework.security.web.firewall.StrictHttpFirewall"
      p:allowedHttpMethods="GET,HEAD"/>

<http-firewall ref="httpFirewall"/>
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    firewall.setAllowedHttpMethods(listOf("GET", "POST"))
    return firewall
}
----
====

[TIP]
====
如果您正在  `new MockHttpServletRequest()`,则当前会创建一个 HTTP 方法作为空字符串  "".  这是无效的 HTTP 方法,将被Spring Security 拒绝.  您可以通过将其替换为  `new MockHttpServletRequest("GET", "")` 来解决此问题.  有关要求改善此问题的问题,请参见 https://jira.spring.io/browse/SPR-16851[SPR_16851] .
====

如果必须允许任何 HTTP 方法(不推荐) ,则可以使用 `StrictHttpFirewall.setUnsafeAllowAnyHttpMethod(true)`.  这将完全禁用 HTTP 方法的验证.

[[servlet-httpfirewall-headers-parameters]]

`StrictHttpFirewall` 还检查 header 的 name 和 value. 它要求每个字符都有一个定义的代码点， 而不是控制字符.

如有需要， 可通过以下方法放宽或调整这一要求:

* `StrictHttpFirewall#setAllowedHeaderNames(Predicate)`
* `StrictHttpFirewall#setAllowedHeaderValues(Predicate)`
* `StrictHttpFirewall#setAllowedParameterNames(Predicate)`

NOTE: 另外， 可以使用 `setAllowedParameterValues(Predicate)` 控制参数值.

例如， 要关闭此检查， 可以将 `StrictHttpFirewall` 与始终返回 `true` 的 `Predicate` 关联起来:

.Allow Any Header Name, Header Value, and Parameter Name
====
.Java
[source,java,role="primary"]
----
@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    firewall.setAllowedHeaderNames((header) -> true);
    firewall.setAllowedHeaderValues((header) -> true);
    firewall.setAllowedParameterNames((parameter) -> true);
    return firewall;
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    firewall.setAllowedHeaderNames { true }
    firewall.setAllowedHeaderValues { true }
    firewall.setAllowedParameterNames { true }
    return firewall
}
----
====

或者， 可能存在允许的特定值.

例如， iPhone XR 使用包含不在 ISO-8859-1 Charset 中的字符的 `User-Agent`.  由于此事实， 某些应用程序服务器将此值解析为两个单独的字符， 后者是一个未定义的字符.

您可以使用 `setAllowedHeaderValues` 方法解决此问题， 如您所见:

.Allow Certain User Agents
====
.Java
[source,java,role="primary"]
----
@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    Pattern allowed = Pattern.compile("[\\p{IsAssigned}&&[^\\p{IsControl}]]*");
    Pattern userAgent = ...;
    firewall.setAllowedHeaderValues((header) -> allowed.matcher(header).matches() || userAgent.matcher(header).matches());
    return firewall;
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    val allowed = Pattern.compile("[\\p{IsAssigned}&&[^\\p{IsControl}]]*")
    val userAgent = Pattern.compile(...)
    firewall.setAllowedHeaderValues { allowed.matcher(it).matches() || userAgent.matcher(it).matches() }
    return firewall
}
----
====

对于 header 的 value， 您可以考虑在验证时将其解析为 UTF-8， 如下所示:

.Parse Headers As UTF-8
====
.Java
[source,java,role="primary"]
----
firewall.setAllowedHeaderValues((header) -> {
    String parsed = new String(header.getBytes(ISO_8859_1), UTF_8);
    return allowed.matcher(parsed).matches();
});
----

.Kotlin
[source,kotlin,role="secondary"]
----
firewall.setAllowedHeaderValues {
    val parsed = String(header.getBytes(ISO_8859_1), UTF_8)
    return allowed.matcher(parsed).matches()
}
----
====
