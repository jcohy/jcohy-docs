// FIXME: Add links to Servlet and WebFlux support

[[csrf]]
= 跨站请求伪造 (CSRF)

Spring 为防止 https://en.wikipedia.org/wiki/Cross-site_request_forgery[跨站请求伪造(CSRF) ]攻击提供了全面的支持.  在以下各节中,我们将探讨:

* <<csrf-explained,什么是 CSRF 攻击? >>
* <<csrf-protection,防御 CSRF 攻击>>
* <<csrf-considerations,CSRF 注意事项>>

// FIXME: Add WebFlux csrf documentation (the link below is broken)
[NOTE]
====
本文档的这一部分讨论 CSRF 保护的简单说明.
有关针对<<servlet-csrf,servlet>> 和基于<<webflux-csrf,WebFlux>> 的应用程序的 CSRF 保护的特定信息,请参阅相关部分.
====

[[csrf-explained]]
== 什么是 CSRF 攻击?
理解 CSRF 攻击的最佳方法是看一个具体示例.

假设您的银行网站提供了一种表单,该表单允许将资金从当前登录的用户转移到另一个银行帐户.
例如,转帐表单可能看起来像:

.转帐表单
====
[source,html]
----
<form method="post"
	action="/transfer">
<input type="text"
	name="amount"/>
<input type="text"
	name="routingNumber"/>
<input type="text"
	name="account"/>
<input type="submit"
	value="Transfer"/>
</form>
----
====

相应的 HTTP 请求可能如下所示:

.转账 HTTP 请求
====
[source]
----
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876
----
====

现在,假装您对银行的网站进行身份验证,然后没有注销,访问了一个恶意的网站.  恶意网站包含具有以下格式的 HTML 页面:

.恶意的转账表单
====
[source,html]
----
<form method="post"
	action="https://bank.example.com/transfer">
<input type="hidden"
	name="amount"
	value="100.00"/>
<input type="hidden"
	name="routingNumber"
	value="evilsRoutingNumber"/>
<input type="hidden"
	name="account"
	value="evilsAccountNumber"/>
<input type="submit"
	value="Win Money!"/>
</form>
----
====

您想赢钱,因此单击 "submit" 按钮.  在此过程中,您无意中将 $100 转让给了恶意用户.  发生这种情况的原因是,尽管恶意网站无法看到您的 cookie,但与您的银行关联的 cookie 仍与请求一起发送.

最糟糕的是,使用 JavaScript 可以使整个过程自动化.  这意味着您甚至不需要单击该按钮.  此外,在访问受 https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)[XSS攻击] 的可靠站点时,也很容易发生这种情况.  那么,我们如何保护用户免受此类攻击呢?

[[csrf-protection]]
== 防御 CSRF 攻击
CSRF 攻击之所以发生是因为从银行网站上的发出的 HTTP 请求,和从恶意的网站发出的请求完全一样的.
这就意味着没有办法拒绝来自恶意的网站的请求和允许来自银行的网站请求. 为了抵御 CSRF 攻击,我们需要确保请求中有一些信息是恶意网站是无法提供的.

Spring 提供了两种机制来防御 CSRF 攻击:

*  <<csrf-protection-stp,同步器令牌模式>>
* 在会话 Cookie 上指定<<SameSite 属性>>

[NOTE]
====
两种保护机制都要求<<csrf-protection-idempotent,安全方法必须是幂等的>>
====

[[csrf-protection-idempotent]]
=== 安全方法必须是幂等的

为了使针对 CSRF 的<<csrf-protection,任何一种>>方法起作用,应用程序必须确保 https://tools.ietf.org/html/rfc7231#section-4.2.1[ 安全的 HTTP方法是幂等的].
这意味着使用 HTTP 方法 `GET`,`HEAD`,`OPTIONS` 和 `TRACE` 进行的请求不应更改应用程序的状态.

[[csrf-protection-stp]]
=== Synchronizer token pattern(STP)同步器令牌模式

抵御 CSRF 攻击的最主要,最全面的方法是使用 https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern[同步器令牌模式].
该解决方案是为了确保每个 HTTP 请求除了我们的会话 cookie 外,还必须在 HTTP 请求中提供一个安全的,随机生成的值,称为 CSRF 令牌.

提交 HTTP 请求时,服务器必须查找预期的 CSRF 令牌,并将其与 HTTP 请求中的实际 CSRF 令牌进行比较.  如果值不匹配,则应拒绝 HTTP 请求.

这项工作的关键在于,实际的 CSRF 令牌应该位于浏览器不会自动包含的 HTTP 请求的一部分中. 例如,在 HTTP 参数或 HTTP 头中设置实际的 CSRF 令牌. 在 cookie 中设置实际 CSRF 令牌不起作用,因为浏览器会自动将 cookie 包含在 HTTP 请求中.

我们可以放宽一点,仅对每个更新应用程序状态的 HTTP 请求要求使用 CSRF 令牌. 为此,我们的应用程序必须确保<<csrf-protection-idempotent,HTTP 方法是幂等>>的. 因为我们希望允许使用外部站点的链接来链接到我们的网站,所以这提高了可用性.
此外,我们不想在 HTTP `GET` 中包含随机令牌,因为这可能导致令牌泄漏.

让我们看一下使用同步器令牌 时<<csrf-explained,示例>>将如何变化. 假设实际的 CSRF 令牌必须位于名为的 HTTP 参数中 `_csrf`. 我们应用程序的传输形式如下:

.同步器令牌表单
====
[source,html]
----
<form method="post"
	action="/transfer">
<input type="hidden"
	name="_csrf"
	value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
<input type="text"
	name="amount"/>
<input type="text"
	name="routingNumber"/>
<input type="hidden"
	name="account"/>
<input type="submit"
	value="Transfer"/>
</form>
----
====

表单现在包含带有 CSRF 令牌值的隐藏域. 外部站点无法读取 CSRF 令牌,因为浏览器的同源策略可确保恶意站点无法读取.

相应的 HTTP 汇款请求如下所示:

.同步器令牌 请求
====
[source]
----
POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&routingNumber=1234&account=9876&_csrf=4bfd1575-3ad1-4d21-96c7-4ef2d9f86721
----
====

您会注意到,HTTP 请求现在包含 `_csrf` 带有安全随机值的参数. 恶意网站无法为 `_csrf` 参数提供正确的值,当服务器将实际的令牌与预期的令牌进行比较时,如果不匹配,传输将失败.

[[csrf-protection-ssa]]
=== SameSite 属性
防止<<csrf,CSRF 攻击>> 的一种新兴方法是在 cookie 上指定 https://tools.ietf.org/html/draft-west-first-party-cookies[SameSite 属性]. 服务器可以 `SameSite` 在设置 cookie 时指定属性,以指示从外部站点发出时不应发送该 cookie.

[NOTE]
====
Spring Security 不直接控制会话 cookie 的创建,因此不提供对 SameSite 属性的支持.  https://spring.io/projects/spring-session[Spring Session]支持 `SameSite` 基于 servlet 的应用程序中的属性. Spring Framework 的 https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/server/session/CookieWebSessionIdResolver.html[CookieWebSessionIdResolver] 为 `SameSite` 基于 `WebFlux` 的应用程序中的属性提供了开箱即用的支持.
====

一个带有 `SameSite` 属性的 HTTP 响应头可能类似于以下:

.SameSite HTTP 响应
====
[source]
----
Set-Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly; SameSite=Lax
----
====

该 `SameSite` 属性的有效值为:

* `Strict` - 指定后,来自 https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-2.1[同一站点]的任何请求都将包含cookie. 否则,cookie将不会包含在HTTP请求中.
* `Lax` - 当来自 https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-2.1[同一站点]或请求来自顶级导航且<<csrf-protection-idempotent,方法为幂等>>时,将发送指定的 cookie . 否则,cookie 将不会包含在 HTTP 请求中.

让我们看一下如何使用属性保护 <<csrf-explained,示例>> `SameSite`. 银行应用程序可以通过 `SameSite` 在会话 cookie 上指定属性来防止 CSRF .

随着 `SameSite` 我们的会话 cookie 属性集,浏览器将继续发送 `JSESSIONID` 从银行网站来请求的 cookie. 但是,浏览器将不再发送 `JSESSIONID` 带有来自邪恶网站的传输请求的 cookie. 由于会话不再存在于来自邪恶网站的传输请求中,因此可以保护应用程序免受 CSRF 攻击.

使用 `SameSite` 属性防御 CSRF 攻击时,应注意一些重要的 https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-5[注意事项].

将 `SameSite` 属性设置为 `Strict` 可以提供更强的防御能力,但会使用户困惑. 考虑一个保持登录到  https://social.example.com. 托管的社交媒体网站的用户. 用户在 https://email.example.org 上收到一封电子邮件,其中包含指向社交媒体网站的链接.
如果用户单击该链接,则他们理所当然地希望能够通过社交媒体站点进行身份验证. 但是,如果 `SameSite` 属性为 `Strict` cookie,则不会发送 cookie,因此不会对用户进行身份验证.

[NOTE]
====
通过实施 https://github.com/spring-projects/spring-security/issues/7537[gh-7537],我们可以提高 `SameSite` 保护针对CSRF攻击的保护性和可用性.
====

另一个明显的考虑因素是,为了使 `SameSite` 属性能够保护用户,浏览器必须 https://developer.mozilla.org/en-US/docs/Web/HTTP/headers/Set-Cookie#Browser_compatibility[支持 `SameSite` ]属性.  大多数现代浏览器都支持 `SameSite` 属性.  但是,旧的浏览器可能不支持.

因此,通常建议将 `SameSite` 属性用作深度防御,而不是针对 CSRF 攻击的唯一防护.

[[csrf-when]]
== 何时使用CSRF保护
什么时候应该使用 CSRF 保护?
什么时候应该使用 CSRF 保护? 我们的建议是对普通用户可能由浏览器处理的任何请求使用 CSRF 保护.  如果仅创建非浏览器客户端使用的服务,则可能需要禁用 CSRF 保护.

[[csrf-when-json]]
=== CSRF保护和JSON
一个常见的问题是 "我需要保护由 javascript 发出的 JSON 请求吗? " 简短的答案是,视情况而定.  但是,你必须非常小心,因为有 CSRF 攻击可以影响 JSON 请求. 例如,一个恶意用户可以使用以下格式,创建一个 http://blog.opensecurityresearch.com/2012/02/json-csrf-with-parameter-padding.html[CSRF和JSON使用以下form]:
====
[source,html]
----
<form action="https://bank.example.com/transfer" method="post" enctype="text/plain">
	<input name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'>
	<input type="submit"
		value="Win Money!"/>
</form>
----
====


这将产生以下 JSON 结构

.CSRF JSON 请求
====
[source,javascript]
----
{ "amount": 100,
"routingNumber": "evilsRoutingNumber",
"account": "evilsAccountNumber",
"ignore_me": "=test"
}
----
====

如果一个应用程序没有验证内容类型,那么它会接触到这种攻击. 根据设置,验证内容类型的 Spring MVC 应用程序仍然可以利用更新 URL 后缀结尾 `".json"` 如下所示:

.CSRF 与 JSON Spring MVC表单
====
[source,html]
----
<form action="https://bank.example.com/transfer.json" method="post" enctype="text/plain">
	<input name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'>
	<input type="submit"
		value="Win Money!"/>
</form>
----
====

[[csrf-when-stateless]]
=== CSRF和无状态的浏览器应用程序

如果我的应用程序是无状态的呢?这并不意味着你是受保护的. 事实上,如果用户对于一个给定的请求不需要在 web 浏览器中执行任何操作,他们可能仍然容易受到 CSRF 攻击.

例如,考虑一个应用程序使用一个定制的 cookie,其中包含所有的声明进行身份验证,而不是 JSESSIONID. 当 CSRF 是由自定义 cookie 与在该 JSESSIONID cookie 在前面的例子中相同的方式发送的,请求被发送.

使用基本身份验证的用户也容易受到 CSRF 攻击,因为浏览器会自动包括以同样的方式,在我们前面的例子中该 JSESSIONID 的 cookie 会发送任何请求的用户名密码.

[[csrf-considerations]]
== CSRF注意事项
实施针对CSRF攻击的防护时需要考虑一些特殊注意事项.

// FIXME: Document rotating the CSRF token at log in to avoid a fixation attack

[[csrf-considerations-login]]
=== 登录

为了防止 https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests[forging登录请求] 应保护 HTTP 请求中的登录免受 CSRF 攻击.  必须防止伪造登录请求,以使恶意用户无法读取受害者的敏感信息.
攻击通常通过以下方式执行:

* 恶意用户使用恶意用户的凭据执行 CSRF 登录.  现在,将受害者验证为恶意用户.
* 然后,恶意用户诱骗受害者访问受感染的网站并输入敏感信息
* 该信息与恶意用户的帐户相关联,因此恶意用户可以使用自己的凭据登录并查看受害者的敏感信息

确保保护HTTP请求不受CSRF攻击的可能的麻烦在于,用户可能会遇到会话超时,从而导致请求被拒绝.  会话超时对于不需要登录才需要会话的用户来说是令人惊讶的. 有关更多信息,请参阅<<csrf-considerations-timeouts,CSRF和会话超时>>部分.

[[csrf-considerations-logout]]
=== 注销

为了防止伪造注销请求,应该保护注销HTTP请求免受CSRF攻击.  必须防止伪造注销请求,以便恶意用户无法读取受害者的敏感信息.  有关攻击的详细信息,请参阅此 https://labs.detectify.com/2017/03/15/loginlogout-csrf-time-to-reconsider/[博客文章].

确保保护 HTTP 请求不受 CSRF 攻击的可能的麻烦在于,用户可能会遇到会话超时,从而导致请求被拒绝.  会话超时对于不需要登录才需要会话的用户来说是令人惊讶的. 有关更多信息,请参阅<<csrf-considerations-timeouts,CSRF 和会话超时>>部分.

[[csrf-considerations-timeouts]]
=== CSRF和会话超时
通常,预期的 CSRF 令牌存储在会话中.  这意味着会话超时后,服务器将不会找到预期的 CSRF 令牌并拒绝 HTTP 请求.  有很多选项可以解决超时问题,每个选项都需要权衡取舍.

* 解决超时的最佳方法是使用 JavaScript 在表单提交时请求 CSRF 令牌.  然后使用 CSRF 令牌更新表单并提交.
* 另一个选择是使用一些 JavaScript,让用户知道他们的会话即将到期.  用户可以单击按钮继续并刷新会话.
* 最后,预期的 CSRF 令牌可以存储在 cookie 中.  这样可以使预期的 CSRF 令牌寿命更长.
+
有人可能会问为什么默认情况下预期的CSRF令牌没有存储在 Cookie 中.  这是因为存在已知的漏洞,可以通过另一个 domain 来设置请求头(即指定 cookie) .
这与 https://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails/[当请求头 `X-Requested-With` 存在时,不再跳过CSRF检查]原因相同.
请参阅此 https://web.archive.org/web/20210221120355/https://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html[ webappsec.org thread]以获取有关如何执行漏洞利用的详细信息.  另一个缺点是,通过删除状态(即超时) ,您将失去在令牌遭到破坏时强制终止令牌的能力.

// FIXME: Document timeout with lengthy form expire. We do not want to automatically replay that request because it can lead to exploit

[[csrf-considerations-multipart]]
=== Multipart (file upload)

保护分段请求(文件上传) 免受 CSRF 攻击会导致 https://en.wikipedia.org/wiki/Chicken_or_the_egg[鸡和蛋] 的问题.  为了防止发生 CSRF 攻击,必须读取 HTTP 请求的正文以获得实际的CSRF令牌.  但是,读取正文表示文件将被上传,这意味着外部站点可以上传文件.

有两个选项来使用 CSRF 保护 multipart/form-data.每个选项都有其权衡.

* <<csrf-considerations-multipart-body,将 CSRF 令牌放入 body 中>>
* <<csrf-considerations-multipart-url,将 CSRF 令牌放入 URL>>

[NOTE]
====
在将 Spring Security 的 CSRF 保护与分段文件上传集成之前,确保没有 CSRF 保护你可以第一时间上传.
有关在Spring中使用multipart表单的更多信息,请参见  https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web.html#mvc-multipart[1.1.11. Multipart Resolver] .  Spring 参考的Multipart Resolver部分和 https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html[MultipartFilter javadoc].
====

[[csrf-considerations-multipart-body]]
==== 将CSRF令牌放入body 中
第一种选择是在请求正文中包含实际的 CSRF 令牌.  通过将 CSRF 令牌放入正文中,将在执行授权之前读取正文.  这意味着任何人都可以在您的服务器上放置临时文件.  但是,只有授权用户才能提交由您的应用程序处理的文件.  通常,这是推荐的方法,因为临时文件上传对大多数服务器的影响可以忽略不计.

[[csrf-considerations-multipart-url]]
==== 将CSRF令牌放入URL
如果不允许未经授权的用户上传临时文件,则可以选择将预期的 CSRF 令牌作为查询参数包括在表单的 `action` 属性中.  这种方法的缺点是查询参数可能会泄漏.  更一般而言,将敏感数据放置在 body 或 header 中以确保其不会泄漏是最佳实践.  可以在 https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3[RFC 2616第15.1.3节在URI中编码敏感信息]中找到其他信息.

[[csrf-considerations-override-method]]
==== HiddenHttpMethodFilter
在某些应用程序中,可以使用 form 参数来覆盖HTTP方法.  例如,下面的表格可用于将 HTTP 方法视为 `delete` 而不是 `post`.

.CSRF form 隐藏的 HTTP 方法
====
[source,html]
----
<form action="/process"
	method="post">
	<!-- ... -->
	<input type="hidden"
		name="_method"
		value="delete"/>
</form>
----
====


该 `HiddenHttpMethodFilter` 应放在 Spring Security 的过滤器之前. 一般来说这是事实,但它可能能够对防止 CSRF 攻击有更多的影响.
请注意,`HiddenHttpMethodFilter` 只覆盖一个 `POST` HTTP 方法,所以这实际上是不可能造成任何实际问题. 但是,它仍然是最好的做法,以确保它被放置在 Spring Security 过滤器之前.
