[[headers]]
= 安全HTTP响应头

[NOTE]
====
文档的此部分讨论安全 HTTP 响应头的一般主题.  有关安全HTTP响应头 <<servlet-headers,servlet>> 和基于 <<webflux-headers,WebFlux>> 的应用程序的特定信息,请参阅相关部分.
====

有许多 https://owasp.org/www-project-secure-headers/#div-headers[HTTP 响应头]  可用于提高 Web 应用程序的安全性.
本节专门介绍 Spring Security 提供显式支持的各种 HTTP 响应头.  如有必要,还可以使用 Spring Security 配置 <<headers-custom,自定义响应头>>.

[[headers-default]]
== 默认安全响应头

[NOTE]
====
请参阅相关部分,以了解如何为基于 <<servlet-headers-default,servlet>> 和基于 <<webflux-headers-default,webflux>> 的应用程序定制默认值.
====

Spring Security 提供了一组默认的与安全性相关的 HTTP 响应头,以提供安全的默认值.

.默认安全的 HTTP 响应头
====
[source,http]
----
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 0
----
====

[NOTE]
====
仅在 HTTPS 请求上添加严格传输安全性
====

如果默认设置不能满足您的需求,则可以轻松地从这些默认设置中删除,修改或添加 headers .  有关这些 header 中的每个 header 的更多详细信息,请参阅相应的部分:

* <<headers-cache-control,缓存控制>>
* <<headers-content-type-options,Content Type 选项>>
* <<headers-hsts,HTTP 严格传输安全>>
* <<headers-frame-options,X-Frame-Options>>
* <<headers-xss-protection,X-XSS-Protection>>

[[headers-cache-control]]
== 缓存控制

[NOTE]
====
请参阅相关部分,以了解如何为基于 <<servlet-headers-cache-control,servlet>> 和基于 <<webflux-headers-cache-control,webflux>> 的应用程序定制默认值.
====

Spring Security 的默认设置是禁用缓存以保护用户的内容.

如果用户进行了身份验证以查看敏感信息然后注销,则我们不希望恶意用户能够单击 "后退" 按钮查看敏感信息.  默认情况下发送的缓存控制 header 是:

.默认缓存控制 HTTP 响应头
====
[source]
----
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
----
====

为了默认安全,Spring Security 默认添加这些头.  但是,如果您的应用程序提供了它自己的缓存控制 header ,Spring Security 将会退出.  这允许应用程序确保可以缓存 CSS 和 JavaScript 之类的静态资源.


[[headers-content-type-options]]
== Content Type 选项

[NOTE]
====
请参阅相关部分,以了解如何为基于 <<servlet-headers-content-type-options,servlet>> 和基于 <<webflux-headers-content-type-options,webflux>> 的应用程序定制默认值.
====

历史上,包括 Internet Explorer 在内的浏览器都会尝试使用内容 https://en.wikipedia.org/wiki/Content_sniffing[嗅探] 来猜测请求的内容类型.  这允许浏览器通过猜测未指定内容类型的资源上的内容类型来改善用户体验.  例如,如果浏览器遇到一个未指定内容类型的 JavaScript 文件,它将能够猜测该内容类型然后执行.

[NOTE]
====
允许上传内容时,还有许多其他事情 (即,仅在不同的域中显示文档,确保设置了 Content-Type 头,清理文档等) .  但是,这些措施不在Spring Security 提供的范围之内.  指出禁用内容嗅探时也很重要,您必须指定内容类型才能使内容正常工作.
====

内容嗅探的问题在于,这允许恶意用户使用多义词 (即,可以作为多种内容类型有效的文件) 执行 XSS 攻击.  例如,某些网站可能允许用户向网站提交有效的附言文档并进行查看.  恶意用户可能会创建一个也是 http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf[有效 JavaScript 文件的 Postscript 文档],并对其执行 XSS 攻击.

可以通过在响应中添加以下 header 来禁用内容嗅探:

.nosniff HTTP 响应头
====
[source,http]
----
X-Content-Type-Options: nosniff
----
====

[[headers-hsts]]
== HTTP Strict Transport Security (HSTS)

[NOTE]
====
请参阅相关部分,以了解如何为基于 <<servlet-headers-hsts,servlet>> 和基于 <<webflux-headers-hsts,webflux>> 的应用程序定制默认值.
====

当您输入您的银行的网站,您进入 `mybank.example.com` 或进入 `https://mybank.example.com` 如果您忽略了 `https` 协议,您可能会受到 https://en.wikipedia.org/wiki/Man-in-the-middle_attack[中间人攻击].
即使网站执行重定向到 `https://mybank.example.com`, 恶意用户也可以截获初始 HTTP 请求并操纵响应(即重定向到  `https://mibank.example.com`  并窃取他们的凭证).

许多用户忽略了 `https` 协议,这就是创建HTTP https://tools.ietf.org/html/rfc6797[严格传输安全性 (HSTS) ]的原因.  将  `mybank.example.com` 添加为 https://tools.ietf.org/html/rfc6797#section-5.1[HSTS主机] 后,
浏览器可以提前知道对  `mybank.example.com` 的任何请求都应解释为 `https://mybank.example.com`.  这大大降低了发生中间人攻击的可能性.

[NOTE]
====
根据 https://tools.ietf.org/html/rfc6797#section-7.2[RFC6797],HSTS 头仅注入到 HTTPS 响应中.  为了使浏览器能够确认 header ,浏览器必须首先信任对用于建立连接的 SSL 证书 (不仅仅是 SSL 证书) 进行签名的 CA.
====

将站点标记为 HSTS 主机的一种方法是将主机预加载到浏览器中.  另一方法是将 `Strict-Transport-Security`  header 添加到响应中.  例如,以下内容将指示浏览器将域视为一年的HSTS主机 (一年大约 31536000 秒) :

.Strict Transport Security HTTP Response Header
====
[source]
----
Strict-Transport-Security: max-age=31536000 ; includeSubDomains ; preload
----
====


可选的 `includeSubDomains` 指令指示 Spring Security 子域 (即secure.mybank.example.com) 也应被视为 HSTS 域.

可选的 `preload` 指令指示 Spring Security 该域应在浏览器中预加载为HSTS域.  有关 HSTS 预加载的更多详细信息,请参见 https://hstspreload.org.

[[headers-hpkp]]
== HTTP Public Key Pinning (HPKP)

[NOTE]
====
为了保持被动,Spring Security 仍在 <<servlet-headers-hpkp,servlet 环境中提供对 HPKP 的支持>>,但是由于上述原因,  Spring Security 团队不再推荐 HPKP.
====

https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning[HTTP Public Key Pinning (HPKP)]  向 Web 客户端指定要与某些 Web 服务器一起使用的公共密钥,以防止使用伪造证书的中间人 (MITM) 攻击.
如果使用得当,HPKP 可以添加更多的保护层,以防止受到破坏的证书.  但是,由于 HPKP 的复杂性,许多专家不再建议使用它, https://www.chromestatus.com/feature/5903385005916160[Chrome甚至取消了对它的支持].

[[headers-hpkp-deprecated]]
有关为何不再推荐使用 HPKP 的更多详细信息,请阅读  https://blog.qualys.com/ssllabs/2016/09/06/is-http-public-key-pinning-dead[Is HTTP Public Key Pinning Dead?] 和 https://scotthelme.co.uk/im-giving-up-on-hpkp/[I'm giving up on HPKP].

[[headers-frame-options]]
== X-Frame-Options

[NOTE]
====
请参阅相关部分,以了解如何为基于 <<servlet-headers-frame-options,servlet>> 和基于 <<webflux-headers-frame-options,webflux>> 的应用程序定制默认值.
====

允许将您的网站添加到框架可能是一个安全问题.  例如,使用聪明的CSS样式用户可能会被诱骗点击他们不想要的内容. 例如,登录到其银行的用户可以单击将按钮授予其他用户访问权限.  这种攻击称为 https://en.wikipedia.org/wiki/Clickjacking[Clickjacking].

[NOTE]
====
处理点击劫持的另一种现代方法是使用<<headers-csp, "内容安全策略 (CSP) " >>.
====

有许多方法可以缓解点击劫持攻击.  例如,要保护旧版浏览器免遭点击劫持攻击,可以使用分帧代码.  虽然不完美,但是对于传统浏览器而言, https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet#Best-for-now_Legacy_Browser_Frame_Breaking_Script[frame breaking code] 是最好的选择.

解决点击劫持的更现代方法是使用 https://developer.mozilla.org/en-US/docs/HTTP/X-Frame-Options[X-Frame-Options]  头:

====
[source]
----
X-Frame-Options: DENY
----
====

[[headers-xss-protection]]
== X-XSS-Protection

[NOTE]
====
请参阅相关部分,以了解如何为基于 <<servlet-headers-xss-protection,servlet>> 和基于 <<webflux-headers-xss-protection,webflux>> 的应用程序定制默认值.
====

一些浏览器内置了对过滤掉 https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_(OWASP-DV-001)[reflected XSS attacks] 的支持.
但该过滤已在主要浏览器中弃用，https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Headers_Cheat_Sheet.html#x-xss-protection[当前 OWASP 建议] 是明确将标头设置为 0。

默认情况下，Spring Security 使用以下头来阻止内容：.

====
[source]
----
X-XSS-Protection: 0
----
====


[[headers-csp]]
== Content Security Policy (CSP)

[NOTE]
====
请参阅相关部分,以了解如何为基于 <<servlet-headers-csp,servlet>> 和基于 <<webflux-headers-csp,webflux>> 的应用程序定制默认值.
====

https://www.w3.org/TR/CSP2/[Content Security Policy (CSP)] 是 Web 应用程序可以利用的一种机制,可以缓解诸如跨站点脚本 (XSS) 之类的内容注入漏洞.
CSP 是一种声明性策略,为 Web 应用程序作者提供了一种工具,可以声明该 Web 应用程序希望从中加载资源的来源,并最终将这些信息通知客户端 (用户代理) .

[NOTE]
====
内容安全策略并非旨在解决所有内容注入漏洞.  取而代之的是,可以利用 CSP 帮助减少内容注入攻击所造成的危害.  作为第一道防线,Web 应用程序作者应验证其输入并对其输出进行编码.
====

Web 应用程序可以通过在响应中包括以下 HTTP header 之一来使用 CSP:

* `Content-Security-Policy`
* `Content-Security-Policy-Report-Only`

这些 header 中的每一个都用作将安全策略传递给客户端的机制.  安全策略包含一组安全策略指令,每个指令负责声明对特定资源表示形式的限制.

例如,Web应用程序可以通过在响应中包括以下 header 来声明它希望从特定的受信任源中加载脚本:

.Content Security Policy Example
====
[source]
----
Content-Security-Policy: script-src https://trustedscripts.example.com
----
====

用户代理会阻止尝试从另一个源 (而不是 _script-src_ 指令中声明的内容) 加载脚本.  此外,如果在安全策略中声明了  https://www.w3.org/TR/CSP2/#directive-report-uri[*_report-uri_*]  指令,则用户代理会将违反行为报告给声明的URL.

例如,如果 Web 应用程序违反了已声明的安全策略,则以下响应头将指示用户代理将违规报告发送到策略的  _report-uri_  指令中指定的 URL.

.Content Security Policy with report-uri
====
[source]
----
Content-Security-Policy: script-src https://trustedscripts.example.com; report-uri /csp-report-endpoint/
----
====

https://www.w3.org/TR/CSP2/#violation-reports[Violation reports] 是标准的 JSON 结构,可以由 Web 应用程序自己的 API 或公共托管的 CSP 违规报告服务 (例如 https://report-uri.io/[REPORT-URI]) 捕获.

Content-Security-Policy-Report-Only  header 为 Web 应用程序作者和管理员提供了监视安全策略而不是强制执行这些策略的功能.  该标题通常在试验或开发站点的安全策略时使用.  当某个策略被认为有效时,可以通过使用  _Content-Security-Policy_   header 字段来强制实施.

给定以下响应头,该策略声明可以从两个可能的来源之一加载脚本.

.Content Security Policy Report Only
====
[source]
----
Content-Security-Policy-Report-Only: script-src 'self' https://trustedscripts.example.com; report-uri /csp-report-endpoint/
----
====

如果站点违反了此策略,则通过尝试从 `evil.example.com` 加载脚本,用户代理会将违规报告发送到 `report-uri` 指令指定的声明 URL, 但仍然允许违规资源加载.

将内容安全策略应用于 Web 应用程序通常是一项艰巨的任务.  以下资源可能会为您的网站制定有效的安全策略提供进一步的帮助.

https://www.html5rocks.com/en/tutorials/security/content-security-policy/[An Introduction to Content Security Policy]

https://developer.mozilla.org/en-US/docs/Web/Security/CSP[CSP Guide - Mozilla Developer Network]

https://www.w3.org/TR/CSP2/[W3C Candidate Recommendation]

[[headers-referrer]]
== Referrer Policy

[NOTE]
====
请参阅相关部分,以了解如何为基于 <<servlet-headers-referrer,servlet>> 和基于 <<webflux-headers-referrer,webflux>> 的应用程序定制默认值.
====

https://www.w3.org/TR/referrer-policy[Referrer Policy] 是一种机制,Web 应用程序可以利用该机制来管理引荐来源网址字段,该字段包含用户所在的最后一页.
Spring Security 的方法是使用 https://www.w3.org/TR/referrer-policy/[Referrer Policy] 头,该 header 提供了不同的 https://www.w3.org/TR/referrer-policy/#referrer-policies[策略]:

.Referrer Policy Example
====
[source]
----
Referrer-Policy: same-origin
----
====

Referrer-Policy 响应头指示浏览器让目的地知道用户先前所在的源.

[[headers-feature]]
== Feature Policy

[NOTE]
====
请参阅相关部分,以了解如何为基于 <<servlet-headers-feature,servlet>> 和基于 <<webflux-headers-feature,webflux>> 的应用程序定制默认值.
====

https://wicg.github.io/feature-policy/[Feature Policy] 是一种机制,允许 Web 开发人员在浏览器中选择性地启用,禁用和修改某些 API 和 Web 功能的行为.

.Feature Policy Example
====
[source]
----
Feature-Policy: geolocation 'self'
----
====

借助 Feature Policy,开发人员可以为浏览器选择一套 "`policies`",以实施整个站点中使用的特定功能.  这些政策限制了网站可以访问或修改某些功能的浏览器默认行为的 API.

[[headers-permissions]]
== Permissions Policy（权限策略）

[NOTE]
====
请参阅相关部分以了解如何配置基于<<servlet-headers-permissions,servlet>> 和 <<webflux-headers-permissions,servlet>> 的应用程序 .
====

https://w3c.github.io/webappsec-permissions-policy/[Permissions Policy] 是一种允许 Web 开发人员有选择地启用、禁用和修改浏览器中某些 API 和 Web 功能的行为的机制。

.Permissions Policy Example
====
[source]
----
Permissions-Policy: geolocation=(self)
----
====

使用权限策略，开发人员可以选择加入一组  "policies"，以便浏览器强制执行整个站点中使用的特定功能。
这些政策限制了站点可以访问的 API 或修改浏览器对某些功能的默认行为。

[[headers-clear-site-data]]
== 清除站点数据

[NOTE]
====
请参阅相关部分,以了解如何为基于 <<servlet-headers-clear-site-data,servlet>> 和基于 <<webflux-headers-clear-site-data,webflux>> 的应用程序定制默认值.
====

https://www.w3.org/TR/clear-site-data/[Clear Site Data] 清除站点数据是一种机制,通过该机制,当 HTTP 响应包含以下 header 时,可以删除所有浏览器端数据 (Cookie,本地存储等) :

====
[source]
----
Clear-Site-Data: "cache", "cookies", "storage", "executionContexts"
----
====

这是注销时执行的不错的清理操作.


[[headers-custom]]
== 自定义 Headers

[NOTE]
====
请参阅相关部分,以了解如何配置两个基于 <<servlet-headers-custom,servlet>> 的应用程序.
====

Spring Security 具有使您可以方便地将更常见的安全 header 添加到您的应用程序的机制.  但是,它也提供了挂钩来启用添加自定义 header .
