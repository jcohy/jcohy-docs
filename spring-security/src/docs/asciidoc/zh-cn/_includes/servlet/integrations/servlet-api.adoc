[[servletapi]]
== Servlet API 整合
本节描述了如何将Spring Security与Servlet API集成在一起.   https://github.com/spring-projects/spring-security/tree/master/samples/xml/servletapi[servletapi-xml] 示例应用程序演示了每种方法的用法.

[[servletapi-25]]
=== Servlet 2.5+ 整合


[[servletapi-remote-user]]
==== HttpServletRequest.getRemoteUser()
https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()[HttpServletRequest.getRemoteUser()] 将返回 `SecurityContextHolder.getContext().getAuthentication().getName()`  的结果,该结果通常是当前用户名.  如果要在应用程序中显示当前用户名,这将很有用.
此外,检查此属性是否为null可以用来指示用户已通过身份验证还是匿名.  知道用户是否通过身份验证对于确定是否应显示某些UI元素很有用(即,仅在用户通过身份验证时才显示注销链接) .

[[servletapi-user-principal]]
==== HttpServletRequest.getUserPrincipal()
https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()[HttpServletRequest.getUserPrincipal()] 将返回 `SecurityContextHolder.getContext().getAuthentication()` 的结果.  这意味着它是一种身份验证,当使用基于用户名和密码的身份验证时,通常是 `UsernamePasswordAuthenticationToken` 的实例.
如果您需要有关用户的其他信息,这将很有用.  例如,您可能创建了一个自定义 `UserDetailsService`,该服务返回一个包含用户名和姓氏的自定义 `UserDetails`.  您可以通过以下方式获取此信息:

[source,java]
----
Authentication auth = httpServletRequest.getUserPrincipal();
// assume integrated custom UserDetails called MyCustomUserDetails
// by default, typically instance of UserDetails
MyCustomUserDetails userDetails = (MyCustomUserDetails) auth.getPrincipal();
String firstName = userDetails.getFirstName();
String lastName = userDetails.getLastName();
----

[NOTE]
====
应当指出,在整个应用程序中执行如此多的逻辑通常是一种不好的做法. 相反,应该将其集中化以减少Spring Security和Servlet API的耦合.
====

[[servletapi-user-in-role]]
==== HttpServletRequest.isUserInRole(String)
https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)[HttpServletRequest.isUserInRole(String)] 将确定 `SecurityContextHolder.getContext().getAuthentication().getAuthorities()` 是否包含 `GrantedAuthority`,并将角色传递给 `isUserInRole(String)`.
通常,用户不应将 "ROLE_" 前缀传递给此方法,因为它是自动添加的.  例如,如果要确定当前用户是否具有权限 "ROLE_ADMIN",则可以使用以下命令:

[source,java]
----
boolean isAdmin = httpServletRequest.isUserInRole("ADMIN");
----

这对于确定是否应显示某些UI组件可能很有用. 例如,仅当当前用户是管理员时,才可以显示管理员链接.

[[servletapi-3]]
=== Servlet 3+ 整合
下面描述了Spring Security与Servlet 3集成的方法.


[[servletapi-authenticate]]
==== HttpServletRequest.authenticate(HttpServletRequest,HttpServletResponse)
https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#authenticate%28javax.servlet.http.HttpServletResponse%29[HttpServletRequest.authenticate(HttpServletRequest,HttpServletResponse)] 方法可用于确保对用户进行身份验证.  如果未通过身份验证,则将使用配置的AuthenticationEntryPoint来请求用户进行身份验证(即重定向到登录页面) .

[[servletapi-login]]
==== HttpServletRequest.login(String,String)
https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login%28java.lang.String,%20java.lang.String%29[HttpServletRequest.login(String,String)]  方法可用于使用当前 `AuthenticationManager` 对用户进行身份验证.  例如,以下尝试使用用户名 "user" 和密码 "password" 进行身份验证:

[source,java]
----
try {
httpServletRequest.login("user","password");
} catch(ServletException e) {
// fail to authenticate
}
----

[NOTE]
====
如果您希望Spring Security处理失败的身份验证尝试,则不必捕获ServletException.
====

[[servletapi-logout]]
==== HttpServletRequest.logout()
https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout%28%29[HttpServletRequest.logout()] 方法可用于注销当前用户.

通常,这意味着将清除 `SecurityContextHolder`,使 `HttpSession` 无效,将清除所有 "记住我" 身份验证,依此类推. 但是,配置的 `LogoutHandler` 实现取决于您的Spring Security配置.  重要的是要注意,在调用 `HttpServletRequest.logout()` 之后,您仍然负责写出响应.  通常,这将涉及重定向到欢迎页面.

[[servletapi-start-runnable]]
==== AsyncContext.start(Runnable)
确保您的凭据将被传播到新线程的 https://docs.oracle.com/javaee/6/api/javax/servlet/AsyncContext.html#start%28java.lang.Runnable%29[AsyncContext.start(Runnable)]方法.  通过使用Spring Security的并发支持,Spring Security重写AsyncContext.start(Runnable) 以确保在处理Runnable时使用当前的SecurityContext.  例如,以下代码将输出当前用户的身份验证:

[source,java]
----
final AsyncContext async = httpServletRequest.startAsync();
async.start(new Runnable() {
	public void run() {
		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
		try {
			final HttpServletResponse asyncResponse = (HttpServletResponse) async.getResponse();
			asyncResponse.setStatus(HttpServletResponse.SC_OK);
			asyncResponse.getWriter().write(String.valueOf(authentication));
			async.complete();
		} catch(Exception e) {
			throw new RuntimeException(e);
		}
	}
});
----

[[servletapi-async]]
==== 异步Servlet支持
如果您使用的是基于Java的配置,则可以开始使用. 如果使用XML配置,则需要进行一些更新. 第一步是确保已更新web.xml,使其至少使用3.0模式,如下所示:

[source,xml]
----
<web-app xmlns="http://java.sun.com/xml/ns/javaee"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
version="3.0">

</web-app>
----

接下来,您需要确保已设置springSecurityFilterChain来处理异步请求.

[source,xml]
----
<filter>
<filter-name>springSecurityFilterChain</filter-name>
<filter-class>
	org.springframework.web.filter.DelegatingFilterProxy
</filter-class>
<async-supported>true</async-supported>
</filter>
<filter-mapping>
<filter-name>springSecurityFilterChain</filter-name>
<url-pattern>/*</url-pattern>
<dispatcher>REQUEST</dispatcher>
<dispatcher>ASYNC</dispatcher>
</filter-mapping>
----

而已！ 现在,Spring Security将确保您的SecurityContext也可以在异步请求中传播.

那么它是怎样工作的? 如果您真的不感兴趣,请随时跳过本节的其余部分,否则请继续阅读.  大部分内容都内置在Servlet规范中,但是Spring Security做了一些调整,以确保异步请求可以正常工作.
在Spring Security 3.2之前,一旦提交HttpServletResponse,就会自动保存SecurityContextHolder中的SecurityContext.  这可能会在异步环境中引起问题.  例如,考虑以下内容:

[source,java]
----
httpServletRequest.startAsync();
new Thread("AsyncThread") {
	@Override
	public void run() {
		try {
			// Do work
			TimeUnit.SECONDS.sleep(1);

			// Write to and commit the httpServletResponse
			httpServletResponse.getOutputStream().flush();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}.start();
----

问题是 Spring Security 不知道该线程,因此不会将 SecurityContext 传播给它.  这意味着当我们提交 HttpServletResponse 时,没有 SecurityContext.  当 Spring Security 在提交 HttpServletResponse 时自动保存 SecurityContext 时,它将丢失我们的登录用户.

从 3.2 版本开始,Spring Security 足够聪明,不再会在调用 `HttpServletRequest.startAsync() `时自动保存 SecurityContext 来提交 HttpServletResponse.

[[servletapi-31]]
=== Servlet 3.1+ 整合
下面描述了与 Spring Security 和 Servlet 3.1 集成的方法.

[[servletapi-change-session-id]]
==== HttpServletRequest#changeSessionId()
https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html#changeSessionId()[HttpServletRequest.changeSessionId()] 是防止 Servlet 3.1 及更高版本中的 <<ns-session-fixation,Session Fixation>> 攻击的默认方法.