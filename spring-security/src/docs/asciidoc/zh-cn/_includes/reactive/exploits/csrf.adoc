[[webflux-csrf]]
= WebFlux 环境的跨站点请求伪造 (CSRF)

本节讨论 Spring Security 对 WebFlux 环境的<<csrf,Cross Site Request Forgery (CSRF)>> 支持.

[[webflux-csrf-using]]
== 使用 Spring Security CSRF 保护
下面概述了使用 Spring Security 的 CSRF 保护的步骤:

* <<webflux-csrf-idempotent,使用正确的 HTTP 动词>>
* <<webflux-csrf-configure,配置 CSRF 保护>>
* <<webflux-csrf-include,包括 CSRF 令牌>>

[[webflux-csrf-idempotent]]
=== 使用正确的 HTTP 动词
防御 CSRF 攻击的第一步是确保您的网站使用正确的 HTTP 动词. <<csrf-protection-idempotent,安全方法必须是幂等>>的中对此进行了详细介绍.

[[webflux-csrf-configure]]
=== 配置 CSRF 保护
下一步是在您的应用程序中配置 Spring Security 的 CSRF 保护. 默认情况下,Spring Security 的 CSRF 保护处于启用状态,但是您可能需要自定义配置. 以下是一些常见的自定义项.

[[webflux-csrf-configure-custom-repository]]
==== 自定义 CsrfTokenRepository

默认情况下,Spring Security 使用 `WebSessionServerCsrfTokenRepository` 将所需的CSRF令牌存储在 `WebSession` 中.  在某些情况下,用户将需要配置自定义 `ServerCsrfTokenRepository`.  例如,可能需要将 `CsrfToken` 持久保存在 cookie 中以支持<<webflux-csrf-include-ajax-auto,基于JavaScript 的应用程序>>.

默认情况下,`CookieServerCsrfTokenRepository` 将写入名为 `XSRF-TOKEN` 的cookie,并从名为 `X-XSRF-TOKEN` 头或HTTP参数 `_csrf` 中读取它.  这些默认值来自 https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection[AngularJS]

您可以使用以下命令在 Java 配置中配置 `CookieServerCsrfTokenRepository`:

.Store CSRF Token in a Cookie
====
.Java
[source,java,role="primary"]
-----
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.csrf(csrf -> csrf.csrfTokenRepository(CookieServerCsrfTokenRepository.withHttpOnlyFalse()))
	return http.build();
}
-----

.Kotlin
[source,kotlin,role="secondary"]
-----
@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        csrf {
            csrfTokenRepository = CookieServerCsrfTokenRepository.withHttpOnlyFalse()
        }
    }
}
-----
====

[NOTE]
====
该示例显式设置 `cookieHttpOnly=false`.  这是允许 JavaScript (即 AngularJS) 读取它所必需的.  如果您不需要直接使用 JavaScript 读取 Cookie 的功能,建议省略 `cookieHttpOnly = false`  (通过使用 `new CookieServerCsrfTokenRepository()` 代替) 以提高安全性.
====

[[webflux-csrf-configure-disable]]
==== 禁用 CSRF 保护
默认情况下,CSRF 保护处于启用状态. 但是, <<csrf-when,如果对您的应用程序有意义>>,则禁用 CSRF 保护很简单.  下面的 Java 配置将禁用 CSRF 保护.

.Disable CSRF Configuration
====
.Java
[source,java,role="primary"]
----
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.csrf(csrf -> csrf.disable()))
	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
-----
@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        csrf {
            disable()
        }
    }
}
-----
====

[[webflux-csrf-include]]
=== 包括 CSRF 令牌

为了使<<csrf-protection-stp,同步器令牌模式>>免受 CSRF 攻击,我们必须在 HTTP 请求中包括实际的 CSRF 令牌.  这必须包含在请求的一部分 (即表单参数,HTTP 头等) 中,浏览器不会自动将其包含在 HTTP 请求中.

Spring Security 的 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/server/csrf/CsrfWebFilter.html[CsrfWebFilter]暴露了 `Mono<CsrfToken>` 作为 `ServerWebExchange` 属性,
名为 `org.springframework.security.web.server.csrf.CsrfToken`.  这意味着任何视图技术都可以访问 `Mono<CsrfToken>` 以将期望的令牌暴露为<<webflux-csrf-include-form-attr,form>>或<<webflux-csrf-include-ajax-meta,meta tag>>.

[[webflux-csrf-include-subscribe]]
如果您的视图技术无法提供简单的方法来订阅 `Mono<CsrfToken>`,则常见的模式是使用 Spring 的 `@ControllerAdvice` 直接暴露 `CsrfToken`.  例如,以下代码会将 CsrfToken 放置在 Spring Security 的<<webflux-csrf-include-form-auto,CsrfRequestDataValueProcessor>> 用来自动包含 CSRF 令牌作为隐藏输入的默认属性名称 (`_csrf`) 上.

.`CsrfToken` as `@ModelAttribute`
====
.Java
[source,java,role="primary"]
----
@ControllerAdvice
public class SecurityControllerAdvice {
	@ModelAttribute
	Mono<CsrfToken> csrfToken(ServerWebExchange exchange) {
		Mono<CsrfToken> csrfToken = exchange.getAttribute(CsrfToken.class.getName());
		return csrfToken.doOnSuccess(token -> exchange.getAttributes()
				.put(CsrfRequestDataValueProcessor.DEFAULT_CSRF_ATTR_NAME, token));
	}
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@ControllerAdvice
class SecurityControllerAdvice {
    @ModelAttribute
    fun csrfToken(exchange: ServerWebExchange): Mono<CsrfToken> {
        val csrfToken: Mono<CsrfToken>? = exchange.getAttribute(CsrfToken::class.java.name)
        return csrfToken!!.doOnSuccess { token ->
            exchange.attributes[CsrfRequestDataValueProcessor.DEFAULT_CSRF_ATTR_NAME] = token
        }
    }
}
----
====

幸运的是,Thymeleaf 提供了无需任何额外工作即可运行的 <<webflux-csrf-include-form-auto,集成>> .

[[webflux-csrf-include-form]]
==== Form URL Encoded
为了post HTML 表单,CSRF 令牌必须作为隐藏域包含在表单中. 例如,呈现的 HTML 可能如下所示:

.CSRF Token HTML
====
[source,html]
----
<input type="hidden"
	name="_csrf"
	value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
----
====

接下来,我们将讨论将 CSRF 令牌作为隐藏输入包含在内的各种方式.

[[webflux-csrf-include-form-auto]]
===== 自动包含 CSRF 令牌

Spring Security 的 CSRF 支持通过其 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/reactive/result/view/CsrfRequestDataValueProcessor.html[CsrfRequestDataValueProcessor]与 Spring 的 https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/reactive/result/view/RequestDataValueProcessor.html[RequestDataValueProcessor]集成.
为了使 `CsrfRequestDataValueProcessor` 正常工作,必须预订 `Mono<CsrfToken>`,并且必须将 `CsrfToken` 作为与 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/reactive/result/view/CsrfRequestDataValueProcessor.html#DEFAULT_CSRF_ATTR_NAME[DEFAULT_CSRF_ATTR_NAME] 匹配的<<webflux-csrf-include-subscribe,属性暴露>>.

幸运的是,Thymeleaf 通过与 `RequestDataValueProcessor` 集成为您提供照顾所有 https://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#integration-with-requestdatavalueprocessor[样板的支持] ,以确保具有不安全 HTTP 方法 (即发布) 的表单将自动包含实际的 CSRF 令牌.

[[webflux-csrf-include-form-attr]]
===== CsrfToken 请求属性

如果在请求中包括实际 CSRF 令牌的 <<webflux-csrf-include,其他选项>>不起作用,则可以利用 `Mono<CsrfToken>` 作为名为 `org.springframework.security.web.server.csrf.CsrfToken` 的 `ServerWebExchange` <<webflux-csrf-include,属性暴露>>的事实.  .

下面的 Thymeleaf 示例假定您在名为 `_csrf` 的属性上<<webflux-csrf-include-subscribe,暴露>> `CsrfToken`.


.CSRF Token in Form with Request Attribute
====
[source,html]
----
<form th:action="@{/logout}"
	method="post">
<input type="submit"
	value="Log out" />
<input type="hidden"
	th:name="${_csrf.parameterName}"
	th:value="${_csrf.token}"/>
</form>
----
====

[[webflux-csrf-include-ajax]]
==== Ajax 和JSON 请求
如果使用的是 JSON,则无法在 HTTP 参数内提交 CSRF 令牌.  相反,您可以在 HTTP 头中提交令牌.

在以下各节中,我们将讨论在基于 JavaScript 的应用程序中将 CSRF 令牌作为 HTTP 请求头包括在内的各种方式.

[[webflux-csrf-include-ajax-auto]]
===== 自动包含

可以轻松<<webflux-csrf-configure-custom-repository,configured>> Spring Security 将期望的 CSRF 令牌存储在 cookie 中. 通过将期望的 CSRF 存储在 cookie 中,像 https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection[AngularJS]这样的 JavaScript 框架将自动在 HTTP 请求头中包含实际的 CSRF 令牌.


[[webflux-csrf-include-ajax-meta]]
===== 元标签

在<<webflux-csrf-include-form-auto,Cookie 中暴露>>CSRF 的另一种方式是将CSRF令牌包含在您的 `meta` 标签.  HTML 可能看起来像这样:

.CSRF meta tag HTML
====
[source,html]
----
<html>
<head>
	<meta name="_csrf" content="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
	<meta name="_csrf_header" content="X-CSRF-TOKEN"/>
	<!-- ... -->
</head>
<!-- ... -->
----
====

一旦元标记包含 CSRF 令牌,JavaScript 代码就会读取元标记并将 CSRF 令牌作为请求头包含在内. 如果您使用的是 jQuery,则可以通过以下方式完成:

.AJAX send CSRF Token
====
[source,javascript]
----
$(function () {
	var token = $("meta[name='_csrf']").attr("content");
	var header = $("meta[name='_csrf_header']").attr("content");
	$(document).ajaxSend(function(e, xhr, options) {
		xhr.setRequestHeader(header, token);
	});
});
----
====

下面的示例假定您在名为 `_csrf` 的属性上<<webflux-csrf-include-subscribe,暴露>> `CsrfToken`. 下面显示了使用 Thymeleaf 进行此操作的示例:

.CSRF meta tag JSP
====
[source,html]
----
<html>
<head>
	<meta name="_csrf" th:content="${_csrf.token}"/>
	<!-- default header name is X-CSRF-TOKEN -->
	<meta name="_csrf_header" th:content="${_csrf.headerName}"/>
	<!-- ... -->
</head>
<!-- ... -->
----
====

[[webflux-csrf-considerations]]
== CSRF 注意事项
实施针对 CSRF 攻击的防护时,需要考虑一些特殊注意事项.  本节讨论与 WebFlux 环境有关的注意事项.  请参阅<<csrf-considerations,CSRF 注意事项>>一节,以进行更一般的讨论.

[[webflux-considerations-csrf-login]]
=== 登录
<<csrf-considerations-login,要求 CSRF 进行登录请求>>很重要,以防止伪造登录尝试.  Spring Security 的 WebFlux 支持是开箱即用的.

[[webflux-considerations-csrf-logout]]
=== 注销

<<csrf-considerations-logout,要求 CSRF 进行注销请求>> 很重要,以防止伪造注销尝试.  默认情况下,Spring Security 的 `LogoutWebFilter` 仅处理 HTTP 发布请求.  这样可以确保注销需要 CSRF 令牌,并且恶意用户不能强制注销用户.

最简单的方法是使用表单注销.  如果您确实需要链接,则可以使用 JavaScript 来使链接执行 POST (即可能以隐藏形式) .  对于禁用了 JavaScript 的浏览器,您可以选择使该链接将用户带到将执行 POST 的注销确认页面.

如果您确实想在注销时使用 HTTP GET,则可以这样做,但是请记住,通常不建议这样做.  例如,以下 Java 配置将使用 URL 执行 `/logout` 通过任何 HTTP 方法请求注销:

// FIXME: This should be a link to log out documentation

.Log out with HTTP GET
====
.Java
[source,java,role="primary"]
----
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.logout(logout -> logout.requiresLogout(new PathPatternParserServerWebExchangeMatcher("/logout")))
	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        logout {
            requiresLogout = PathPatternParserServerWebExchangeMatcher("/logout")
        }
    }
}
----
====


[[webflux-considerations-csrf-timeouts]]
=== CSRF 和会话超时

默认情况下,Spring Security 将 CSRF 令牌存储在 `WebSession` 中.  这可能会导致会话到期的情况,这意味着没有期望的 CSRF 令牌进行验证.

我们已经讨论了会话超时的<<csrf-considerations-login,一般解决方案>>.  本节讨论与 WebFlux 支持有关的 CSRF 超时的详细信息.

更改期望的 CSRF 令牌在 cookie 中的存储很简单.  有关详细信息,请参阅 <<webflux-csrf-configure-custom-repository,自定义 `CsrfTokenRepository`>> 部分.

// FIXME: We should add a custom AccessDeniedHandler section in the reference and update the links above

// FIXME: We need a WebFlux multipart body vs action story. WebFlux always has multipart enabled.
[[webflux-csrf-considerations-multipart]]
=== Multipart (文件上传)
我们<<csrf-considerations-multipart,已经讨论>> 了如何保护分段请求 (文件上传) 免受 CSRF 攻击如何导致 https://en.wikipedia.org/wiki/Chicken_or_the_egg[鸡和蛋的问题]. 本节讨论如何实现将 CSRF 令牌放置在 WebFlux 应用程序的<<webflux-csrf-considerations-multipart-body,body>> 和<<webflux-csrf-considerations-multipart-url,url>> 中.

[NOTE]
====
有关在 Spring 上使用多部分表单的更多信息,请参见 Spring 参考的 https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web-reactive.html#webflux-multipart[Multipart Data] 部分.
====

[[webflux-csrf-considerations-multipart-body]]
==== 将 CSRF 令牌放入body 中
我们<<csrf-considerations-multipart,已经讨论>>了将 CSRF 令牌放入正文中的取舍.
在 WebFlux 应用程序中,可以使用以下配置进行配置:

.Enable obtaining CSRF token from multipart/form-data
====
.Java
[source,java,role="primary"]
----
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.csrf(csrf -> csrf.tokenFromMultipartDataEnabled(true))
	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
		// ...
        csrf {
            tokenFromMultipartDataEnabled = true
        }
    }
}
----
====

[[webflux-csrf-considerations-multipart-url]]
==== 将CSRF令牌放入URL

我们 <<csrf-considerations-multipart,已经讨论>>了在 URL 中放置 CSRF 令牌的权衡.  由于 CsrfToken 是作为 `ServerHttpRequest`  <<webflux-csrf-include,请求属性>>暴露的,因此我们可以使用它来创建带有 CSRF 令牌的 `action`.  Thymeleaf 的示例如下所示:

.CSRF Token in Action
====
[source,html]
----
<form method="post"
	th:action="@{/upload(${_csrf.parameterName}=${_csrf.token})}"
	enctype="multipart/form-data">
----
====

[[webflux-csrf-considerations-override-method]]
=== HiddenHttpMethodFilter
我们 <<csrf-considerations-override-method,已经讨论>> 了重写HTTP方法.

在 Spring WebFlux 应用程序中,使用 https://docs.spring.io/spring-framework/docs/5.2.x/javadoc-api/org/springframework/web/filter/reactive/HiddenHttpMethodFilter.html[HiddenHttpMethodFilter] 重写 HTTP 方法.
