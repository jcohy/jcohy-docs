[[webflux-headers]]
= 安全HTTP响应头
<<headers,Security HTTP Response Headers>>可用于提高 Web 应用程序的安全性.  本节专门针对基于 WebFlux 的安全 HTTP 响应提供支持.

[[webflux-headers-default]]
== 默认安全头

Spring Security 提供了一组默认的  <<headers-default,default set of Security HTTP Response Headers>>  ,以提供安全的默认值.  虽然这些头中的每一个均被视为最佳实践,但应注意,并非所有客户端都使用这些头,因此鼓励进行额外的测试.

您可以自定义特定的标题.  例如,假设您希望使用默认值,但您希望为 <<servlet-headers-frame-options,X-Frame-Options>> 指定 `SAMEORIGIN`.

您可以使用以下配置轻松完成此操作:

.Customize Default Security Headers
====
.Java
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.frameOptions(frameOptions -> frameOptions
				.mode(Mode.SAMEORIGIN)
			)
		);
	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            frameOptions {
                mode = Mode.SAMEORIGIN
            }
        }
    }
}
----
====

如果您不想添加默认值,并且希望对应使用的内容进行明确控制,则可以禁用默认值.下面提供了这种配置的示例:

.Disable HTTP Security Response Headers
====
.Java
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers.disable());
	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            disable()
        }
    }
}
----
====

[[webflux-headers-cache-control]]
== Cache Control

Spring Security 默认包含 <<headers-cache-control,Cache Control>> 头.

但是,如果您实际上想缓存特定的响应,则您的应用程序可以有选择地调用 https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/server/reactive/ServerHttpResponse.html[ServerHttpResponse]  来覆盖 Spring Security 设置的 header.  这对于确保正确缓存 CSS,JavaScript 和图片之类的内容很有用.

使用 Spring WebFlux 时,通常在您的配置中完成.  有关如何执行此操作的详细信息,请参见 Spring 参考文档的  https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources[静态资源] 部分.

如有必要,您还可以禁用 Spring Security 的缓存控制 HTTP 响应头.

.Cache Control Disabled
====
.Java
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.cache(cache -> cache.disable())
		);
	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            cache {
                disable()
            }
        }
    }
}
----
====

[[webflux-headers-content-type-options]]
== Content Type 选项

Spring Security 默认包含  <<headers-content-type-options,Content-Type>> 头.  但是,您可以使用以下命令将其禁用:

.Content Type Options Disabled
====
.Java
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.contentTypeOptions(contentTypeOptions -> contentTypeOptions.disable())
		);
	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            contentTypeOptions {
                disable()
            }
        }
    }
}
----
====

[[webflux-headers-hsts]]
== HTTP Strict Transport Security (HSTS)
Spring Security 默认提供严格传输安全头.  但是,您可以显式自定义结果.  例如,以下是为 HSTS 显式提供的示例:

.Strict Transport Security
====
.Java
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.hsts(hsts -> hsts
				.includeSubdomains(true)
				.preload(true)
				.maxAge(Duration.ofDays(365))
			)
		);
	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            hsts {
                includeSubdomains = true
                preload = true
                maxAge = Duration.ofDays(365)
            }
        }
    }
}
----
====

[[webflux-headers-frame-options]]
== X-Frame-Options

默认情况下,Spring Security 使用  <<headers-frame-options,X-Frame-Options>> 禁用 iframe 中的渲染.

您可以使用以下方法自定义框架选项以在使用相同的 origin:

.X-Frame-Options: SAMEORIGIN
====
.Java
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.frameOptions(frameOptions -> frameOptions
				.mode(SAMEORIGIN)
			)
		);
	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            frameOptions {
                mode = SAMEORIGIN
            }
        }
    }
}
----
====

[[webflux-headers-xss-protection]]
== X-XSS-Protection

默认情况下,Spring Security 指示浏览器使用 <<headers-xss-protection,X-XSS-Protection header>> 阻止反射的 XSS 攻击.
您可以使用以下配置禁用 `X-XSS-Protection`:

.X-XSS-Protection Customization
====
.Java
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.xssProtection(xssProtection -> xssProtection.disable())
		);
	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            xssProtection {
                disable()
            }
        }
    }
}
----
====

[[webflux-headers-csp]]
== Content Security Policy (CSP)

Spring Security 默认情况下不会添加  <<headers-csp,Content Security Policy>>,因为没有应用程序的上下文就无法知道合理的默认值.  Web 应用程序作者必须声明安全策略以强制执行和/或监视受保护的资源.

例如,给定以下安全策略:

.Content Security Policy Example
====
[source,http]
----
Content-Security-Policy: script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/
----
====

您可以使用配置启用 CSP 头,如下所示:

.Content Security Policy
====
.Java
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.contentSecurityPolicy(policy -> policy
				.policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
			)
		);
	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            contentSecurityPolicy {
                policyDirectives = "script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
            }
        }
    }
}
----
====

要启用 CSP `report-only` 头，请提供以下配置：

.Content Security Policy Report Only
====
.Java
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.contentSecurityPolicy(policy -> policy
				.policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
				.reportOnly()
			)
		);
	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            contentSecurityPolicy {
                policyDirectives = "script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
                reportOnly = true
            }
        }
    }
}
----
====

[[webflux-headers-referrer]]
== 推荐人策略

Spring Security 默认情况下不添加  <<headers-referrer,Referrer Policy>> 头.  您可以使用配置启用 Referrer Policy  头,如下所示:

.Referrer Policy Configuration
====
.Java
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.referrerPolicy(referrer -> referrer
				.policy(ReferrerPolicy.SAME_ORIGIN)
			)
		);
	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            referrerPolicy {
                policy = ReferrerPolicy.SAME_ORIGIN
            }
        }
    }
}
----
====

[[webflux-headers-feature]]
== Feature Policy (功能策略)

Spring Security 默认不添加  <<headers-feature,Feature Policy>>  头.  以下  `Feature-Policy`  头:

.Feature-Policy Example
====
[source]
----
Feature-Policy: geolocation 'self'
----
====

可以使用配置启用 Feature-Policy 头,如下所示:

.Feature-Policy Configuration
====
.Java
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.featurePolicy("geolocation 'self'")
		);
	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            featurePolicy("geolocation 'self'")
        }
    }
}
----
====

[[webflux-headers-permissions]]
== Permissions Policy

Spring Security 默认不添加 <<headers-permissions,Permissions Policy>> 头。
以下 `Permissions-Policy` 头：

.Permissions-Policy Example
====
[source]
----
Permissions-Policy: geolocation=(self)
----
====

您可以启用 Permissions Policy 头，如下所示：

.Permissions-Policy Configuration
====
.Java
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.headers(headers -> headers
			.permissionsPolicy(permissions -> permissions
				.policy("geolocation=(self)")
			)
		);
	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            permissionsPolicy {
                policy = "geolocation=(self)"
            }
        }
    }
}
----
====

[[webflux-headers-clear-site-data]]
=== 配置内容安全策略

Spring Security 默认情况下不添加<<headers-clear-site-data,Clear-Site-Data>>  头.  以下 Clear-Site-Data 头:

.Clear-Site-Data Example
====
----
Clear-Site-Data: "cache", "cookies"
----
====

可以使用以下配置在注销时发送:

.Clear-Site-Data Configuration
====
.Java
[source,java,role="primary"]
----
@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	ServerLogoutHandler securityContext = new SecurityContextServerLogoutHandler();
	ClearSiteDataServerHttpHeadersWriter writer = new ClearSiteDataServerHttpHeadersWriter(CACHE, COOKIES);
	ServerLogoutHandler clearSiteData = new HeaderWriterServerLogoutHandler(writer);
	DelegatingServerLogoutHandler logoutHandler = new DelegatingServerLogoutHandler(securityContext, clearSiteData);

	http
		// ...
		.logout()
			.logoutHandler(logoutHandler);
	return http.build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    val securityContext: ServerLogoutHandler = SecurityContextServerLogoutHandler()
    val writer = ClearSiteDataServerHttpHeadersWriter(CACHE, COOKIES)
    val clearSiteData: ServerLogoutHandler = HeaderWriterServerLogoutHandler(writer)
    val customLogoutHandler = DelegatingServerLogoutHandler(securityContext, clearSiteData)

    return http {
        // ...
        logout {
            logoutHandler = customLogoutHandler
        }
    }
}
----
====
