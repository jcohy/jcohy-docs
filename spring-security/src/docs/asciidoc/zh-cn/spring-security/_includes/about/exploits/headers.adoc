[[headers]]
= 安全HTTP响应头

[NOTE]
====
文档的此部分讨论安全HTTP响应头的一般主题.  有关安全HTTP响应头 <<servlet-headers,servlet>> 和基于 <<webflux-headers,WebFlux>> 的应用程序的特定信息，请参阅相关部分.
====

有许多  https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#tab=Headers[HTTP响应头]  可用于提高Web应用程序的安全性.
本节专门介绍 Spring Security 提供显式支持的各种HTTP响应头.  如有必要，还可以使用 Spring Security 配置 <<headers-custom,自定义响应头>>.

[[headers-default]]
== 默认安全响应头

[NOTE]
====
请参阅相关部分，以了解如何为基于 <<servlet-headers-default,servlet>> 和基于 <<webflux-headers-default,webflux>> 的应用程序定制默认值.
====

Spring Security 提供了一组默认的与安全性相关的HTTP响应头，以提供安全的默认值.

.默认安全的 HTTP 响应头
====
[source,http]
----
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
----
====

NOTE: 仅在HTTPS请求上添加严格传输安全性

如果默认设置不能满足您的需求，则可以轻松地从这些默认设置中删除，修改或添加 headers .  有关这些标头中的每个标头的更多详细信息，请参阅相应的部分:

* <<headers-cache-control,缓存控制>>
* <<headers-content-type-options,Content Type 选项>>
* <<headers-hsts,HTTP严格传输安全>>
* <<headers-frame-options,X-Frame-Options>>
* <<headers-xss-protection,X-XSS-Protection>>

[[headers-cache-control]]
== 缓存控制

[NOTE]
====
请参阅相关部分，以了解如何为基于 <<servlet-headers-cache-control,servlet>> 和基于 <<webflux-headers-cache-control,webflux>> 的应用程序定制默认值.
====

Spring Security的默认设置是禁用缓存以保护用户的内容.

如果用户进行了身份验证以查看敏感信息然后注销，则我们不希望恶意用户能够单击 "后退" 按钮查看敏感信息.  默认情况下发送的缓存控制标头是:

.默认缓存控制 HTTP 响应头
====
[source]
----
Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
----
====

为了默认安全，Spring Security 默认添加这些头.  但是，如果您的应用程序提供了它自己的缓存控制标头，Spring Security 将会退出.  这允许应用程序确保可以缓存CSS和JavaScript之类的静态资源.


[[headers-content-type-options]]
== Content Type 选项

[NOTE]
====
请参阅相关部分，以了解如何为基于 <<servlet-headers-content-type-options,servlet>> 和基于 <<webflux-headers-content-type-options,webflux>> 的应用程序定制默认值.
====

历史上，包括 Internet Explorer 在内的浏览器都会尝试使用内容 https://en.wikipedia.org/wiki/Content_sniffing[嗅探] 来猜测请求的内容类型.  这允许浏览器通过猜测未指定内容类型的资源上的内容类型来改善用户体验.  例如，如果浏览器遇到一个未指定内容类型的JavaScript文件，它将能够猜测该内容类型然后执行.

[NOTE]
====
允许上传内容时，还有许多其他事情 (即，仅在不同的域中显示文档，确保设置了 Content-Type 头，清理文档等) .  但是，这些措施不在Spring Security提供的范围之内.  指出禁用内容嗅探时也很重要，您必须指定内容类型才能使内容正常工作.
====

内容嗅探的问题在于，这允许恶意用户使用多义词 (即，可以作为多种内容类型有效的文件) 执行XSS攻击.  例如，某些网站可能允许用户向网站提交有效的附言文档并进行查看.  恶意用户可能会创建一个也是 http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf[有效JavaScript文件的Postscript文档]，并对其执行XSS攻击.

可以通过在响应中添加以下标头来禁用内容嗅探:

.nosniff HTTP 响应头
====
[source,http]
----
X-Content-Type-Options: nosniff
----
====

[[headers-hsts]]
== HTTP Strict Transport Security (HSTS)

[NOTE]
====
请参阅相关部分，以了解如何为基于 <<servlet-headers-hsts,servlet>> 和基于 <<webflux-headers-hsts,webflux>> 的应用程序定制默认值.
====

当您输入您的银行的网站，您进入 mybank.example.com 或进入 https://mybank.example.com[] 如果您忽略了 https 协议，您可能会受到 https://en.wikipedia.org/wiki/Man-in-the-middle_attack[中间人攻击].
即使网站执行重定向到 https://mybank.example.com， 恶意用户也可以截获初始HTTP请求并操纵响应(即重定向到  https://mibank.example.com  并窃取他们的凭证).

许多用户忽略了https协议，这就是创建HTTP https://tools.ietf.org/html/rfc6797[严格传输安全性 (HSTS) ]的原因.  将 mybank.example.com 添加为 https://tools.ietf.org/html/rfc6797#section-5.1[HSTS主机] 后，浏览器可以提前知道对 mybank.example.com 的任何请求都应解释为https://mybank.example.com.  这大大降低了发生中间人攻击的可能性.

[NOTE]
====
根据 https://tools.ietf.org/html/rfc6797#section-7.2[RFC6797]，HSTS头仅注入到HTTPS响应中.  为了使浏览器能够确认标头，浏览器必须首先信任对用于建立连接的SSL证书 (不仅仅是SSL证书) 进行签名的CA.
====

将站点标记为HSTS主机的一种方法是将主机预加载到浏览器中.  另一方法是将 `Strict-Transport-Security` 标头添加到响应中.  例如，以下内容将指示浏览器将域视为一年的HSTS主机 (一年大约31536000秒) :

.Strict Transport Security HTTP Response Header
====
[source]
----
Strict-Transport-Security: max-age=31536000 ; includeSubDomains ; preload
----
====


可选的 `includeSubDomains` 指令指示Spring Security子域 (即secure.mybank.example.com) 也应被视为HSTS域.

可选的 `preload` 指令指示Spring Security该域应在浏览器中预加载为HSTS域.  有关HSTS预加载的更多详细信息，请参见 https://hstspreload.org.

[[headers-hpkp]]
== HTTP Public Key Pinning (HPKP)

[NOTE]
====
为了保持被动，Spring Security 仍在 <<servlet-headers-hpkp,servlet 环境中提供对 HPKP 的支持>>，但是由于上述原因，安全团队不再推荐 HPKP.
====

https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning[HTTP Public Key Pinning (HPKP)]  向Web客户端指定要与某些Web服务器一起使用的公共密钥，以防止使用伪造证书的中间人 (MITM) 攻击.
如果使用得当，HPKP可以添加更多的保护层，以防止受到破坏的证书.  但是，由于HPKP的复杂性，许多专家不再建议使用它，https://www.chromestatus.com/feature/5903385005916160[Chrome甚至取消了对它的支持].

[[headers-hpkp-deprecated]]
有关为何不再推荐使用HPKP的更多详细信息，请阅读  https://blog.qualys.com/ssllabs/2016/09/06/is-http-public-key-pinning-dead[Is HTTP Public Key Pinning Dead?] 和 https://scotthelme.co.uk/im-giving-up-on-hpkp/[I'm giving up on HPKP].

[[headers-frame-options]]
== X-Frame-Options

[NOTE]
====
请参阅相关部分，以了解如何为基于 <<servlet-headers-frame-options,servlet>> 和基于 <<webflux-headers-frame-options,webflux>> 的应用程序定制默认值.
====

允许将您的网站添加到框架可能是一个安全问题.  例如，使用聪明的CSS样式用户可能会被诱骗点击他们不想要的内容 (https://www.youtube.com/watch?v=3mk0RySeNsU[视频演示]) .  例如，登录到其银行的用户可以单击将按钮授予其他用户访问权限.  这种攻击称为 https://en.wikipedia.org/wiki/Clickjacking[Clickjacking].

[NOTE]
====
处理点击劫持的另一种现代方法是使用<<headers-csp, "内容安全策略 (CSP) " >>.
====

有许多方法可以缓解点击劫持攻击.  例如，要保护旧版浏览器免遭点击劫持攻击，可以使用分帧代码.  虽然不完美，但是对于传统浏览器而言， https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet#Best-for-now_Legacy_Browser_Frame_Breaking_Script[frame breaking code] 是最好的选择.

解决点击劫持的更现代方法是使用 https://developer.mozilla.org/en-US/docs/HTTP/X-Frame-Options[X-Frame-Options]  头:

[source]
----
X-Frame-Options: DENY
----

[[headers-xss-protection]]
== X-XSS-Protection

[NOTE]
====
请参阅相关部分，以了解如何为基于 <<servlet-headers-xss-protection,servlet>> 和基于 <<webflux-headers-xss-protection,webflux>> 的应用程序定制默认值.
====

一些浏览器内置了对过滤掉 https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_(OWASP-DV-001)[reflected XSS attacks]的支持.  这绝非万无一失，但确实有助于XSS保护.

通常默认情况下会启用过滤，因此添加标头通常只会确保标头已启用，并指示浏览器在检测到XSS攻击时应采取的措施.
例如，过滤器可能会尝试以最小侵入性的方式更改内容以仍然呈现所有内容.  有时，这种替换本身可能会成为 https://hackademix.net/2009/11/21/ies-xss-filter-creates-xss-vulnerabilities/[XSS漏洞本身].  相反，最好是阻止内容，而不要尝试对其进行修复.  为此，我们可以添加以下标头:


[source]
----
X-XSS-Protection: 1; mode=block
----


[[headers-csp]]
== Content Security Policy (CSP)

[NOTE]
====
请参阅相关部分，以了解如何为基于 <<servlet-headers-csp,servlet>> 和基于 <<webflux-headers-csp,webflux>> 的应用程序定制默认值.
====

https://www.w3.org/TR/CSP2/[Content Security Policy (CSP)] 是Web应用程序可以利用的一种机制，可以缓解诸如跨站点脚本 (XSS) 之类的内容注入漏洞.  CSP是一种声明性策略，为Web应用程序作者提供了一种工具，可以声明该Web应用程序希望从中加载资源的来源，并最终将这些信息通知客户端 (用户代理) .

[NOTE]
====
内容安全策略并非旨在解决所有内容注入漏洞.  取而代之的是，可以利用CSP帮助减少内容注入攻击所造成的危害.  作为第一道防线，Web应用程序作者应验证其输入并对其输出进行编码.
====

Web应用程序可以通过在响应中包括以下HTTP标头之一来使用CSP:

* `Content-Security-Policy`
* `Content-Security-Policy-Report-Only`

这些标头中的每一个都用作将安全策略传递给客户端的机制.  安全策略包含一组安全策略指令，每个指令负责声明对特定资源表示形式的限制.

例如，Web应用程序可以通过在响应中包括以下标头来声明它希望从特定的受信任源中加载脚本:

.Content Security Policy Example
====
[source]
----
Content-Security-Policy: script-src https://trustedscripts.example.com
----
====

用户代理会阻止尝试从另一个源 (而不是 _script-src_ 指令中声明的内容) 加载脚本.  此外，如果在安全策略中声明了  https://www.w3.org/TR/CSP2/#directive-report-uri[*_report-uri_*]  指令，则用户代理会将违反行为报告给声明的URL.

例如，如果Web应用程序违反了已声明的安全策略，则以下响应标头将指示用户代理将违规报告发送到策略的  _report-uri_  指令中指定的URL.

.Content Security Policy with report-uri
====
[source]
----
Content-Security-Policy: script-src https://trustedscripts.example.com; report-uri /csp-report-endpoint/
----
====

https://www.w3.org/TR/CSP2/#violation-reports[*_Violation reports_*] 是标准的JSON结构，可以由Web应用程序自己的API或公共托管的CSP违规报告服务 (例如 https://report-uri.io/[*_REPORT-URI_*]) 捕获.

Content-Security-Policy-Report-Only 标头为Web应用程序作者和管理员提供了监视安全策略而不是强制执行这些策略的功能.  该标题通常在试验和/或开发站点的安全策略时使用.  当某个策略被认为有效时，可以通过使用  _Content-Security-Policy_  标头字段来强制实施.

给定以下响应头，该策略声明可以从两个可能的来源之一加载脚本.

.Content Security Policy Report Only
====
[source]
----
Content-Security-Policy-Report-Only: script-src 'self' https://trustedscripts.example.com; report-uri /csp-report-endpoint/
----
====

如果站点违反了此策略，则通过尝试从 _evil.com_ 加载脚本，用户代理会将违规报告发送到 _report-uri_ 指令指定的声明URL，但仍然允许违规资源加载.

将内容安全策略应用于Web应用程序通常是一项艰巨的任务.  以下资源可能会为您的网站制定有效的安全策略提供进一步的帮助.

https://www.html5rocks.com/en/tutorials/security/content-security-policy/[An Introduction to Content Security Policy]

https://developer.mozilla.org/en-US/docs/Web/Security/CSP[CSP Guide - Mozilla Developer Network]

https://www.w3.org/TR/CSP2/[W3C Candidate Recommendation]

[[headers-referrer]]
== Referrer Policy

[NOTE]
====
请参阅相关部分，以了解如何为基于 <<servlet-headers-referrer,servlet>> 和基于 <<webflux-headers-referrer,webflux>> 的应用程序定制默认值.
====

https://www.w3.org/TR/referrer-policy[Referrer Policy] 是一种机制，Web应用程序可以利用该机制来管理引荐来源网址字段，该字段包含用户所在的最后一页.
Spring Security的方法是使用 https://www.w3.org/TR/referrer-policy/[Referrer Policy] 头，该标头提供了不同的 https://www.w3.org/TR/referrer-policy/#referrer-policies[策略]:

.Referrer Policy Example
====
[source]
----
Referrer-Policy: same-origin
----
====

Referrer-Policy 响应头指示浏览器让目的地知道用户先前所在的源.

[[headers-feature]]
== Feature Policy

[NOTE]
====
请参阅相关部分，以了解如何为基于 <<servlet-headers-feature,servlet>> 和基于 <<webflux-headers-feature,webflux>> 的应用程序定制默认值.
====

https://wicg.github.io/feature-policy/[Feature Policy] 是一种机制，允许Web开发人员在浏览器中选择性地启用，禁用和修改某些API和Web功能的行为.

.Feature Policy Example
====
[source]
----
Feature-Policy: geolocation 'self'
----
====

借助 Feature Policy，开发人员可以为浏览器选择一套 "策略"，以实施整个站点中使用的特定功能.  这些政策限制了网站可以访问或修改某些功能的浏览器默认行为的API.


[[headers-clear-site-data]]
== 清除站点数据

[NOTE]
====
请参阅相关部分，以了解如何为基于 <<servlet-headers-clear-site-data,servlet>> 和基于 <<webflux-headers-clear-site-data,webflux>> 的应用程序定制默认值.
====

https://www.w3.org/TR/clear-site-data/[Clear Site Data] 清除站点数据是一种机制，通过该机制，当HTTP响应包含以下标头时，可以删除所有浏览器端数据 (Cookie，本地存储等) :

[source]
----
Clear-Site-Data: "cache", "cookies", "storage", "executionContexts"
----

这是注销时执行的不错的清理操作.


[[headers-custom]]
== 自定义 Headers

[NOTE]
====
请参阅相关部分，以了解如何配置两个基于 <<servlet-headers-custom,servlet>> 的应用程序.
====

Spring Security具有使您可以方便地将更常见的安全标头添加到您的应用程序的机制.  但是，它也提供了挂钩来启用添加自定义标头.
