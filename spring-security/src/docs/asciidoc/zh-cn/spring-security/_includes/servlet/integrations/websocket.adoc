[[websocket]]
== WebSocket 安全

Spring Security 4增加了对确保Spring https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html[Spring's WebSocket support]的支持。本节介绍如何使用Spring Security的WebSocket支持。

NOTE: 您可以在  https://github.com/spring-projects/spring-session/tree/master/samples/boot/websocket 中找到WebSocket安全性的完整工作示例。

.直接JSR 356支持
****
Spring Security不提供直接的JSR-356支持，因为这样做几乎没有价值。 这是因为格式是未知的，因此Spring https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-intro-sub-protocol[几乎无法保护未知格式]。 另外，JSR-356没有提供拦截消息的方法，因此安全性将具有相当大的侵入性。
****

[[websocket-configuration]]
=== WebSocket 配置

Spring Security 4.0通过Spring Messaging抽象引入了对WebSocket的授权支持。 要使用Java配置来配置授权，只需扩展 `AbstractSecurityWebSocketMessageBrokerConfigurer` 并配置 `MessageSecurityMetadataSourceRegistry`。 例如：

[source,java]
----
@Configuration
public class WebSocketSecurityConfig
      extends AbstractSecurityWebSocketMessageBrokerConfigurer { // <1> <2>

    protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
        messages
                .simpDestMatchers("/user/**").authenticated() // <3>
    }
}
----

这将确保：

<1> 任何入站CONNECT消息均需要有效的CSRF令牌来实施 <<websocket-sameorigin,同源策略>>
<2> 对于任何入站请求，在simpUser标头属性中使用用户填充SecurityContextHolder。
<3> 我们的消息需要适当的授权。具体来说，任何以 "/user/" 开头的入站消息都需要 `ROLE_USER`。有关授权的更多详细信息，请参见 <<websocket-authorization,第15.7.3节 "WebSocket授权">>

Spring Security还提供<<nsa-websocket-security,XML命名空间>>支持以保护WebSocket。 可比较的基于XML的配置如下所示：

[source,xml]
----
<websocket-message-broker> <!--1--> <!--2-->
    <!--3-->
    <intercept-message pattern="/user/**" access="hasRole('USER')" />
</websocket-message-broker>
----

这将确保：

<1> 任何入站CONNECT消息均需要有效的CSRF令牌来实施 <<websocket-sameorigin,同源策略>>
<2> 对于任何入站请求，在simpUser标头属性中使用用户填充SecurityContextHolder。
<3> 我们的消息需要适当的授权。具体来说，任何以 "/user/" 开头的入站消息都需要 `ROLE_USER`。有关授权的更多详细信息，请参见 <<websocket-authorization,第15.7.3节 "WebSocket授权">>

[[websocket-authentication]]
=== WebSocket 认证

WebSockets重用建立 `WebSocket` 连接时在HTTP请求中找到的相同身份验证信息。 这意味着 `HttpServletRequest` 上的 `Principal` 将移交给 `WebSockets`。 如果您使用的是Spring Security，则 `HttpServletRequest` 上的 `Principal` 将被自动覆盖。

更具体地说，要确保用户已通过 `WebSocket` 应用程序的身份验证，所需要做的就是确保您设置Spring Security以对基于HTTP的Web应用程序进行身份验证。


[[websocket-authorization]]
=== WebSocket 授权

Spring Security 4.0通过Spring Messaging抽象引入了对WebSocket的授权支持。 要使用Java配置来配置授权，只需扩展 `AbstractSecurityWebSocketMessageBrokerConfigurer` 并配置 `MessageSecurityMetadataSourceRegistry`。 例如：

[source,java]
----
@Configuration
public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer {

    @Override
    protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
        messages
                .nullDestMatcher().authenticated() // <1>
                .simpSubscribeDestMatchers("/user/queue/errors").permitAll() // <2>
                .simpDestMatchers("/app/**").hasRole("USER") // <3>
                .simpSubscribeDestMatchers("/user/**", "/topic/friends/*").hasRole("USER") // <4>
                .simpTypeMatchers(MESSAGE, SUBSCRIBE).denyAll() // <5>
                .anyMessage().denyAll(); // <6>

    }
}
----

这将确保：

<1> 任何没有目的地的消息(即除了消息类型或订阅之外的任何消息)都需要用户进行身份验证
<2> 任何人都可以订阅 /user/queue/errors
<3> 任何以 "/app/" 开头的消息都要求用户使用角色ROLE_USER
<4> 任何以 "/user/" 或类型为SUBSCRIBE的 "/topic/friends/" 开头的消息都需要ROLE_USER
<5> 拒绝消息或订阅类型的任何其他消息。由于第6步，我们不需要这个步骤，但它说明了如何匹配特定的消息类型。
<6> 拒绝任何其他消息。这是一个确保您不会错过任何消息的好主意。

Spring Security还提供<<nsa-websocket-security,XML命名空间>>支持以保护WebSocket。可比较的基于XML的配置如下所示：

[source,xml]
----
<websocket-message-broker>
    <!--1-->
    <intercept-message type="CONNECT" access="permitAll" />
    <intercept-message type="UNSUBSCRIBE" access="permitAll" />
    <intercept-message type="DISCONNECT" access="permitAll" />

    <intercept-message pattern="/user/queue/errors" type="SUBSCRIBE" access="permitAll" /> <!--2-->
    <intercept-message pattern="/app/**" access="hasRole('USER')" />      <!--3-->

    <!--4-->
    <intercept-message pattern="/user/**" access="hasRole('USER')" />
    <intercept-message pattern="/topic/friends/*" access="hasRole('USER')" />

    <!--5-->
    <intercept-message type="MESSAGE" access="denyAll" />
    <intercept-message type="SUBSCRIBE" access="denyAll" />

    <intercept-message pattern="/**" access="denyAll" /> <!--6-->
</websocket-message-broker>
----

这将确保：

<1> 任何没有目的地的消息(即除了消息类型或订阅之外的任何消息)都需要用户进行身份验证
<2> 任何人都可以订阅 /user/queue/errors
<3> 任何以 "/app/" 开头的消息都要求用户使用角色ROLE_USER
<4> 任何以 "/user/" 或类型为SUBSCRIBE的 "/topic/friends/" 开头的消息都需要ROLE_USER
<5> 拒绝消息或订阅类型的任何其他消息。由于第6步，我们不需要这个步骤，但它说明了如何匹配特定的消息类型。
<6> 拒绝任何其他消息。这是一个确保您不会错过任何消息的好主意。

[[websocket-authorization-notes]]
==== WebSocket授权说明

为了正确保护您的应用程序，了解Spring的WebSocket支持非常重要。

[[websocket-authorization-notes-messagetypes]]
===== WebSocket对消息类型的授权

重要的是要了解 SUBSCRIBE 和 MESSAGE 类型的消息之间的区别以及它在Spring中的工作方式。

考虑聊天应用程序。

* 系统可以通过 "/topic/system/notifications" 的目的地向所有用户发送 "MESSAGE" 通知
* 客户可以通过订阅接收到 "/topic/system/notifications" 的通知.

尽管我们希望客户能够订阅  "/topic/system/notifications"，但我们不想让他们将MESSAGE发送到该目的地。 如果我们允许向  "/topic/system/notifications" 发送消息，则客户端可以直接向该端点发送消息并模拟系统。

通常，应用程序通常拒绝发送到以 https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp[代理前缀]（即 "/topic/" 或 "/queue/"）开头的目标的任何MESSAGE。

[[websocket-authorization-notes-destinations]]
===== 目的地上的WebSocket授权

了解目的地如何转变也很重要。

考虑聊天应用程序。

* 用户可以通过将消息发送到 "/app/chat" 的目的地来向特定用户发送消息。
* 应用程序会看到该消息，并确保将  "from" 属性指定为当前用户（我们不能信任客户端）。
* 然后，应用程序使用  `SimpMessageSendingOperations.convertAndSendToUser("toUser", "/queue/messages", message)` 将消息发送给收件人。
* 消息变成目标 "/queue/user/messages-<sessionid>"

使用上面的应用程序，我们希望允许我们的客户端收听 "/user/queue"，它被转换为  "/queue/user/messages-<sessionid>"。 但是，我们不希望客户端能够收听 "/queue/*"，因为那样会使客户端看到每个用户的消息。

通常，应用程序通常会拒绝发送到以 https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp[代理前缀] （即 "/topic/" 或 "/queue/")开头的消息的任何SUBSCRIBE。 当然，我们可能会提供例外情况来说明类似

[[websocket-authorization-notes-outbound]]
==== 出站邮件

Spring包含一个标题为 https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp-message-flow[消息流] 的部分，该部分描述了消息如何在系统中流动。 重要的是要注意，Spring Security仅保护 `clientInboundChannel`。 Spring Security不会尝试保护 `clientOutboundChannel`。

最重要的原因是性能。 对于每条传入的消息，通常会有更多的出去消息。 我们鼓励保护对端点的订阅，而不是保护出站消息。

[[websocket-sameorigin]]
=== 强制同源策略

需要强调的是，浏览器不会对WebSocket连接强制执行 https://en.wikipedia.org/wiki/Same-origin_policy[同源策略]。这是一个非常重要的考虑因素。

[[websocket-sameorigin-why]]
==== 为什么同源？

请考虑以下情形。 用户访问 bank.com 并验证其帐户。 同一用户在其浏览器中打开另一个选项卡，并访问 evil.com。 相同来源政策可确保 evil.com 无法读取数据或将数据写入 bank.com。

对于WebSocket，不适用 “同源策略”。 实际上，除非 bank.com 明确禁止，否则 evil.com 可以代表用户读取和写入数据。 这意味着用户可以通过 webSocket进行任何操作（即转帐），evil.com 可以代表该用户进行操作。

由于SockJS尝试模拟WebSocket，因此它也绕过了相同起源策略。 这意味着开发人员在使用SockJS时需要明确保护其应用程序不受外部域的影响。

[[websocket-sameorigin-spring]]
==== Spring WebSocket允许的来源

幸运的是，自Spring 4.1.5起，Spring的WebSocket和SockJS支持限制了对 https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-server-allowed-origins[当前域] 的访问。 Spring Security增加了一层保护，以提供 https://en.wikipedia.org/wiki/Defense_in_depth_%2528computing%2529[深度防御]。

[[websocket-sameorigin-csrf]]
==== 将CSRF添加到Stomp头

默认情况下，Spring Security需要任何CONNECT消息类型的 <<csrf,CSRF令牌>>。 这样可以确保只有有权访问CSRF令牌的站点才能连接。 由于只有相同来源可以访问CSRF令牌，因此不允许外部域进行连接。

通常，我们需要在HTTP标头或HTTP参数中包含CSRF令牌。 但是，SockJS不允许使用这些选项。 相反，我们必须在Stomp标头中包含令牌

应用程序可以通过访问名为 _csrf 的请求属性来<<servlet-csrf-include,获取CSRF令牌>>。 例如，以下将允许在JSP中访问 `CsrfToken`：

[source,javascript]
----
var headerName = "${_csrf.headerName}";
var token = "${_csrf.token}";
----

如果使用的是静态HTML，则可以在REST端点上公开 `CsrfToken`。例如，以下内容将在URL /csrf 上公开 `CsrfToken`

[source,java]
----
@RestController
public class CsrfController {

    @RequestMapping("/csrf")
    public CsrfToken csrf(CsrfToken token) {
        return token;
    }
}
----

JavaScript可以对端点进行REST调用，并使用响应填充 `headerName` 和令牌。

现在，我们可以将令牌包含在Stomp客户端中。
例如：

[source,javascript]
----
...
var headers = {};
headers[headerName] = token;
stompClient.connect(headers, function(frame) {
  ...

}
----

[[websocket-sameorigin-disable]]
==== 在WebSockets中禁用CSRF

如果您想允许其他域访问您的站点，则可以禁用Spring Security的保护。
例如，在Java配置中，您可以使用以下代码：

[source,java]
----
@Configuration
public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer {

    ...

    @Override
    protected boolean sameOriginDisabled() {
        return true;
    }
}
----


[[websocket-sockjs]]
=== 使用SockJS

https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-fallback[SockJS] 提供后备传输以支持较旧的浏览器。使用后备选项时，我们需要放松一些安全性约束，以允许SockJS与Spring Security一起使用。

[[websocket-sockjs-sameorigin]]
==== SockJS & frame-options

SockJS可能使用利用 https://github.com/sockjs/sockjs-client/tree/v0.3.4[iframe的传输方式]。 默认情况下，Spring Security会 <<headers-frame-options,拒绝>>对网站进行构架以防止Clickjacking攻击。 为了允许基于SockJS框架的传输正常工作，我们需要配置Spring Security以允许相同的来源对内容进行框架化。

您可以使用frame-options元素来自定义X-Frame-Options。 例如，以下内容将指示Spring Security使用 "X-Frame-Options: SAMEORIGIN" 它允许在同一域内的iframe：

[source,xml]
----
<http>
    <!-- ... -->

    <headers>
        <frame-options
          policy="SAMEORIGIN" />
    </headers>
</http>
----

同样，您可以使用以下方法自定义框架选项以在Java配置中使用相同的来源：

[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
   WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers -> headers
                .frameOptions(frameOptions -> frameOptions
                     .sameOrigin()
                )
        );
    }
}
----

[[websocket-sockjs-csrf]]
==== SockJS & 放宽CSRF

SockJS在CONNECT消息上使用POST进行任何基于HTTP的传输。 通常，我们需要在HTTP标头或HTTP参数中包含CSRF令牌。 但是，SockJS不允许使用这些选项。 相反，我们必须按照<<websocket-sameorigin-csrf,将CSRF添加到Stomp头>>一节中的说明，将令牌包括在Stomp标头中。

这也意味着我们需要通过Web层放宽对CSRF的保护。 具体来说，我们要为连接URL禁用CSRF保护。 我们不想禁用每个URL的CSRF保护。 否则，我们的站点将容易受到CSRF攻击。

通过提供CSRF RequestMatcher，我们可以轻松实现这一目标。 我们的Java配置非常简单。 例如，如果我们的踩踏端点为 "/chat/" ，则可以使用以下配置仅对以 "/chat/" 开头的URL禁用CSRF保护：

[source,java]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig
    extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf
                // ignore our stomp endpoints since they are protected using Stomp headers
                .ignoringAntMatchers("/chat/**")
            )
            .headers(headers -> headers
                // allow same origin to frame our site to support iframe SockJS
                .frameOptions(frameOptions -> frameOptions
                    .sameOrigin()
                )
            )
            .authorizeRequests(authorize -> authorize
                ...
            )
            ...
----

如果使用基于XML的配置，则可以使用<<nsa-csrf-request-matcher-ref,csrf@request-matcher-ref>>。例如：

[source,xml]
----
<http ...>
    <csrf request-matcher-ref="csrfMatcher"/>

    <headers>
        <frame-options policy="SAMEORIGIN"/>
    </headers>

    ...
</http>

<b:bean id="csrfMatcher"
    class="AndRequestMatcher">
    <b:constructor-arg value="#{T(org.springframework.security.web.csrf.CsrfFilter).DEFAULT_CSRF_MATCHER}"/>
    <b:constructor-arg>
        <b:bean class="org.springframework.security.web.util.matcher.NegatedRequestMatcher">
          <b:bean class="org.springframework.security.web.util.matcher.AntPathRequestMatcher">
            <b:constructor-arg value="/chat/**"/>
          </b:bean>
        </b:bean>
    </b:constructor-arg>
</b:bean>
----
