[[servlet-cas]]
== CAS 认证

[[cas-overview]]
=== 概述
JA-SIG 产生了企业范围的单点登录系统，称为 CAS.
与其他计划不同，JA-SIG的中央身份验证服务是开源的，广泛使用，易于理解，独立于平台并支持代理功能.  Spring Security 完全支持 CAS，并提供了从 Spring Security 的单应用程序部署到由企业范围的CAS服务器保护的多应用程序部署的简便迁移路径.

您可以在 https://www.apereo.org. 上了解有关 CAS 的更多信息.  您还需要访问此站点以下载 CAS Server 文件.

[[cas-how-it-works]]
=== CAS 如何工作?
尽管 CA S网站包含详细介绍CAS体系结构的文档，但我们还是在 Spring Security 的上下文中再次介绍了总体概述.  Spring Security 3.x 支持CAS3. 在撰写本文时，CAS 服务器的版本为 3.4.

您需要在企业中的某个位置设置CAS服务器.  CAS服务器只是一个标准的WAR文件，因此设置服务器没有任何困难.  在WAR文件中，您将自定义显示给用户的登录页面和其他单一登录页面.

部署CAS 3.4 服务器时，还需要在CAS随附的 `deployerConfigContext.xml` 中指定 `AuthenticationHandler`. `AuthenticationHandler` 有一个简单的方法，该方法返回有关给定凭据集是否有效的布尔值.
您的 `AuthenticationHandler` 实现将需要链接到某种类型的后端身份验证存储库，例如LDAP服务器或数据库. CAS本身提供了许多 `AuthenticationHandler` 来提供帮助.  在下载和部署服务器war文件时，该文件将设置为成功验证输入与用户名匹配的密码的用户的身份，这对于测试非常有用.

除了CAS服务器本身之外，其他关键参与者当然是整个企业中部署的安全Web应用程序.  这些Web应用程序称为 "服务".  有三种类型的服务.
那些对服务票证进行身份验证的人，那些可以获取代理票证的人以及那些对代理票证进行身份验证的人.  验证代理票证的方式有所不同，因为必须验证代理列表，并且通常可以重复使用代理票证.

[[cas-sequence]]
==== Spring Security 和 CAS 交互序列
Web浏览器，CAS服务器和受 Spring Security 保护的服务之间的基本交互如下:

* 网络用户正在浏览服务的公共页面.  不涉及 CAS 或 Spring Security.
* 用户最终请求的页面是安全的，或者它使用的其中一个bean是安全的.  Spring Security 的 `ExceptionTranslationFilter` 将检测 `AccessDeniedException` 或 `AuthenticationException`.
* 由于用户的 `Authentication` 对象 (或缺少该对象) 导致 `AuthenticationException`，因此 `ExceptionTranslationFilter` 将调用已配置的 `AuthenticationEntryPoint`.  如果使用 CAS，则为 `CasAuthenticationEntryPoint` 类.
* `CasAuthenticationEntryPoint` 会将用户的浏览器重定向到CAS服务器.  它还将指示一个服务参数，它是 Spring Security 服务 (您的应用程序) 的回调URL.  例如，浏览器重定向到的URL可能是 https://my.company.com/cas/login?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas.
* 用户的浏览器重定向到 CAS 后，将提示他们输入用户名和密码.  如果用户提供的会话 cookie 指示他们先前已登录，则不会提示他们再次登录 (此过程有一个例外，我们将在后面介绍) .  CAS将使用上面讨论的 `PasswordHandler` (如果使用CAS 3.0，则使用 `AuthenticationHandler`) 来确定用户名和密码是否有效.
* 成功登录后，CAS 会将用户的浏览器重定向回原始服务.  它还将包含一个 `ticket` 参数，它是代表 "service ticket" 的不透明字符串.  继续前面的示例，浏览器重定向到的URL可能是 https://server3.company.com/webapp/login/cas?ticket=ST-0-ER94xMJmn6pha35CQRoZ.
* 回到服务Web应用程序中，`CasAuthenticationFilter` 始终在监听对 `/login/cas` 的请求 (这是可配置的，但在本简介中将使用默认值) .  处理过滤器将构造一个代表服务票证的 `UsernamePasswordAuthenticationToken`.  主体将等于 `CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER`，而凭据将是服务凭单的不透明值.  然后，此身份验证请求将移交给已配置的 `AuthenticationManager`.
* `AuthenticationManager` 实现将是 `ProviderManager`，后者又由 `CasAuthenticationProvider` 配置.  `CasAuthenticationProvider` 仅响应包含特定于 CAS 的主体的 `UsernamePasswordAuthenticationToken` (如 `CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER`) 和 `CasAuthenticationToken` (稍后讨论) .
* `CasAuthenticationProvider` 将使用 `TicketValidator` 实现来验证服务票证.  这通常是 `Cas20ServiceTicketValidator`，它是CAS客户端库中包含的类之一.  如果应用程序需要验证代理票证，则使用 `Cas20ProxyTicketValidator`.  `TicketValidator` 向CAS服务器发出HTTPS请求，以验证服务票证.
  它还可能包含此示例中包含的代理回调URL: https://my.company.com/cas/proxyValidate?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas&ticket=ST-0-ER94xMJmn6pha35CQRoZ＆pgtUrl=https://server3.company.com/webapp/login/cas/proxyreceptor.
* 返回 CAS 服务器，将收到验证请求.  如果提供的服务票证与票证签发到的服务URL相匹配，则 CAS 将以 XML 的形式提供肯定的响应，指示用户名.  如果身份验证中涉及任何代理 (如下所述) ，则代理列表也包含在XML响应中.
* [可选]如果对CAS验证服务的请求包括代理回调URL (在pgtUrl参数中) ，则 CAS 将在 XML 响应中包括 pgtIou 字符串.  此 `pgtIou` 表示授予代理的票证IOU.  然后，CAS服务器将创建自己的HTTPS连接回到 `pgtUrl`.  这是为了相互认证CAS服务器和要求保护的服务URL.  HTTPS连接将用于将代理授予票证发送到原始Web应用程序.  例如，https://server3.company.com/webapp/login/cas/proxyreceptor?
* `Cas20TicketValidator` 将解析从CAS服务器接收到的XML.  它将把票证响应返回给 `CasAuthenticationProvider`，其中包括用户名 (强制性) ，代理列表 (如果涉及) 和授予代理票证的IOU (如果请求了代理回调) .
* 接下来，`CasAuthenticationProvider` 将调用已配置的 `CasProxyDecider`.  `CasProxyDecider` 指示 `TicketResponse` 中的代理列表是否对服务可接受.  Spring Security提供了几种实现: `RejectProxyTickets`，`AcceptAnyCasProxy` 和 `NamedCasProxyDecider`.  这些名称在很大程度上是不言自明的，但 `NamedCasProxyDecider` 除外，该名称允许提供受信任代理的列表.
* 接下来，`CasAuthenticationProvider` 将请求 `AuthenticationUserDetailsService` 来加载应用于断言中包含的用户的 `GrantedAuthority` 对象.
* 如果没有问题，`CasAuthenticationProvider` 会构造一个 `CasAuthenticationToken`，其中包括 `TicketResponse` 和 `GrantedAuthoritys` 中包含的详细信息.
* 然后，控制权返回到 `CasAuthenticationFilter`，它将创建的 `CasAuthenticationToken` 放在安全上下文中.
* 用户的浏览器被重定向到导致 `AuthenticationException` 的原始页面 (或自定义目标，具体取决于配置) .

很高兴您还在这里！ 现在来看一下它的配置方式

[[cas-client]]
=== CAS 客户端配置
由于 Spring Security 使CAS的Web应用程序端变得容易.  假定您已经知道使用 Spring Security 的基础知识，因此下面不再赘述.  我们假设正在使用基于命名空间的配置，并根据需要添加 CAS Bean.  每个部分都基于上一部分.  完整的示例应用程序可以在Spring Security <<samples,Samples>> 中找到.

[[cas-st]]
==== Service Ticket 认证
本节描述如何设置 Spring Security 来认证 Service Ticket.  通常，这是Web应用程序所需的全部.  您将需要在应用程序上下文中添加 `ServiceProperties` bean.  这代表您的CAS服务:

[source,xml]
----
<bean id="serviceProperties"
	class="org.springframework.security.cas.ServiceProperties">
<property name="service"
	value="https://localhost:8443/cas-sample/login/cas"/>
<property name="sendRenew" value="false"/>
</bean>
----

`service` 必须等于由 `CasAuthenticationFilter` 监视的URL.  `sendRenew` 默认为 `false`，但如果您的应用程序特别敏感，则应将其设置为 `true`.  该参数的作用是告诉CAS登录服务单次登录是不可接受的.  而是，用户将需要重新输入其用户名和密码才能访问该服务.

应该配置以下bean以启动 CAS 身份验证过程 (假设您使用的是命名空间配置) :

[source,xml]
----
<security:http entry-point-ref="casEntryPoint">
...
<security:custom-filter position="CAS_FILTER" ref="casFilter" />
</security:http>

<bean id="casFilter"
	class="org.springframework.security.cas.web.CasAuthenticationFilter">
<property name="authenticationManager" ref="authenticationManager"/>
</bean>

<bean id="casEntryPoint"
	class="org.springframework.security.cas.web.CasAuthenticationEntryPoint">
<property name="loginUrl" value="https://localhost:9443/cas/login"/>
<property name="serviceProperties" ref="serviceProperties"/>
</bean>
----

为了使CAS能够运行，`ExceptionTranslationFilter` 必须将其 `authenticationEntryPoint` 属性设置为 `CasAuthenticationEntryPoint` bean.
可以像上面的示例一样使用 <<nsa-http-entry-point-ref,entry-point-ref>> 轻松完成此操作.  `CasAuthenticationEntryPoint` 必须引用 `ServiceProperties` Bean (如上所述) ，该bean提供企业 CAS 登录服务器的URL.  这是重定向用户浏览器的地方.

`CasAuthenticationFilter` 具有与 `UsernamePasswordAuthenticationFilter` (用于基于表单的登录名) 非常相似的属性.  您可以使用这些属性来自定义行为，例如验证成功和失败的行为.

接下来，您需要添加一个 `CasAuthenticationProvider` 及其合作者:

[source,xml,attrs="-attributes"]
----
<security:authentication-manager alias="authenticationManager">
<security:authentication-provider ref="casAuthenticationProvider" />
</security:authentication-manager>

<bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider">
<property name="authenticationUserDetailsService">
	<bean class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper">
	<constructor-arg ref="userService" />
	</bean>
</property>
<property name="serviceProperties" ref="serviceProperties" />
<property name="ticketValidator">
	<bean class="org.jasig.cas.client.validation.Cas20ServiceTicketValidator">
	<constructor-arg index="0" value="https://localhost:9443/cas" />
	</bean>
</property>
<property name="key" value="an_id_for_this_auth_provider_only"/>
</bean>

<security:user-service id="userService">
<!-- Password is prefixed with {noop} to indicate to DelegatingPasswordEncoder that
NoOpPasswordEncoder should be used.
This is not safe for production, but makes reading
in samples easier.
Normally passwords should be hashed using BCrypt -->
<security:user name="joe" password="{noop}joe" authorities="ROLE_USER" />
...
</security:user-service>
----

一旦 CAS 验证了用户的授权，`CasAuthenticationProvider` 就会使用 `UserDetailsService` 实例为用户加载授权.  我们在这里显示了一个简单的内存设置.  请注意，`CasAuthenticationProvider` 实际上并未使用密码进行身份验证，但确实使用了权限.

如果您参考<<cas-how-it-works,CAS的工作原理>>部分，那么所有这些bean都是不言自明的.

这样就完成了 CAS 的最基本配置.  如果您没有犯任何错误，则您的网络应用程序应该可以在 CAS 单点登录框架内愉快地工作.  Spring Security 的其他部分无需关心 CAS 处理的身份验证这一事实.  在以下各节中，我们将讨论一些 (可选) 更高级的配置.


[[cas-singlelogout]]
==== 单点注销
CAS 协议支持单点注销，可以轻松添加到您的 Spring Security 配置中.  以下是处理单点注销的 Spring Security 配置的更新

[source,xml]
----
<security:http entry-point-ref="casEntryPoint">
...
<security:logout logout-success-url="/cas-logout.jsp"/>
<security:custom-filter ref="requestSingleLogoutFilter" before="LOGOUT_FILTER"/>
<security:custom-filter ref="singleLogoutFilter" before="CAS_FILTER"/>
</security:http>

<!-- This filter handles a Single Logout Request from the CAS Server -->
<bean id="singleLogoutFilter" class="org.jasig.cas.client.session.SingleSignOutFilter"/>

<!-- This filter redirects to the CAS Server to signal Single Logout should be performed -->
<bean id="requestSingleLogoutFilter"
	class="org.springframework.security.web.authentication.logout.LogoutFilter">
<constructor-arg value="https://localhost:9443/cas/logout"/>
<constructor-arg>
	<bean class=
		"org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler"/>
</constructor-arg>
<property name="filterProcessesUrl" value="/logout/cas"/>
</bean>
----

`logout` 元素将用户从本地应用程序注销，但不会终止与CAS服务器或已登录的任何其他应用程序的会话.  `requestSingleLogoutFilter` 过滤器将允许请求 `/spring_security_cas_logout` 的URL，以将应用程序重定向到配置的 CAS Server 注销URL.
然后，CAS 服务器将向已登录的所有服务发送 "单一注销" 请求.  `singleLogoutFilter` 通过在静态Map中查找 `HttpSession` 并使其无效来处理 Single Logout 请求.

为什么同时需要 `logout` 元素和 `singleLogoutFilter` 可能令人困惑.  最好先在本地注销，因为 `SingleSignOutFilter` 只是将 `HttpSession` 存储在静态Map中，以便对其调用无效.  使用上述配置，注销流程为:

* 用户请求 `/logout`，这将使用户退出本地应用程序，并将用户发送到注销成功页面.
* 注销成功页面 `/cas-logout.jsp` 应该指示用户单击指向 `/logout/cas` 的链接，以便注销所有应用程序.
* 当用户单击链接时，用户将被重定向到CAS单一注销URL (`https://localhost:9443/cas/logout`) .
* 然后，在 CAS 服务器端，CAS 单一注销URL向所有 CAS 服务提交单一注销请求.  在CAS服务方面，JASIG的 `SingleSignOutFilter` 通过使原始会话无效来处理注销请求.

下一步是将以下内容添加到您的 web.xml 中

[source,xml]
----
<filter>
<filter-name>characterEncodingFilter</filter-name>
<filter-class>
	org.springframework.web.filter.CharacterEncodingFilter
</filter-class>
<init-param>
	<param-name>encoding</param-name>
	<param-value>UTF-8</param-value>
</init-param>
</filter>
<filter-mapping>
<filter-name>characterEncodingFilter</filter-name>
<url-pattern>/*</url-pattern>
</filter-mapping>
<listener>
<listener-class>
	org.jasig.cas.client.session.SingleSignOutHttpSessionListener
</listener-class>
</listener>
----

使用 `SingleSignOutFilter` 时，您可能会遇到一些编码问题.  因此，建议添加 `CharacterEncodingFilter` 以确保使用 `SingleSignOutFilter` 时字符编码正确.  同样，请参阅JASIG的文档以了解详细信息.  `SingleSignOutHttpSessionListener` 确保 `HttpSession` 过期时，将删除用于单次注销的映射.

[[cas-pt-client]]
==== 通过CAS向无状态服务进行身份验证
本节介绍如何使用 CAS 对服务进行身份验证.  换句话说，本节讨论如何设置使用通过CAS认证的服务的客户端.  下一节将介绍如何设置无状态服务以使用CAS进行身份验证.


[[cas-pt-client-config]]
===== 配置CAS以获取代理授予票证
为了向无状态服务进行身份验证，应用程序需要获取代理授予票证 (PGT) .  本节描述了如何配置 Spring Security 以获得基于 thencas-st[Service Ticket Authentication] 配置的PGT.

第一步是在 Spring Security 配置中包括 `ProxyGrantingTicketStorage`.  这用于存储由 `CasAuthenticationFilter` 获得的PGT，以便可以将其用于获取代理凭单.  配置示例如下所示

[source,xml]
----
<!--
NOTE: In a real application you should not use an in memory implementation.
You will also want to ensure to clean up expired tickets by calling
ProxyGrantingTicketStorage.cleanup()
-->
<bean id="pgtStorage" class="org.jasig.cas.client.proxy.ProxyGrantingTicketStorageImpl"/>
----

下一步是更新 `CasAuthenticationProvider`，使其能够获取代理票证.  为此，将 `Cas20ServiceTicketValidator` 替换为 `Cas20ProxyTicketValidator`.  应该将 `proxyCallbackUrl` 设置为应用程序将在其上接收PGT的URL.  最后，配置还应该引用 `ProxyGrantingTicketStorage`，以便它可以使用PGT获取代理票证.  您可以在下面找到配置更改的示例.

[source,xml]
----
<bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider">
...
<property name="ticketValidator">
	<bean class="org.jasig.cas.client.validation.Cas20ProxyTicketValidator">
	<constructor-arg value="https://localhost:9443/cas"/>
		<property name="proxyCallbackUrl"
		value="https://localhost:8443/cas-sample/login/cas/proxyreceptor"/>
	<property name="proxyGrantingTicketStorage" ref="pgtStorage"/>
	</bean>
</property>
</bean>
----

最后一步是更新 `CasAuthenticationFilter` 以接受PGT并将它们存储在 `ProxyGrantingTicketStorage` 中.  重要的是 `proxyReceptorUrl` 与 `Cas20ProxyTicketValidator` 的 `proxyCallbackUrl` 相匹配.  配置示例如下所示.

[source,xml]
----

<bean id="casFilter"
		class="org.springframework.security.cas.web.CasAuthenticationFilter">
	...
	<property name="proxyGrantingTicketStorage" ref="pgtStorage"/>
	<property name="proxyReceptorUrl" value="/login/cas/proxyreceptor"/>
</bean>

----

[[cas-pt-client-sample]]
===== 使用代理票证调用无状态服务
现在，Spring Security 获得了PGT，您可以使用它们创建代理票证，该票证可用于对无状态服务进行身份验证.  <<samples,sample 应用程序>> 在 `ProxyTicketSampleServlet` 中包含一个工作示例.  示例代码可以在下面找到:

[source,java]
----
protected void doGet(HttpServletRequest request, HttpServletResponse response)
	throws ServletException, IOException {
// NOTE: The CasAuthenticationToken can also be obtained using
// SecurityContextHolder.getContext().getAuthentication()
final CasAuthenticationToken token = (CasAuthenticationToken) request.getUserPrincipal();
// proxyTicket could be reused to make calls to the CAS service even if the
// target url differs
final String proxyTicket = token.getAssertion().getPrincipal().getProxyTicketFor(targetUrl);

// Make a remote call using the proxy ticket
final String serviceUrl = targetUrl+"?ticket="+URLEncoder.encode(proxyTicket, "UTF-8");
String proxyResponse = CommonUtils.getResponseFromServer(serviceUrl, "UTF-8");
...
}
----

[[cas-pt]]
==== 代理票证认证
`CasAuthenticationProvider` 区分有状态客户端和无状态客户端.  有状态客户端被认为是任何提交给 `CasAuthenticationFilter` 的 `filterProcessUrl` 的客户端.  无状态客户端是指在 `filterProcessUrl` 之外的URL上向 `CasAuthenticationFilter` 提出身份验证请求的客户端.

由于远程协议无法在 `HttpSession` 的上下文中展示自己，因此无法依靠默认做法将安全上下文存储在请求之间的会话中.  此外，由于CAS服务器在票证已由 `TicketValidator` 验证后使票证失效，因此无法在后续请求中显示相同的代理票证.

一个明显的选择是根本不使用CAS远程协议客户端.  但是，这将消除CAS的许多理想功能.  作为中间立场，`CasAuthenticationProvider` 使用 `StatelessTicketCache`.  这仅用于使用等于 `CasAuthenticationFilter.CAS_STATELESS_IDENTIFIER` 的主体的无状态客户端.
发生的情况是，`CasAuthenticationProvider` 会将生成的 `CasAuthenticationToken` 存储在 `StatelessTicketCache` 中，该密钥在代理凭单上输入.  因此，远程协议客户端可以提供相同的代理票证，并且 `CasAuthenticationProvider` 无需联系CAS服务器进行验证 (除了第一个请求) .  一旦通过身份验证，代理票证就可以用于原始目标服务以外的URL.

本部分以前面的部分为基础，以适应代理票证身份验证.  第一步是指定对所有工件进行身份验证，如下所示.

[source,xml]
----
<bean id="serviceProperties"
	class="org.springframework.security.cas.ServiceProperties">
...
<property name="authenticateAllArtifacts" value="true"/>
</bean>
----

下一步是为 `CasAuthenticationFilter` 指定 `serviceProperties` 和 `authenticationDetailsSource`.  `serviceProperties` 属性指示 `CasAuthenticationFilter` 尝试认证所有工件，而不是仅对 `filterProcessUrl` 中存在的工件进行认证.
`ServiceAuthenticationDetailsSource` 创建一个 `ServiceAuthenticationDetails`，以确保在验证票证时将基于 `HttpServletRequest` 的当前URL用作服务URL.  可以通过注入返回返回自定义 `ServiceAuthenticationDetails` 的自定义 `AuthenticationDetailsSource` 来自定义生成服务URL的方法.

[source,xml]
----
<bean id="casFilter"
	class="org.springframework.security.cas.web.CasAuthenticationFilter">
...
<property name="serviceProperties" ref="serviceProperties"/>
<property name="authenticationDetailsSource">
	<bean class=
	"org.springframework.security.cas.web.authentication.ServiceAuthenticationDetailsSource">
	<constructor-arg ref="serviceProperties"/>
	</bean>
</property>
</bean>
----

您还需要更新 `CasAuthenticationProvider` 来处理代理票证.  为此，将 `Cas20ServiceTicketValidator` 替换为 `Cas20ProxyTicketValidator`.  您将需要配置 `statelessTicketCache` 以及要接受的代理.  您可以在下面找到接受所有代理所需的更新示例.

[source,xml]
----

<bean id="casAuthenticationProvider"
	class="org.springframework.security.cas.authentication.CasAuthenticationProvider">
...
<property name="ticketValidator">
	<bean class="org.jasig.cas.client.validation.Cas20ProxyTicketValidator">
	<constructor-arg value="https://localhost:9443/cas"/>
	<property name="acceptAnyProxy" value="true"/>
	</bean>
</property>
<property name="statelessTicketCache">
	<bean class="org.springframework.security.cas.authentication.EhCacheBasedTicketCache">
	<property name="cache">
		<bean class="net.sf.ehcache.Cache"
			init-method="initialise" destroy-method="dispose">
		<constructor-arg value="casTickets"/>
		<constructor-arg value="50"/>
		<constructor-arg value="true"/>
		<constructor-arg value="false"/>
		<constructor-arg value="3600"/>
		<constructor-arg value="900"/>
		</bean>
	</property>
	</bean>
</property>
</bean>
----
