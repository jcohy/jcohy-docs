[[servlet-csrf]]
= Servlet环境的跨站点请求伪造(CSRF)

本部分讨论了Spring Security对Servlet环境的<<csrf,跨站点请求伪造(CSRF) >>支持.

[[servlet-csrf-using]]
== 使用 Spring Security 保护 CSRF
下面描述了如何使用Spring Security 防御CSRF的步骤:

* <<servlet-csrf-idempotent,使用正确的HTTP动词>>
* <<servlet-csrf-configure,配置防御CSRF>>
* <<servlet-csrf-include,包括CSRF令牌>>

[[servlet-csrf-idempotent]]
=== 使用正确的HTTP动词
防御CSRF攻击的第一步是确保您的网站使用正确的HTTP动词.  <<csrf-protection-idempotent,安全方法必须是幂等的>>中对此进行了详细介绍.

[[servlet-csrf-configure]]
=== 配置防御CSRF
下一步是在您的应用程序中配置Spring Security的防御CSRF.  默认情况下，Spring Security的对CSRF的防御处于启用状态，但是您可能需要自定义配置.  以下是一些常见的自定义项.

[[servlet-csrf-configure-custom-repository]]
==== 自定义 CsrfTokenRepository

默认情况下，Spring Security使用 `HttpSessionCsrfTokenRepository` 将所需的CSRF令牌存储在 `HttpSession` 中.  在某些情况下，用户需要配置自定义 `CsrfTokenRepository`.  例如，可能需要将 `CsrfToken` 持久保存在 `cookie` 中以<<servlet-csrf-include-ajax-auto,支持JavaScript的应用程序>>.

默认情况下，`CookieCsrfTokenRepository` 将写入名为 `XSRF-TOKEN` 的 `cookie`，并从名为 `X-XSRF-TOKEN` 的请求头或 HTTP 参数 为 `_csrf` 中读取它.  这些默认值来自 https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection[AngularJS]

您可以使用以下命令以XML配置 `CookieCsrfTokenRepository`:

.使用XML配置将CSRF令牌存储在Cookie中
====
[source,xml]
----
<http>
	<!-- ... -->
	<csrf token-repository-ref="tokenRepository"/>
</http>
<b:bean id="tokenRepository"
	class="org.springframework.security.web.csrf.CookieCsrfTokenRepository"
	p:cookieHttpOnly="false"/>
----
====

[NOTE]
====
该示例显式设置 `cookieHttpOnly=false`.  这是允许JavaScript(即AngularJS) 可以从cookie中读取他需要的东西.  如果不需要直接使用JavaScript读取cookie的功能，建议省略 `cookieHttpOnly = false` 以提高安全性.
====


您可以使用以下命令在Java配置中配置 `CookieCsrfTokenRepository`:

.使用Java配置将CSRF令牌存储在Cookie中
====
[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			.csrf(csrf -> csrf
				.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
			);
	}
}
----
====

[NOTE]
====
该示例显式设置 `cookieHttpOnly=false`.  这是允许JavaScript(即AngularJS) 可以从cookie中读取他需要的东西.  如果不需要直接使用JavaScript读取cookie的功能，建议省略 `cookieHttpOnly = false` (通过使用新的 `CookieCsrfTokenRepository()` 代替) 以提高安全性.
====

[[servlet-csrf-configure-disable]]
==== 禁用CSRF防御
默认情况下，CSRF保护处于启用状态. 但是，如果对<<csrf-when,您的应用程序有意义>>，则禁用CSRF防御很简单.

下面的XML配置将禁用CSRF保护.


.禁用CSRF XML配置
====
[source,xml]
----
<http>
	<!-- ... -->
	<csrf disabled="true"/>
</http>
----
====

下面的Java配置将禁用CSRF保护.

.禁用CSRF Java配置
====
[source,java]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			.csrf(csrf -> csrf.disable());
	}
}
----
====

[[servlet-csrf-include]]
=== 包括CSRF令牌
为了使<<csrf-protection-stp,同步器令牌模式>>免受CSRF攻击，我们必须在HTTP请求中包括实际的CSRF令牌.  这必须包含在请求的一部分(即表单参数，HTTP标头等) 中，浏览器不会自动将其包含在HTTP请求中.

Spring Security的 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/csrf/CsrfFilter.html[CsrfFilter]  公开了一个 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/csrf/CsrfToken.html[CsrfToken] 作为名为 `_csrf` 的 `HttpServletRequest` 属性.  这意味着任何视图技术都可以访问 `CsrfToken` 以将期望的令牌公开为<<servlet-csrf-include-form-attr,form>>或<<servlet-csrf-include-ajax-meta-attr,meta tag>>.
幸运的是，下面列出了一些集成，这些集成使<<servlet-csrf-include-form,form>> 中的令牌和<<servlet-csrf-include-ajax,ajax>> 请求的包含变得更加容易.

[[servlet-csrf-include-form]]
==== Form URL Encoded
为了 post HTML表单，CSRF令牌必须作为隐藏域包含在表单中. 例如，呈现的HTML可能如下所示:

.CSRF Token HTML
====
[source,html]
----
<input type="hidden"
	name="_csrf"
	value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
----
====

接下来，我们将讨论将CSRF令牌作为隐藏域包含在内的各种方式.

[[servlet-csrf-include-form-auto]]
===== 自动包含 CSRF 令牌

Spring Security的CSRF支持通过其 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/servlet/support/csrf/CsrfRequestDataValueProcessor.html[CsrfRequestDataValueProcessor]与Spring的 https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/support/RequestDataValueProcessor.html[RequestDataValueProcessor] 集成.
这意味着，如果您利用Spring的 https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view-jsp-formtaglib[Spring’s form tag library]，Thymleaf或与 `RequestDataValueProcessor` 集成的任何其他视图技术，则具有不安全的HTTP方法(即发布) 的表单将自动包含实际的CSRF令牌.


[[servlet-csrf-include-form-tag]]
===== csrfInput Tag

如果您使用的是JSP，则可以使用Spring的 https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view-jsp-formtaglib[Spring’s form tag library]..  但是，如果这不是一个选择，则还可以轻松地将标记包含在 <<taglibs-csrfinput,csrfInput>> 标签中.

[[servlet-csrf-include-form-attr]]
===== CsrfToken 请求属性

如果在请求中包括实际CSRF令牌的 <<servlet-csrf-include,其他选项>>不起作用，则可以利用 `CsrfToken` 作为名为 `_csrf` 的 `HttpServletRequest` 属性<<servlet-csrf-include,公开>>的事实.

下面显示了使用JSP进行此操作的示例:

.带有请求属性的表单中的CSRF令牌
====
[source,xml]
----
<c:url var="logoutUrl" value="/logout"/>
<form action="${logoutUrl}"
	method="post">
<input type="submit"
	value="Log out" />
<input type="hidden"
	name="${_csrf.parameterName}"
	value="${_csrf.token}"/>
</form>
----
====

[[servlet-csrf-include-ajax]]
==== Ajax 和 JSON 请求
如果使用的是JSON，则无法在HTTP参数内提交CSRF令牌.  相反，您可以在HTTP头中提交令牌.

在以下各节中，我们将讨论在基于JavaScript的应用程序中将CSRF令牌作为HTTP请求头包括在内的各种方式.

[[servlet-csrf-include-ajax-auto]]
===== 自动包含

可以轻松<<servlet-csrf-configure-custom-repository,配置>> Spring Security将期望的CSRF令牌存储在cookie中.  通过将期望的CSRF存储在cookie中，像 https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection[AngularJS]  这样的JavaScript框架将自动在HTTP请求标头中包含实际的CSRF令牌.

[[servlet-csrf-include-ajax-meta]]
===== Meta tags

在<<servlet-csrf-include-form-auto,Cookie中公开CSRF>> 的另一种方式是将CSRF令牌包含在您的元标记中.  HTML可能看起来像这样:

.CSRF meta tag HTML
====
[source,html]
----
<html>
<head>
	<meta name="_csrf" content="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
	<meta name="_csrf_header" content="X-CSRF-TOKEN"/>
	<!-- ... -->
</head>
<!-- ... -->
----
====

一旦元标记包含CSRF令牌，JavaScript代码就会读取元标记并将CSRF令牌作为标头包含在内. 如果您使用的是jQuery，则可以通过以下方式完成:

.AJAX send CSRF Token
====
[source,javascript]
----
$(function () {
	var token = $("meta[name='_csrf']").attr("content");
	var header = $("meta[name='_csrf_header']").attr("content");
	$(document).ajaxSend(function(e, xhr, options) {
		xhr.setRequestHeader(header, token);
	});
});
----
====

[[servlet-csrf-include-ajax-meta-tag]]
====== csrfMeta 标签

如果您使用的是JSP，则将CSRF令牌写入meta标记的一种简单方法是利用  <<taglibs-csrfmeta,csrfMeta>> 标签.

[[servlet-csrf-include-ajax-meta-attr]]
====== CsrfToken 请求属性

如果在请求中包括实际CSRF令牌的 <<servlet-csrf-include,其他选项>>  不起作用，则可以利用 `CsrfToken` 作为名为 `_csrf` 的 `HttpServletRequest` 属性<<servlet-csrf-include,公开>>的事实. 下面显示了使用JSP进行此操作的示例:

.CSRF meta tag JSP
====
[source,html]
----
<html>
<head>
	<meta name="_csrf" content="${_csrf.token}"/>
	<!-- default header name is X-CSRF-TOKEN -->
	<meta name="_csrf_header" content="${_csrf.headerName}"/>
	<!-- ... -->
</head>
<!-- ... -->
----
====

[[servlet-csrf-considerations]]
== CSRF 注意事项
实施针对CSRF攻击的防护时，需要考虑一些特殊注意事项.  本节讨论与Servlet环境有关的那些注意事项.  请参阅 <<csrf-considerations,CSRF注意事项>> 一节，以进行更一般的讨论.

[[servlet-considerations-csrf-login]]
=== 登录

<<csrf-considerations-login,要求CSRF进行登录>> 请求很重要，以防止伪造登录尝试.  Spring Security的servlet支持是开箱即用的.

[[servlet-considerations-csrf-logout]]
=== 注销

<<csrf-considerations-logout,要求CSRF进行注销>>请求很重要，以防止伪造注销尝试.  如果启用了CSRF保护(默认) ，Spring Security的 `LogoutFilter` 仅处理HTTP POST.  这样可以确保注销需要CSRF令牌，并且恶意用户不能强制注销用户.

最简单的方法是使用表单注销.  如果您确实需要链接，则可以使用JavaScript来使链接执行POST(即可能以隐藏形式) .  对于禁用了JavaScript的浏览器，您可以选择使该链接将用户带到将执行POST的注销确认页面.

如果您确实想在注销时使用HTTP GET，则可以这样做，但是请记住，通常不建议这样做.  例如，以下Java配置将使用URL `/logout` 通过任何HTTP方法请求注销:

.使用 HTTP GET 进行注销
====
[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			.logout(logout -> logout
				.logoutRequestMatcher(new AntPathRequestMatcher("/logout"))
			);
	}
}
----
====

[[servlet-considerations-csrf-timeouts]]
=== CSRF 和 Session 超时

默认情况下，Spring Security将CSRF令牌存储在 `HttpSession` 中.  这可能会导致会话到期的情况，这意味着没有期望的CSRF令牌进行验证.

我们已经讨论了会话超时的<<csrf-considerations-login,一般解决方案>> .  本节讨论与Servlet支持有关的CSRF超时的细节.

更改期望的CSRF令牌在cookie中的存储很简单.  有关详细信息，请参阅  <<servlet-csrf-configure-custom-repository,自定义 CsrfTokenRepository>>部分.

如果令牌确实过期，则可能需要通过指定自定义 `AccessDeniedHandler` 来定制令牌的处理方式.  自定义 `AccessDeniedHandler` 可以按照您喜欢的任何方式处理 `InvalidCsrfTokenException`.  有关如何自定义 `AccessDeniedHandler` 的示例，请参阅所提供的<<nsa-access-denied-handler,xml>>和 https://github.com/spring-projects/spring-security/blob/3.2.0.RC1/config/src/test/java/org/springframework/security/config/annotation/web/configurers/NamespaceHttpAccessDeniedHandlerTests.java#L64[Java configuration] 链接.

[[servlet-csrf-considerations-multipart]]
=== Multipart (文件上传)
我们 <<csrf-considerations-multipart,已经讨论>> 了如何保护分段请求(文件上传) 免受CSRF攻击如何导致 https://en.wikipedia.org/wiki/Chicken_or_the_egg[鸡和蛋的问题] . 本节讨论如何实现将CSRF令牌放置在Servlet应用程序的 <<servlet-csrf-considerations-multipart-body,body>>和<<servlet-csrf-considerations-multipart-url,url>> 中.

[NOTE]
====
有关在Spring中使用多部分表单的更多信息，请参见 https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web.html#mvc-multipart[1.1.11. Multipart Resolver]和 https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html[MultipartFilter javadoc].
====

[[servlet-csrf-considerations-multipart-body]]
==== 将CSRF令牌放入 body

我们<<csrf-considerations-multipart-body,已经讨论>> 了将CSRF令牌放入正文的权衡. 在本节中，我们将讨论如何配置Spring Security从主体读取CSRF.

为了从主体读取CSRF令牌，在Spring Security过滤器之前指定 `MultipartFilter`.  在Spring Security过滤器之前指定 `MultipartFilter` 意味着没有授权可以调用 `MultipartFilter`，这意味着任何人都可以在您的服务器上放置临时文件.
但是，只有授权用户才能提交由您的应用程序处理的文件.  通常，这是推荐的方法，因为临时文件上传对大多数服务器的影响应该忽略不计.

// FIXME: Document Spring Boot

为了确保在使用Java配置的Spring Security过滤器之前指定了 `MultipartFilter`，用户可以如下所示覆盖 `beforeSpringSecurityFilterChain`:

.初始化 MultipartFilter
====
[source,java]
----
public class SecurityApplicationInitializer extends AbstractSecurityWebApplicationInitializer {

	@Override
	protected void beforeSpringSecurityFilterChain(ServletContext servletContext) {
		insertFilters(servletContext, new MultipartFilter());
	}
}
----
====
为了确保在具有XML配置的Spring Security过滤器之前指定 `MultipartFilter`，用户可以确保将 `MultipartFilter` 的 `<filter-mapping>` 元素放在 `web.xml` 中的 `springSecurityFilterChain` 之前，如下所示:

.web.xml - MultipartFilter
====
[source,xml]
----
<filter>
	<filter-name>MultipartFilter</filter-name>
	<filter-class>org.springframework.web.multipart.support.MultipartFilter</filter-class>
</filter>
<filter>
	<filter-name>springSecurityFilterChain</filter-name>
	<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
</filter>
<filter-mapping>
	<filter-name>MultipartFilter</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>
<filter-mapping>
	<filter-name>springSecurityFilterChain</filter-name>
	<url-pattern>/*</url-pattern>
</filter-mapping>
----
====

[[servlet-csrf-considerations-multipart-url]]
==== 将 CSRF Token 放在 URL 中

如果不允许未经授权的用户上传临时文件，则可以选择将 `MultipartFilter` 放在Spring Security过滤器之后，并将CSRF作为查询参数包括在表单的 `action` 属性中.  由于 `CsrfToken` 是作为 `HttpServletRequest` <<servlet-csrf-include,请求属性>> 公开的，因此我们可以使用它来创建带有CSRF令牌的操作.  带有jsp的示例如下所示

.CSRF Token in Action
====
[source,html]
----
<form method="post"
	action="./upload?${_csrf.parameterName}=${_csrf.token}"
	enctype="multipart/form-data">
----
====

[[servlet-csrf-considerations-override-method]]
=== HiddenHttpMethodFilter
我们 <<csrf-considerations-multipart-body,已经讨论>> 了将CSRF令牌放入正文中的取舍.

在Spring的Servlet支持中，使用 https://docs.spring.io/spring-framework/docs/5.2.x/javadoc-api/org/springframework/web/filter/reactive/HiddenHttpMethodFilter.html[HiddenHttpMethodFilter] 覆盖HTTP方法. 有关更多信息，请参见参考文档的 https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web.html#mvc-rest-method-conversion[HTTP Method Conversion]  部分.
