[[taglibs]]
== JSP 标签库
Spring Security有自己的taglib，它为访问安全信息和在JSP中应用安全约束提供了基本的支持。


=== Declaring the Taglib
要使用任何标签，必须在JSP中声明 Security 的标签库：

[source,xml]
----
<%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %>
----

[[taglibs-authorize]]
=== 授权标签
该标签用于确定是否应评估其内容。 在Spring Security 3.0中，它可以以两种方式使用 footnote:[Spring Security 2.0的遗留选项也受支持，但不建议使用]。 第一种方法使用网络安全表达式，该表达式在标记的访问属性中指定。
表达式评估将委派给在应用程序上下文中定义的 `SecurityExpressionHandler<FilterInvocation>` （您应该在 `<http>` 命名空间配置中启用Web表达式，以确保此服务可用）。 因此，例如，您可能有

[source,xml]
----
<sec:authorize access="hasRole('supervisor')">

This content will only be visible to users who have the "supervisor" authority in their list of <tt>GrantedAuthority</tt>s.

</sec:authorize>
----

当与Spring Security PermissionEvaluator结合使用时，该标签还可用于检查权限。
例如：

[source,xml]
----
<sec:authorize access="hasPermission(#domain,'read') or hasPermission(#domain,'write')">

This content will only be visible to users who have read or write permission to the Object found as a request attribute named "domain".

</sec:authorize>
----

通常的要求是，如果实际上允许用户单击某个链接，则仅显示该链接。
我们如何预先确定是否允许某事？ 此标记还可以在替代模式下运行，该模式允许您将特定的URL定义为属性。
如果允许用户调用该URL，则将评估标记主体，否则将跳过该标记主体。
所以你可能会喜欢

[source,xml]
----
<sec:authorize url="/admin">

This content will only be visible to users who are authorized to send requests to the "/admin" URL.

</sec:authorize>
----

要使用此标记，您的应用程序上下文中还必须有一个 `WebInvocationPrivilegeEvaluator` 的实例。
如果使用命名空间，将自动注册一个命名空间。
这是 `DefaultWebInvocationPrivilegeEvaluator` 的实例，该实例为提供的URL创建一个虚拟Web请求，并调用安全拦截器以查看该请求成功还是失败。
这使您可以委托给您在 `<http>` 命名空间配置中使用 `intercept-url` 声明定义的访问控制设置，并且省去了在JSP中重复信息（例如所需角色）的麻烦。
这种方法还可以与提供HTTP方法的 `method` 属性结合使用，以实现更具体的匹配。

通过将变量 `var` 属性设置为变量名称，可以将评估标记（无论是授予还是拒绝访问）的布尔结果存储在页面上下文范围变量中，而无需在其他地方重复和重新评估条件在页面中。


==== 禁用测试的授权标签
在页面上为未授权用户隐藏链接不会阻止他们访问URL。 例如，他们可以直接将其输入浏览器中。 在测试过程中，您可能希望显示隐藏区域，以检查链接在后端是否真正固定。 如果将系统属性 `spring.security.disableUISecurity` 设置为 `true`，则 `authorize` 标记仍将运行，但不会隐藏其内容。
默认情况下，它还将用 `<span class="securityHiddenUI">...</span>`  标签包围内容。 这使您可以显示具有特定CSS样式（例如不同的背景颜色）的“隐藏”内容。 例如，尝试在启用此属性的情况下运行“教程”示例应用程序。

如果要更改默认范围标签中的周围文本（或使用空字符串将其完全删除），还可以设置属性 `spring.security.securedUIPrefix` 和 `spring.security.securedUISuffix`。

=== authentication 标签

此标记允许访问存储在安全上下文中的当前 `Authentication`  对象。 它直接在JSP中呈现对象的属性。 因此，例如，如果 `Authentication` 的 `principal` 属性是Spring Security的 `UserDetails` 对象的实例，则使用 `<sec:authentication property="principal.username" />` 将呈现当前用户的名称。

当然，在这种情况下不必使用JSP标签，并且有些人希望在视图中保持尽可能少的逻辑。 您可以在MVC控制器中访问 `Authentication` 对象（通过调用 `SecurityContextHolder.getContext().getAuthentication()`），然后将数据直接添加到模型中以通过视图进行呈现。

=== accesscontrollist 标签
该标签仅在与Spring Security的ACL模块一起使用时才有效。 它检查以逗号分隔的指定域对象的所需权限列表。 如果当前用户拥有所有这些权限，则将评估标签正文。 如果他们不这样做，它将被跳过。 一个例子可能是

CAUTION: 通常，应将此标签视为已弃用。而是使用<<taglibs-authorize,第15.9.2节 "授权标签">>

[source,xml]
----
<sec:accesscontrollist hasPermission="1,2" domainObject="${someObject}">

This will be shown if the user has all of the permissions represented by the values "1" or "2" on the given object.

</sec:accesscontrollist>
----

权限被传递到在应用程序上下文中定义的 `PermissionFactory`，将它们转换为ACL `Permission` 实例，因此它们可以是工厂支持的任何格式-它们不必是整数，它们可以是诸如 `READ` 或 `WRITE` 之类的字符串 。 如果未找到 `PermissionFactory`，则将使用 `DefaultPermissionFactory` 的实例。 应用程序上下文中的AclService将用于加载所提供对象的Acl实例。 将以所需的权限调用Acl，以检查是否所有权限都被授予。

该标签还与 `authorize` 标签相同，支持 `var` 属性。

[[taglibs-csrfinput]]
=== csrfInput 标签
如果启用了CSRF保护，则此标签会插入一个隐藏的表单字段，其中包含CSRF保护令牌的正确名称和值。 如果未启用CSRF保护，则此标签不输出任何内容。

通常，Spring Security会为您使用的任何 `<form:form>` 标记自动插入CSRF表单字段，但是如果由于某些原因您不能使用 `<form:form>`，`csrfInput` 是一个方便的替代品。

您应该将此标记放置在HTML `<form></form>` 块中，通常将其放置在其他输入字段中。 请勿将此标签放在Spring  `<form:form></form:form>`  块中。 Spring Security自动处理Spring表单。

[source,xml]
----
	<form method="post" action="/do/something">
		<sec:csrfInput />
		Name:<br />
		<input type="text" name="name" />
		...
	</form>
----

[[taglibs-csrfmeta]]
=== csrfMetaTags 标签
如果启用了CSRF保护，则此标记将插入包含CSRF保护令牌形式字段，标头名称和CSRF保护令牌值的元标记。 这些元标记对于在应用程序中的JavaScript中采用CSRF保护很有用。

您应该将 `csrfMetaTags` 放置在HTML `<head></head>` 块中，通常将其放置在其他meta标签中。 使用此标记后，您可以使用JavaScript轻松访问表单字段名称，标题名称和令牌值。 在此示例中，使用JQuery简化了任务。

[source,xml]
----
<!DOCTYPE html>
<html>
	<head>
		<title>CSRF Protected JavaScript Page</title>
		<meta name="description" content="This is the description for this page" />
		<sec:csrfMetaTags />
		<script type="text/javascript" language="javascript">

			var csrfParameter = $("meta[name='_csrf_parameter']").attr("content");
			var csrfHeader = $("meta[name='_csrf_header']").attr("content");
			var csrfToken = $("meta[name='_csrf']").attr("content");

			// using XMLHttpRequest directly to send an x-www-form-urlencoded request
			var ajax = new XMLHttpRequest();
			ajax.open("POST", "https://www.example.org/do/something", true);
			ajax.setRequestHeader("Content-Type", "application/x-www-form-urlencoded data");
			ajax.send(csrfParameter + "=" + csrfToken + "&name=John&...");

			// using XMLHttpRequest directly to send a non-x-www-form-urlencoded request
			var ajax = new XMLHttpRequest();
			ajax.open("POST", "https://www.example.org/do/something", true);
			ajax.setRequestHeader(csrfHeader, csrfToken);
			ajax.send("...");

			// using JQuery to send an x-www-form-urlencoded request
			var data = {};
			data[csrfParameter] = csrfToken;
			data["name"] = "John";
			...
			$.ajax({
				url: "https://www.example.org/do/something",
				type: "POST",
				data: data,
				...
			});

			// using JQuery to send a non-x-www-form-urlencoded request
			var headers = {};
			headers[csrfHeader] = csrfToken;
			$.ajax({
				url: "https://www.example.org/do/something",
				type: "POST",
				headers: headers,
				...
			});

		<script>
	</head>
	<body>
		...
	</body>
</html>
----

如果未启用CSRF保护，则 `csrfMetaTags` 不输出任何内容。