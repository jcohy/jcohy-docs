
[[oauth2resourceserver]]
== OAuth 2.0 资源服务器

Spring Security支持使用两种形式的OAuth 2.0 https://tools.ietf.org/html/rfc6750.html[Bearer Tokens] 来保护端点:

* https://tools.ietf.org/html/rfc7519[JWT]
* Opaque Tokens

在应用程序将其权限管理委派给 https://tools.ietf.org/html/rfc6749[授权服务器]  (例如Okta或Ping Identity) 的情况下，这很方便.  资源服务器可以咨询该授权服务器以授权请求.

[NOTE]
====
Spring Security {gh-samples-url}[Spring Security repository] 中提供了  {gh-samples-url}/boot/oauth2resourceserver[JWTs] 和 {gh-samples-url}/boot/oauth2resourceserver-opaque[Opaque Tokens] 的示例.
====

=== 依赖
大多数资源服务器支持都收集在 `spring-security-oauth2-resource-server` 中.
但是，`spring-security-oauth2-jose` 中支持对JWT进行解码和验证，这意味着，对于拥有支持JWT编码的Bearer Token的工作资源服务器而言，两者都是必需的.

[[oauth2resourceserver-jwt-minimalconfiguration]]
=== JWT的最小配置

使用 https://spring.io/projects/spring-boot[Spring Boot] 时，将应用程序配置为资源服务器包括两个基本步骤.  首先，包括所需的依赖关系，其次，指示授权服务器的位置.

==== 指定授权服务器

在Spring Boot应用程序中，要指定要使用的授权服务器，只需执行以下操作:

[source,yml]
----
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://idp.example.com/issuer
----

其中 `https://idp.example.com/issuer` 是授权服务器将颁发的JWT令牌的 `iss` 声明中包含的值.  资源服务器将使用此属性进行进一步的自我配置，发现授权服务器的公钥，然后验证传入的JWT.

[NOTE]
要使用 `issuer-uri` 属性，还必须确保 `https://idp.example.com/issuer/.well-known/openid-configuration`, `https://idp.example.com/.well-known/openid-configuration/issuer`, 或  `https://idp.example.com/.well-known/oauth-authorization-server/issuer` 是授权服务器支持的端点.
此端点称为 https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[Provider Configuration]  端点或授权服务器 https://tools.ietf.org/html/rfc8414#section-3[Authorization Server Metadata] 端点.


就是这样！

==== 启动预期

使用此属性和这些依赖关系时，资源服务器将自动配置自身以验证JWT编码的 Bearer 令牌.

它通过确定性的启动过程来实现:



1. 点击提供者配置或授权服务器元数据端点，处理 `jwks_url` 属性的响应
2. 配置验证策略以查询 `jwks_url` 以获取有效的公共密钥
3. 配置验证策略，以根据 `https://idp.example.com` 验证每个JWT的 `iss` 声明.

此过程的结果是，授权服务器必须启动并接收请求，才能成功启动资源服务器.

[NOTE]
如果在资源服务器查询授权服务器时授权服务器已关闭 (给出适当的超时) ，则启动将失败.

==== 运行时预期

应用程序启动后，资源服务器将尝试处理任何包含 `Authorization: Bearer`  头的请求:

[source,html]
----
GET / HTTP/1.1
Authorization: Bearer some-token-value # Resource Server will process this
----

只要指示了此方案，资源服务器就会尝试根据Bearer Token规范处理请求.

给定格式正确的JWT，资源服务器将:



1. 在启动期间根据从 `jwks_url` 端点获取并与JWTs标头匹配的公钥验证其签名
2. 验证JWT的 `exp` 和 `nbf` 时间戳以及JWT的 `iss` 声明，以及
3. 将每个范围映射到具有前缀 `SCOPE_` 的权限.

[NOTE]
当授权服务器提供新的密钥时，Spring Security将自动旋转用于验证JWT令牌的密钥.

默认情况下，生成的  `Authentication#getPrincipal` 是Spring Security `Jwt` 对象，并且  `Authentication#getName` 映射到JWT的 `sub` 属性 (如果存在) .

从这里，考虑跳到:

<<oauth2resourceserver-jwt-jwkseturi,如何在不使资源服务器启动受限于授权服务器的可用性的情况下进行配置>>

<<oauth2resourceserver-jwt-sansboot,如何在没有Spring Boot的情况下进行配置>>

[[oauth2resourceserver-jwt-jwkseturi]]
=== 直接指定授权服务器JWK设置Uri

如果授权服务器不支持任何配置端点，或者如果资源服务器必须能够独立于授权服务器启动，那么还可以提供 `jwk-set-uri`:

[source,yaml]
----
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://idp.example.com
          jwk-set-uri: https://idp.example.com/.well-known/jwks.json
----

[NOTE]
JWK Set uri尚未标准化，但通常可以在授权服务器的文档中找到

因此，资源服务器在启动时不会对授权服务器执行ping操作.  我们仍然指定 `issuer-uri`，以便Resource Server仍然验证传入JWT上的 `iss` 声明.

[NOTE]
此属性也可以直接在<<oauth2resourceserver-jwt-jwkseturi-dsl,DSL>>上提供.

[[oauth2resourceserver-jwt-sansboot]]
=== 覆盖或替换引导自动配置

Spring Boot代表Resource Server生成了两个 `@Bean`.

第一个是将应用程序配置为资源服务器的 `WebSecurityConfigurerAdapter`.  当包含 `spring-security-oauth2-jose` 时，此 `WebSecurityConfigurerAdapter` 看起来像:

.Default JWT Configuration
====
.Java
[source,java,role="primary"]
----
protected void configure(HttpSecurity http) {
    http
        .authorizeRequests(authorize -> authorize
            .anyRequest().authenticated()
        )
        .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
fun configure(http: HttpSecurity) {
    http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
        oauth2ResourceServer {
            jwt { }
        }
    }
}
----
====

如果应用程序未公开 `WebSecurityConfigurerAdapter` Bean，则Spring Boot将公开上述默认值.

替换它就像在应用程序中公开Bean一样简单:

.Custom JWT Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_message:read")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    .jwtAuthenticationConverter(myConverter())
                )
            );
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("SCOPE_message:read"))
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt {
                    jwtAuthenticationConverter = myConverter()
                }
            }
        }
    }
}
----
====

以上要求 `message:read` 的范围: 以 `/messages/` 开头的所有URL.

`oauth2ResourceServer` DSL上的方法还将覆盖或替换自动配置.

例如，第二个 `@Bean` Spring Boot创建的是 `JwtDecoder`，它将 `String` 令牌解码为经过验证的 `Jwt` 实例:


.JWT Decoder
====
[source,java]
----
@Bean
public JwtDecoder jwtDecoder() {
    return JwtDecoders.fromIssuerLocation(issuerUri);
}
----
====

[NOTE]
调用  `{security-api-url}org/springframework/security/oauth2/jwt/JwtDecoders.html#fromIssuerLocation-java.lang.String-[JwtDecoders#fromIssuerLocation]` 是调用提供者配置或授权服务器元数据端点以扩展 JWK 设置 Uri 的过程.

如果该应用程序未公开 `JwtDecoder` Bean，则Spring Boot将公开上述默认值.

可以使用 `jwkSetUri()` 覆盖其配置，也可以使用 `decoder()` 替换其配置.

或者，如果您根本不使用Spring Boot，那么这两个组件-过滤器链和`JwtDecoder`可以在XML中指定.

过滤器链的指定如下:

.Default JWT Configuration
====
.Xml
[source,xml,role="primary"]
----
<http>
    <intercept-uri pattern="/**" access="authenticated"/>
    <oauth2-resource-server>
        <jwt decoder-ref="jwtDecoder"/>
    </oauth2-resource-server>
</http>
----
====

And the `JwtDecoder` like so:

.JWT Decoder
====
.Xml
[source,xml,role="primary"]
----
<bean id="jwtDecoder"
        class="org.springframework.security.oauth2.jwt.JwtDecoders"
        factory-method="fromIssuerLocation">
    <constructor-arg value="${spring.security.oauth2.resourceserver.jwt.jwk-set-uri}"/>
</bean>
----
====

[[oauth2resourceserver-jwt-jwkseturi-dsl]]
==== 使用 `jwkSetUri()`

授权服务器的JWK设置Uri可以配置为<<oauth2resourceserver-jwt-jwkseturi,as a configuration property>>，也可以在DSL中提供:

.JWK Set Uri Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class DirectlyConfiguredJwkSetUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    .jwkSetUri("https://idp.example.com/.well-known/jwks.json")
                )
            );
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class DirectlyConfiguredJwkSetUri : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt {
                    jwkSetUri = "https://idp.example.com/.well-known/jwks.json"
                }
            }
        }
    }
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <intercept-uri pattern="/**" access="authenticated"/>
    <oauth2-resource-server>
        <jwt jwk-set-uri="https://idp.example.com/.well-known/jwks.json"/>
    </oauth2-resource-server>
</http>
----
====

使用 `jwkSetUri()` 优先于任何配置属性.

[[oauth2resourceserver-jwt-decoder-dsl]]
==== 使用 `decoder()`

比 `jwkSetUri()` 更强大的是 `decoder()`，它将完全替代 `JwtDecoder` 的所有Boot自动配置:

.JWT Decoder Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class DirectlyConfiguredJwtDecoder extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    .decoder(myCustomDecoder())
                )
            );
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class DirectlyConfiguredJwtDecoder : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt {
                    jwtDecoder = myCustomDecoder()
                }
            }
        }
    }
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <intercept-uri pattern="/**" access="authenticated"/>
    <oauth2-resource-server>
        <jwt decoder-ref="myCustomDecoder"/>
    </oauth2-resource-server>
</http>
----
====


当需要进行更深入的配置 (例如<<oauth2resourceserver-jwt-validation,validation>>，<<oauth2resourceserver-jwt-claimsetmapping,mapping>>或<<oauth2resourceserver-jwt-timeouts,request timeouts>>) 时，这非常方便.

[[oauth2resourceserver-jwt-decoder-bean]]
==== 暴露  `JwtDecoder` `@Bean`

或者，公开 `JwtDecoder` `@Bean` 与  `decoder()` 具有相同的效果:

[source,java]
----
@Bean
public JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();
}
----

[[oauth2resourceserver-jwt-decoder-algorithm]]
=== 配置可信算法

默认情况下，`NimbusJwtDecoder` 以及资源服务器将仅使用 `RS256` 信任和验证令牌.

您可以通过<<oauth2resourceserver-jwt-boot-algorithm,Spring Boot>>，<<oauth2resourceserver-jwt-decoder-builder,NimbusJwtDecoder Builder>>或从<<oauth2resourceserver-jwt-decoder-jwk-response,JWK Set response>>中对此进行自定义.

[[oauth2resourceserver-jwt-boot-algorithm]]
==== 通过Spring Boot

设置算法的最简单方法是作为属性:

[source,yaml]
----
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          jws-algorithm: RS512
          jwk-set-uri: https://idp.example.org/.well-known/jwks.json
----

[[oauth2resourceserver-jwt-decoder-builder]]
==== 使用 Builder

但是，为了获得更大的功能，我们可以使用 `NimbusJwtDecoder` 附带的 Builder:

[source,java]
----
@Bean
JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.fromJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).build();
}
----

多次调用 `jwsAlgorithm` 会将 `NimbusJwtDecoder` 配置为信任多个算法，如下所示:

[source,java]
----
@Bean
JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.fromJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).jwsAlgorithm(EC512).build();
}
----

或者，您可以调用 `jwsAlgorithms`:

[source,java]
----
@Bean
JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.fromJwkSetUri(this.jwkSetUri)
            .jwsAlgorithms(algorithms -> {
                    algorithms.add(RS512);
                    algorithms.add(EC512);
            }).build();
}
----

[[oauth2resourceserver-jwt-decoder-jwk-response]]
==== 来自JWK Set的回复

由于Spring Security的JWT支持基于Nimbus，因此您也可以使用其所有出色的功能.

例如，Nimbus有一个 `JWSKeySelector` 实现，它将基于JWK Set URI响应选择算法集.
您可以使用它生成 `NimbusJwtDecoder`，如下所示:

```java
@Bean
public JwtDecoder jwtDecoder() {
    // makes a request to the JWK Set endpoint
    JWSKeySelector<SecurityContext> jwsKeySelector =
            JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(this.jwkSetUrl);

    DefaultJWTProcessor<SecurityContext> jwtProcessor =
            new DefaultJWTProcessor<>();
    jwtProcessor.setJWSKeySelector(jwsKeySelector);

    return new NimbusJwtDecoder(jwtProcessor);
}
```

[[oauth2resourceserver-jwt-decoder-public-key]]
=== 信任单个非对称密钥

比使用JWK Set端点备份资源服务器更简单的方法是对RSA公钥进行硬编码. 可以通过<<oauth2resourceserver-jwt-decoder-public-key-boot,Spring Boot>>或<<oauth2resourceserver-jwt-decoder-public-key-builder,使用Builder>>提供公共密钥.

[[oauth2resourceserver-jwt-decoder-public-key-boot]]
==== 通过 Spring Boot

通过Spring Boot指定密钥非常简单.
密钥的位置可以这样指定:

[source,yaml]
----
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          public-key-location: classpath:my-key.pub
----

或者，为了进行更复杂的查找，可以对 `RsaKeyConversionServicePostProcessor` 进行后置处理:

[source,java]
----
@Bean
BeanFactoryPostProcessor conversionServiceCustomizer() {
    return beanFactory ->
        beanFactory.getBean(RsaKeyConversionServicePostProcessor.class)
                .setResourceLoader(new CustomResourceLoader());
}
----

指定密钥的位置:

```yaml
key.location: hfds://my-key.pub
```

然后自动装配值:

```java
@Value("${key.location}")
RSAPublicKey key;
```

[[oauth2resourceserver-jwt-decoder-public-key-builder]]
==== 使用 Builder

要直接连接 `RSAPublicKey`，只需使用适当的 `NimbusJwtDecoder` builder，如下所示:

```java
@Bean
public JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withPublicKey(this.key).build();
}
```

[[oauth2resourceserver-jwt-decoder-secret-key]]
=== 信任单个对称密钥

使用单个对称密钥也很简单. 您可以简单地加载 `SecretKey` 并使用适当的 `NimbusJwtDecoder` 构建器，如下所示:

[source,java]
----
@Bean
public JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withSecretKey(this.key).build();
}
----

[[oauth2resourceserver-jwt-authorization]]
=== 配置授权

从OAuth 2.0授权服务器发出的JWT通常具有 `scope` 或 `scp` 属性，指示其被授予的作用域 (或权限) ，例如:

`{ ..., "scope" : "messages contacts"}`

在这种情况下，资源服务器将尝试将这些作用域强制为已授予权限的列表，并为每个作用域添加字符串 "SCOPE_" 作为前缀.

这意味着为了保护具有从JWT扩展的作用域的端点或方法，相应的表达式应包含以下前缀:


.Authorization Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class DirectlyConfiguredJwkSetUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .mvcMatchers("/contacts/**").hasAuthority("SCOPE_contacts")
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_messages")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class DirectlyConfiguredJwkSetUri : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/contacts/**", hasAuthority("SCOPE_contacts"))
                authorize("/messages/**", hasAuthority("SCOPE_messages"))
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt { }
            }
        }
    }
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/>
    <intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/>
    <oauth2-resource-server>
        <jwt jwk-set-uri="https://idp.example.org/.well-known/jwks.json"/>
    </oauth2-resource-server>
</http>
----
====


或类似地具有方法安全性:

[source,java]
----
@PreAuthorize("hasAuthority('SCOPE_messages')")
public List<Message> getMessages(...) {}
----

[[oauth2resourceserver-jwt-authorization-extraction]]
==== 手动提取权限

但是，在许多情况下，此默认设置不足.
例如，某些授权服务器不使用 `scope` 属性，而是使用自己的自定义属性.
或者，在其他时候，资源服务器可能需要将属性或属性组成调整为内部化的权限.

为此，DSL公开了 `jwtAuthenticationConverter()`:

.Authorities Extractor Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class DirectlyConfiguredJwkSetUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    .jwtAuthenticationConverter(grantedAuthoritiesExtractor())
                )
            );
    }
}

Converter<Jwt, AbstractAuthenticationToken> grantedAuthoritiesExtractor() {
    JwtAuthenticationConverter jwtAuthenticationConverter =
            new JwtAuthenticationConverter();

    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter
            (new GrantedAuthoritiesExtractor());

    return jwtAuthenticationConverter;
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class DirectlyConfiguredJwkSetUri : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt {
                    jwtAuthenticationConverter = grantedAuthoritiesExtractor()
                }
            }
        }
    }

    private fun grantedAuthoritiesExtractor(): JwtAuthenticationConverter {
        val jwtAuthenticationConverter = JwtAuthenticationConverter()
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(GrantedAuthoritiesExtractor())
        return jwtAuthenticationConverter
    }
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/>
    <intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/>
    <oauth2-resource-server>
        <jwt jwk-set-uri="https://idp.example.org/.well-known/jwks.json"
                jwt-authentication-converter-ref="grantedAuthoritiesExtractor"/>
    </oauth2-resource-server>
</http>

<bean id="grantedAuthoritiesExtractor"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter">
    <property name="jwtGrantedAuthoritiesConverter">
        <bean class="my.custom.GrantedAuthoritiesConverter"/>
    </property>
</bean>
----
====

负责将 `Jwt` 转换为 `Authentication`. 作为其配置的一部分，我们可以提供一个辅助转换器，从 `Jwt` 到授权的 `Collection`.

最终的转换器可能类似于下面的 `GrantedAuthoritiesExtractor`:

[source,java]
----
static class GrantedAuthoritiesExtractor
        implements Converter<Jwt, Collection<GrantedAuthority>> {

    public Collection<GrantedAuthority> convert(Jwt jwt) {
        Collection<?> authorities = (Collection<?>)
                jwt.getClaims().getOrDefault("mycustomclaim", Collections.emptyList());

        return authorities.stream()
                .map(Object::toString)
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}
----

为了获得更大的灵活性，DSL支持使用实现  `Converter<Jwt, AbstractAuthenticationToken>` 的任何类完全替换该转换器:

[source,java]
----
static class CustomAuthenticationConverter implements Converter<Jwt, AbstractAuthenticationToken> {
    public AbstractAuthenticationToken convert(Jwt jwt) {
        return new CustomAuthenticationToken(jwt);
    }
}
----

[[oauth2resourceserver-jwt-validation]]
=== 配置验证

使用<<oauth2resourceserver-jwt-minimalconfiguration,Spring Boot 最小配置>> (指示授权服务器的 issuer uri) ，Resource Server将默认验证 `iss` 声明以及 `exp` 和 `nbf` 时间戳声明.

在需要自定义验证的情况下，资源服务器附带两个标准验证器，并且还接受自定义 `OAuth2TokenValidator` 实例.

[[oauth2resourceserver-jwt-validation-clockskew]]
==== 自定义时间戳验证

JWT通常具有有效期窗口，该窗口的开始在 `nbf` 声明中指示，而结束在 `exp` 声明中指示.

但是，每台服务器都会经历时钟漂移，这可能导致令牌在一个服务器上已经过期，而在另一台服务器上没有过期. 随着分布式系统中服务器数量的增加，这可能会导致某些实现上的不良反应.

资源服务器使用 `JwtTimestampValidator` 验证令牌的有效性窗口，并且可以将它配置为 `ClockSkew` 来缓解上述问题:

[source,java]
----
@Bean
JwtDecoder jwtDecoder() {
     NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder)
             JwtDecoders.fromIssuerLocation(issuerUri);

     OAuth2TokenValidator<Jwt> withClockSkew = new DelegatingOAuth2TokenValidator<>(
            new JwtTimestampValidator(Duration.ofSeconds(60)),
            new IssuerValidator(issuerUri));

     jwtDecoder.setJwtValidator(withClockSkew);

     return jwtDecoder;
}
----

[NOTE]
默认情况下，资源服务器将时钟偏差配置为30秒.

[[oauth2resourceserver-jwt-validation-custom]]
==== 配置自定义验证器

使用 `OAuth2TokenValidator` API为 `aud` 声明添加检查很简单:

[source,java]
----
OAuth2TokenValidator<Jwt> audienceValidator() {
    return new JwtClaimValidator<List<String>>(AUD, aud -> aud.contains("messaging"));
}
----

Or, for more control you can implement your own `OAuth2TokenValidator`:

[source,java]
----
static class AudienceValidator implements OAuth2TokenValidator<Jwt> {
    OAuth2Error error = new OAuth2Error("custom_code", "Custom error message", null);

    @Override
    public OAuth2TokenValidatorResult validate(Jwt jwt) {
        if (jwt.getAudience().contains("messaging")) {
            return OAuth2TokenValidatorResult.success();
        } else {
            return OAuth2TokenValidatorResult.failure(error);
        }
    }
}

// ...

OAuth2TokenValidator<Jwt> audienceValidator() {
    return new AudienceValidator();
}
----

然后，要添加到资源服务器中，只需指定 `JwtDecoder` 实例即可:

[source,java]
----
@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder)
        JwtDecoders.fromIssuerLocation(issuerUri);

    OAuth2TokenValidator<Jwt> audienceValidator = audienceValidator();
    OAuth2TokenValidator<Jwt> withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri);
    OAuth2TokenValidator<Jwt> withAudience = new DelegatingOAuth2TokenValidator<>(withIssuer, audienceValidator);

    jwtDecoder.setJwtValidator(withAudience);

    return jwtDecoder;
}
----

[[oauth2resourceserver-jwt-claimsetmapping]]
=== 配置 Claim (声明)集映射

Spring Security使用 https://bitbucket.org/connect2id/nimbus-jose-jwt/wiki/Home[Nimbus] 库来解析JWT并验证其签名.  因此，Spring Security受制于Nimbus对每个字段值以及如何将每个字段强制转换为Java类型的解释.

例如，由于Nimbus仍与Java 7兼容，因此它不使用 `Instant` 来表示时间戳字段.

而且完全有可能使用其他库或进行JWT处理，这可能会自行做出需要调整的决定.

或者，很简单，出于特定于域的原因，资源服务器可能希望从JWT中添加或删除声明.

为此，资源服务器支持将JWT声明集与 `MappedJwtClaimSetConverter` 映射.

[[oauth2resourceserver-jwt-claimsetmapping-singleclaim]]
==== 自定义单个 Claim 的转换

默认情况下，`MappedJwtClaimSetConverter` 将尝试将 claims 强制为以下类型:

|============
| Claim | Java Type
| `aud` | `Collection<String>`
| `exp` | `Instant`
| `iat` | `Instant`
| `iss` | `String`
| `jti` | `String`
| `nbf` | `Instant`
| `sub` | `String`
|============

可以使用  `MappedJwtClaimSetConverter.withDefaults` 配置单个声明的转化策略:

```java
@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();

    MappedJwtClaimSetConverter converter = MappedJwtClaimSetConverter
            .withDefaults(Collections.singletonMap("sub", this::lookupUserIdBySub));
    jwtDecoder.setClaimSetConverter(converter);

    return jwtDecoder;
}
```

这将保留所有默认值，除了它将覆盖 `sub` 的默认声明转换器.

[[oauth2resourceserver-jwt-claimsetmapping-add]]
==== 添加一个 Claim

`MappedJwtClaimSetConverter` 也可以用于添加自定义声明，例如，以适应现有系统:

```java
MappedJwtClaimSetConverter.withDefaults(Collections.singletonMap("custom", custom -> "value"));
```

[[oauth2resourceserver-jwt-claimsetmapping-remove]]
==== 删除一个 Claim

使用相同的API删除声明也很简单:

```java
MappedJwtClaimSetConverter.withDefaults(Collections.singletonMap("legacyclaim", legacy -> null));
```

[[oauth2resourceserver-jwt-claimsetmapping-rename]]
==== 重命名一个 Claim

在更复杂的场景中，例如一次查询多个声明或重命名一个声明，资源服务器接受任何实现 `Converter<Map<String, Object>, Map<String,Object>>` 的类:

```java
public class UsernameSubClaimAdapter implements Converter<Map<String, Object>, Map<String, Object>> {
    private final MappedJwtClaimSetConverter delegate =
            MappedJwtClaimSetConverter.withDefaults(Collections.emptyMap());

    public Map<String, Object> convert(Map<String, Object> claims) {
        Map<String, Object> convertedClaims = this.delegate.convert(claims);

        String username = (String) convertedClaims.get("user_name");
        convertedClaims.put("sub", username);

        return convertedClaims;
    }
}
```

然后，可以像平常一样提供实例:

```java
@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();
    jwtDecoder.setClaimSetConverter(new UsernameSubClaimAdapter());
    return jwtDecoder;
}
```

[[oauth2resourceserver-jwt-timeouts]]
=== 配置超时

默认情况下，资源服务器使用30秒钟的连接和套接字超时来与授权服务器进行协调.

在某些情况下，这可能太短了.  此外，它没有考虑退避和发现等更复杂的模式.

为了调整资源服务器连接到授权服务器的方式，`NimbusJwtDecoder` 接受 `RestOperations` 的实例:

```java
@Bean
public JwtDecoder jwtDecoder(RestTemplateBuilder builder) {
    RestOperations rest = builder
            .setConnectionTimeout(60000)
            .setReadTimeout(60000)
            .build();

    NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).restOperations(rest).build();
    return jwtDecoder;
}
```

[[oauth2resourceserver-opaque-minimalconfiguration]]
===  Introspection 最小配置

通常，opaque token 可以通过授权服务器托管的 https://tools.ietf.org/html/rfc7662[OAuth 2.0 Introspection Endpoint]进行验证. 当需要撤销时，这可能很方便.

使用 https://spring.io/projects/spring-boot[Spring Boot] 时，将应用程序配置为使用内省的资源服务器包括两个基本步骤. 首先，包括所需的依赖性，其次，指示内省端点详细信息.

[[oauth2resourceserver-opaque-introspectionuri]]
==== 指定授权服务器

要指定内省端点的位置，只需执行以下操作:

[source,yaml]
----
security:
  oauth2:
    resourceserver:
      opaque-token:
        introspection-uri: https://idp.example.com/introspect
        client-id: client
        client-secret: secret
----

其中 `https://idp.example.com/introspect` 是授权服务器托管的内省端点，而 `client-id` 和 `client-secret` 是击中该端点所需的凭据.

资源服务器将使用这些属性进一步进行自我配置，并随后验证传入的JWT.

[NOTE]
使用内省时，授权服务器的字眼就是法律.  如果授权服务器响应令牌是有效的，那么令牌是有效的.

就是这样！

==== 启动时预期

使用此属性和这些依赖关系时，资源服务器将自动配置自身以验证不透明承载令牌.

该启动过程比JWT的启动过程简单得多，因为不需要发现端点，也不需要添加其他验证规则.

==== 运行时预期

应用程序启动后，资源服务器将尝试处理任何包含 `Authorization: Bearer` 头的请求:

```http
GET / HTTP/1.1
Authorization: Bearer some-token-value # Resource Server will process this
```

只要指示了此方案，资源服务器就会尝试根据Bearer Token规范处理请求.

给定一个不透明的令牌，资源服务器将

1. 使用提供的凭据和令牌查询提供的内省端点
2. 检查响应是否为  `{ 'active' : true }`  属性
3. 将每个范围映射到具有前缀 `SCOPE_` 的权限

默认情况下，生成的  `Authentication#getPrincipal` 是Spring Security   `{security-api-url}org/springframework/security/oauth2/core/OAuth2AuthenticatedPrincipal.html[OAuth2AuthenticatedPrincipal]`  对象，并且 `Authentication#getName` 映射到令牌的 `sub` 属性 (如果存在) .

从这里，您可能要跳转到:

* <<oauth2resourceserver-opaque-attributes,查找身份验证后的属性>>
* <<oauth2resourceserver-opaque-authorization-extraction,手动提取权限>>
* <<oauth2resourceserver-opaque-jwt-introspector,对JWT使用内省>>

[[oauth2resourceserver-opaque-attributes]]
=== 查找身份验证后的属性

令牌通过身份验证后，将在 `SecurityContext` 中设置 `BearerTokenAuthentication` 的实例.

这意味着在配置中使用 `@EnableWebMvc` 时，它可以在 `@Controller` 方法中使用:

[source,java]
----
@GetMapping("/foo")
public String foo(BearerTokenAuthentication authentication) {
    return authentication.getTokenAttributes().get("sub") + " is the subject";
}
----

由于 `BearerTokenAuthentication` 拥有 `OAuth2AuthenticatedPrincipal`，这也意味着它也可用于控制器方法:

[source,java]
----
@GetMapping("/foo")
public String foo(@AuthenticationPrincipal OAuth2AuthenticatedPrincipal principal) {
    return principal.getAttribute("sub") + " is the subject";
}
----

==== 通过SpEL查找属性

当然，这也意味着可以通过SpEL访问属性.

例如，如果使用 `@EnableGlobalMethodSecurity` 以便可以使用 `@PreAuthorize` 注解，则可以执行以下操作:


```java
@PreAuthorize("principal?.attributes['sub'] == 'foo'")
public String forFoosEyesOnly() {
    return "foo";
}
```

[[oauth2resourceserver-opaque-sansboot]]
=== 覆盖或替换自动配置

Spring Boot代表Resource Server生成了两个 `@Bean`.

第一个是将应用程序配置为资源服务器的 `WebSecurityConfigurerAdapter`. 使用 Opaque Token 时，此 `WebSecurityConfigurerAdapter` 如下所示:

.Default Opaque Token Configuration
====
.Java
[source,java,role="primary"]
----
protected void configure(HttpSecurity http) {
    http
        .authorizeRequests(authorize -> authorize
            .anyRequest().authenticated()
        )
        .oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken);
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
override fun configure(http: HttpSecurity) {
    http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
        oauth2ResourceServer {
            opaqueToken { }
        }
    }
}
----
====

如果应用程序未公开 `WebSecurityConfigurerAdapter` Bean，则Spring Boot将公开上述默认值.

替换它就像在应用程序中公开Bean一样简单:

.Custom Opaque Token Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_message:read")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .opaqueToken(opaqueToken -> opaqueToken
                    .introspector(myIntrospector())
                )
            );
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("SCOPE_message:read"))
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                opaqueToken {
                    introspector = myIntrospector()
                }
            }
        }
    }
}
----
====

以上要求 `message:read` 的范围: 以 `/messages/` 开头的所有URL.

`oauth2ResourceServer` DSL上的方法还将覆盖或替换自动配置.

例如，第二个 `@Bean` Spring Boot创建的是一个 `OpaqueTokenIntrospector`，它将 `String` 令牌解码为 `OAuth2AuthenticatedPrincipal` 的经过验证的实例:

[source,java]
----
@Bean
public OpaqueTokenIntrospector introspector() {
    return new NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret);
}
----

如果应用程序未公开 `OpaqueTokenIntrospector` Bean，则Spring Boot将公开以上默认的bean.

可以使用 `introspectionUri()` 和 `introspectionClientCredentials()` 覆盖其配置，也可以使用 `introspector()` 替换其配置.

或者，如果您根本不使用Spring Boot，那么这两个组件-过滤器链和`OpaqueTokenIntrospector`都可以用XML指定.

过滤器链的指定如下:

.Default Opaque Token Configuration
====
.Xml
[source,xml,role="primary"]
----
<http>
    <intercept-uri pattern="/**" access="authenticated"/>
    <oauth2-resource-server>
        <opaque-token introspector-ref="opaqueTokenIntrospector"/>
    </oauth2-resource-server>
</http>
----
====

And the `OpaqueTokenIntrospector` like so:

.Opaque Token Introspector
====
.Xml
[source,xml,role="primary"]
----
<bean id="opaqueTokenIntrospector"
        class="org.springframework.security.oauth2.server.resource.introspection.NimbusOpaqueTokenIntrospector">
    <constructor-arg value="${spring.security.oauth2.resourceserver.opaquetoken.introspection_uri}"/>
    <constructor-arg value="${spring.security.oauth2.resourceserver.opaquetoken.client_id}"/>
    <constructor-arg value="${spring.security.oauth2.resourceserver.opaquetoken.client_secret}"/>
</bean>
----
====

[[oauth2resourceserver-opaque-introspectionuri-dsl]]
==== 使用 `introspectionUri()`


授权服务器的Introspection Uri可以配置为<<oauth2resourceserver-opaque-introspectionuri,配置属性>>，也可以在DSL中提供:

.Introspection URI Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class DirectlyConfiguredIntrospectionUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .opaqueToken(opaqueToken -> opaqueToken
                    .introspectionUri("https://idp.example.com/introspect")
                    .introspectionClientCredentials("client", "secret")
                )
            );
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class DirectlyConfiguredIntrospectionUri : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                opaqueToken {
                    introspectionUri = "https://idp.example.com/introspect"
                    introspectionClientCredentials("client", "secret")
                }
            }
        }
    }
}
----

.Xml
[source,xml,role="secondary"]
----
<bean id="opaqueTokenIntrospector"
        class="org.springframework.security.oauth2.server.resource.introspection.NimbusOpaqueTokenIntrospector">
    <constructor-arg value="https://idp.example.com/introspect"/>
    <constructor-arg value="client"/>
    <constructor-arg value="secret"/>
</bean>
----
====

使用 `introspectionUri()` 优先于任何配置属性.

[[oauth2resourceserver-opaque-introspector-dsl]]
==== 使用 `introspector()`

比 `introspectionUri()` 更强大的是 `introspector()` ，它将完全替代 `OpaqueTokenIntrospector` 的所有Boot自动配置:

.Introspector Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class DirectlyConfiguredIntrospector extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .opaqueToken(opaqueToken -> opaqueToken
                    .introspector(myCustomIntrospector())
                )
            );
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class DirectlyConfiguredIntrospector : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                opaqueToken {
                    introspector = myCustomIntrospector()
                }
            }
        }
    }
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <intercept-uri pattern="/**" access="authenticated"/>
    <oauth2-resource-server>
        <opaque-token introspector-ref="myCustomIntrospector"/>
    </oauth2-resource-server>
</http>
----
====

当需要更深入的配置 (例如<<oauth2resourceserver-opaque-authorization-extraction,权限映射>>, <<oauth2resourceserver-opaque-jwt-introspector,JWT吊销>>, 或 <<oauth2resourceserver-opaque-timeouts,请求超时>>) 时，这很方便.

[[oauth2resourceserver-opaque-introspector-bean]]
==== 公开 `OpaqueTokenIntrospector` `@Bean`

或者，公开 `OpaqueTokenIntrospector`  `@Bean` 与 `introspector()` 具有相同的效果:

[source,java]
----
@Bean
public OpaqueTokenIntrospector introspector() {
    return new NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret);
}
----

[[oauth2resourceserver-opaque-authorization]]
=== 配置授权

OAuth 2.0内省端点通常会返回一个 `scope` 属性，指示其被授予的范围 (或权限) ，例如:

`{ ..., "scope" : "messages contacts"}`

在这种情况下，资源服务器将尝试将这些作用域强制为已授予权限的列表，并为每个作用域添加字符串 "SCOPE_" 作为前缀.

这意味着要保护具有不透明令牌扩展范围的端点或方法，相应的表达式应包含以下前缀:

.Authorization Opaque Token Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class MappedAuthorities extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorizeRequests -> authorizeRequests
                .mvcMatchers("/contacts/**").hasAuthority("SCOPE_contacts")
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_messages")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken);
    }
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/>
    <intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/>
    <oauth2-resource-server>
        <opaque-token introspector-ref="opaqueTokenIntrospector"/>
    </oauth2-resource-server>
</http>
----
====

或类似地具有方法安全性:

```java
@PreAuthorize("hasAuthority('SCOPE_messages')")
public List<Message> getMessages(...) {}
```

[[oauth2resourceserver-opaque-authorization-extraction]]
==== 手动提取权限

默认情况下，Opaque Token 支持将从内省响应中提取范围声明，并将其解析为各个 `GrantedAuthority` 实例.

例如，如果内省响应为:

[source,json]
----
{
    "active" : true,
    "scope" : "message:read message:write"
}
----

然后，资源服务器将生成具有两个权限的  `Authentication` ，一个权限用于  `message:read` ，另一个权限用于 `message:write`.

当然，这可以使用自定义的 `OpaqueTokenIntrospector` 进行自定义，该 `OpaqueTokenIntrospector` 查看属性集并以自己的方式进行转换:

[source,java]
----
public class CustomAuthoritiesOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");

    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal principal = this.delegate.introspect(token);
        return new DefaultOAuth2AuthenticatedPrincipal(
                principal.getName(), principal.getAttributes(), extractAuthorities(principal));
    }

    private Collection<GrantedAuthority> extractAuthorities(OAuth2AuthenticatedPrincipal principal) {
        List<String> scopes = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE);
        return scopes.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}
----

此后，可以通过将其公开为 `@Bean` 来简单地配置此自定义内省器:

[source,java]
----
@Bean
public OpaqueTokenIntrospector introspector() {
    return new CustomAuthoritiesOpaqueTokenIntrospector();
}
----

[[oauth2resourceserver-opaque-timeouts]]
=== 配置超时

默认情况下，资源服务器使用30秒钟的连接和套接字超时来与授权服务器进行协调.

在某些情况下，这可能太短了.
此外，它不考虑退避和发现等更复杂的模式.

为了调整资源服务器连接到授权服务器的方式，`NimbusOpaqueTokenIntrospector` 接受 `RestOperations` 的实例:

```java
@Bean
public OpaqueTokenIntrospector introspector(RestTemplateBuilder builder) {
    RestOperations rest = builder
            .basicAuthentication(clientId, clientSecret)
            .setConnectionTimeout(60000)
            .setReadTimeout(60000)
            .build();

    return new NimbusOpaqueTokenIntrospector(introspectionUri, rest);
}
```

[[oauth2resourceserver-opaque-jwt-introspector]]
=== 对JWT使用内省

一个常见的问题是内省是否与JWT兼容.
Spring Security的Opaque令牌支持被设计为不关心令牌的格式-它将很乐意将任何令牌传递给提供的内省端点.

因此，假设您有一个要求，如果JWT被吊销，则要求您在每个请求中与授权服务器进行核对.

即使您为令牌使用JWT格式，您的验证方法也是内省的，这意味着您想要执行以下操作:

[source,yaml]
----
spring:
  security:
    oauth2:
      resourceserver:
        opaque-token:
          introspection-uri: https://idp.example.org/introspection
          client-id: client
          client-secret: secret
----

在这种情况下，得到的  `Authentication` 将是 `BearerTokenAuthentication`.
相应的 `OAuth2AuthenticatedPrincipal` 中的任何属性将是内省端点返回的任何属性.

但是，可以说，奇怪的是，内省端点仅返回令牌是否处于 active 状态.
怎么办?

在这种情况下，您可以创建一个自定义的 `OpaqueTokenIntrospector`，它仍然会命中端点，但是随后更新返回的主体以将JWT声明作为属性:

[source,java]
----
public class JwtOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private JwtDecoder jwtDecoder = new NimbusJwtDecoder(new ParseOnlyJWTProcessor());

    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal principal = this.delegate.introspect(token);
        try {
            Jwt jwt = this.jwtDecoder.decode(token);
            return new DefaultOAuth2AuthenticatedPrincipal(jwt.getClaims(), NO_AUTHORITIES);
        } catch (JwtException e) {
            throw new OAuth2IntrospectionException(e);
        }
    }

    private static class ParseOnlyJWTProcessor extends DefaultJWTProcessor<SecurityContext> {
    	JWTClaimsSet process(SignedJWT jwt, SecurityContext context)
                throws JOSEException {
            return jwt.getJWTClaimSet();
        }
    }
}
----

此后，可以通过将其公开为 `@Bean` 来简单地配置此自定义内省器:

[source,java]
----
@Bean
public OpaqueTokenIntrospector introspector() {
    return new JwtOpaqueTokenIntropsector();
}
----

[[oauth2resourceserver-opaque-userinfo]]
=== 调用 `/userinfo` 端点

一般来说，资源服务器不在乎底层用户，而在乎已授予的权限.

就是说，有时将授权声明绑定到用户可能很有价值.

如果应用程序还使用 `spring-security-oauth2-client` 并设置了适当的 `ClientRegistrationRepository`，则使用自定义的 `OpaqueTokenIntrospector` 非常简单.  下面的实现实现了三件事:

* 委托内省端点确认令牌的有效性
* 查找与 `/userinfo` 端点关联的适当的客户端注册
* 调用并返回来自 `/userinfo` 端点的响应

[source,java]
----
public class UserInfoOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private final OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private final OAuth2UserService oauth2UserService = new DefaultOAuth2UserService();

    private final ClientRegistrationRepository repository;

    // ... constructor

    @Override
    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal authorized = this.delegate.introspect(token);
        Instant issuedAt = authorized.getAttribute(ISSUED_AT);
        Instant expiresAt = authorized.getAttribute(EXPIRES_AT);
        ClientRegistration clientRegistration = this.repository.findByRegistrationId("registration-id");
        OAuth2AccessToken token = new OAuth2AccessToken(BEARER, token, issuedAt, expiresAt);
        OAuth2UserRequest oauth2UserRequest = new OAuth2UserRequest(clientRegistration, token);
        return this.oauth2UserService.loadUser(oauth2UserRequest);
    }
}
----

如果您不使用 `spring-security-oauth2-client`，它仍然非常简单.  您只需要使用您自己的 `WebClient` 实例调用 `/userinfo`:

[source,java]
----
public class UserInfoOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private final OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private final WebClient rest = WebClient.create();

    @Override
    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal authorized = this.delegate.introspect(token);
        return makeUserInfoRequest(authorized);
    }
}
----

无论哪种方式，在创建 `OpaqueTokenIntrospector` 之后，都应该将其发布为 `@Bean` 来覆盖默认值:

[source,java]
----
@Bean
OpaqueTokenIntrospector introspector() {
    return new UserInfoOpaqueTokenIntrospector(...);
}
----

[[oauth2reourceserver-opaqueandjwt]]
=== 同时支持 JWT 和 Opaque Token

在某些情况下，您可能需要访问两种令牌.  例如，您可能支持多个租户，其中一个租户发布JWT，其他租户发布不透明令牌.

如果必须在请求时做出此决定，则可以使用 `AuthenticationManagerResolver` 来实现，如下所示:

[source,java]
----
@Bean
AuthenticationManagerResolver<HttpServletRequest> tokenAuthenticationManagerResolver() {
    BearerTokenResolver bearerToken = new DefaultBearerTokenResolver();
    JwtAuthenticationProvider jwt = jwt();
    OpaqueTokenAuthenticationProvider opaqueToken = opaqueToken();

    return request -> {
        String token = bearerToken.resolve(request);
        if (isAJwt(token)) {
            return jwt::authenticate;
        } else {
            return opaqueToken::authenticate;
        }
    }
}
----

然后在DSL中指定此 `AuthenticationManagerResolver`:

.Authentication Manager Resolver
====
.Java
[source,java,role="primary"]
----
http
    .authorizeRequests(authorize -> authorize
        .anyRequest().authenticated()
    )
    .oauth2ResourceServer(oauth2 -> oauth2
        .authenticationManagerResolver(this.tokenAuthenticationManagerResolver)
    );
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <oauth2-resource-server authentication-manager-resolver-ref="tokenAuthenticationManagerResolver"/>
</http>
----
====

[[oauth2resourceserver-multitenancy]]
=== 多租户

当存在多种验证承载令牌的策略时，资源服务器被视为多租户，并以某些租户标识符为关键字.

例如，您的资源服务器可能接受来自两个不同授权服务器的承载令牌.  或者，您的授权服务器可能代表多个发行者.

在每种情况下，都需要完成两件事，并且要与选择的方式进行权衡:

1. 解析租户
2. 传播租户

==== 通过 Claim 解析租户

区分租户的一种方法是通过 issuer claim.  由于签发者的声明伴随着已签名的JWT，因此可以通过 `JwtIssuerAuthenticationManagerResolver` 来完成，如下所示:

.Multitenancy Tenant by JWT Claim
====
.Java
[source,java,role="primary"]
----
JwtIssuerAuthenticationManagerResolver authenticationManagerResolver = new JwtIssuerAuthenticationManagerResolver
    ("https://idp.example.org/issuerOne", "https://idp.example.org/issuerTwo");

http
    .authorizeRequests(authorize -> authorize
        .anyRequest().authenticated()
    )
    .oauth2ResourceServer(oauth2 -> oauth2
        .authenticationManagerResolver(authenticationManagerResolver)
    );
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <oauth2-resource-server authentication-manager-resolver-ref="authenticationManagerResolver"/>
</http>

<bean id="authenticationManagerResolver"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtIssuerAuthenticationManagerResolver">
    <constructor-arg>
        <list>
            <value>https://idp.example.org/issuerOne</value>
            <value>https://idp.example.org/issuerTwo</value>
        </list>
    </constructor-arg>
</bean>
----
====

这很好，因为发布者端点是延迟加载的.  实际上，仅当发送带有相应发行者的第一个请求时，才会实例化相应的JwtAuthenticationProvider.  这样就可以启动应用程序，而与启动并可用的那些授权服务器无关.

===== 动态租户

当然，您可能不想在每次添加新租户时都重新启动应用程序.  在这种情况下，可以使用 `AuthenticationManager` 实例的存储库配置 `JwtIssuerAuthenticationManagerResolver`，您可以在运行时对其进行编辑，如下所示:

[source,java]
----
private void addManager(Map<String, AuthenticationManager> authenticationManagers, String issuer) {
	JwtAuthenticationProvider authenticationProvider = new JwtAuthenticationProvider
	        (JwtDecoders.fromIssuerLocation(issuer));
	authenticationManagers.put(issuer, authenticationProvider::authenticate);
}

// ...

JwtIssuerAuthenticationManagerResolver authenticationManagerResolver =
        new JwtIssuerAuthenticationManagerResolver(authenticationManagers::get);

http
    .authorizeRequests(authorize -> authorize
        .anyRequest().authenticated()
    )
    .oauth2ResourceServer(oauth2 -> oauth2
        .authenticationManagerResolver(authenticationManagerResolver)
    );
----

在这种情况下，您可以使用给定 issuer 的策略来构造 `JwtIssuerAuthenticationManagerResolver`，以获取 `AuthenticationManager`.  这种方法使我们可以在运行时从存储库中添加和删除元素 (如片段中的Map所示) .

NOTE: 仅选择任何 issuer 并从中构造 `AuthenticationManager` 是不安全的.  issuer 应该是代码可以从白名单之类的受信任来源进行验证的发行者.

===== 仅解析一次 Claim

您可能已经观察到，这种策略虽然简单，但是却存在一个折衷，即JWT由 `AuthenticationManagerResolver` 解析一次，然后由 `JwtDecoder` 解析.

通过直接使用Nimbus的 `JWTClaimSetAwareJWSKeySelector` 配置 `JwtDecoder` 可以减轻这种额外的解析:

[source,java]
----
@Component
public class TenantJWSKeySelector
    implements JWTClaimSetAwareJWSKeySelector<SecurityContext> {

	private final TenantRepository tenants; <1>
	private final Map<String, JWSKeySelector<SecurityContext>> selectors = new ConcurrentHashMap<>(); <2>

	public TenantJWSKeySelector(TenantRepository tenants) {
		this.tenants = tenants;
	}

	@Override
	public List<? extends Key> selectKeys(JWSHeader jwsHeader, JWTClaimsSet jwtClaimsSet, SecurityContext securityContext)
			throws KeySourceException {
		return this.selectors.computeIfAbsent(toTenant(jwtClaimsSet), this::fromTenant)
				.selectJWSKeys(jwsHeader, securityContext);
	}

	private String toTenant(JWTClaimsSet claimSet) {
		return (String) claimSet.getClaim("iss");
	}

	private JWSKeySelector<SecurityContext> fromTenant(String tenant) {
		return Optional.ofNullable(this.tenantRepository.findById(tenant)) <3>
		        .map(t -> t.getAttrbute("jwks_uri"))
				.map(this::fromUri)
				.orElseThrow(() -> new IllegalArgumentException("unknown tenant"));
	}

	private JWSKeySelector<SecurityContext> fromUri(String uri) {
		try {
			return JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(new URL(uri)); <4>
		} catch (Exception e) {
			throw new IllegalArgumentException(e);
		}
	}
}
----
<1> 租户信息的假想来源
<2> `JWKKeySelector` 的缓存，由租户标识符输入
<3> 查找租户比简单地即时计算JWK Set端点更安全-查找充当租户白名单
<4> 通过从JWK Set端点返回的密钥类型创建一个 `JWSKeySelector` -此处的延迟查找意味着您不需要在启动时配置所有租户

上面的按键选择器由许多按键选择器组成.
它根据JWT中的 `iss` 声明选择要使用的键选择器.

NOTE: 要使用此方法，请确保将授权服务器配置为包括声明集作为令牌签名的一部分.
没有这个，您就不能保证发行人不会被坏演员改变.

接下来，我们可以构造一个 `JWTProcessor`:

[source,java]
----
@Bean
JWTProcessor jwtProcessor(JWTClaimSetJWSKeySelector keySelector) {
	ConfigurableJWTProcessor<SecurityContext> jwtProcessor =
            new DefaultJWTProcessor();
	jwtProcessor.setJWTClaimSetJWSKeySelector(keySelector);
	return jwtProcessor;
}
----

如您所见，将租户意识降低到此级别的权衡是更多配置.
我们还有一点.

接下来，我们仍然要确保您正在验证发行人.
但是，由于每个JWT的颁发者可能有所不同，因此，您还需要一个支持租户的验证器:

[source,java]
----
@Component
public class TenantJwtIssuerValidator implements OAuth2TokenValidator<Jwt> {
	private final TenantRepository tenants;
	private final Map<String, JwtIssuerValidator> validators = new ConcurrentHashMap<>();

	public TenantJwtIssuerValidator(TenantRepository tenants) {
		this.tenants = tenants;
	}

	@Override
	public OAuth2TokenValidatorResult validate(Jwt token) {
		return this.validators.computeIfAbsent(toTenant(token), this::fromTenant)
				.validate(token);
	}

	private String toTenant(Jwt jwt) {
		return jwt.getIssuer();
	}

	private JwtIssuerValidator fromTenant(String tenant) {
		return Optional.ofNullable(this.tenants.findById(tenant))
		        .map(t -> t.getAttribute("issuer"))
				.map(JwtIssuerValidator::new)
				.orElseThrow(() -> new IllegalArgumentException("unknown tenant"));
	}
}
----

现在我们有了一个可以识别租户的处理器和一个可以识别租户的验证器，我们可以继续创建 `JwtDecoder` 了:

[source,java]
----
@Bean
JwtDecoder jwtDecoder(JWTProcessor jwtProcessor, OAuth2TokenValidator<Jwt> jwtValidator) {
	NimbusJwtDecoder decoder = new NimbusJwtDecoder(processor);
	OAuth2TokenValidator<Jwt> validator = new DelegatingOAuth2TokenValidator<>
			(JwtValidators.createDefault(), this.jwtValidator);
	decoder.setJwtValidator(validator);
	return decoder;
}
----

我们已经结束了有关解决租户的讨论.

如果选择按请求材料解决租户，则需要确保以相同的方式访问下游资源服务器.
例如，如果要按子域进行解析，则需要使用相同的子域来寻址下游资源服务器.

但是，如果您通过不记名令牌中的声明解决该问题，请继续阅读以了解<<oauth2resourceserver-bearertoken-resolver,Spring Security's support for bearer token propagation>>.

[[oauth2resourceserver-bearertoken-resolver]]
=== Bearer Token 解析

默认情况下，资源服务器在 `Authorization` 头中查找 bearer 令牌.
但是，可以通过两种方式进行自定义.

==== 从自定义请求头读取 bearer 令牌

例如，您可能需要从自定义请求头读取 bearer 令牌
为此，您可以将 `HeaderBearerTokenResolver` 实例连接到DSL，如以下示例所示:

.Custom Bearer Token Header
====
.Java
[source,java,role="primary"]
----
http
    .oauth2ResourceServer(oauth2 -> oauth2
        .bearerTokenResolver(new HeaderBearerTokenResolver("x-goog-iap-jwt-assertion"))
    );
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <oauth2-resource-server bearer-token-resolver-ref="bearerTokenResolver"/>
</http>

<bean id="bearerTokenResolver"
        class="org.springframework.security.oauth2.server.resource.web.HeaderBearerTokenResolver">
    <constructor-arg value="x-goog-iap-jwt-assertion"/>
</bean>
----
====

==== 从表单参数读取 bearer 令牌

或者，您可能希望从表单参数中读取令牌，可以通过配置 `DefaultBearerTokenResolver` 来完成，如下所示:

.Form Parameter Bearer Token
====
.Java
[source,java,role="primary"]
----
DefaultBearerTokenResolver resolver = new DefaultBearerTokenResolver();
resolver.setAllowFormEncodedBodyParameter(true);
http
    .oauth2ResourceServer(oauth2 -> oauth2
        .bearerTokenResolver(resolver)
    );
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <oauth2-resource-server bearer-token-resolver-ref="bearerTokenResolver"/>
</http>

<bean id="bearerTokenResolver"
        class="org.springframework.security.oauth2.server.resource.web.HeaderBearerTokenResolver">
    <property name="allowFormEncodedBodyParameter" value="true"/>
</bean>
----
====

=== Bearer Token 传递

现在您已经拥有了一个 Bearer 令牌，将它传递给下游服务可能会很方便.
使用 `{security-api-url}org/springframework/security/oauth2/server/resource/web/reactive/function/client/ServletBearerExchangeFilterFunction.html[ServletBearerExchangeFilterFunction]` 非常简单，您可以在以下示例中看到它:

[source,java]
----
@Bean
public WebClient rest() {
    return WebClient.builder()
            .filter(new ServletBearerExchangeFilterFunction())
            .build();
}
----

当上述 `WebClient` 用于执行请求时，Spring Security将查找当前的 `Authentication` 并提取任何 `AbstractOAuth2Token` 凭据.  然后，它将在授权请求头中传递该令牌.

例如:

[source,java]
----
this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .retrieve()
        .bodyToMono(String.class)
        .block()
----

将调用  `https://other-service.example.com/endpoint`， 为您添加 Bearer 令牌授权 `Authorization`  头.

在您需要覆盖此行为的地方，您可以自己提供请求头，这很简单，例如:

[source,java]
----
this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .headers(headers -> headers.setBearerAuth(overridingToken))
        .retrieve()
        .bodyToMono(String.class)
        .block()
----

在这种情况下，过滤器将回退并将请求转发到Web过滤器链的其余部分.

[NOTE]
与 https://docs.spring.io/spring-security/site/docs/current-SNAPSHOT/api/org/springframework/security/oauth2/client/web/reactive/function/client/ServletOAuth2AuthorizedClientExchangeFilterFunction.html[OAuth 2.0 Client filter function]功能不同，此过滤器功能不会在令牌过期时尝试更新令牌.  要获得此级别的支持，请使用OAuth 2.0客户端过滤器.

==== `RestTemplate` 支持

目前尚无对 `RestTemplate` 的专门支持，但您可以使用自己的拦截器非常简单地实现传播:

[source,java]
----
@Bean
RestTemplate rest() {
	RestTemplate rest = new RestTemplate();
	rest.getInterceptors().add((request, body, execution) -> {
		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
		if (authentication == null) {
			return execution.execute(request, body);
		}

		if (!(authentication.getCredentials() instanceof AbstractOAuth2Token)) {
			return execution.execute(request, body);
		}

		AbstractOAuth2Token token = (AbstractOAuth2Token) authentication.getCredentials();
	    request.getHeaders().setBearerAuth(token.getTokenValue());
	    return execution.execute(request, body);
	});
	return rest;
}
----

[[oauth2resourceserver-bearertoken-failure]]
=== Bearer Token 失败

bearer token 可能由于多种原因而无效.  例如，令牌可能失效.

在这种情况下，资源服务器会抛出 `InvalidBearerTokenException`.
与其他例外一样，这会导致OAuth 2.0 bearer token 错误响应:

[source,http request]
----
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer error_code="invalid_token", error_description="Unsupported algorithm of none", error_uri="https://tools.ietf.org/html/rfc6750#section-3.1"
----

此外，它以 `AuthenticationFailureBadCredentialsEvent` 的形式发布，您可以像这样: <<servlet-events,监听您的应用程序>>

[source,java]
----
@Component
public class FailureEvents {
	@EventListener
    public void onFailure(AuthenticationFailureEvent failure) {
		if (badCredentials.getAuthentication() instanceof BearerTokenAuthenticationToken) {
		    // ... handle
        }
    }
}
----