[[servlet-authentication-form]]
= 表单登录

Spring Security 支持通过 html 表单提供的用户名和密码.  本节详细介绍了基于表单的身份验证在 Spring Security 中的工作方式.

让我们看看基于表单的登录在 Spring Security 中如何工作.  首先，我们了解如何将用户重定向到登录表单.
// FIXME: describe authenticationentrypoint, authenticationfailurehandler, authenticationsuccesshandler

.重定向到登录页
image::{figures}/loginurlauthenticationentrypoint.png[]

该图基于  <<servlet-securityfilterchain,`SecurityFilterChain`>>.

image:{icondir}/number_1.png[] 首先，未经过身份验证和授权的用户向 `/private` 资源发起请求.

image:{icondir}/number_2.png[] Spring Security 的 <<servlet-authorization-filtersecurityinterceptor,`FilterSecurityInterceptor`>> 通过抛出 `AccessDeniedException` 来指示未经身份验证的请求被拒绝.

image:{icondir}/number_3.png[] 由于未对用户进行身份验证，因此 <<servlet-exceptiontranslationfilter,`ExceptionTranslationFilter`>>  会启动 "开始身份验证"，并使用配置的  <<servlet-authentication-authenticationentrypoint,`AuthenticationEntryPoint`>> 将重定向发送到登录页面.  在大多数情况下，{security-api-url}org/springframework/security/web/authentication/LoginUrlAuthenticationEntryPoint.html[`LoginUrlAuthenticationEntryPoint`]  是 `AuthenticationEntryPoint`  的实例.

image:{icondir}/number_4.png[] 然后，浏览器将请求将其重定向到的登录页面.

image:{icondir}/number_5.png[] 应用程序中的某些内容必须<<servlet-authentication-form-custom,呈现登录页面>>.  .

[[servlet-authentication-usernamepasswordauthenticationfilter]]
提交用户名和密码后，`UsernamePasswordAuthenticationFilter` 会对用户名和密码进行身份验证.  `UsernamePasswordAuthenticationFilter` 扩展了 <<servlet-authentication-abstractprocessingfilter,AbstractAuthenticationProcessingFilter>>，因此此图看起来应该非常相似.

.Authenticating Username and Password
image::{figures}/usernamepasswordauthenticationfilter.png[]

该图基于 <<servlet-securityfilterchain,`SecurityFilterChain`>>.

image:{icondir}/number_1.png[] 当用户提交其用户名和密码时，`UsernamePasswordAuthenticationFilter` 通过从 `HttpServletRequest` 中提取用户名和密码来创建 `UsernamePasswordAuthenticationToken`，这是一种 <<servlet-authentication-authentication,`Authentication`>>.

image:{icondir}/number_2.png[] 接下来，将 `UsernamePasswordAuthenticationToken` 传递到 `AuthenticationManager` 进行身份验证.  `AuthenticationManager` 外观的详细信息取决于 <<servlet-authentication-unpwd-storage,用户信息的存储方式>>.

image:{icondir}/number_3.png[] 如果身份验证失败，则失败

* 已清除 <<servlet-authentication-securitycontextholder,SecurityContextHolder>>.
* `RememberMeServices.loginFail` 被调用.  如果记住我未配置，则为空.
// FIXME: link to rememberme
* `AuthenticationFailureHandler` 被调用.
// FIXME: link to AuthenticationFailureHandler

image:{icondir}/number_4.png[] 如果身份验证成功，则为成功.

* 新的登录通知 `SessionAuthenticationStrategy`.
// FIXME: Add link to SessionAuthenticationStrategy
* <<servlet-authentication-authentication,Authentication >> 是在 <<servlet-authentication-securitycontextholder,SecurityContextHolder>> 上设置的.  之后，`SecurityContextPersistenceFilter` 将 `SecurityContext` 保存到 `HttpSession` 中.
// FIXME: link securitycontextpersistencefilter
* `RememberMeServices.loginSuccess` 被调用.  如果记住我未配置，则为空.
// FIXME: link to rememberme
* `ApplicationEventPublisher` 发布一个 `InteractiveAuthenticationSuccessEvent`.
* `AuthenticationSuccessHandler` 被调用.  通常，这是一个 `SimpleUrlAuthenticationSuccessHandler`，当我们重定向到登录页面时，它将重定向到  <<servlet-exceptiontranslationfilter,`ExceptionTranslationFilter`>>  保存的请求.

[[servlet-authentication-form-min]]
默认情况下，Spring Security 表单登录处于启用状态.  但是，一旦提供了任何基于 servlet 的配置，就必须显式提供基于表单的登录.  可以在下面找到最小的显式Java配置:

.Form Log In
====
.Java
[source,java,role="primary"]
----
protected void configure(HttpSecurity http) {
	http
		// ...
		.formLogin(withDefaults());
}
----

.XML
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->
	<form-login />
</http>
----

.Kotlin
[source,kotlin,role="secondary"]
----
fun configure(http: HttpSecurity) {
	http {
		// ...
		formLogin { }
	}
}
----
====

在这种配置中，Spring Security 将呈现一个默认的登录页面.  大多数生产应用程序将需要自定义登录表单.

[[servlet-authentication-form-custom]]

下面的配置演示了如何提供自定义登录表单.
.Custom Log In Form Configuration
====
.Java
[source,java,role="primary"]
----
protected void configure(HttpSecurity http) throws Exception {
	http
		// ...
		.formLogin(form -> form
			.loginPage("/login")
			.permitAll()
		);
}
----

.XML
[source,xml,role="secondary"]
----
<http>
	<!-- ... -->
	<intercept-url pattern="/login" access="permitAll" />
	<form-login login-page="/login" />
</http>
----

.Kotlin
[source,kotlin,role="secondary"]
----
fun configure(http: HttpSecurity) {
	http {
		// ...
		formLogin {
			loginPage = "/login"
			permitAll()
		}
	}
}
----
====

[[servlet-authentication-form-custom-html]]
在 Spring Security 配置中指定登录页面后，您将负责呈现该页面.  以下是 https://www.thymeleaf.org/[Thymeleaf]  模板，该模板生成符合 `/login` 登录页面的HTML登录表单.

.Log In Form
====
.src/main/resources/templates/login.html
[source,xml]
----
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="https://www.thymeleaf.org">
	<head>
		<title>Please Log In</title>
	</head>
	<body>
		<h1>Please Log In</h1>
		<div th:if="${param.error}">
			Invalid username and password.</div>
		<div th:if="${param.logout}">
			You have been logged out.</div>
		<form th:action="@{/login}" method="post">
			<div>
			<input type="text" name="username" placeholder="Username"/>
			</div>
			<div>
			<input type="password" name="password" placeholder="Password"/>
			</div>
			<input type="submit" value="Log in" />
		</form>
	</body>
</html>
----
====

关于默认HTML表单，有一些关键点:

* 	一个POST请求到 `/login` 用来验证用户
* 该表格将需要包含一个由Thymeleaf  <<servlet-csrf-include-form-auto,自动包含>>的 <<servlet-csrf,CSRF Token>>.
* 该表单 `username` 参数为 username
* 该表单 `password` 参数为 password
* 如果HTTP参数错误，则表明用户未能提供有效的 username/password
* 如果HTTP参数存在 logout 参数，则表明用户已成功注销

自定义页面这些参数已经够用了.  但是，如果需要，可以使用其他配置自定义以上所有内容.

[[servlet-authentication-form-custom-controller]]
如果您使用的是 Spring MVC，则需要一个将  `GET /login`   映射到我们创建的登录模板的控制器.  下面是最小的LoginController示例:

.LoginController
====
.src/main/java/example/LoginController.java
[source,java]
----
@Controller
class LoginController {
	@GetMapping("/login")
	String login() {
		return "login";
	}
}
----
====
