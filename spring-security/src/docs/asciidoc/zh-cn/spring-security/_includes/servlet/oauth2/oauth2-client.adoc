[[oauth2client]]
== OAuth 2.0 客户端

OAuth 2.0客户端功能提供了对 https://tools.ietf.org/html/rfc6749#section-1.1[OAuth 2.0 授权框架]中定义的客户端角色的支持.

在较高级别，可用的核心功能包括:

.授权支持
* https://tools.ietf.org/html/rfc6749#section-1.3.1[授权码]
* https://tools.ietf.org/html/rfc6749#section-6[刷新令牌]
* https://tools.ietf.org/html/rfc6749#section-1.3.4[客户端凭证]
* https://tools.ietf.org/html/rfc6749#section-1.3.3[资源所有者密码凭证]

.HTTP 客户端支持
* <<oauth2Client-webclient-servlet, 在 Servlet 环境中集成 `WebClient`>> (用于请求受保护的资源)

`HttpSecurity.oauth2Client()` DSL提供了许多配置选项，用于自定义OAuth 2.0客户端使用的核心组件.  另外， `HttpSecurity.oauth2Client().authorizationCodeGrant()` 启用自定义授权码授权.

以下代码显示了 `HttpSecurity.oauth2Client()` DSL提供的完整配置选项:

.OAuth2 Client Configuration Options
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class OAuth2ClientSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Client(oauth2 -> oauth2
				.clientRegistrationRepository(this.clientRegistrationRepository())
				.authorizedClientRepository(this.authorizedClientRepository())
				.authorizedClientService(this.authorizedClientService())
				.authorizationCodeGrant(codeGrant -> codeGrant
					.authorizationRequestRepository(this.authorizationRequestRepository())
					.authorizationRequestResolver(this.authorizationRequestResolver())
					.accessTokenResponseClient(this.accessTokenResponseClient())
				)
			);
	}
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class OAuth2ClientSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Client {
                clientRegistrationRepository = clientRegistrationRepository()
                authorizedClientRepository = authorizedClientRepository()
                authorizedClientService = authorizedClientService()
                authorizationCodeGrant {
                    authorizationRequestRepository = authorizationRequestRepository()
                    authorizationRequestResolver = authorizationRequestResolver()
                    accessTokenResponseClient = accessTokenResponseClient()
                }
            }
        }
    }
}
----
====

`OAuth2AuthorizedClientManager` 负责与一个或多个 `OAuth2AuthorizedClientProvider` 协作管理OAuth 2.0客户端的授权 (或重新授权) .

以下代码显示了一个示例，该示例说明如何注册 `OAuth2AuthorizedClientManager` `@Bean` 并将其与 `OAuth2AuthorizedClientProvider` 组合关联，该组合提供对 `authorization_code`，`refresh_token`，`client_credentials` 和  `password`  授权类型的支持:

[source,java]
----
@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.authorizationCode()
					.refreshToken()
					.clientCredentials()
					.password()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}
----

以下各节将详细介绍OAuth 2.0客户端使用的核心组件以及可用的配置选项:

* <<oauth2Client-core-interface-class,核心 "类和接口">>
** <<oauth2Client-client-registration, ClientRegistration>>
** <<oauth2Client-client-registration-repo, ClientRegistrationRepository>>
** <<oauth2Client-authorized-client, OAuth2AuthorizedClient>>
** <<oauth2Client-authorized-repo-service, OAuth2AuthorizedClientRepository / OAuth2AuthorizedClientService>>
** <<oauth2Client-authorized-manager-provider, OAuth2AuthorizedClientManager / OAuth2AuthorizedClientProvider>>
* <<oauth2Client-auth-grant-support,授权类型支持>>
** <<oauth2Client-auth-code-grant, Authorization Code>>
** <<oauth2Client-refresh-token-grant, Refresh Token>>
** <<oauth2Client-client-creds-grant, Client Credentials>>
** <<oauth2Client-password-grant, Resource Owner Password Credentials>>
* <<oauth2Client-additional-features,其他功能>>
** <<oauth2Client-registered-authorized-client, 解决客户端授权>>
* <<oauth2Client-webclient-servlet,在Servlet环境中集成WebClient>>


[[oauth2Client-core-interface-class]]
=== 核心 "类和接口"


[[oauth2Client-client-registration]]
==== ClientRegistration

`ClientRegistration` 是向OAuth 2.0或OpenID Connect 1.0提供程序注册的客户端的表示.

客户端注册包含信息，例如客户端ID，客户端密钥，授权类型，重定向URI，作用域，授权URI，令牌URI和其他详细信息.

`ClientRegistration` 及其属性定义如下:

[source,java]
----
public final class ClientRegistration {
	private String registrationId;	<1>
	private String clientId;	<2>
	private String clientSecret;	<3>
	private ClientAuthenticationMethod clientAuthenticationMethod;	<4>
	private AuthorizationGrantType authorizationGrantType;	<5>
	private String redirectUriTemplate;	<6>
	private Set<String> scopes;	<7>
	private ProviderDetails providerDetails;
	private String clientName;	<8>

	public class ProviderDetails {
		private String authorizationUri;	<9>
		private String tokenUri;	<10>
		private UserInfoEndpoint userInfoEndpoint;
		private String jwkSetUri;	<11>
        private Map<String, Object> configurationMetadata;  <12>

		public class UserInfoEndpoint {
			private String uri;	<13>
            private AuthenticationMethod authenticationMethod;  <14>
			private String userNameAttributeName;	<15>

		}
	}
}
----
<1> `registrationId`: 唯一标识 `ClientRegistration` 的ID. .
<2> `clientId`: 客户端标识符.
<3> `clientSecret`: 客户端密钥.
<4> `clientAuthenticationMethod`: 提供者对客户端进行身份验证的方法.  支持的值为 *basic*，*post* 和 *none* https://tools.ietf.org/html/rfc6749#section-2.1[(public clients)].
<5> `authorizationGrantType`: OAuth 2.0授权框架定义了四种 https://tools.ietf.org/html/rfc6749#section-1.3[授权类型] .  支持的值是 `authorization_code`，`client_credentials`，`password`.
<6> `redirectUriTemplate`: 终端用户对客户端进行身份验证和授权访问后，授权服务器会将终端用户重定向到该客户的注册重定向URI.
<7> `scopes`: 客户在授权请求流程中请求的范围，例如openid，电子邮件或配置文件.
<8> `clientName`: 用于客户端的描述性名称.  该名称可能在某些情况下使用，例如在自动生成的登录页面中显示客户端名称时.
<9> `authorizationUri`: 授权服务器的授权端点URI.
<10> `tokenUri`: 授权服务器的令牌端点URI.
<11> `jwkSetUri`: 用于从授权服务器检索JSON Web密钥( https://tools.ietf.org/html/rfc7517[JSON Web Key (JWK)])集的URI，其中包含用于验证ID令牌的JSON Web签名( https://tools.ietf.org/html/rfc7515[JSON Web Signature (JWS)]) 以及用户信息响应 (可选) 的加密密钥.
<12> `configurationMetadata`:  https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[OpenID Provider 配置信息]. 仅当配置了Spring Boot 2.x属性 `spring.security.oauth2.client.provider.[providerId].issuerUri`  时，此信息才可用.
<13> `(userInfoEndpoint)uri`: UserInfo端点URI，用于访问经过身份验证的最终用户的声明/属性.
<14> `(userInfoEndpoint)authenticationMethod`: 将访问令牌发送到UserInfo端点时使用的身份验证方法. 支持  *header*, *form* 和 *query* 值
<15> `userNameAttributeName`: 在UserInfo响应中返回的属性名称，该属性引用了最终用户的名称或标识符.

可以使用发现OpenID Connect提供者的 https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[Configuration endpoint] 或授权服务器的 https://tools.ietf.org/html/rfc8414#section-3[元数据端点] 来初始配置 `ClientRegistration`.

`ClientRegistrations` 提供了以这种方式配置 `ClientRegistration` 的便捷方法，如以下示例所示:

[source,java]
----
ClientRegistration clientRegistration =
    ClientRegistrations.fromIssuerLocation("https://idp.example.com/issuer").build();
----

上面的代码将依次查询 `https://idp.example.com/issuer/.well-known/openid-configuration` ，然后依次查询 `https://idp.example.com/.well-known/openid-configuration/issuer`，
最后是  `https://idp.example.com/.well-known/oauth-authorization-server/issuer` ，从第一个停止返回200响应.

或者，您可以使用 `ClientRegistrations.fromOidcIssuerLocation()`  仅查询OpenID Connect提供程序的配置端点.

[[oauth2Client-client-registration-repo]]
==== ClientRegistrationRepository

`ClientRegistrationRepository` 充当OAuth 2.0 / OpenID Connect 1.0  `ClientRegistration` 的存储库.

[NOTE]
客户端注册信息最终由关联的授权服务器存储和拥有.  此存储库提供了检索与授权服务器一起存储的主要客户端注册信息的子集的功能.

Spring Boot 2.x自动配置将 `spring.security.oauth2.client.registration._[registrationId]_`  下的每个属性绑定到 `ClientRegistration` 的实例，然后在 `ClientRegistrationRepository` 中组成每个 `ClientRegistration` 实例.

[NOTE]
`ClientRegistrationRepository` 的默认实现是 `InMemoryClientRegistrationRepository`.

自动配置还会在 `ApplicationContext` 中将 `ClientRegistrationRepository` 注册为 `@Bean`，以便在应用程序需要时可用于依赖注入.

以下清单显示了一个示例:

[source,java]
----
@Controller
public class OAuth2ClientController {

	@Autowired
	private ClientRegistrationRepository clientRegistrationRepository;

	@GetMapping("/")
	public String index() {
		ClientRegistration oktaRegistration =
			this.clientRegistrationRepository.findByRegistrationId("okta");

		...

		return "index";
	}
}
----


[[oauth2Client-authorized-client]]
==== OAuth2AuthorizedClient

`OAuth2AuthorizedClient` 是授权客户端的表示.  当终端用户 (资源所有者) 已向客户端授权访问其受保护资源的权限时，则认为该客户端已被授权.

`OAuth2AuthorizedClient` 的目的是将 `OAuth2AccessToken` (和可选的 `OAuth2RefreshToken`) 与 `ClientRegistration` (客户端) 和资源所有者相关联，`ClientRegistration` 和资源所有者是授权的主要最终用户.


[[oauth2Client-authorized-repo-service]]
==== OAuth2AuthorizedClientRepository / OAuth2AuthorizedClientService

`OAuth2AuthorizedClientRepository` 负责在Web请求之间持久保存 `OAuth2AuthorizedClient`.  而 `OAuth2AuthorizedClientService` 的主要作用是在应用程序级别管理 `OAuth2AuthorizedClient`.

从开发人员的角度来看，`OAuth2AuthorizedClientRepository` 或 `OAuth2AuthorizedClientService` 提供了查找与客户端关联的 `OAuth2AccessToken` 的功能，以便可以将其用于发起受保护的资源请求.

以下清单显示了一个示例:

[source,java]
----
@Controller
public class OAuth2ClientController {

    @Autowired
    private OAuth2AuthorizedClientService authorizedClientService;

    @GetMapping("/")
    public String index(Authentication authentication) {
        OAuth2AuthorizedClient authorizedClient =
            this.authorizedClientService.loadAuthorizedClient("okta", authentication.getName());

        OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

        ...

        return "index";
    }
}
----

[NOTE]
Spring Boot 2.x自动配置在 `ApplicationContext` 中注册了 `OAuth2AuthorizedClientRepository` 和/或 `OAuth2AuthorizedClientService` `@Bean`.  但是，应用程序可以选择覆盖并注册自定义 `OAuth2AuthorizedClientRepository` 或 `OAuth2AuthorizedClientService` ``@Bean`.

`OAuth2AuthorizedClientService` 的默认实现是 `InMemoryOAuth2AuthorizedClientService`，它在内存中存储 `OAuth2AuthorizedClient`.

或者，可以将JDBC实现 `JdbcOAuth2AuthorizedClientService` 配置为将 `OAuth2AuthorizedClient` 持久存储在数据库中.

[NOTE]
`JdbcOAuth2AuthorizedClientService` 取决于<<dbschema-oauth2-client, OAuth 2.0客户端架构>>中描述的表定义.

[[oauth2Client-authorized-manager-provider]]
==== OAuth2AuthorizedClientManager / OAuth2AuthorizedClientProvider

`OAuth2AuthorizedClientManager` 负责 `OAuth2AuthorizedClient` 的整体管理.

主要职责包括:

* 使用 `OAuth2AuthorizedClientProvider` 授权 (或重新授权) OAuth 2.0客户端.
* 通常使用 `OAuth2AuthorizedClientService` 或 `OAuth2AuthorizedClientRepository` 委托 `OAuth2AuthorizedClient` 的持久性.

`OAuth2AuthorizedClientProvider` 实施用于授权 (或重新授权) OAuth 2.0客户端的策略.  实施通常将实施授权类型，例如.  `authorization_code`, `client_credentials` 等.

`OAuth2AuthorizedClientManager` 的默认实现是 `DefaultOAuth2AuthorizedClientManager`，它与 `OAuth2AuthorizedClientProvider` 关联，
该 `OAuth2AuthorizedClientProvider` 可以使用基于委托的组合来支持多种授权授权类型.  `OAuth2AuthorizedClientProviderBuilder` 可以用于配置和构建基于委托的组合.

以下代码显示了如何配置和构建 `OAuth2AuthorizedClientProvider` 组合的示例，该组合提供对  `authorization_code`，`refresh_token`，`client_credentials` 和 `password` 授权类型的支持:

[source,java]
----
@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.authorizationCode()
					.refreshToken()
					.clientCredentials()
					.password()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}
----

`DefaultOAuth2AuthorizedClientManager` 也与类型为 `Function<OAuth2AuthorizeRequest, Map<String, Object>>` 的 `contextAttributesMapper` 关联，后者负责将属性从 `OAuth2AuthorizeRequest` 映射到要与 `OAuth2AuthorizationContext` 关联的属性的映射.
当您需要为 `OAuth2AuthorizedClientProvider` 提供必需的 (受支持的) 属性时，这很有用.  `PasswordOAuth2AuthorizedClientProvider` 要求资源所有者的用户名和密码在 `OAuth2AuthorizationContext.getAttributes()` 中可用.

以下代码显示了 `contextAttributesMapper` 的示例:

[source,java]
----
@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.password()
					.refreshToken()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	// Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters,
	// map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`
	authorizedClientManager.setContextAttributesMapper(contextAttributesMapper());

	return authorizedClientManager;
}

private Function<OAuth2AuthorizeRequest, Map<String, Object>> contextAttributesMapper() {
	return authorizeRequest -> {
		Map<String, Object> contextAttributes = Collections.emptyMap();
		HttpServletRequest servletRequest = authorizeRequest.getAttribute(HttpServletRequest.class.getName());
		String username = servletRequest.getParameter(OAuth2ParameterNames.USERNAME);
		String password = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD);
		if (StringUtils.hasText(username) && StringUtils.hasText(password)) {
			contextAttributes = new HashMap<>();

			// `PasswordOAuth2AuthorizedClientProvider` requires both attributes
			contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username);
			contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password);
		}
		return contextAttributes;
	};
}
----


[[oauth2Client-auth-grant-support]]
=== 授权类型支持


[[oauth2Client-auth-code-grant]]
==== Authorization Code  (授权码)

[NOTE]
有关 https://tools.ietf.org/html/rfc6749#section-1.3.1[Authorization Code] 的更多详细信息，请参考OAuth 2.0授权框架.


===== 获取授权

[NOTE]
请参阅 https://tools.ietf.org/html/rfc6749#section-4.1.1[Authorization Request/Response]  协议流程以获取授权码.

===== 发起授权请求

`OAuth2AuthorizationRequestRedirectFilter` 使用 `OAuth2AuthorizationRequestResolver` 来解析 `OAuth2AuthorizationRequest` 并通过将终端用户重定向到授权服务器的授权端点来开始授权码授权流程.

`OAuth2AuthorizationRequestResolver` 的主要作用是从提供的Web请求中解析 `OAuth2AuthorizationRequest`.  默认实现 `DefaultOAuth2AuthorizationRequestResolver` 在 (默认) 路径 `/oauth2/authorization/{registrationId}` 上进行匹配，
以提取 `registrationId` 并使用其关联的 `ClientRegistration` 构建 `OAuth2AuthorizationRequest`.

为OAuth 2.0客户端注册提供以下Spring Boot 2.x属性:

[source,yaml,attrs="-attributes"]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/authorized/okta"
            scope: read, write
        provider:
          okta:
            authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token
----

基本路径为 `/oauth2/authorization/okta` 的请求将通过 `OAuth2AuthorizationRequestRedirectFilter` 发起授权请求重定向，并最终启动授权码授权流程.

[NOTE]
`AuthorizationCodeOAuth2AuthorizedClientProvider` 是用于授权码认证的 `OAuth2AuthorizedClientProvider` 的实现，该授权码还通过 `OAuth2AuthorizationRequestRedirectFilter` 发起授权请求重定向.

如果OAuth 2.0客户端是 https://tools.ietf.org/html/rfc6749#section-2.1[Public Client]，则按以下方式配置OAuth 2.0客户端注册:

[source,yaml,attrs="-attributes"]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-authentication-method: none
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/authorized/okta"
            ...
----

使用 https://tools.ietf.org/html/rfc7636[Proof Key for Code Exchange] (PKCE)支持公共客户端.  如果客户端在不受信任的环境 (例如，本机应用程序或基于Web浏览器的应用程序) 中运行，因此无法维护其凭据的机密性，则在满足以下条件时将自动使用PKCE:

. `client-secret` 被省略 (或为空)
. `client-authentication-method` 设置为 "none" (`ClientAuthenticationMethod.NONE`)

[[oauth2Client-auth-code-redirect-uri]]
`DefaultOAuth2AuthorizationRequestResolver` 还使用 `UriComponentsBuilder` 支持 `redirect-uri` 的 `URI` 模板变量.

以下配置使用所有受支持的 `URI` 模板变量:

[source,yaml,attrs="-attributes"]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            ...
            redirect-uri: "{baseScheme}://{baseHost}{basePort}{basePath}/authorized/{registrationId}"
            ...
----

[NOTE]
`{baseUrl}` 解析为 `{baseScheme}://{baseHost}{basePort}{basePath}`

当OAuth 2.0客户端在<<http-proxy-server, 代理服务器>>后面运行时，使用 `URI` 模板变量配置 `redirect-uri` 尤其有用.  这样可以确保在扩展 `redirect-uri` 时使用 `X-Forwarded-*` 头.

===== 自定义授权请求

`OAuth2AuthorizationRequestResolver` 可以实现的主要用例之一是能够使用OAuth 2.0授权框架中定义的标准参数之外的其他参数自定义授权请求.

例如，OpenID Connect从 https://tools.ietf.org/html/rfc6749#section-4.1.1[OAuth 2.0 Authorization Framework] 中定义的标准参数开始，为 https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest[Authorization Code Flow] 定义其他OAuth 2.0请求参数.  这些扩展参数之一是提示参数.

[NOTE]
可选的.  用空格分隔的，区分大小写的ASCII字符串值列表，用于指定授权服务器是否提示终端用户进行重新认证和同意.  定义的值是: none, login, consent, select_account

以下示例显示了如何实现 `OAuth2AuthorizationRequestResolver`，该 `OAuth2AuthorizationRequestResolver` 通过包含请求参数  `prompt=consent` 来定制 `oauth2Login()` 的授权请求.

[source,java]
----
@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

	@Autowired
	private ClientRegistrationRepository clientRegistrationRepository;

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.authorizeRequests(authorize -> authorize
				.anyRequest().authenticated()
			)
			.oauth2Login(oauth2 -> oauth2
				.authorizationEndpoint(authorization -> authorization
					.authorizationRequestResolver(
					    new CustomAuthorizationRequestResolver(
					            this.clientRegistrationRepository)    <1>
					)
				)
			);
	}
}

public class CustomAuthorizationRequestResolver implements OAuth2AuthorizationRequestResolver {
	private final OAuth2AuthorizationRequestResolver defaultAuthorizationRequestResolver;

	public CustomAuthorizationRequestResolver(
			ClientRegistrationRepository clientRegistrationRepository) {

		this.defaultAuthorizationRequestResolver =
				new DefaultOAuth2AuthorizationRequestResolver(
						clientRegistrationRepository, "/oauth2/authorization");
	}

	@Override
	public OAuth2AuthorizationRequest resolve(HttpServletRequest request) {
		OAuth2AuthorizationRequest authorizationRequest =
				this.defaultAuthorizationRequestResolver.resolve(request);  <2>

		return authorizationRequest != null ?   <3>
				customAuthorizationRequest(authorizationRequest) :
				null;
	}

	@Override
	public OAuth2AuthorizationRequest resolve(
			HttpServletRequest request, String clientRegistrationId) {

		OAuth2AuthorizationRequest authorizationRequest =
				this.defaultAuthorizationRequestResolver.resolve(
				    request, clientRegistrationId);    <2>

		return authorizationRequest != null ?   <3>
				customAuthorizationRequest(authorizationRequest) :
				null;
	}

	private OAuth2AuthorizationRequest customAuthorizationRequest(
			OAuth2AuthorizationRequest authorizationRequest) {

		Map<String, Object> additionalParameters =
				new LinkedHashMap<>(authorizationRequest.getAdditionalParameters());
		additionalParameters.put("prompt", "consent");  <4>

		return OAuth2AuthorizationRequest.from(authorizationRequest)    <5>
				.additionalParameters(additionalParameters) <6>
				.build();
	}
}
----
<1> 配置自定义 `OAuth2AuthorizationRequestResolver`
<2> 尝试使用 `DefaultOAuth2AuthorizationRequestResolver` 解析 `OAuth2AuthorizationRequest`
<3> 如果 `OAuth2AuthorizationRequest` 已解决，则返回自定义版本，否则返回 `null`
<4> 将自定义参数添加到现有的 `OAuth2AuthorizationRequest.additionalParameters`
<5> 创建默认 `OAuth2AuthorizationRequest` 的副本，该副本将返回 `OAuth2AuthorizationRequest.Builder` 以进行进一步修改
<6> 覆盖默认的 `AdditionalParameters`

[TIP]
`OAuth2AuthorizationRequest.Builder.build()` 构造 `OAuth2AuthorizationRequest.authorizationRequestUri`，它表示完整的授权请求 `URI`，包括使用 `application/x-www-form-urlencoded` 格式的所有查询参数.

对于简单的用例，对于特定的提供者，附加请求参数始终相同，可以将其直接添加到 `authorization-uri` 中.

例如，如果请求参数 `prompt` 的值始终是提供者okta的 `consent` ，则可以简单地进行如下配置:

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        provider:
          okta:
            authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize?prompt=consent
----

前面的示例显示了在标准参数之上添加自定义参数的常见用例.  或者，如果您的要求更高，则可以通过简单地覆盖 `OAuth2AuthorizationRequest.authorizationRequestUri` 属性来完全控制构建授权请求 `URI`.

以下示例显示了 `customAuthorizationRequest()` 方法与上一示例的不同形式，而是覆盖了 `OAuth2AuthorizationRequest.authorizationRequestUri` 属性.

[source,java]
----
private OAuth2AuthorizationRequest customAuthorizationRequest(
		OAuth2AuthorizationRequest authorizationRequest) {

	String customAuthorizationRequestUri = UriComponentsBuilder
			.fromUriString(authorizationRequest.getAuthorizationRequestUri())
			.queryParam("prompt", "consent")
			.build(true)
			.toUriString();

	return OAuth2AuthorizationRequest.from(authorizationRequest)
			.authorizationRequestUri(customAuthorizationRequestUri)
			.build();
}
----


===== 保存授权请求

`AuthorizationRequestRepository` 负责从发起授权请求到接收到授权响应 (回调) 之间的 `OAuth2AuthorizationRequest` 的持久性.

[TIP]
`OAuth2AuthorizationRequest` 用于关联和验证授权响应.

`AuthorizationRequestRepository` 的默认实现是 `HttpSessionOAuth2AuthorizationRequestRepository`，它将 `OAuth2AuthorizationRequest` 存储在 `HttpSession` 中.

如果您具有 `AuthorizationRequestRepository` 的自定义实现，则可以如以下示例所示对其进行配置:

.AuthorizationRequestRepository Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class OAuth2ClientSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Client(oauth2 -> oauth2
				.authorizationCodeGrant(codeGrant -> codeGrant
					.authorizationRequestRepository(this.authorizationRequestRepository())
					...
				)
			);
	}
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class OAuth2ClientSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Client {
                authorizationCodeGrant {
                    authorizationRequestRepository = authorizationRequestRepository()
                }
            }
        }
    }
}
----
====

===== 访问令牌请求

[NOTE]
请参阅 https://tools.ietf.org/html/rfc6749#section-4.1.3[Access Token Request/Response]  协议流程以获取授权码.

用于授权码授权的 `OAuth2AccessTokenResponseClient` 的默认实现是 `DefaultAuthorizationCodeTokenResponseClient`，它使用 `RestOperations` 在授权服务器的令牌端点交换访问令牌的授权码.

`DefaultAuthorizationCodeTokenResponseClient` 非常灵活，因为它允许您自定义令牌请求的预处理和/或令牌响应的后处理.

===== 自定义访问令牌请求

如果需要自定义令牌请求的预处理，则可以为 `DefaultAuthorizationCodeTokenResponseClient.setRequestEntityConverter()` 提供自定义 `Converter<OAuth2AuthorizationCodeGrantRequest, RequestEntity<?>>`.
默认实现 `OAuth2AuthorizationCodeGrantRequestEntityConverter` 构建标准 https://tools.ietf.org/html/rfc6749#section-4.1.3[OAuth 2.0 Access Token Request] 的 `RequestEntity` 表示形式.  但是，提供自定义转换器将允许您扩展标准令牌请求并添加自定义参数.


IMPORTANT: 自定义 `Converter` 必须返回预期的OAuth 2.0提供者可以理解的OAuth 2.0访问令牌请求的有效 `RequestEntity` 表示形式.

===== 自定义访问令牌响应

另一方面，如果您需要自定义令牌响应的后处理，则需要为  `DefaultAuthorizationCodeTokenResponseClient.setRestOperations()` 提供一个自定义配置的 `RestOperations`.  默认的 `RestOperations` 配置如下:

[source,java]
----
RestTemplate restTemplate = new RestTemplate(Arrays.asList(
		new FormHttpMessageConverter(),
		new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());
----

TIP: 发送OAuth 2.0访问令牌请求时，需要使用Spring MVC `FormHttpMessageConverter`.

`OAuth2AccessTokenResponseHttpMessageConverter` 是OAuth 2.0访问令牌响应的 `HttpMessageConverter`.  您可以为 `OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()` 提供一个自定义 `Converter<Map<String, String>, OAuth2AccessTokenResponse>`，
该转换器用于将OAuth 2.0访问令牌响应参数转换为 `OAuth2AccessTokenResponse`.

`OAuth2ErrorResponseErrorHandler` 是一个 `ResponseErrorHandler`，可以处理OAuth 2.0错误，例如.  400错误的请求.  它使用 `OAuth2ErrorHttpMessageConverter` 将OAuth 2.0错误参数转换为 `OAuth2Error`.

无论您是自定义 `DefaultAuthorizationCodeTokenResponseClient` 还是提供自己的 `OAuth2AccessTokenResponseClient` 实现，都需要按以下示例所示进行配置:

.Access Token Response Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class OAuth2ClientSecurityConfig extends WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			.oauth2Client(oauth2 -> oauth2
				.authorizationCodeGrant(codeGrant -> codeGrant
					.accessTokenResponseClient(this.accessTokenResponseClient())
					...
				)
			);
	}
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class OAuth2ClientSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Client {
                authorizationCodeGrant {
                    accessTokenResponseClient = accessTokenResponseClient()
                }
            }
        }
    }
}
----
====


[[oauth2Client-refresh-token-grant]]
==== 刷新Token

[NOTE]
有关以下内容的更多详细信息，请参阅OAuth 2.0授权框架 https://tools.ietf.org/html/rfc6749#section-1.5[Refresh Token].


===== 刷新访问令牌

[NOTE]
请参阅 https://tools.ietf.org/html/rfc6749#section-6[Access Token Request/Response] 协议流程以获取刷新令牌授权.

用于刷新令牌授权的 `OAuth2AccessTokenResponseClient` 的默认实现是 `DefaultRefreshTokenTokenResponseClient`，当在授权服务器的令牌端点刷新访问令牌时使用 `RestOperations`.

`DefaultRefreshTokenTokenResponseClient` 非常灵活，因为它允许您自定义令牌请求的预处理和/或令牌响应的后处理

===== 自定义刷新令牌请求

如果需要自定义令牌请求的预处理，则可以为 `DefaultRefreshTokenTokenResponseClient.setRequestEntityConverter()` 提供自定义 `Converter<OAuth2RefreshTokenGrantRequest, RequestEntity<?>>`
默认实现 `OAuth2RefreshTokenGrantRequestEntityConverter` 构建标准 https://tools.ietf.org/html/rfc6749#section-6[OAuth 2.0 Access Token Request]的 `RequestEntity` 表示.  但是，提供自定义 `Converter` 将允许您扩展标准令牌请求并添加自定义参数.

IMPORTANT: 自定义 `Converter` 必须返回预期的OAuth 2.0提供程序可以理解的OAuth 2.0访问令牌请求的有效 `RequestEntity` 表示形式.

===== 自定义刷新令牌响应

另一方面，如果您需要自定义令牌响应的后处理，则需要为  `DefaultRefreshTokenTokenResponseClient.setRestOperations()` 提供一个自定义配置的 `RestOperations`.  默认的 `RestOperations` 配置如下:

[source,java]
----
RestTemplate restTemplate = new RestTemplate(Arrays.asList(
		new FormHttpMessageConverter(),
		new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());
----

TIP: 发送OAuth 2.0访问令牌请求时，需要使用Spring MVC `FormHttpMessageConverter`.

`OAuth2AccessTokenResponseHttpMessageConverter` 是OAuth 2.0访问令牌响应的 `HttpMessageConverter`.  您可以为  `OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()` 提供一个自定义 `Converter<Map<String, String>, OAuth2AccessTokenResponse>`，该转换器用于将OAuth 2.0访问令牌响应参数转换为 `OAuth2AccessTokenResponse`.

`OAuth2ErrorResponseErrorHandler` 是一个 `ResponseErrorHandler`，可以处理OAuth 2.0错误，例如.  400错误的请求.  它使用 `OAuth2ErrorHttpMessageConverter` 将OAuth 2.0错误参数转换为 `OAuth2Error`.

无论您是自定义 `DefaultRefreshTokenTokenResponseClient` 还是提供自己的 `OAuth2AccessTokenResponseClient` 实现，都需要按以下示例所示进行配置:

[source,java]
----
// Customize
OAuth2AccessTokenResponseClient<OAuth2RefreshTokenGrantRequest> refreshTokenTokenResponseClient = ...

OAuth2AuthorizedClientProvider authorizedClientProvider =
		OAuth2AuthorizedClientProviderBuilder.builder()
				.authorizationCode()
				.refreshToken(configurer -> configurer.accessTokenResponseClient(refreshTokenTokenResponseClient))
				.build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);
----

[NOTE]
`OAuth2AuthorizedClientProviderBuilder.builder().refreshToken()` 配置一个 `RefreshTokenOAuth2AuthorizedClientProvider`，它是 `OAuth2AuthorizedClientProvider` 的实现，用于刷新令牌授权.

`OAuth2RefreshToken` 可以选择在访问令牌响应中返回 `authorization_code` 和 `password` 授权类型.  如果 `OAuth2AuthorizedClient.getRefreshToken()` 可用且 `OAuth2AuthorizedClient.getAccessToken()` 过期，则 `RefreshTokenOAuth2AuthorizedClientProvider` 将自动刷新它.

[[oauth2Client-client-creds-grant]]
==== Client Credentials(客户端凭证)

[NOTE]
有关 https://tools.ietf.org/html/rfc6749#section-1.3.4[Client Credentials] 授权的更多详细信息，请参考OAuth 2.0授权框架.

===== 访问令牌请求

[NOTE]
请参阅 https://tools.ietf.org/html/rfc6749#section-4.4.2[Access Token Request/Response]  协议流以获取 "客户端凭证" 授权.

客户端凭据授权的 `OAuth2AccessTokenResponseClient` 的默认实现是 `DefaultClientCredentialsTokenResponseClient`，当在授权服务器的令牌端点请求访问令牌时，它会使用 `RestOperations`.

`DefaultClientCredentialsTokenResponseClient` 非常灵活，因为它允许您自定义令牌请求的预处理和/或令牌响应的后处理.

===== 自定义访问令牌请求

如果需要自定义令牌请求的预处理，则可以为 `DefaultClientCredentialsTokenResponseClient.setRequestEntityConverter()`  提供自定义 `Converter<OAuth2ClientCredentialsGrantRequest, RequestEntity<?>>`.
默认实现 `OAuth2ClientCredentialsGrantRequestEntityConverter` 构建标准 https://tools.ietf.org/html/rfc6749#section-4.4.2[OAuth 2.0 Access Token Request] 的 `RequestEntity` 表示.  但是，提供自定义转换器将允许您扩展标准令牌请求并添加自定义参数.

IMPORTANT: 自定义 `Converter` 必须返回预期的OAuth 2.0提供程序可以理解的OAuth 2.0访问令牌请求的有效 `RequestEntity` 表示形式.

===== 自定义访问令牌响应

另一方面，如果您需要自定义令牌响应的后处理，则需要为 ·DefaultClientCredentialsTokenResponseClient.setRestOperations()` 提供一个自定义配置的 `RestOperations`.  默认的 `RestOperations` 配置如下:

[source,java]
----
RestTemplate restTemplate = new RestTemplate(Arrays.asList(
		new FormHttpMessageConverter(),
		new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());
----

TIP: 发送OAuth 2.0访问令牌请求时，需要使用Spring MVC `FormHttpMessageConverter`.


`OAuth2AccessTokenResponseHttpMessageConverter` 是OAuth 2.0访问令牌响应的 `HttpMessageConverter`.  您可以为 `OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()`  提供一个自定义 `Converter<Map<String, String>, OAuth2AccessTokenResponse>` ，
该转换器用于将OAuth 2.0访问令牌响应参数转换为 `OAuth2AccessTokenResponse`.

`OAuth2ErrorResponseErrorHandler` 是一个 `ResponseErrorHandler`，可以处理OAuth 2.0错误，例如.  400错误的请求.  它使用 `OAuth2ErrorHttpMessageConverter` 将OAuth 2.0错误参数转换为 `OAuth2Error`.

无论您是自定义 `DefaultClientCredentialsTokenResponseClient` 还是提供自己的 `OAuth2AccessTokenResponseClient` 实现，都需要按以下示例所示进行配置:

[source,java]
----
// Customize
OAuth2AccessTokenResponseClient<OAuth2ClientCredentialsGrantRequest> clientCredentialsTokenResponseClient = ...

OAuth2AuthorizedClientProvider authorizedClientProvider =
		OAuth2AuthorizedClientProviderBuilder.builder()
				.clientCredentials(configurer -> configurer.accessTokenResponseClient(clientCredentialsTokenResponseClient))
				.build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);
----

[NOTE]
`OAuth2AuthorizedClientProviderBuilder.builder().clientCredentials()` 配置 `ClientCredentialsOAuth2AuthorizedClientProvider`，这是 `OAuth2AuthorizedClientProvider` 的实现，用于Client Credentials授权.

===== 使用访问令牌

为OAuth 2.0客户端注册提供以下Spring Boot 2.x属性:

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: client_credentials
            scope: read, write
        provider:
          okta:
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token
----

......以及 `OAuth2AuthorizedClientManager` `@Bean`:

[source,java]
----
@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.clientCredentials()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	return authorizedClientManager;
}
----

您可以按以下方式获取 `OAuth2AccessToken`:

[source,java]
----
@Controller
public class OAuth2ClientController {

	@Autowired
	private OAuth2AuthorizedClientManager authorizedClientManager;

	@GetMapping("/")
	public String index(Authentication authentication,
						HttpServletRequest servletRequest,
						HttpServletResponse servletResponse) {

		OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
				.principal(authentication)
				.attributes(attrs -> {
					attrs.put(HttpServletRequest.class.getName(), servletRequest);
					attrs.put(HttpServletResponse.class.getName(), servletResponse);
				})
				.build();
		OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest);

		OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

		...

		return "index";
	}
}
----

[NOTE]
`HttpServletRequest` 和 `HttpServletResponse` 都是可选属性.  如果未提供，它将使用 `RequestContextHolder.getRequestAttributes()` 默认为 `ServletRequestAttributes`.

[[oauth2Client-password-grant]]
==== 资源所有者密码凭证

[NOTE]
有关资源所有者密码凭据授权的更多详细信息，请参考 https://tools.ietf.org/html/rfc6749#section-1.3.3[Resource Owner Password Credentials].


===== 访问令牌请求

[NOTE]
请参阅https://tools.ietf.org/html/rfc6749#section-4.3.2[Access Token Request/Response]  协议流，以获取 "资源所有者密码凭据" 授权.

用于资源所有者密码凭据授权的 `OAuth2AccessTokenResponseClient` 的默认实现是 `DefaultPasswordTokenResponseClient`，当在授权服务器的令牌端点请求访问令牌时，它将使用 `RestOperations`.

`DefaultPasswordTokenResponseClient` 非常灵活，因为它允许您自定义令牌请求的预处理和/或令牌响应的后处理.

===== 自定义访问令牌请求

如果需要自定义令牌请求的预处理，则可以为 `DefaultPasswordTokenResponseClient.setRequestEntityConverter()` 提供自定义 `Converter<OAuth2PasswordGrantRequest, RequestEntity<?>>`.
默认实现 `OAuth2PasswordGrantRequestEntityConverter` 构建标准 https://tools.ietf.org/html/rfc6749#section-4.3.2[OAuth 2.0 Access Token Request]的 `RequestEntity` 表示形式.  但是，提供自定义 `Converter` 将允许您扩展标准令牌请求并添加自定义参数.

IMPORTANT: 自定义 `Converter` 必须返回预期的OAuth 2.0提供程序可以理解的OAuth 2.0访问令牌请求的有效 `RequestEntity` 表示形式.

===== 自定义访问令牌响应

另一方面，如果您需要自定义令牌响应的后处理，则需要为 `DefaultPasswordTokenResponseClient.setRestOperations()` 提供一个自定义配置的 `RestOperations`.  默认的 `RestOperations` 配置如下:

[source,java]
----
RestTemplate restTemplate = new RestTemplate(Arrays.asList(
		new FormHttpMessageConverter(),
		new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());
----

TIP: 发送OAuth 2.0访问令牌请求时，需要使用Spring MVC `FormHttpMessageConverter`.


`OAuth2AccessTokenResponseHttpMessageConverter` 是OAuth 2.0访问令牌响应的 `HttpMessageConverter`.  您可以为 `OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()` 提供一个自定义 `Converter<Map<String, String>, OAuth2AccessTokenResponse>`，该转换器用于将OAuth 2.0访问令牌响应参数转换为 `OAuth2AccessTokenResponse`.

`OAuth2ErrorResponseErrorHandler` 是一个 `ResponseErrorHandler`，可以处理OAuth 2.0错误，例如.  400错误的请求.  它使用 `OAuth2ErrorHttpMessageConverter` 将OAuth 2.0错误参数转换为 `OAuth2Error`.

无论您是自定义 `DefaultPasswordTokenResponseClient` 还是提供自己的 `OAuth2AccessTokenResponseClient` 实现，都需要按以下示例所示进行配置:

[source,java]
----
// Customize
OAuth2AccessTokenResponseClient<OAuth2PasswordGrantRequest> passwordTokenResponseClient = ...

OAuth2AuthorizedClientProvider authorizedClientProvider =
		OAuth2AuthorizedClientProviderBuilder.builder()
				.password(configurer -> configurer.accessTokenResponseClient(passwordTokenResponseClient))
				.refreshToken()
				.build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);
----

[NOTE]
`OAuth2AuthorizedClientProviderBuilder.builder().password()` 配置 `PasswordOAuth2AuthorizedClientProvider`，它是 `OAuth2AuthorizedClientProvider` 的实现，用于资源所有者密码证书授权.

===== 使用访问令牌

为OAuth 2.0客户端注册提供以下Spring Boot 2.x属性:

[source,yaml]
----
spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: password
            scope: read, write
        provider:
          okta:
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token
----

......以及 `OAuth2AuthorizedClientManager` `@Bean`:

[source,java]
----
@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
		ClientRegistrationRepository clientRegistrationRepository,
		OAuth2AuthorizedClientRepository authorizedClientRepository) {

	OAuth2AuthorizedClientProvider authorizedClientProvider =
			OAuth2AuthorizedClientProviderBuilder.builder()
					.password()
					.refreshToken()
					.build();

	DefaultOAuth2AuthorizedClientManager authorizedClientManager =
			new DefaultOAuth2AuthorizedClientManager(
					clientRegistrationRepository, authorizedClientRepository);
	authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

	// Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters,
	// map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`
	authorizedClientManager.setContextAttributesMapper(contextAttributesMapper());

	return authorizedClientManager;
}

private Function<OAuth2AuthorizeRequest, Map<String, Object>> contextAttributesMapper() {
	return authorizeRequest -> {
		Map<String, Object> contextAttributes = Collections.emptyMap();
		HttpServletRequest servletRequest = authorizeRequest.getAttribute(HttpServletRequest.class.getName());
		String username = servletRequest.getParameter(OAuth2ParameterNames.USERNAME);
		String password = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD);
		if (StringUtils.hasText(username) && StringUtils.hasText(password)) {
			contextAttributes = new HashMap<>();

			// `PasswordOAuth2AuthorizedClientProvider` requires both attributes
			contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username);
			contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password);
		}
		return contextAttributes;
	};
}
----

您可以按以下方式获取 `OAuth2AccessToken`:

[source,java]
----
@Controller
public class OAuth2ClientController {

	@Autowired
	private OAuth2AuthorizedClientManager authorizedClientManager;

	@GetMapping("/")
	public String index(Authentication authentication,
						HttpServletRequest servletRequest,
						HttpServletResponse servletResponse) {

		OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
				.principal(authentication)
				.attributes(attrs -> {
					attrs.put(HttpServletRequest.class.getName(), servletRequest);
					attrs.put(HttpServletResponse.class.getName(), servletResponse);
				})
				.build();
		OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest);

		OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

		...

		return "index";
	}
}
----

[NOTE]
`HttpServletRequest` 和 `HttpServletResponse` 都是可选属性.  如果未提供，它将使用 `RequestContextHolder.getRequestAttributes()` 默认为 `ServletRequestAttributes`.


[[oauth2Client-additional-features]]
=== 其他功能


[[oauth2Client-registered-authorized-client]]
==== 解析授权客户端


`@RegisteredOAuth2AuthorizedClient` 注解提供了将方法参数解析为 `OAuth2AuthorizedClient` 类型的参数值的功能.  与使用 `OAuth2AuthorizedClientManager` 或 `OAuth2AuthorizedClientService` 访问 `OAuth2AuthorizedClient` 相比，这是一种方便的选择.

[source,java]
----
@Controller
public class OAuth2ClientController {

	@GetMapping("/")
	public String index(@RegisteredOAuth2AuthorizedClient("okta") OAuth2AuthorizedClient authorizedClient) {
		OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

		...

		return "index";
	}
}
----

`@RegisteredOAuth2AuthorizedClient` 注解由 `OAuth2AuthorizedClientArgumentResolver` 处理，该注解直接使用<<oauth2Client-authorized-manager-provider, OAuth2AuthorizedClientManager>> 并继承其功能.

[[oauth2Client-webclient-servlet]]
=== 在Servlet环境中集成WebClient

OAuth 2.0客户端支持使用 `ExchangeFilterFunction` 与 `WebClient` 集成.

`ServletOAuth2AuthorizedClientExchangeFilterFunction` 提供了一种简单的机制，可以通过使用 `OAuth2AuthorizedClient` 并包括关联的 `OAuth2AccessToken` 作为承载令牌来请求受保护的资源.  它直接使用 <<oauth2Client-authorized-manager-provider, OAuth2AuthorizedClientManager>>，因此继承了以下功能:

* 如果尚未授权客户端，则将请求 `OAuth2AccessToken`.
** `authorization_code` - 触发授权请求重定向以启动流程
** `client_credentials` - 访问令牌直接从令牌端点获取
** `password` - 访问令牌直接从令牌端点获取
* 如果 `OAuth2AccessToken` 过期，则如果 `OAuth2AuthorizedClientProvider` 可用于执行授权，它将被刷新 (或更新) .

以下代码显示了如何使用OAuth 2.0客户端支持配置 `WebClient` 的示例:

[source,java]
----
@Bean
WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {
	ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =
			new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
	return WebClient.builder()
			.apply(oauth2Client.oauth2Configuration())
			.build();
}
----


==== 提供授权客户端

`ServletOAuth2AuthorizedClientExchangeFilterFunction` 通过从 `ClientRequest.attributes()`  (请求属性) 解析 `OAuth2AuthorizedClient` 来确定要使用的客户端 (用于请求) .

以下代码显示了如何将 `OAuth2AuthorizedClient` 设置为请求属性:

[source,java]
----
@GetMapping("/")
public String index(@RegisteredOAuth2AuthorizedClient("okta") OAuth2AuthorizedClient authorizedClient) {
	String resourceUri = ...

	String body = webClient
			.get()
			.uri(resourceUri)
			.attributes(oauth2AuthorizedClient(authorizedClient))   <1>
			.retrieve()
			.bodyToMono(String.class)
			.block();

	...

	return "index";
}
----
<1> `oauth2AuthorizedClient()` 是 `ServletOAuth2AuthorizedClientExchangeFilterFunction` 中的 `static` 方法.

以下代码显示了如何将 `ClientRegistration.getRegistrationId()` 设置为请求属性:

[source,java]
----
@GetMapping("/")
public String index() {
	String resourceUri = ...

	String body = webClient
			.get()
			.uri(resourceUri)
			.attributes(clientRegistrationId("okta"))   <1>
			.retrieve()
			.bodyToMono(String.class)
			.block();

	...

	return "index";
}
----
<1> `clientRegistrationId()` 是 `ServletOAuth2AuthorizedClientExchangeFilterFunction` 中的 `static` 方法.


==== 默认授权客户端

如果未提供 `OAuth2AuthorizedClient` 或 `ClientRegistration.getRegistrationId()` 作为请求属性，则 `ServletOAuth2AuthorizedClientExchangeFilterFunction` 可以根据其配置确定要使用的默认客户端.

如果配置了 `setDefaultOAuth2AuthorizedClient(true)` 且用户已使用 `HttpSecurity.oauth2Login()` 进行了身份验证，则使用与当前 `OAuth2AuthenticationToken` 关联的 `OAuth2AccessToken`.

以下代码显示了特定的配置:

[source,java]
----
@Bean
WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {
	ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =
			new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
	oauth2Client.setDefaultOAuth2AuthorizedClient(true);
	return WebClient.builder()
			.apply(oauth2Client.oauth2Configuration())
			.build();
}
----

[WARNING]
建议谨慎使用此功能，因为所有HTTP请求都会收到访问令牌.

或者，如果 `setDefaultClientRegistrationId("okta")` 配置了有效的 `ClientRegistration`，则使用与 `OAuth2AuthorizedClient` 关联的 `OAuth2AccessToken`.

以下代码显示了特定的配置:

[source,java]
----
@Bean
WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {
	ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =
			new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
	oauth2Client.setDefaultClientRegistrationId("okta");
	return WebClient.builder()
			.apply(oauth2Client.oauth2Configuration())
			.build();
}
----

[WARNING]
建议谨慎使用此功能，因为所有HTTP请求都会收到访问令牌.
