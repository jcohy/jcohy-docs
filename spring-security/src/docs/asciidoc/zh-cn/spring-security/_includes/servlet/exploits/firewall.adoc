[[servlet-httpfirewall]]
= HttpFirewall
Spring Security在多个区域中针对传入的请求对您定义的模式进行测试，以便确定应如何处理请求。 当 `FilterChainProxy` 决定请求应通过哪个过滤器链，以及 `FilterSecurityInterceptor` 决定将哪些安全性约束应用于请求时，会发生这种情况。
 根据定义的模式进行测试时，重要的是要了解该机制是什么以及使用了哪个 `URL` 值。

Servlet规范为 `HttpServletRequest` 定义了一些属性，可以通过 `getter` 方法访问这些属性，我们可能希望将这些属性匹配。这些是 `contextPath`，`servletPath`，`pathInfo` 和 `queryString`。 Spring Security只对保护应用程序中的路径感兴趣，因此 `contextPath` 被忽略。
不幸的是，servlet规范没有确切定义特定请求 `URI` 的 `ServletPath` 和 `pathInfo` 的值。例如，URL的每个路径段都可以包含 https://www.ietf.org/rfc/rfc2396.txt[RFC 2396] footnote:[当浏览器不支持cookie且将 `jsessionid` 参数附加到分号后的URL时，您可能已经看到了。但是，RFC允许这些参数出现在URL的任何路径段中]  中定义的参数。规范没有明确说明是否应将这些参数包含在 `servletPath` 和 `pathInfo` 值中，并且行为在不同的servlet容器之间有所不同。
存在以下危险：当将应用程序部署在不从这些值中剥离路径参数的容器中时，攻击者可能会将其添加到请求的URL中，从而导致模式匹配意外成功或失败。footnote:[一旦请求离开 `FilterChainProxy`，原始值将被返回，因此对于应用程序仍然可用。]。传入URL中的其他变体也是可能的。
例如，它可能包含路径遍历序列（例如  `/../`）或多个正斜杠（`//`），这也可能导致模式匹配失败。一些容器在执行servlet映射之前将它们标准化，但其他容器则没有。为了避免此类问题，`FilterChainProxy` 使用 `HttpFirewall` 策略检查并包装请求。
默认情况下，未规范化的请求将自动被拒绝，并且出于匹配目的，将删除路径参数和重复的斜杠。 footnote:[因此，例如，原始请求路径 `/secure;hack=1/somefile.html;hack=2` 将作为  `/secure/somefile.html` 返回。 ]。
因此，必须使用 `FilterChainProxy` 来管理安全筛选器链。请注意，`servletPath` 和 `pathInfo` 值由容器解码，因此您的应用程序不应具有任何包含分号的有效路径，因为将出于匹配目的而删除这些部分。

如上所述，默认策略是使用Ant样式的路径进行匹配，这对于大多数用户而言可能是最佳选择。 该策略在 `AntPathRequestMatcher` 类中实现，该类使用Spring的 `AntPathMatcher` 对连接的 `ServletPath` 和 `pathInfo` 进行模式的不区分大小写的匹配，而忽略了 `queryString`。

如果由于某种原因需要更强大的匹配策略，则可以使用正则表达式。 然后，该策略实现是 `RegexRequestMatcher`。 有关更多信息，请参见Javadoc。

实际上，我们建议您在服务层使用方法安全性来控制对应用程序的访问，并且不要完全依赖于在Web应用程序级别定义的安全性约束的使用。 URL会发生变化，很难考虑应用程序可能支持的所有可能的URL以及如何处理请求。
 您应该尝试限制自己使用一些简单易懂的简单蚂蚁路径。 始终尝试使用 "deny-by-default" 方法，在此方法中，您最后定义了一个全包通配符（/** 或 **），并拒绝访问。


在服务层定义的安全性更加健壮，更难绕开，因此您应始终利用Spring Security的方法安全性选项。

`HttpFirewall` 还通过拒绝HTTP响应标头中的换行符来防止 https://www.owasp.org/index.php/HTTP_Response_Splitting[HTTP Response Splitting] 。

默认情况下，使用 `StrictHttpFirewall`。 此实现拒绝看起来是恶意的请求。 如果对您的要求过于严格，则可以自定义拒绝哪些类型的请求。 但是，重要的是要知道这样做可以使您的应用程序容易受到攻击。 例如，如果您希望利用Spring MVC的矩阵变量，则可以使用以下配置：

.允许矩阵变量
====
.Java
[source,java,role="primary"]
----
@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    firewall.setAllowSemicolon(true);
    return firewall;
}
----

.XML
[source,xml,role="secondary"]
----
<b:bean id="httpFirewall"
    class="org.springframework.security.web.firewall.StrictHttpFirewall"
    p:allowSemicolon="true"/>

<http-firewall ref="httpFirewall"/>
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    firewall.setAllowSemicolon(true)
    return firewall
}
----
====

`StrictHttpFirewall` 提供允许的有效HTTP方法的列表，这些方法可防止 https://www.owasp.org/index.php/Cross_Site_Tracing[跨站点跟踪（XST）] 和 https://www.owasp.org/index.php/Test_HTTP_Methods_(OTG-CONFIG-006)[HTTP动词篡改]。
默认的有效方法是  "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", 和 "PUT".。 如果您的应用程序需要修改有效方法，则可以配置自定义 `StrictHttpFirewall` bean。 例如，以下内容仅允许HTTP "GET" 和 "POST" 方法：

.只允许 GET & POST
====
.Java
[source,java,role="primary"]
----
@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    firewall.setAllowedHttpMethods(Arrays.asList("GET", "POST"));
    return firewall;
}
----

.XML
[source,xml,role="secondary"]
----
<b:bean id="httpFirewall"
      class="org.springframework.security.web.firewall.StrictHttpFirewall"
      p:allowedHttpMethods="GET,HEAD"/>

<http-firewall ref="httpFirewall"/>
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    firewall.setAllowedHttpMethods(listOf("GET", "POST"))
    return firewall
}
----
====

[TIP]
====
如果您正在  `new MockHttpServletRequest()`，则当前会创建一个HTTP方法作为空字符串  ""。 这是无效的HTTP方法，将被Spring Security拒绝。 您可以通过将其替换为  `new MockHttpServletRequest("GET", "")` 来解决此问题。 有关要求改善此问题的问题，请参见 https://jira.spring.io/browse/SPR-16851[SPR_16851] 。
====

如果必须允许任何HTTP方法（不推荐），则可以使用 `StrictHttpFirewall.setUnsafeAllowAnyHttpMethod(true)`。 这将完全禁用HTTP方法的验证。