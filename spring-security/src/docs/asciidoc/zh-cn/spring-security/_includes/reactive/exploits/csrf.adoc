[[webflux-csrf]]
= WebFlux环境的跨站点请求伪造（CSRF）

本节讨论Spring Security对WebFlux环境的<<csrf,Cross Site Request Forgery (CSRF)>> 支持。

[[webflux-csrf-using]]
== 使用Spring Security CSRF保护
下面概述了使用Spring Security的CSRF保护的步骤：

* <<webflux-csrf-idempotent,使用正确的HTTP动词>>
* <<webflux-csrf-configure,配置CSRF保护>>
* <<webflux-csrf-include,包括CSRF令牌>>

[[webflux-csrf-idempotent]]
=== 使用正确的HTTP动词
防御CSRF攻击的第一步是确保您的网站使用正确的HTTP动词。<<csrf-protection-idempotent,安全方法必须是幂等>>的中对此进行了详细介绍。

[[webflux-csrf-configure]]
=== 配置CSRF保护
下一步是在您的应用程序中配置Spring Security的CSRF保护。默认情况下，Spring Security的CSRF保护处于启用状态，但是您可能需要自定义配置。以下是一些常见的自定义项。

[[webflux-csrf-configure-custom-repository]]
==== 自定义 CsrfTokenRepository

默认情况下，Spring Security使用 `WebSessionServerCsrfTokenRepository` 将所需的CSRF令牌存储在 `WebSession` 中。 在某些情况下，用户将需要配置自定义 `ServerCsrfTokenRepository`。 例如，可能需要将 `CsrfToken` 持久保存在cookie中以支持<<webflux-csrf-include-ajax-auto,基于JavaScript的应用程序>>。

默认情况下，`CookieServerCsrfTokenRepository` 将写入名为 `XSRF-TOKEN` 的cookie，并从名为 `X-XSRF-TOKEN` 头或HTTP参数 `_csrf` 中读取它。 这些默认值来自 https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection[AngularJS]

您可以使用以下命令在Java配置中配置 `CookieCsrfTokenRepository`：

.使用Java配置将CSRF令牌存储在Cookie中
====
[source,java]
-----
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.csrf(csrf -> csrf.csrfTokenRepository(CookieServerCsrfTokenRepository.withHttpOnlyFalse()))
	return http.build();
}
-----
====

[NOTE]
====
该示例显式设置 `cookieHttpOnly=false`。 这是允许JavaScript（即AngularJS）读取它所必需的。 如果您不需要直接使用JavaScript读取Cookie的功能，建议省略 `cookieHttpOnly = false` （通过使用 `new CookieServerCsrfTokenRepository()` 代替）以提高安全性。
====

[[webflux-csrf-configure-disable]]
==== 禁用CSRF保护
默认情况下，CSRF保护处于启用状态。但是， <<csrf-when,如果对您的应用程序有意义>>，则禁用CSRF保护很简单。 下面的Java配置将禁用CSRF保护。

.禁用CSRF Java配置
====
[source,java]
----
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.csrf(csrf -> csrf.disable()))
	return http.build();
}
----
====

[[webflux-csrf-include]]
=== 包括CSRF令牌

为了使<<csrf-protection-stp,同步器令牌模式>>免受CSRF攻击，我们必须在HTTP请求中包括实际的CSRF令牌。 这必须包含在请求的一部分（即表单参数，HTTP标头等）中，浏览器不会自动将其包含在HTTP请求中。

Spring Security的 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/server/csrf/CsrfWebFilter.html[CsrfWebFilter]公开了 `Mono<CsrfToken>` 作为 `ServerWebExchange` 属性，
名为 `org.springframework.security.web.server.csrf.CsrfToken`。 这意味着任何视图技术都可以访问 `Mono<CsrfToken>` 以将期望的令牌公开为<<webflux-csrf-include-form-attr,form>>或<<webflux-csrf-include-ajax-meta,meta tag>>。

[[webflux-csrf-include-subscribe]]
如果您的视图技术无法提供简单的方法来订阅 `Mono<CsrfToken>`，则常见的模式是使用Spring的 `@ControllerAdvice` 直接公开 `CsrfToken`。 例如，以下代码会将CsrfToken放置在Spring Security的<<webflux-csrf-include-form-auto,CsrfRequestDataValueProcessor>> 用来自动包含CSRF令牌作为隐藏输入的默认属性名称（`_csrf`）上。

.`CsrfToken` as `@ModelAttribute`
====
[source,java]
----
@ControllerAdvice
public class SecurityControllerAdvice {
	@ModelAttribute
	Mono<CsrfToken> csrfToken(ServerWebExchange exchange) {
		Mono<CsrfToken> csrfToken = exchange.getAttribute(CsrfToken.class.getName());
		return csrfToken.doOnSuccess(token -> exchange.getAttributes()
				.put(CsrfRequestDataValueProcessor.DEFAULT_CSRF_ATTR_NAME, token));
	}
}
----
====
幸运的是，Thymeleaf提供了无需任何额外工作即可运行的 <<webflux-csrf-include-form-auto,集成>> 。

[[webflux-csrf-include-form]]
==== Form URL Encoded
为了post HTML表单，CSRF令牌必须作为隐藏域包含在表单中。例如，呈现的HTML可能如下所示：

.CSRF Token HTML
====
[source,html]
----
<input type="hidden"
	name="_csrf"
	value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
----
====

接下来，我们将讨论将CSRF令牌作为隐藏输入包含在内的各种方式。

[[webflux-csrf-include-form-auto]]
===== 自动包含CSRF令牌

Spring Security的CSRF支持通过其 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/reactive/result/view/CsrfRequestDataValueProcessor.html[CsrfRequestDataValueProcessor]与Spring的 https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/reactive/result/view/RequestDataValueProcessor.html[RequestDataValueProcessor]集成。
为了使 `CsrfRequestDataValueProcessor` 正常工作，必须预订 `Mono<CsrfToken>`，并且必须将 `CsrfToken` 作为与 https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/reactive/result/view/CsrfRequestDataValueProcessor.html#DEFAULT_CSRF_ATTR_NAME[DEFAULT_CSRF_ATTR_NAME]匹配的<<webflux-csrf-include-subscribe,属性公开>>。

幸运的是，Thymleaf通过与 `RequestDataValueProcessor` 集成为您提供照顾所有 https://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#integration-with-requestdatavalueprocessor[样板的支持] ，以确保具有不安全HTTP方法（即发布）的表单将自动包含实际的CSRF令牌。

[[webflux-csrf-include-form-attr]]
===== CsrfToken请求属性

如果在请求中包括实际CSRF令牌的 <<webflux-csrf-include,其他选项>>不起作用，则可以利用 `Mono<CsrfToken>` 作为名为 `org.springframework.security.web.server.csrf.CsrfToken` 的 `ServerWebExchange` <<webflux-csrf-include,属性公开>>的事实。 。

下面的Thymeleaf示例假定您在名为 `_csrf` 的属性上<<webflux-csrf-include-subscribe,公开>> `CsrfToken`。


.CSRF Token in Form with Request Attribute
====
[source,html]
----
<form th:action="@{/logout}"
	method="post">
<input type="submit"
	value="Log out" />
<input type="hidden"
	th:name="${_csrf.parameterName}"
	th:value="${_csrf.token}"/>
</form>
----
====

[[webflux-csrf-include-ajax]]
==== Ajax和JSON请求
如果使用的是JSON，则无法在HTTP参数内提交CSRF令牌。 相反，您可以在HTTP标头中提交令牌。

在以下各节中，我们将讨论在基于JavaScript的应用程序中将CSRF令牌作为HTTP请求标头包括在内的各种方式。

[[webflux-csrf-include-ajax-auto]]
===== 自动包含

可以轻松<<webflux-csrf-configure-custom-repository,configured>> Spring Security将期望的CSRF令牌存储在cookie中。通过将期望的CSRF存储在cookie中，像 https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection[AngularJS]这样的JavaScript框架将自动在HTTP请求标头中包含实际的CSRF令牌。


[[webflux-csrf-include-ajax-meta]]
===== 元标签

在<<webflux-csrf-include-form-auto,Cookie中公开>>CSRF的另一种方式是将CSRF令牌包含在您的 `meta` 标签。 HTML可能看起来像这样：

.CSRF meta tag HTML
====
[source,html]
----
<html>
<head>
	<meta name="_csrf" content="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
	<meta name="_csrf_header" content="X-CSRF-TOKEN"/>
	<!-- ... -->
</head>
<!-- ... -->
----
====

一旦元标记包含CSRF令牌，JavaScript代码就会读取元标记并将CSRF令牌作为标头包含在内。如果您使用的是jQuery，则可以通过以下方式完成：

.AJAX send CSRF Token
====
[source,javascript]
----
$(function () {
	var token = $("meta[name='_csrf']").attr("content");
	var header = $("meta[name='_csrf_header']").attr("content");
	$(document).ajaxSend(function(e, xhr, options) {
		xhr.setRequestHeader(header, token);
	});
});
----
====

下面的示例假定您在名为 `_csrf` 的属性上<<webflux-csrf-include-subscribe,公开>> `CsrfToken`。下面显示了使用Thymeleaf进行此操作的示例：

.CSRF meta tag JSP
====
[source,html]
----
<html>
<head>
	<meta name="_csrf" th:content="${_csrf.token}"/>
	<!-- default header name is X-CSRF-TOKEN -->
	<meta name="_csrf_header" th:content="${_csrf.headerName}"/>
	<!-- ... -->
</head>
<!-- ... -->
----
====

[[webflux-csrf-considerations]]
== CSRF注意事项
实施针对CSRF攻击的防护时，需要考虑一些特殊注意事项。 本节讨论与WebFlux环境有关的注意事项。 请参阅<<csrf-considerations,CSRF注意事项>>一节，以进行更一般的讨论。

[[webflux-considerations-csrf-login]]
=== 登录
<<csrf-considerations-login,要求CSRF进行登录请求>>很重要，以防止伪造登录尝试。 Spring Security的WebFlux支持是开箱即用的。

[[webflux-considerations-csrf-logout]]
=== 注销

<<csrf-considerations-logout,要求CSRF进行注销请求>> 很重要，以防止伪造注销尝试。 默认情况下，Spring Security的 `LogoutWebFilter` 仅处理HTTP发布请求。 这样可以确保注销需要CSRF令牌，并且恶意用户不能强制注销用户。

最简单的方法是使用表单注销。 如果您确实需要链接，则可以使用JavaScript来使链接执行POST（即可能以隐藏形式）。 对于禁用了JavaScript的浏览器，您可以选择使该链接将用户带到将执行POST的注销确认页面。

如果您确实想在注销时使用HTTP GET，则可以这样做，但是请记住，通常不建议这样做。 例如，以下Java配置将使用URL执行 `/logout` 通过任何HTTP方法请求注销：

// FIXME: This should be a link to log out documentation

.Log out with HTTP GET
====
[source,java]
----
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.logout(logout -> logout.requiresLogout(new PathPatternParserServerWebExchangeMatcher("/logout")))
	return http.build();
}

----
====


[[webflux-considerations-csrf-timeouts]]
=== CSRF和会话超时

默认情况下，Spring Security将CSRF令牌存储在 `WebSession` 中。 这可能会导致会话到期的情况，这意味着没有期望的CSRF令牌进行验证。

我们已经讨论了会话超时的<<csrf-considerations-login,一般解决方案>>。 本节讨论与WebFlux支持有关的CSRF超时的详细信息。

更改期望的CSRF令牌在cookie中的存储很简单。 有关详细信息，请参阅 <<webflux-csrf-configure-custom-repository,自定义CsrfTokenRepository>> 部分。

// FIXME: We should add a custom AccessDeniedHandler section in the reference and update the links above

// FIXME: We need a WebFlux multipart body vs action story. WebFlux always has multipart enabled.
[[webflux-csrf-considerations-multipart]]
=== Multipart (文件上传)
我们<<csrf-considerations-multipart,已经讨论>> 了如何保护分段请求（文件上传）免受CSRF攻击如何导致 https://en.wikipedia.org/wiki/Chicken_or_the_egg[鸡和蛋的问题]。本节讨论如何实现将CSRF令牌放置在WebFlux应用程序的<<webflux-csrf-considerations-multipart-body,body>>和<<webflux-csrf-considerations-multipart-url,url>> 中。

[NOTE]
====
有关在Spring上使用多部分表单的更多信息，请参见Spring参考的 https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web-reactive.html#webflux-multipart[Multipart Data] 部分。
====

[[webflux-csrf-considerations-multipart-body]]
==== 将CSRF令牌放入body 中
我们<<csrf-considerations-multipart,已经讨论>>了将CSRF令牌放入正文中的取舍。
在WebFlux应用程序中，可以使用以下配置进行配置：

.Enable obtaining CSRF token from multipart/form-data
====
[source,java]
----
@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
	http
		// ...
		.csrf(csrf -> csrf.tokenFromMultipartDataEnabled(true))
	return http.build();
}

----
====

[[webflux-csrf-considerations-multipart-url]]
==== 将CSRF令牌放入URL

我们 <<csrf-considerations-multipart,已经讨论>>了在URL中放置CSRF令牌的权衡。 由于CsrfToken是作为 `ServerHttpRequest`  <<webflux-csrf-include,请求属性>>公开的，因此我们可以使用它来创建带有CSRF令牌的 `action`。 Thymeleaf的示例如下所示：

.CSRF Token in Action
====
[source,html]
----
<form method="post"
	th:action="@{/upload(${_csrf.parameterName}=${_csrf.token})}"
	enctype="multipart/form-data">
----
====

[[webflux-csrf-considerations-override-method]]
=== HiddenHttpMethodFilter
我们 <<csrf-considerations-override-method,已经讨论>> 了重写HTTP方法。

在Spring WebFlux应用程序中，使用 https://docs.spring.io/spring-framework/docs/5.2.x/javadoc-api/org/springframework/web/filter/reactive/HiddenHttpMethodFilter.html[HiddenHttpMethodFilter] 重写HTTP方法。
