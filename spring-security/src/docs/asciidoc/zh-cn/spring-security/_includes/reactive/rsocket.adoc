[[rsocket]]
= RSocket Security

Spring Security的RSocket支持依赖于 `SocketAcceptorInterceptor`。 安全性的主要入口点位 于 `PayloadSocketAcceptorInterceptor` 中，该接口使RSocket API适应于允许使用 `PayloadInterceptor` 实现拦截 `PayloadExchange` 的问题。

您可以找到一些示例程序来演示以下代码：

* Hello RSocket {gh-samples-url}/boot/hellorsocket[hellorsocket]
* https://github.com/rwinch/spring-flights/tree/security[Spring Flights]

== 最小的RSocket安全配置

您可以在下面找到最小的RSocket安全配置：

[source,java]
-----
@Configuration
@EnableRSocketSecurity
public class HelloRSocketSecurityConfig {

	@Bean
	public MapReactiveUserDetailsService userDetailsService() {
		UserDetails user = User.withDefaultPasswordEncoder()
			.username("user")
			.password("user")
			.roles("USER")
			.build();
		return new MapReactiveUserDetailsService(user);
	}
}
-----

此配置启用<<rsocket-authentication-basic,basic authentication>>，并设置<<authorization,rsocket-authorization>>以要求经过身份验证的用户才能进行任何请求。

== Adding SecuritySocketAcceptorInterceptor

为了使Spring Security正常工作，我们需要将 `SecuritySocketAcceptorInterceptor` 应用于 `ServerRSocketFactory`。 这就是将我们使用RSocket基础结构创建的 `PayloadSocketAcceptorInterceptor` 连接起来的原因。 在Spring Boot应用程序中，可以使用以下代码完成此操作。

[source,java]
----
@Bean
ServerRSocketFactoryCustomizer springSecurityRSocketSecurity(
		SecuritySocketAcceptorInterceptor interceptor) {
	return builder -> builder.addSocketAcceptorPlugin(interceptor);
}
----

[[rsocket-authentication]]
== RSocket 认证

RSocket身份验证是通过 `AuthenticationPayloadInterceptor` 来执行的，该 `AuthenticationPayloadInterceptor` 充当调用 `ReactiveAuthenticationManager` 实例的控制器。

[[rsocket-authentication-setup-vs-request]]
=== 设置时的身份验证与请求时间

通常，认证可以在建立时间和/或请求时间进行。

在某些情况下，设置时进行身份验证是有意义的。 常见的情况是单个用户（即移动连接）利用RSocket连接时。 在这种情况下，只有一个用户可以利用该连接，因此可以在连接时进行一次身份验证。

在共享RSocket连接的情况下，有必要在每个请求上发送凭据。 例如，作为下游服务连接到RSocket服务器的Web应用程序将建立所有用户利用的单个连接。 在这种情况下，如果RSocket服务器需要根据Web应用程序的用户凭据执行授权，则每个请求都是有意义的。

在某些情况下，设置和按请求进行身份验证是有意义的。 考虑一个如上所述的Web应用程序。 如果我们需要限制与Web应用程序本身的连接，则可以在连接时提供具有 `SETUP` 权限的凭据。 这样，每个用户将具有不同的权限，但没有SETUP权限。 这意味着单个用户可以发出请求，但不能建立其他连接。

[[rsocket-authentication-basic]]
=== Basic Authentication

Spring Security对RSocket的https://github.com/rsocket/rsocket/issues/272[基本身份验证元数据扩展提供了早期支持]。

RSocket接收器可以使用 `BasicAuthenticationPayloadExchangeConverter` 解码凭据，`BasicAuthenticationPayloadExchangeConverter` 使用DSL的 `basicAuthentication` 部分自动设置。 可以在下面找到显式配置。

[source,java]
----
@Bean
PayloadSocketAcceptorInterceptor rsocketInterceptor(RSocketSecurity rsocket) {
	rsocket
		.authorizePayload(authorize ->
			authorize
					.anyRequest().authenticated()
					.anyExchange().permitAll()
		)
		.basicAuthentication(Customizer.withDefaults());
	return rsocket.build();
}
----

RSocket发送者可以使用 `BasicAuthenticationEncoder` 发送凭证，该凭证可以添加到Spring的 `RSocketStrategies` 中。

[source,java]
----
RSocketStrategies.Builder strategies = ...;
strategies.encoder(new BasicAuthenticationEncoder());
----

然后可以使用它在设置中向接收方发送用户名和密码：

[source,java]
----
UsernamePasswordMetadata credentials = new UsernamePasswordMetadata("user", "password");
Mono<RSocketRequester> requester = RSocketRequester.builder()
	.setupMetadata(credentials, UsernamePasswordMetadata.BASIC_AUTHENTICATION_MIME_TYPE)
	.rsocketStrategies(strategies.build())
	.connectTcp(host, port);
----

替代地或附加地，可以在请求中发送用户名和密码。

[source,java]
----
Mono<RSocketRequester> requester;
UsernamePasswordMetadata credentials = new UsernamePasswordMetadata("user", "password");

public Mono<AirportLocation> findRadar(String code) {
	return this.requester.flatMap(req ->
		req.route("find.radar.{code}", code)
			.metadata(credentials, UsernamePasswordMetadata.BASIC_AUTHENTICATION_MIME_TYPE)
			.retrieveMono(AirportLocation.class)
	);
}
----

[[rsocket-authentication-jwt]]
=== JWT

Spring Security对RSocket的 https://github.com/rsocket/rsocket/issues/272[RSocket's Bearer Token Authentication Metadata Extension]。 支持以对JWT进行身份验证（确定JWT有效）的形式出现，然后使用JWT做出授权决策。

RSocket接收器可以使用 `BearerPayloadExchangeConverter` 解码凭据，而 `BearerPayloadExchangeConverter` 使用DSL的 `jwt` 部分自动设置。 可以在下面找到示例配置：

[source,java]
----
@Bean
PayloadSocketAcceptorInterceptor rsocketInterceptor(RSocketSecurity rsocket) {
	rsocket
		.authorizePayload(authorize ->
			authorize
				.anyRequest().authenticated()
				.anyExchange().permitAll()
		)
		.jwt(Customizer.withDefaults());
	return rsocket.build();
}
----

上面的配置取决于是否存在 `ReactiveJwtDecoder` `@Bean`。在发行人处创建一个示例的示例如下：

[source,java]
----
@Bean
ReactiveJwtDecoder jwtDecoder() {
	return ReactiveJwtDecoders
		.fromIssuerLocation("https://example.com/auth/realms/demo");
}
----

RSocket发送方不需要执行任何特殊操作即可发送令牌，因为该值只是一个简单的String。例如，可以在设置时发送令牌：

[source,java]
----
String token = ...;
Mono<RSocketRequester> requester = RSocketRequester.builder()
	.setupMetadata(token, BearerTokenMetadata.BEARER_AUTHENTICATION_MIME_TYPE)
	.connectTcp(host, port);
----

替代地或附加地，可以在请求中发送令牌。

[source,java]
----
Mono<RSocketRequester> requester;
String token = ...;

public Mono<AirportLocation> findRadar(String code) {
	return this.requester.flatMap(req ->
		req.route("find.radar.{code}", code)
	        .metadata(token, BearerTokenMetadata.BEARER_AUTHENTICATION_MIME_TYPE)
			.retrieveMono(AirportLocation.class)
	);
}
----

[[rsocket-authorization]]
== RSocket 授权

RSocket授权是通过 `AuthorizationPayloadInterceptor` 执行的，`AuthorizationPayloadInterceptor` 充当调用 `ReactiveAuthorizationManager` 实例的控制器。 DSL可用于基于 `PayloadExchange` 设置授权规则。 可以在下面找到示例配置：

[[source,java]]
----
rsocket
	.authorizePayload(authorize ->
		authz
			.setup().hasRole("SETUP") // <1>
			.route("fetch.profile.me").authenticated() // <2>
			.matcher(payloadExchange -> isMatch(payloadExchange)) // <3>
				.hasRole("CUSTOM")
			.route("fetch.profile.{username}") // <4>
				.access((authentication, context) -> checkFriends(authentication, context))
			.anyRequest().authenticated() // <5>
			.anyExchange().permitAll() // <6>
	)
----
<1> 建立连接需要权限 `ROLE_SETUP`
<2> 如果路由为 `fetch.profile.me`，则授权仅要求对用户进行身份验证
<3> 在此规则中，我们设置了一个自定义匹配器，其中的授权要求用户具有权限 `ROLE_CUSTOM`
<4> 此规则利用自定义授权。 匹配器用名称  `username` 表示变量，该变量在 `context` 中可用。 自定义授权规则在 `checkFriends` 方法中公开。
<5> 此规则可确保没有规则的请求将要求对用户进行身份验证。 请求是包含元数据的地方。 它不会包括其他有效载荷。
<6> 该规则可确保任何人都没有规则的任何交换。 在此示例中，这意味着没有元数据的有效负载没有授权规则。

重要的是要了解授权规则是按顺序执行的。 仅匹配的第一个授权规则将被调用。
