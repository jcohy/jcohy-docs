= Spring Cloud Gateway
include::_attributes.adoc[]

*{spring-cloud-version}*

include::intro.adoc[]

[[gateway-starter]]
== 如何 Spring Cloud Gateway

如果想要在你的项目中使用 Spring Cloud Gateway, 请使用 group Id 为 `org.springframework.cloud` ， artifact ID 为 `spring-cloud-starter-gateway` 的 starter.
请查看 https://projects.spring.io/spring-cloud/[Spring Cloud Project page] 了解有关使用当前 Spring Cloud Release Train 的详细信息。.

如果你包含了 starter，但是你不想启用网关，设置 `spring.cloud.gateway.enabled=false`。


IMPORTANT: Spring Cloud Gateway 构建在 https://spring.io/projects/spring-boot#learn[Spring Boot 2.x], https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html[Spring WebFlux], 和 https://projectreactor.io/docs[Project Reactor].
之上，因此，当您使用 Spring Cloud Gateway 时，您所知道同步库（例如 Spring Data 和 Spring Security）的模式可能并不适用。
如果您不熟悉这些项目，我们建议您在使用 Spring Cloud Gateway 之前，先阅读它们的文档，以熟悉一些新概念。

IMPORTANT: Spring Cloud Gateway 需要 Spring Boot 和 Spring Webflux 提供的 Netty 运行时。 它不能在传统的 Servlet 容器中工作，也构建为 WAR 使用。

== 术语

* *Route（路由）*: 网关的基本构件。它包含了一个 ID、一个目的地 URI、一个谓词（Predicate）集合和一个过滤器（Filter）集合。如果谓词集合为真，则路由被匹配。.
* *Predicate（谓词）*: 这是一个 https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html[Java 8 Function Predicate]. 输入类型是 https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/server/ServerWebExchange.html[Spring Framework `ServerWebExchange`]。
这让你可以在 HTTP 请求中的任何内容上进行匹配，比如 header 或查询参数。
* *Filter（过滤器）*: 这是 {github-code}/spring-cloud-gateway-server/src/main/java/org/springframework/cloud/gateway/filter/GatewayFilter.java[`GatewayFilter`] 的实例，已经有一些特殊工厂构建。你可以在发送请求之前或之后在过滤器中修改请求和响应。

[[gateway-how-it-works]]
== 它是如何工作的

下图提供了一个关于 Spring Cloud Gateway 如何工作的高层次概述。

image:: {image-resource}/spring_cloud_gateway_diagram.png[Spring Cloud Gateway Diagram]

客户端向 Spring Cloud Gateway 发出请求。如果 Gateway 的 Handler Mapping 确定一个请求与路由相匹配，它将被发送到 Gateway Web 处理器上。
这个处理器通过一个特定于该请求的过滤器链来执行该请求。过滤器被虚线分割的原因是，过滤器可以在代理请求发送之前和之后执行一些逻辑。所有的 "`pre`" （前）过滤器逻辑都被执行。然后发出代理请求。
在代理请求发出后，"`post`" （后）过滤器逻辑被运行。

NOTE: 在路由中定义的没有端口的 URI，其 HTTP 和 HTTPS URI 的默认端口值分别为 80 和 443。

== 配置 Route Predicate 工厂和 Gateway Filter 工厂

有两张方式配置 predicates 和 filters：快捷方式的和完整的参数，大多数情况下使用快捷方式

名称和参数名称作为 `code` 列在每一节的第一或第二句中。参数通常按照快捷配置所需的顺序列出。

=== 快捷配置

快捷方式配置由过滤器名称（filter name），后面跟一个等号 (`=`)，然后是用逗号 (`,`) 分隔的参数值。

.application.yml
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: after_route
        uri: https://example.org
        predicates:
        - Cookie=mycookie,mycookievalue
----

上面的例子定义了 `Cookie` 路由谓词工厂，有两个参数，有两个参数，cookie 名称， `mycookie` 和与 `mycookievalue` 匹配的值。

=== 完整配置

完全配置看起来更像标准的 yaml 配置，有 name/value 键值对。一般来说，会有一个 `name` key 和一个 `args` key。args key 是一个键值对的映射，用于配置谓词或过滤器。

.application.yml
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: after_route
        uri: https://example.org
        predicates:
        - name: Cookie
          args:
            name: mycookie
            regexp: mycookievalue
----

这就是上面所示的 `Cookie` 谓词的快捷配置的完整配置。

[[gateway-request-predicates-factories]]
== Route Predicate Factories(路由谓词工厂)

Spring Cloud Gateway 将路由匹配作为 Spring WebFlux `HandlerMapping` 基础设施的一部分。Spring Cloud Gateway 包括许多内置的路由谓词工厂。
所有这些谓词都与 HTTP 请求的不同属性相匹配。你可以用逻辑 `and` 语句组合多个路由谓词工厂。

=== After

`After` 路由谓词工厂需要一个参数，即 `datetime`（这是一个 java `ZonedDateTime`）。这个谓词匹配发生在指定日期时间之后的请求。下面的例子配置了一个 `After` 路由谓词。


.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: after_route
        uri: https://example.org
        predicates:
        - After=2017-01-20T17:42:47.789-07:00[America/Denver]
----
====

该路由与北美山区时间（丹佛）2017 年 1 月 20 日 17:42 之后发出的任何请求相匹配。

=== Before

Before 路由谓词工厂只需要一个参数，即 `datetime`（这是一个 java `ZonedDateTime`）。这个谓词匹配发生在指定 `datetime` 之前的请求。下面的例子配置了一 `个Before` 路由谓词。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: before_route
        uri: https://example.org
        predicates:
        - Before=2017-01-20T17:42:47.789-07:00[America/Denver]
----
====

该路由与北美山区时间2017年1月20日17:42（丹佛）之前发出的任何请求相匹配。

=== Between

`Between` 路由谓词工厂需要两个参数，`datetime1` 和 `datetime2`，它们是 java `ZonedDateTime` 对象。这个谓词匹配发生在 `datetime1` 之后和 `datetime2` 之前的请求。
`datetime2` 的参数必须在 `datetime1` 之后。下面的例子配置了一个 between 路由谓词。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: between_route
        uri: https://example.org
        predicates:
        - Between=2017-01-20T17:42:47.789-07:00[America/Denver], 2017-01-21T17:42:47.789-07:00[America/Denver]
----
====

这个路由匹配 2017 年 1 月 20 日山区时间（丹佛）17:42 之后和 2017 年 1 月 21 日山区时间（丹佛）17:42 之前的任何请求。这对维护窗口可能是有用的。

=== Cookie

`Cookie` 路由谓词工厂接受两个参数，即 cookie `name` 和一个 `regexp`（这是一个 Java 正则表达式）。这个谓词匹配具有给定名称且其值符合正则表达式的 cookie。
下面的例子配置了一个 cookie 路由谓词工厂。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: cookie_route
        uri: https://example.org
        predicates:
        - Cookie=chocolate, ch.p
----
====

这个路由匹配有一个名为 `chocolate` 的cookie，其值符合 `ch.p` 正则表达式的请求。

=== Header

`Header` 路由谓词工厂需要两个参数，`header` 和一个 `regexp`（这是一个 Java 正则表达式）。这个谓词与具有给定名称且其值与正则表达式相匹配的 `header` 匹配。下面的例子配置了一个 header 路由谓词。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: header_route
        uri: https://example.org
        predicates:
        - Header=X-Request-Id, \d+
----
====

如果请求有一个名为 `X-Request-Id` 的header，其值与 `\d+` 正则表达式相匹配（也就是说，它的值是一个或多个数字），则该路由匹配。

=== Host

`Host` 路由谓语工厂接受一个参数：一个主机（Host）名称的 `patterns` 列表。该 pattern 是 Ant 风格的模式，以 `.` 为分隔符。这个谓词匹配符合该 pattern 的 `Host` header。
下面的例子配置了一个 host 路由谓词。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: host_route
        uri: https://example.org
        predicates:
        - Host=**.somehost.org,**.anotherhost.org
----
====

支持URI模板变量（如 `{sub}.myhost.org`）。

如果请求的 `Host` header 的值为 `www.somehost.org` 或 `beta.somehost.org` 或 `www.anotherhost.org`，则该路由匹配。

这个谓词提取 URI 模板变量（比如前面例子中定义的 `sub`）作为名称和值的映射，并将其放在 `ServerWebExchange.getAttributes()` 中，`key` 值定义在 `ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE`。
然后这些值就可以被 <<gateway-route-filters,`GatewayFilter` factories>> 使用了。

=== Method

`Method` 路由谓词工厂接受一个 `methods` 参数，它是一个或多个参数：要匹配的 HTTP 方法。下面的例子配置了一个 method 路由谓词。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: method_route
        uri: https://example.org
        predicates:
        - Method=GET,POST
----
====

如果请求方式是 `GET` 或 `POST`，则该路由匹配。

=== Path

`Path` 路由谓词工厂需要两个参数：一个 Spring `PathMatcher` `patterns` 的 list 和一个可选的 flag `matchTrailingSlash`（默认为 true）。下面的例子配置了一个 path 路由谓词。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: path_route
        uri: https://example.org
        predicates:
        - Path=/red/{segment},/blue/{segment}
----
====

如果请求路径是 `/red/1` 或 `/red/1/` 或 `/red/blue` 或 `/blue/green`，则该路由匹配。

如果 `matchTrailingSlash` 被设置为 `false`，那么请求路径 `/red/1/` 将不会被匹配。

这个谓词提取 URI 模板变量（比如前面例子中定义的 `segment`）作为 name 和 value 的映射，并把它放在 `ServerWebExchange.getAttributes()` 中，KEY 值定义在 `ServerWebExchangeUtils.URI_TEMPLATE_VARIABLES_ATTRIBUTE`。
然后这些值就可以被 <<gateway-route-filters,`GatewayFilter` factories>> 使用了。

有一个实用的方法（称为 `get`），可以使访问这些变量变得更容易。下面的例子显示了如何使用 `get` 方法。

====
[source,java]
----
Map<String, String> uriVariables = ServerWebExchangeUtils.getPathPredicateVariables(exchange);

String segment = uriVariables.get("segment");
----
====

=== Query

`Query` 路由谓词工厂需要两个参数：一个必需的 `param` 和一个可选的 `regexp`（这是一个 Java 正则表达式）。下面的例子配置了一个 query 路由谓词。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: query_route
        uri: https://example.org
        predicates:
        - Query=green
----
====

如果请求包含一个 `green` 的查询参数，前面的路由就会匹配。

.application.yml
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: query_route
        uri: https://example.org
        predicates:
        - Query=red, gree.
----

如果请求中包含一个 `red` 的查询参数，其值与 `gree.` 表达式相匹配，那么路由就会匹配。例如： `green` 和 `greet` 。

=== RemoteAddr

`RemoteAddr` 路由谓词工厂接受一个 `sources` 集合（最小长度为 `1`），它是  CIDR-notation （IPv4 或 IPv6）字符串，如 `192.168.0.1/16`（其中 `192.168.0.1` 是一个IP地址，16 是一个子网掩码）。下面的例子配置了一个 `RemoteAddr` 路由谓词。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: remoteaddr_route
        uri: https://example.org
        predicates:
        - RemoteAddr=192.168.1.1/24
----
====

如果请求的远程地址 `192.168.1.10`，则该路由匹配。

==== 修改远程地址（Remote Addresse）的解析方式

默认情况下，`RemoteAddr` 路由谓语工厂使用传入请求中的远程地址。如果 Spring Cloud Gateway 位于代理层后面，这可能与实际的客户 IP 地址不一致。

你可以通过设置一个自定义的 `RemoteAddressResolver` 来定制远程地址的解析方式。Spring Cloud Gateway 有一个非默认的远程地址解析器，它是基于 `X-Forwarded-For` Header 的，
即 `XForwardedRemoteAddressResolver`。

`XForwardedRemoteAddressResolver` 有两个静态构造方法，它们对安全问题采取了不同的方法。

* `XForwardedRemoteAddressResolver::trustAll` 返回一个 `RemoteAddressResolver`，它总是采用 `X-Forwarded-For` 头中发现的第一个 IP 地址。这种方法容易受到欺骗，因为恶意的客户端可以为 `X-Forwarded-For` 设置一个初始值，这将被解析器所接受。
* `XForwardedRemoteAddressResolver::maxTrustedIndex` 需要一个索引，该索引与在 Spring Cloud Gateway 前面运行的可信基础设施的数量相关。例如，如果 Spring Cloud Gateway 只能通过 `HAProxy` 访问，那么应使用 `1` 的值。如果在 Spring Cloud Gateway 被访问之前需要经过 `2` 个受信任的基础设施，那么应该使用 `2` 的值。

请考虑以下 header 值。

====
[source]
----
X-Forwarded-For: 0.0.0.1, 0.0.0.2, 0.0.0.3
----
====

以下的 `maxTrustedIndex` 值产生以下的远程地址。

[options="header"]
|===
|`maxTrustedIndex`           | result
|[`Integer.MIN_VALUE`,0]     | (invalid, `IllegalArgumentException` during initialization)
|1                           | 0.0.0.3
|2                           | 0.0.0.2
|3                           | 0.0.0.1
|[4, `Integer.MAX_VALUE`]    | 0.0.0.1
|===

下面的例子显示了如何用 Java 实现同样的配置。

.GatewayConfig.java
====
[source,java]
----
RemoteAddressResolver resolver = XForwardedRemoteAddressResolver
    .maxTrustedIndex(1);

...

.route("direct-route",
    r -> r.remoteAddr("10.1.1.1", "10.10.1.1/24")
        .uri("https://downstream1")
.route("proxied-route",
    r -> r.remoteAddr(resolver, "10.10.1.1", "10.10.1.1/24")
        .uri("https://downstream2")
)
----
====

=== Weight

`Weight` 路由谓语工厂需要两个参数：`group` 和 `weight`（一个int值）。`weight` 是按 `group` 计算的。下面的例子配置了一个 weight 路由谓词。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: weight_high
        uri: https://weighthigh.org
        predicates:
        - Weight=group1, 8
      - id: weight_low
        uri: https://weightlow.org
        predicates:
        - Weight=group1, 2
----
====

此路由将转发 `~80%` 的流量到 https://weighthigh.org，`~20%` 的流量到 https://weighlow.org。

=== XForwarded Remote Addr

``XForwarded Remote Addr ``路由谓语工厂接受一个 `sources` 集合（最长度为 `1`），这些 `sources` 是 CIDR-notation（IPv4 或 IPv6）字符串，如 `192.168.0.1/16`（其中 192.168.0.1 是一个 IP 地址，16 是子网掩码）。

这个路由谓词允许根据 `X-Forwarded-For` 的 HTTP Header 对请求进行过滤。

这可以与反向代理一起使用，如负载均衡器或 web 应用防火墙，只有当请求来自这些反向代理所使用的受信任的 IP 地址列表时，才应该被允许。

下面的例子配置了一个 `XForwardedRemoteAddr` 路由谓词。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: xforwarded_remoteaddr_route
        uri: https://example.org
        predicates:
        - XForwardedRemoteAddr=192.168.1.1/24
----
====

例如，如果 `X-Forwarded-For` Header 包含 `192.168.1.10`，则该路由匹配。

[[gatewayfilter-factories]]
== `GatewayFilter` 工厂

路由（Route）过滤器（Filter）允许以某种方式修改传入的 HTTP 请求或传出的 HTTP 响应。路由过滤器的范围是一个特定的路由。Spring Cloud Gateway 包括许多内置的 GatewayFilter 工厂。

NOTE: 关于如何使用以下任何过滤器的更详细的例子，请看
https://github.com/spring-cloud/spring-cloud-gateway/tree/master/spring-cloud-gateway-server/src/test/java/org/springframework/cloud/gateway/filter/factory[单元测试].

=== `AddRequestHeader` `GatewayFilter` 工厂

`AddRequestHeader` `GatewayFilter` 工厂需要一个 `name` 和 `value` 参数。下面的例子配置了一个 `AddRequestHeader` `GatewayFilter`。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: add_request_header_route
        uri: https://example.org
        filters:
        - AddRequestHeader=X-Request-red, blue
----
====

这个列表将 `X-Request-red:blue` header 添加到所有匹配请求的下游请求的 header 信息中。

`AddRequestHeader` 知道用于匹配路径或主机的URI变量。URI变量可以在值中使用，并在运行时被扩展。下面的例子配置了一个 `AddRequestHeader` `GatewayFilter`，它使用一个变量。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: add_request_header_route
        uri: https://example.org
        predicates:
        - Path=/red/{segment}
        filters:
        - AddRequestHeader=X-Request-Red, Blue-{segment}
----
====

=== `AddRequestHeadersIfNotPresent` `GatewayFilter` 工厂

`AddRequestHeadersIfNotPresent` `GatewayFilter` 工厂接受一个由冒号分隔的 `name` 和 `value` 键值对的集合。下面的例子配置了一个 `AddRequestHeadersIfNotPresent` `GatewayFilter`。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: add_request_headers_route
        uri: https://example.org
        filters:
        - AddRequestHeadersIfNotPresent=X-Request-Color-1:blue,X-Request-Color-2:green
----
====

这个列表为所有匹配的请求在下游请求的 header 信息中添加了两个 header 信息 `X-Request-Color-1:blue` 和 `X-Request-Color-2:green`。
这类似于 `AddRequestHeader` 的工作方式，但与 `AddRequestHeader` 不同的是，它只在 header 信息不存在的情况下才会这样做。否则，客户端请求中的原始值将被发送。

此外，要设置一个多值 header，可以多次使用 header 的名称，如 `AddRequestHeadersIfNotPresent=X-Request-Color-1:blue,X-Request-Color-1:green`。

`AddRequestHeadersIfNotPresent` 也支持 URI 变量，用于匹配路径或主机。URI 变量可以在值中使用，并在运行时被扩展。下面的例子配置了一个使用变量的 `AddRequestHeadersIfNotPresent` `GatewayFilter`。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: add_request_header_route
        uri: https://example.org
        predicates:
        - Path=/red/{segment}
        filters:
        - AddRequestHeadersIfNotPresent=X-Request-Red:Blue-{segment}
----
====

=== `AddRequestParameter` `GatewayFilter` 工厂

`AddRequestParameter` `GatewayFilter` Factory 需要一个 `name` 和 `value` 参数。下面的例子配置了一个 `AddRequestParameter` `GatewayFilter`。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: add_request_parameter_route
        uri: https://example.org
        filters:
        - AddRequestParameter=red, blue
----
====

这将为所有匹配的请求在下游请求的查询字符串中添加 `red=blue`。
`AddRequestParameter` 知道用于匹配路径或主机的 URI 变量。URI 变量可以在值中使用，并在运行时被扩展。下面的例子配置了一个 `AddRequestParameter` `GatewayFilter`，它使用了一个变量。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: add_request_parameter_route
        uri: https://example.org
        predicates:
        - Host: {segment}.myhost.org
        filters:
        - AddRequestParameter=foo, bar-{segment}
----
====

=== `AddResponseHeader` `GatewayFilter` 工厂

`AddResponseHeader` `GatewayFilter` 工厂需要一个 `name` 和 `value` 参数。下面的例子配置了一个 `AddResponseHeader` `GatewayFilter`。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: add_response_header_route
        uri: https://example.org
        filters:
        - AddResponseHeader=X-Response-Red, Blue
----
====

这将把 `X-Response-Red:Blue` header 添加到所有匹配请求的下游响应的 header 中。

`AddResponseHeader` 知道用于匹配路径或主机的 URI 变量。URI 变量可以在值中使用，并在运行时被扩展。下面的例子配置了一个 `AddResponseHeader` `GatewayFilter`，它使用了一个变量。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: add_response_header_route
        uri: https://example.org
        predicates:
        - Host: {segment}.myhost.org
        filters:
        - AddResponseHeader=foo, bar-{segment}
----
====

[[spring-cloud-circuitbreaker-filter-factory]]
=== `CircuitBreaker` `GatewayFilter` 工厂

Spring Cloud CircuitBreaker GatewayFilter 工厂使用 Spring Cloud CircuitBreaker API 将 Gateway 路由包裹在一个熔断器中。
Spring Cloud CircuitBreaker 支持多个可与 Spring Cloud Gateway 一起使用的库。Spring Cloud 支持 Resilience4J 开箱即用。

要启用 Spring Cloud CircuitBreaker 过滤器，你需要添加 `spring-cloud-starter-circuitbreaker-reactor-resilience4j` 依赖。下面的例子配置了一个 Spring Cloud CircuitBreaker GatewayFilter。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: circuitbreaker_route
        uri: https://example.org
        filters:
        - CircuitBreaker=myCircuitBreaker
----
====

要配置熔断器，请参阅你所使用的底层熔断器实现的配置。

* https://cloud.spring.io/spring-cloud-circuitbreaker/reference/html/spring-cloud-circuitbreaker.html[Resilience4J Documentation]

Spring Cloud CircuitBreaker 过滤器还可以接受一个可选的 `fallbackUri` 参数。目前，只支持 `forward:` 模式的 URI。如果 fallback 被调用，请求将被转发到 URI 所匹配的控制器。下面的例子配置了这样一个 fallback。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: circuitbreaker_route
        uri: lb://backing-service:8088
        predicates:
        - Path=/consumingServiceEndpoint
        filters:
        - name: CircuitBreaker
          args:
            name: myCircuitBreaker
            fallbackUri: forward:/inCaseOfFailureUseThis
        - RewritePath=/consumingServiceEndpoint, /backingServiceEndpoint
----
====

也可以通过Java来实现相同的配置，如下:

.Application.java
====
[source,java]
----
@Bean
public RouteLocator routes(RouteLocatorBuilder builder) {
    return builder.routes()
        .route("circuitbreaker_route", r -> r.path("/consumingServiceEndpoint")
            .filters(f -> f.circuitBreaker(c -> c.name("myCircuitBreaker").fallbackUri("forward:/inCaseOfFailureUseThis"))
                .rewritePath("/consumingServiceEndpoint", "/backingServiceEndpoint")).uri("lb://backing-service:8088")
        .build();
}
----
====

当熔断器 fallback 被调用时，这个例子转发到 `/inCaseofFailureUseThis` URI。请注意，这个例子还演示了（可选）Spring Cloud LoadBalancer 的负载均衡（由目标 URI 上的 `lb` 前缀定义）。

`CircuitBreaker` 还支持 `fallbackUri` 中的URI变量。这允许更复杂的路由选项，比如使用 PathPattern 表达式 转发原始主机或 URL 路径的部分。

在下面的例子中，调用 `consumingServiceEndpoint/users/1` 将被重定向到 `inCaseOfFailureUseThis/users/1`。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: circuitbreaker_route
        uri: lb://backing-service:8088
        predicates:
        - Path=/consumingServiceEndpoint/{*segments}
        filters:
        - name: CircuitBreaker
          args:
            name: myCircuitBreaker
            fallbackUri: forward:/inCaseOfFailureUseThis/{segments}
----
====

一般情况下是使用 `fallbackUri` 来定义网关应用程序中的内部 controller 或 handler。然而，你也可以将请求重新路由到外部应用程序的 controller 或 handler，如下所示。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: ingredients
        uri: lb://ingredients
        predicates:
        - Path=//ingredients/**
        filters:
        - name: CircuitBreaker
          args:
            name: fetchIngredients
            fallbackUri: forward:/fallback
      - id: ingredients-fallback
        uri: http://localhost:9994
        predicates:
        - Path=/fallback
----
====

在这个例子中，网关应用程序中没有 `fallback` 端点或处理程序。然而，在另一个应用程序中有一个，在 `http://localhost:9994` 下注册。

在请求被转发到 `fallback` 的情况下，Spring Cloud CircuitBreaker Gateway 过滤器也提供了造成这种情况的 `Throwable`。它作为 `ServerWebExchangeUtils.CIRCUITBREAKER_EXECUTION_EXCEPTION_ATTR` 属性被添加到 `ServerWebExchange` 中，
在网关应用中处理 `fallback` 时可以使用。

对于外部 controller/handler 的情况，可以添加带有异常细节的header。你可以在 <<fallback-headers, FallbackHeaders GatewayFilter Factory 章节>>找到更多关于这样做的信息。

[[circuit-breaker-status-codes]]
==== 熔断指定的状态码

在某些情况下，你可能想根据它所包裹的路由返回的状态码来熔断。断路器配置对象需要一个状态码列表，如果返回这些代码将导致断路器熔断。
当设置你想让断路器熔断的状态代码时，你可以使用一个带有状态码值的 `int` 或 `HttpStatus` 枚举的字符串表示。

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: circuitbreaker_route
        uri: lb://backing-service:8088
        predicates:
        - Path=/consumingServiceEndpoint
        filters:
        - name: CircuitBreaker
          args:
            name: myCircuitBreaker
            fallbackUri: forward:/inCaseOfFailureUseThis
            statusCodes:
              - 500
              - "NOT_FOUND"
----
====

.Application.java
====
[source,java]
----
@Bean
public RouteLocator routes(RouteLocatorBuilder builder) {
    return builder.routes()
        .route("circuitbreaker_route", r -> r.path("/consumingServiceEndpoint")
            .filters(f -> f.circuitBreaker(c -> c.name("myCircuitBreaker").fallbackUri("forward:/inCaseOfFailureUseThis").addStatusCode("INTERNAL_SERVER_ERROR"))
                .rewritePath("/consumingServiceEndpoint", "/backingServiceEndpoint")).uri("lb://backing-service:8088")
        .build();
}
----
====

=== The `CacheRequestBody` `GatewayFilter` Factory
Some situations necessitate reading the request body. Since the request can be read only once, we need to cache the request body.
You can use the `CacheRequestBody` filter to cache the request body before sending it downstream and getting the body from `exchange` attribute.

The following listing shows how to cache the request body `GatewayFilter`:

====
[source,java]
----
@Bean
public RouteLocator routes(RouteLocatorBuilder builder) {
    return builder.routes()
        .route("cache_request_body_route", r -> r.path("/downstream/**")
            .filters(f -> f.prefixPath("/httpbin")
        		.cacheRequestBody(String.class).uri(uri))
        .build();
}
----
====


.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: cache_request_body_route
        uri: lb://downstream
        predicates:
        - Path=/downstream/**
        filters:
        - name: CacheRequestBody
          args:
            bodyClass: java.lang.String
----
====
`CacheRequestBody` extracts the request body and converts it to a body class (such as `java.lang.String`, defined in the preceding example).
`CacheRequestBody` then places it in the attributes available from `ServerWebExchange.getAttributes()`, with a key defined in `ServerWebExchangeUtils.CACHED_REQUEST_BODY_ATTR`.

NOTE: This filter works only with HTTP (including HTTPS) requests.

=== The `DedupeResponseHeader` `GatewayFilter` Factory

The `DedupeResponseHeader` GatewayFilter factory takes a `name` parameter and an optional `strategy` parameter. `name` can contain a space-separated list of header names.
The following example configures a `DedupeResponseHeader` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: dedupe_response_header_route
        uri: https://example.org
        filters:
        - DedupeResponseHeader=Access-Control-Allow-Credentials Access-Control-Allow-Origin
----
====

This removes duplicate values of `Access-Control-Allow-Credentials` and `Access-Control-Allow-Origin` response headers in cases when both the gateway CORS logic and the downstream logic add them.

The `DedupeResponseHeader` filter also accepts an optional `strategy` parameter.
The accepted values are `RETAIN_FIRST` (default), `RETAIN_LAST`, and `RETAIN_UNIQUE`.


[[fallback-headers]]
=== The `FallbackHeaders` `GatewayFilter` Factory

The `FallbackHeaders` factory lets you add Spring Cloud CircuitBreaker execution exception details in the headers of a request forwarded to a `fallbackUri` in an external application, as in the following scenario:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: ingredients
        uri: lb://ingredients
        predicates:
        - Path=//ingredients/**
        filters:
        - name: CircuitBreaker
          args:
            name: fetchIngredients
            fallbackUri: forward:/fallback
      - id: ingredients-fallback
        uri: http://localhost:9994
        predicates:
        - Path=/fallback
        filters:
        - name: FallbackHeaders
          args:
            executionExceptionTypeHeaderName: Test-Header
----
====

In this example, after an execution exception occurs while running the circuit breaker, the request is forwarded to the `fallback` endpoint or handler in an application running on `localhost:9994`.
The headers with the exception type, message and (if available) root cause exception type and message are added to that request by the `FallbackHeaders` filter.

You can overwrite the names of the headers in the configuration by setting the values of the following arguments (shown with their default values):

* `executionExceptionTypeHeaderName` (`"Execution-Exception-Type"`)
* `executionExceptionMessageHeaderName` (`"Execution-Exception-Message"`)
* `rootCauseExceptionTypeHeaderName` (`"Root-Cause-Exception-Type"`)
* `rootCauseExceptionMessageHeaderName` (`"Root-Cause-Exception-Message"`)

For more information on circuit breakers and the gateway see the <<spring-cloud-circuitbreaker-filter-factory, Spring Cloud CircuitBreaker Factory section>>.

=== The `JsonToGrpc` `GatewayFilter` Factory

The JSONToGRPCFilter GatewayFilter Factory converts a JSON payload to a gRPC request.

The filter takes the following arguments:

* `protoDescriptor`: Proto descriptor file.

This file can be generated using `protoc` and specifying the `--descriptor_set_out` flag:

[source,bash]
----
protoc --proto_path=src/main/resources/proto/ \
--descriptor_set_out=src/main/resources/proto/hello.pb  \
src/main/resources/proto/hello.proto
----

* `protoFile`: Proto definition file.

* `service`: Fully qualified name of the service that handles the request.

* `method`: Method name in the service that handles the request.

NOTE: `streaming` is not supported.


*application.yml.*

[source,java]
----
@Bean
public RouteLocator routes(RouteLocatorBuilder builder) {
    return builder.routes()
            .route("json-grpc", r -> r.path("/json/hello").filters(f -> {
                String protoDescriptor = "file:src/main/proto/hello.pb";
                String protoFile = "file:src/main/proto/hello.proto";
                String service = "HelloService";
                String method = "hello";
                return f.jsonToGRPC(protoDescriptor, protoFile, service, method);
            }).uri(uri))
----

[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
        - id: json-grpc
          uri: https://localhost:6565/testhello
          predicates:
            - Path=/json/**
          filters:
            - name: JsonToGrpc
              args:
                protoDescriptor: file:proto/hello.pb
                protoFile: file:proto/hello.proto
                service: com.example.grpcserver.hello.HelloService
                method: hello

----

When a request is made through the gateway to `/json/hello`, the request is transformed by using the definition provided in `hello.proto`, sent to `com.example.grpcserver.hello.HelloService/hello`, and the response back is transformed to JSON.

By default, it creates a `NettyChannel` by using the default `TrustManagerFactory`. However, you can customize this `TrustManager` by creating a bean of type `GrpcSslConfigurer`:

[source,java]
----

@Configuration
public class GRPCLocalConfiguration {
    @Bean
    public GRPCSSLContext sslContext() {
		TrustManager trustManager = trustAllCerts();
        return new GRPCSSLContext(trustManager);
    }
}
----


=== The `LocalResponseCache` `GatewayFilter` Factory

This filter allows caching the response body and headers to follow these rules:

* It can only cache bodiless GET requests.
* It caches the response only for one of the following status codes: HTTP 200 (OK), HTTP 206 (Partial Content), or HTTP 301 (Moved Permanently).
* Response data is not cached if `Cache-Control` header does not allow it (`no-store` present in the request or `no-store` or `private` present in the response).
* If the response is already cached and a new request is performed with no-cache value in `Cache-Control` header, it returns a bodiless response with 304 (Not Modified).

This filter (which configures the local response cache per route) is available only if the <<local-cache-response-global-filter, local response global cache>> is enabled.

It accepts the first parameter to override the time to expire a cache entry (expressed in `s` for seconds, `m` for minutes, and `h` for hours) and a second parameter to set the maximum size of the cache to evict entries for this route (KB, MB, or GB).

The following listing shows how to add local response cache `GatewayFilter`:

====
[source,java]
----
@Bean
public RouteLocator routes(RouteLocatorBuilder builder) {
    return builder.routes()
        .route("rewrite_response_upper", r -> r.host("*.rewriteresponseupper.org")
            .filters(f -> f.prefixPath("/httpbin")
        		.localResponseCache(Duration.ofMinutes(30), "500MB")
            ).uri(uri))
        .build();
}
----

or this

.application.yaml
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: resource
        uri: http://localhost:9000
        predicates:
        - Path=/resource
        filters:
        - LocalResponseCache=30m,500MB
----

NOTE: This filter also automatically calculates the `max-age` value in the HTTP `Cache-Control` header.
Only if `max-age` is present on the original response is the value rewritten with the number of seconds set in the `timeToLive` configuration parameter.
In consecutive calls, this value is recalculated with the number of seconds left until the response expires.
====

=== The `MapRequestHeader` `GatewayFilter` Factory

The `MapRequestHeader` `GatewayFilter` factory takes `fromHeader` and `toHeader` parameters.
It creates a new named header (`toHeader`), and the value is extracted out of an existing named header (`fromHeader`) from the incoming http request.
If the input header does not exist, the filter has no impact.
If the new named header already exists, its values are augmented with the new values.
The following example configures a `MapRequestHeader`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: map_request_header_route
        uri: https://example.org
        filters:
        - MapRequestHeader=Blue, X-Request-Red
----
====

This adds the `X-Request-Red:<values>` header to the downstream request with updated values from the incoming HTTP request's `Blue` header.

=== The `ModifyRequestBody` `GatewayFilter` Factory

You can use the `ModifyRequestBody` filter to modify the request body before it is sent downstream by the gateway.

NOTE: This filter can be configured only by using the Java DSL.

The following listing shows how to modify a request body `GatewayFilter`:

====
[source,java]
----
@Bean
public RouteLocator routes(RouteLocatorBuilder builder) {
    return builder.routes()
        .route("rewrite_request_obj", r -> r.host("*.rewriterequestobj.org")
            .filters(f -> f.prefixPath("/httpbin")
                .modifyRequestBody(String.class, Hello.class, MediaType.APPLICATION_JSON_VALUE,
                    (exchange, s) -> return Mono.just(new Hello(s.toUpperCase())))).uri(uri))
        .build();
}

static class Hello {
    String message;

    public Hello() { }

    public Hello(String message) {
        this.message = message;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
----

NOTE: If the request has no body, the `RewriteFilter` is passed `null`. `Mono.empty()` should be returned to assign a missing body in the request.

====


=== The `ModifyResponseBody` `GatewayFilter` Factory

You can use the `ModifyResponseBody` filter to modify the response body before it is sent back to the client.

NOTE: This filter can be configured only by using the Java DSL.

The following listing shows how to modify a response body `GatewayFilter`:

====
[source,java]
----
@Bean
public RouteLocator routes(RouteLocatorBuilder builder) {
    return builder.routes()
        .route("rewrite_response_upper", r -> r.host("*.rewriteresponseupper.org")
            .filters(f -> f.prefixPath("/httpbin")
        		.modifyResponseBody(String.class, String.class,
        		    (exchange, s) -> Mono.just(s.toUpperCase()))).uri(uri))
        .build();
}
----

NOTE: If the response has no body, the `RewriteFilter` is passed `null`. `Mono.empty()` should be returned to assign a missing body in the response.
====

=== The `PrefixPath` `GatewayFilter` Factory

The `PrefixPath` `GatewayFilter` factory takes a single `prefix` parameter.
The following example configures a `PrefixPath` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: prefixpath_route
        uri: https://example.org
        filters:
        - PrefixPath=/mypath
----
====

This prefixes `/mypath` to the path of all matching requests.
So a request to `/hello` is sent to `/mypath/hello`.

=== The `PreserveHostHeader` `GatewayFilter` Factory

The `PreserveHostHeader` `GatewayFilter` factory has no parameters.
This filter sets a request attribute that the routing filter inspects to determine if the original host header should be sent rather than the host header determined by the HTTP client.
The following example configures a `PreserveHostHeader` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: preserve_host_route
        uri: https://example.org
        filters:
        - PreserveHostHeader
----
====

=== The `RedirectTo` `GatewayFilter` Factory

The `RedirectTo` `GatewayFilter` factory takes two parameters, `status` and `url`.
The `status` parameter should be a 300 series redirect HTTP code, such as 301.
The `url` parameter should be a valid URL.
This is the value of the `Location` header.
For relative redirects, you should use `uri: no://op` as the uri of your route definition.
The following listing configures a `RedirectTo` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: prefixpath_route
        uri: https://example.org
        filters:
        - RedirectTo=302, https://acme.org
----
====

This will send a status 302 with a `Location:https://acme.org` header to perform a redirect.


=== `RemoveJsonAttributesResponseBody` `GatewayFilter` Factory

The `RemoveJsonAttributesResponseBody` `GatewayFilter` factory takes a collection of `attribute names` to search for, an optional last parameter from the list can be a boolean to remove the attributes just at root level (that's the default value if not present at the end of the parameter configuration, `false`) or recursively (`true`).
It provides a convenient method to apply a transformation to JSON body content by deleting attributes from it.

The following example configures an `RemoveJsonAttributesResponseBody` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: removejsonattributes_route
        uri: https://example.org
        filters:
        - RemoveJsonAttributesResponseBody=id,color
----
====

This removes attributes "id" and "color" from the JSON content body at root level.

The following example configures an `RemoveJsonAttributesResponseBody` `GatewayFilter` that uses the optional last parameter:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: removejsonattributes_recursively_route
        uri: https://example.org
        predicates:
        - Path=/red/{segment}
        filters:
        - RemoveJsonAttributesResponseBody=id,color,true
----
====

This removes attributes "id" and "color" from the JSON content body at any level.

=== The `RemoveRequestHeader` GatewayFilter Factory

The `RemoveRequestHeader` `GatewayFilter` factory takes a `name` parameter.
It is the name of the header to be removed.
The following listing configures a `RemoveRequestHeader` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: removerequestheader_route
        uri: https://example.org
        filters:
        - RemoveRequestHeader=X-Request-Foo
----
====

This removes the `X-Request-Foo` header before it is sent downstream.

=== The `RemoveRequestParameter` `GatewayFilter` Factory

The `RemoveRequestParameter` `GatewayFilter` factory takes a `name` parameter.
It is the name of the query parameter to be removed.
The following example configures a `RemoveRequestParameter` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: removerequestparameter_route
        uri: https://example.org
        filters:
        - RemoveRequestParameter=red
----
====

This will remove the `red` parameter before it is sent downstream.


=== The `RemoveResponseHeader` `GatewayFilter` Factory

The `RemoveResponseHeader` `GatewayFilter` factory takes a `name` parameter.
It is the name of the header to be removed.
The following listing configures a `RemoveResponseHeader` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: removeresponseheader_route
        uri: https://example.org
        filters:
        - RemoveResponseHeader=X-Response-Foo
----
====

This will remove the `X-Response-Foo` header from the response before it is returned to the gateway client.

To remove any kind of sensitive header, you should configure this filter for any routes for which you may want to do so.
In addition, you can configure this filter once by using `spring.cloud.gateway.default-filters` and have it applied to all routes.


=== The `RequestHeaderSize` `GatewayFilter` Factory

The `RequestHeaderSize` `GatewayFilter` factory takes `maxSize` and `errorHeaderName` parameters.
The `maxSize` parameter is the maximum data size allowed by the request header (including key and value). The `errorHeaderName` parameter sets the name of the response header containing an error message, by default it is "errorMessage".
The following listing configures a `RequestHeaderSize` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: requestheadersize_route
        uri: https://example.org
        filters:
        - RequestHeaderSize=1000B
----
====

This will send a status 431 if size of any request header is greater than 1000 Bytes.

=== The `RequestRateLimiter` `GatewayFilter` Factory

The `RequestRateLimiter` `GatewayFilter` factory uses a `RateLimiter` implementation to determine if the current request is allowed to proceed. If it is not, a status of `HTTP 429 - Too Many Requests` (by default) is returned.

This filter takes an optional `keyResolver` parameter and parameters specific to the rate limiter (described <<key-resolver-section, later in this section>>).

`keyResolver` is a bean that implements the `KeyResolver` interface.
In configuration, reference the bean by name using SpEL.
`#{@myKeyResolver}` is a SpEL expression that references a bean named `myKeyResolver`.
The following listing shows the `KeyResolver` interface:

.KeyResolver.java
====
[source,java]
----
public interface KeyResolver {
	Mono<String> resolve(ServerWebExchange exchange);
}
----
====

[[key-resolver-section]]
The `KeyResolver` interface lets pluggable strategies derive the key for limiting requests.
In future milestone releases, there will be some `KeyResolver` implementations.

The default implementation of `KeyResolver` is the `PrincipalNameKeyResolver`, which retrieves the `Principal` from the `ServerWebExchange` and calls `Principal.getName()`.

By default, if the `KeyResolver` does not find a key, requests are denied.
You can adjust this behavior by setting the `spring.cloud.gateway.filter.request-rate-limiter.deny-empty-key` (`true` or `false`) and `spring.cloud.gateway.filter.request-rate-limiter.empty-key-status-code` properties.

[NOTE]
=====
The `RequestRateLimiter` is not configurable with the "shortcut" notation. The following example below is _invalid_:

.application.properties
====
----
# INVALID SHORTCUT CONFIGURATION
spring.cloud.gateway.routes[0].filters[0]=RequestRateLimiter=2, 2, #{@userkeyresolver}
----
====
=====

==== The Redis `RateLimiter`

The Redis implementation is based on work done at https://stripe.com/blog/rate-limiters[Stripe].
It requires the use of the `spring-boot-starter-data-redis-reactive` Spring Boot starter.

The algorithm used is the https://en.wikipedia.org/wiki/Token_bucket[Token Bucket Algorithm].

The `redis-rate-limiter.replenishRate` property defines how many requests per second to allow (without any dropped requests).
This is the rate at which the token bucket is filled.

The `redis-rate-limiter.burstCapacity` property is the maximum number of requests a user is allowed in a single second (without any dropped requests).
This is the number of tokens the token bucket can hold.
Setting this value to zero blocks all requests.

The `redis-rate-limiter.requestedTokens` property is how many tokens a request costs.
This is the number of tokens taken from the bucket for each request and defaults to `1`.

A steady rate is accomplished by setting the same value in `replenishRate` and `burstCapacity`.
Temporary bursts can be allowed by setting `burstCapacity` higher than `replenishRate`.
In this case, the rate limiter needs to be allowed some time between bursts (according to `replenishRate`), as two consecutive bursts results in dropped requests (`HTTP 429 - Too Many Requests`).
The following listing configures a `redis-rate-limiter`:

Rate limits below `1 request/s` are accomplished by setting `replenishRate` to the wanted number of requests, `requestedTokens` to the timespan in seconds, and `burstCapacity` to the product of `replenishRate` and `requestedTokens`.
For example, setting `replenishRate=1`, `requestedTokens=60`, and `burstCapacity=60` results in a limit of `1 request/min`.
.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: requestratelimiter_route
        uri: https://example.org
        filters:
        - name: RequestRateLimiter
          args:
            redis-rate-limiter.replenishRate: 10
            redis-rate-limiter.burstCapacity: 20
            redis-rate-limiter.requestedTokens: 1

----
====

The following example configures a `KeyResolver` in Java:

.Config.java
====
[source,java]
----
@Bean
KeyResolver userKeyResolver() {
    return exchange -> Mono.just(exchange.getRequest().getQueryParams().getFirst("user"));
}
----
====

This defines a request rate limit of 10 per user. A burst of 20 is allowed, but, in the next second, only 10 requests are available.
The `KeyResolver` is a simple one that gets the `user` request parameter
NOTE: This is not recommended for production

You can also define a rate limiter as a bean that implements the `RateLimiter` interface.
In configuration, you can reference the bean by name using SpEL.
`#{@myRateLimiter}` is a SpEL expression that references a bean with named `myRateLimiter`.
The following listing defines a rate limiter that uses the `KeyResolver` defined in the previous listing:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: requestratelimiter_route
        uri: https://example.org
        filters:
        - name: RequestRateLimiter
          args:
            rate-limiter: "#{@myRateLimiter}"
            key-resolver: "#{@userKeyResolver}"

----
====

=== The `RewriteLocationResponseHeader` `GatewayFilter` Factory

The `RewriteLocationResponseHeader` `GatewayFilter` factory modifies the value of the `Location` response header, usually to get rid of backend-specific details.
It takes the `stripVersionMode`, `locationHeaderName`, `hostValue`, and `protocolsRegex` parameters.
The following listing configures a `RewriteLocationResponseHeader` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: rewritelocationresponseheader_route
        uri: http://example.org
        filters:
        - RewriteLocationResponseHeader=AS_IN_REQUEST, Location, ,
----
====

For example, for a request of `POST https://api.example.com/some/object/name`, the `Location` response header value of `https://object-service.prod.example.net/v2/some/object/id` is rewritten as `https://api.example.com/some/object/id`.

The `stripVersionMode` parameter has the following possible values: `NEVER_STRIP`, `AS_IN_REQUEST` (default), and `ALWAYS_STRIP`.

* `NEVER_STRIP`: The version is not stripped, even if the original request path contains no version.
* `AS_IN_REQUEST`: The version is stripped only if the original request path contains no version.
* `ALWAYS_STRIP`: The version is always stripped, even if the original request path contains version.

The `hostValue` parameter, if provided, is used to replace the `host:port` portion of the response `Location` header.
If it is not provided, the value of the `Host` request header is used.

The `protocolsRegex` parameter must be a valid regex `String`, against which the protocol name is matched.
If it is not matched, the filter does nothing.
The default is `http|https|ftp|ftps`.

=== The `RewritePath` `GatewayFilter` Factory

The `RewritePath` `GatewayFilter` factory takes a path `regexp` parameter and a `replacement` parameter.
This uses Java regular expressions for a flexible way to rewrite the request path.
The following listing configures a `RewritePath` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: rewritepath_route
        uri: https://example.org
        predicates:
        - Path=/red/**
        filters:
        - RewritePath=/red/?(?<segment>.*), /$\{segment}
----
====

For a request path of `/red/blue`, this sets the path to `/blue` before making the downstream request. Note that the `$` should be replaced with `$\` because of the YAML specification.

=== The `RewriteResponseHeader` `GatewayFilter` Factory

The `RewriteResponseHeader` `GatewayFilter` factory takes `name`, `regexp`, and `replacement` parameters.
It uses Java regular expressions for a flexible way to rewrite the response header value.
The following example configures a `RewriteResponseHeader` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: rewriteresponseheader_route
        uri: https://example.org
        filters:
        - RewriteResponseHeader=X-Response-Red, , password=[^&]+, password=***
----
====

For a header value of `/42?user=ford&password=omg!what&flag=true`, it is set to `/42?user=ford&password=\***&flag=true` after making the downstream request.
You must use `$\` to mean `$` because of the YAML specification.

=== The `SaveSession` `GatewayFilter` Factory

The `SaveSession` `GatewayFilter` factory forces a `WebSession::save` operation _before_ forwarding the call downstream.
This is of particular use when using something like https://projects.spring.io/spring-session/[Spring Session] with a lazy data store and you need to ensure the session state has been saved before making the forwarded call.
The following example configures a `SaveSession` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: save_session
        uri: https://example.org
        predicates:
        - Path=/foo/**
        filters:
        - SaveSession
----
====

If you integrate https://projects.spring.io/spring-security/[Spring Security] with Spring Session and want to ensure security details have been forwarded to the remote process, this is critical.

=== The `SecureHeaders` `GatewayFilter` Factory

The `SecureHeaders` `GatewayFilter` factory adds a number of headers to the response, per the recommendation made in https://blog.appcanary.com/2017/http-security-headers.html[this blog post].

The following headers (shown with their default values) are added:

* `X-Xss-Protection:1 (mode=block`)
* `Strict-Transport-Security (max-age=631138519`)
* `X-Frame-Options (DENY)`
* `X-Content-Type-Options (nosniff)`
* `Referrer-Policy (no-referrer)`
* `Content-Security-Policy (default-src 'self' https:; font-src 'self' https: data:; img-src 'self' https: data:; object-src 'none'; script-src https:; style-src 'self' https: 'unsafe-inline)'`
* `X-Download-Options (noopen)`
* `X-Permitted-Cross-Domain-Policies (none)`

To change the default values, set the appropriate property in the `spring.cloud.gateway.filter.secure-headers` namespace.
The following properties are available:

* `xss-protection-header`
* `strict-transport-security`
* `x-frame-options`
* `x-content-type-options`
* `referrer-policy`
* `content-security-policy`
* `x-download-options`
* `x-permitted-cross-domain-policies`

To disable the default values set the `spring.cloud.gateway.filter.secure-headers.disable` property with comma-separated values.
The following example shows how to do so:

====
[source]
----
spring.cloud.gateway.filter.secure-headers.disable=x-frame-options,strict-transport-security
----
====

NOTE: The lowercase full name of the secure header needs to be used to disable it..

=== The `SetPath` `GatewayFilter` Factory

The `SetPath` `GatewayFilter` factory takes a path `template` parameter.
It offers a simple way to manipulate the request path by allowing templated segments of the path.
This uses the URI templates from Spring Framework.
Multiple matching segments are allowed.
The following example configures a `SetPath` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: setpath_route
        uri: https://example.org
        predicates:
        - Path=/red/{segment}
        filters:
        - SetPath=/{segment}
----
====

For a request path of `/red/blue`, this sets the path to `/blue` before making the downstream request.

=== The `SetRequestHeader` `GatewayFilter` Factory

The `SetRequestHeader` `GatewayFilter` factory takes `name` and `value` parameters.
The following listing configures a `SetRequestHeader` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: setrequestheader_route
        uri: https://example.org
        filters:
        - SetRequestHeader=X-Request-Red, Blue
----
====

This `GatewayFilter` replaces (rather than adding) all headers with the given name.
So, if the downstream server responded with a `X-Request-Red:1234`, this would be replaced with `X-Request-Red:Blue`, which is what the downstream service would receive.

`SetRequestHeader` is aware of URI variables used to match a path or host.
URI variables may be used in the value and are expanded at runtime.
The following example configures an `SetRequestHeader` `GatewayFilter` that uses a variable:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: setrequestheader_route
        uri: https://example.org
        predicates:
        - Host: {segment}.myhost.org
        filters:
        - SetRequestHeader=foo, bar-{segment}
----
====

=== The `SetResponseHeader` `GatewayFilter` Factory

The `SetResponseHeader` `GatewayFilter` factory takes `name` and `value` parameters.
The following listing configures a `SetResponseHeader` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: setresponseheader_route
        uri: https://example.org
        filters:
        - SetResponseHeader=X-Response-Red, Blue
----
====

This GatewayFilter replaces (rather than adding) all headers with the given name.
So, if the downstream server responded with a `X-Response-Red:1234`, this is replaced with `X-Response-Red:Blue`, which is what the gateway client would receive.

`SetResponseHeader` is aware of URI variables used to match a path or host.
URI variables may be used in the value and will be expanded at runtime.
The following example configures an `SetResponseHeader` `GatewayFilter` that uses a variable:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: setresponseheader_route
        uri: https://example.org
        predicates:
        - Host: {segment}.myhost.org
        filters:
        - SetResponseHeader=foo, bar-{segment}
----
====

=== The `SetStatus` `GatewayFilter` Factory

The `SetStatus` `GatewayFilter` factory takes a single parameter, `status`.
It must be a valid Spring `HttpStatus`.
It may be the integer value `404` or the string representation of the enumeration: `NOT_FOUND`.
The following listing configures a `SetStatus` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: setstatusstring_route
        uri: https://example.org
        filters:
        - SetStatus=UNAUTHORIZED
      - id: setstatusint_route
        uri: https://example.org
        filters:
        - SetStatus=401
----
====

In either case, the HTTP status of the response is set to 401.

You can configure the `SetStatus` `GatewayFilter` to return the original HTTP status code from the proxied request in a header in the response.
The header is added to the response if configured with the following property:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      set-status:
        original-status-header-name: original-http-status
----
====

=== The `StripPrefix` `GatewayFilter` Factory

The `StripPrefix` `GatewayFilter` factory takes one parameter, `parts`.
The `parts` parameter indicates the number of parts in the path to strip from the request before sending it downstream.
The following listing configures a `StripPrefix` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: nameRoot
        uri: https://nameservice
        predicates:
        - Path=/name/**
        filters:
        - StripPrefix=2
----
====

When a request is made through the gateway to `/name/blue/red`, the request made to `nameservice` looks like `https://nameservice/red`.

=== The `Retry` `GatewayFilter` Factory

The `Retry` `GatewayFilter` factory supports the following parameters:

* `retries`: The number of retries that should be attempted.
* `statuses`: The HTTP status codes that should be retried, represented by using `org.springframework.http.HttpStatus`.
* `methods`: The HTTP methods that should be retried, represented by using `org.springframework.http.HttpMethod`.
* `series`: The series of status codes to be retried, represented by using `org.springframework.http.HttpStatus.Series`.
* `exceptions`: A list of thrown exceptions that should be retried.
* `backoff`: The configured exponential backoff for the retries.
Retries are performed after a backoff interval of `firstBackoff * (factor ^ n)`, where `n` is the iteration.
If `maxBackoff` is configured, the maximum backoff applied is limited to `maxBackoff`.
If `basedOnPreviousValue` is true, the backoff is calculated byusing `prevBackoff * factor`.

The following defaults are configured for `Retry` filter, if enabled:

* `retries`: Three times
* `series`: 5XX series
* `methods`: GET method
* `exceptions`: `IOException` and `TimeoutException`
* `backoff`: disabled

The following listing configures a Retry `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: retry_test
        uri: http://localhost:8080/flakey
        predicates:
        - Host=*.retry.com
        filters:
        - name: Retry
          args:
            retries: 3
            statuses: BAD_GATEWAY
            methods: GET,POST
            backoff:
              firstBackoff: 10ms
              maxBackoff: 50ms
              factor: 2
              basedOnPreviousValue: false
----
====

NOTE: When using the retry filter with a `forward:` prefixed URL, the target endpoint should be written carefully so that, in case of an error, it does not do anything that could result in a response being sent to the client and committed.
For example, if the target endpoint is an annotated controller, the target controller method should not return `ResponseEntity` with an error status code.
Instead, it should throw an `Exception` or signal an error (for example, through a `Mono.error(ex)` return value), which the retry filter can be configured to handle by retrying.

WARNING: When using the retry filter with any HTTP method with a body, the body will be cached and the gateway will become memory constrained. The body is cached in a request attribute defined by `ServerWebExchangeUtils.CACHED_REQUEST_BODY_ATTR`. The type of the object is a `org.springframework.core.io.buffer.DataBuffer`.

A simplified "shortcut" notation can be added with a single `status` and `method`.

The following two examples are equivalent:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: retry_route
        uri: https://example.org
        filters:
        - name: Retry
          args:
            retries: 3
            statuses: INTERNAL_SERVER_ERROR
            methods: GET
            backoff:
              firstBackoff: 10ms
              maxBackoff: 50ms
              factor: 2
              basedOnPreviousValue: false

      - id: retryshortcut_route
        uri: https://example.org
        filters:
        - Retry=3,INTERNAL_SERVER_ERROR,GET,10ms,50ms,2,false
----
====

=== The `RequestSize` `GatewayFilter` Factory

When the request size is greater than the permissible limit, the `RequestSize` `GatewayFilter` factory can restrict a request from reaching the downstream service.
The filter takes a `maxSize` parameter.
The `maxSize` is a `DataSize` type, so values can be defined as a number followed by an optional `DataUnit` suffix such as 'KB' or 'MB'. The default is 'B' for bytes.
It is the permissible size limit of the request defined in bytes.
The following listing configures a `RequestSize` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: request_size_route
        uri: http://localhost:8080/upload
        predicates:
        - Path=/upload
        filters:
        - name: RequestSize
          args:
            maxSize: 5000000
----
====

The `RequestSize` `GatewayFilter` factory sets the response status as `413 Payload Too Large` with an additional header `errorMessage` when the request is rejected due to size. The following example shows such an `errorMessage`:

====
[source]
----
errorMessage : Request size is larger than permissible limit. Request size is 6.0 MB where permissible limit is 5.0 MB
----
====

NOTE: The default request size is set to five MB if not provided as a filter argument in the route definition.

=== The `SetRequestHostHeader` `GatewayFilter` Factory

There are certain situation when the host header may need to be overridden. In this situation, the `SetRequestHostHeader` `GatewayFilter` factory can replace the existing host header with a specified vaue.
The filter takes a `host` parameter.
The following listing configures a `SetRequestHostHeader` `GatewayFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: set_request_host_header_route
        uri: http://localhost:8080/headers
        predicates:
        - Path=/headers
        filters:
        - name: SetRequestHostHeader
          args:
            host: example.org
----
====

The `SetRequestHostHeader` `GatewayFilter` factory replaces the value of the host header with `example.org`.


=== The `TokenRelay` `GatewayFilter` Factory

A Token Relay is where an OAuth2 consumer acts as a Client and
forwards the incoming token to outgoing resource requests. The
consumer can be a pure Client (like an SSO application) or a Resource
Server.

Spring Cloud Gateway can forward OAuth2 access tokens downstream to the services
it is proxying. To add this functionality to the gateway, you need to add the `TokenRelayGatewayFilterFactory` like this:

.App.java
[source,java]
----

@Bean
public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
    return builder.routes()
            .route("resource", r -> r.path("/resource")
                    .filters(f -> f.tokenRelay())
                    .uri("http://localhost:9000"))
            .build();
}
----

or this

.application.yaml
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: resource
        uri: http://localhost:9000
        predicates:
        - Path=/resource
        filters:
        - TokenRelay=
----

and it will (in addition to logging the user in and grabbing a token)
pass the authentication token downstream to the services (in this case
`/resource`).

To enable this for Spring Cloud Gateway add the following dependencies

- `org.springframework.boot:spring-boot-starter-oauth2-client`

How does it work?  The
{githubmaster}/src/main/java/org/springframework/cloud/gateway/security/TokenRelayGatewayFilterFactory.java[filter]
extracts an access token from the currently authenticated user,
and puts it in a request header for the downstream requests.

For a full working sample see https://github.com/spring-cloud-samples/sample-gateway-oauth2login[this project].

NOTE: A `TokenRelayGatewayFilterFactory` bean will only be created if the proper `spring.security.oauth2.client.*` properties are set which will trigger creation of a `ReactiveClientRegistrationRepository` bean.

NOTE: The default implementation of `ReactiveOAuth2AuthorizedClientService` used by `TokenRelayGatewayFilterFactory`
uses an in-memory data store.  You will need to provide your own implementation `ReactiveOAuth2AuthorizedClientService`
if you need a more robust solution.


=== Default Filters

To add a filter and apply it to all routes, you can use `spring.cloud.gateway.default-filters`.
This property takes a list of filters.
The following listing defines a set of default filters:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      default-filters:
      - AddResponseHeader=X-Response-Default-Red, Default-Blue
      - PrefixPath=/httpbin
----
====

== Global Filters

The `GlobalFilter` interface has the same signature as `GatewayFilter`.
These are special filters that are conditionally applied to all routes.

NOTE: This interface and its usage are subject to change in future milestone releases.

[[gateway-combined-global-filter-and-gatewayfilter-ordering]]
=== Combined Global Filter and `GatewayFilter` Ordering

When a request matches a route, the filtering web handler adds all instances of `GlobalFilter` and all route-specific instances of `GatewayFilter` to a filter chain.
This combined filter chain is sorted by the `org.springframework.core.Ordered` interface, which you can set by implementing the `getOrder()` method.

As Spring Cloud Gateway distinguishes between "`pre`" and "`post`" phases for filter logic execution (see <<gateway-how-it-works, How it Works>>), the filter with the highest precedence is the first in the "`pre`"-phase and the last in the "`post`"-phase.

The following listing configures a filter chain:

.ExampleConfiguration.java
====
[source,java]
----
@Bean
public GlobalFilter customFilter() {
    return new CustomGlobalFilter();
}

public class CustomGlobalFilter implements GlobalFilter, Ordered {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        log.info("custom global filter");
        return chain.filter(exchange);
    }

    @Override
    public int getOrder() {
        return -1;
    }
}
----
====

=== The Gateway Metrics Filter

To enable gateway metrics, add `spring-boot-starter-actuator` as a project dependency. Then, by default, the gateway metrics filter runs as long as the `spring.cloud.gateway.metrics.enabled` property is not set to `false`.
This filter adds a timer metric named `spring.cloud.gateway.requests` with the following tags:

* `routeId`: The route ID.
* `routeUri`: The URI to which the API is routed.
* `outcome`: The outcome, as classified by link:https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/HttpStatus.Series.html[HttpStatus.Series].
* `status`: The HTTP status of the request returned to the client.
* `httpStatusCode`: The HTTP Status of the request returned to the client.
* `httpMethod`: The HTTP method used for the request.

In addition, through the `spring.cloud.gateway.metrics.tags.path.enabled` property (by default, `false`), you can activate an extra metric with the path tag:

* `path`: The path of the request.

These metrics are then available to be scraped from `/actuator/metrics/spring.cloud.gateway.requests` and can be easily integrated with Prometheus to create a link:images/gateway-grafana-dashboard.jpeg[Grafana] link:gateway-grafana-dashboard.json[dashboard].

NOTE: To enable the prometheus endpoint, add `micrometer-registry-prometheus` as a project dependency.

[[local-cache-response-global-filter]]
=== The Local Response Cache Filter

The `LocalResponseCache` runs if its associated property is enabled (`spring.cloud.gateway.filter.local-response-cache.enabled`) and activates a local cache for all responses that meet the following criteria:
- The request is a bodiless GET.
- The response has one of the following status codes: HTTP 200 (OK), HTTP 206 (Partial Content), or HTTP 301 (Moved Permanently).
- The HTTP `Cache-Control` header allows caching (that means it does not have any of the following values: `no-store` present in the request and `no-store` or `private` present in the response).

It accepts two configuration parameters:
- `spring.cloud.gateway.filter.local-response-cache.size`: Sets the maximum size of the cache to evict entries for this route (in KB, MB and GB).
- `spring.cloud.gateway.filter.local-response-cache.timeToLive` Sets the time to expire a cache entry (expressed in s for seconds, m for minutes, and h for hours).
If none of these parameters are configured but the global filter is enabled, by default, it configures 5 minutes of time to live for the cached response.

This filter also implements the automatic calculation of the `max-age value in the HTTP `Cache-Control` header.
If `max-age` is present on the original response, the value is rewritten with the number of seconds set in the `timeToLive` configuration parameter.
In subsequent calls, this value is recalculated with the number of seconds left until the response expires.

=== Forward Routing Filter

The `ForwardRoutingFilter` looks for a URI in the exchange attribute `ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR`.
If the URL has a `forward` scheme (such as `forward:///localendpoint`), it uses the Spring `DispatcherHandler` to handle the request.
The path part of the request URL is overridden with the path in the forward URL.
The unmodified original URL is appended to the list in the `ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR` attribute.

=== The Netty Routing Filter

The Netty routing filter runs if the URL located in the `ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR` exchange attribute has a `http` or `https` scheme.
It uses the Netty `HttpClient` to make the downstream proxy request.
The response is put in the `ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR` exchange attribute for use in a later filter.
(There is also an experimental `WebClientHttpRoutingFilter` that performs the same function but does not require Netty.)

=== The Netty Write Response Filter

The `NettyWriteResponseFilter` runs if there is a Netty `HttpClientResponse` in the `ServerWebExchangeUtils.CLIENT_RESPONSE_ATTR` exchange attribute.
It runs after all other filters have completed and writes the proxy response back to the gateway client response.
(There is also an experimental `WebClientWriteResponseFilter` that performs the same function but does not require Netty.)

[[reactive-loadbalancer-client-filter]]
=== The `ReactiveLoadBalancerClientFilter`

The `ReactiveLoadBalancerClientFilter` looks for a URI in the exchange attribute named `ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR`.
If the URL has a `lb` scheme (such as `lb://myservice`), it uses the Spring Cloud `ReactorLoadBalancer` to resolve the name (`myservice` in this example) to an actual host and port and replaces the URI in the same attribute.
The unmodified original URL is appended to the list in the `ServerWebExchangeUtils.GATEWAY_ORIGINAL_REQUEST_URL_ATTR` attribute.
The filter also looks in the `ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR` attribute to see if it equals `lb`.
If so, the same rules apply.
The following listing configures a `ReactiveLoadBalancerClientFilter`:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: myRoute
        uri: lb://service
        predicates:
        - Path=/service/**
----
====

NOTE: By default, when a service instance cannot be found by the `ReactorLoadBalancer`, a `503` is returned.
You can configure the gateway to return a `404` by setting `spring.cloud.gateway.loadbalancer.use404=true`.

NOTE: The `isSecure` value of the `ServiceInstance` returned from the `ReactiveLoadBalancerClientFilter` overrides
the scheme specified in the request made to the Gateway.
For example, if the request comes into the Gateway over `HTTPS` but the `ServiceInstance` indicates it is not secure, the downstream request is made over `HTTP`.
The opposite situation can also apply.
However, if `GATEWAY_SCHEME_PREFIX_ATTR` is specified for the route in the Gateway configuration, the prefix is stripped and the resulting scheme from the route URL overrides the `ServiceInstance` configuration.

TIP: Gateway supports all the LoadBalancer features. You can read more about them in the https://docs.spring.io/spring-cloud-commons/docs/current/reference/html/#spring-cloud-loadbalancer[Spring Cloud Commons documentation].

=== The `RouteToRequestUrl` Filter

If there is a `Route` object in the `ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR` exchange attribute, the `RouteToRequestUrlFilter` runs.
It creates a new URI, based off of the request URI but updated with the URI attribute of the `Route` object.
The new URI is placed in the `ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR` exchange attribute.

If the URI has a scheme prefix, such as `lb:ws://serviceid`, the `lb` scheme is stripped from the URI and placed in the `ServerWebExchangeUtils.GATEWAY_SCHEME_PREFIX_ATTR` for use later in the filter chain.

=== The Websocket Routing Filter

If the URL located in the `ServerWebExchangeUtils.GATEWAY_REQUEST_URL_ATTR` exchange attribute has a `ws` or `wss` scheme, the websocket routing filter runs. It uses the Spring WebSocket infrastructure to forward the websocket request downstream.

You can load-balance websockets by prefixing the URI with `lb`, such as `lb:ws://serviceid`.

NOTE: If you use https://github.com/sockjs[SockJS] as a fallback over normal HTTP, you should configure a normal HTTP route as well as the websocket Route.

The following listing configures a websocket routing filter:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      # SockJS route
      - id: websocket_sockjs_route
        uri: http://localhost:3001
        predicates:
        - Path=/websocket/info/**
      # Normal Websocket route
      - id: websocket_route
        uri: ws://localhost:3001
        predicates:
        - Path=/websocket/**
----
====

=== Marking An Exchange As Routed

After the gateway has routed a `ServerWebExchange`, it marks that exchange as "`routed`" by adding `gatewayAlreadyRouted`
to the exchange attributes. Once a request has been marked as routed, other routing filters will not route the request again,
essentially skipping the filter. There are convenience methods that you can use to mark an exchange as routed
or check if an exchange has already been routed.

* `ServerWebExchangeUtils.isAlreadyRouted` takes a `ServerWebExchange` object and checks if it has been "`routed`".
* `ServerWebExchangeUtils.setAlreadyRouted` takes a `ServerWebExchange` object and marks it as "`routed`".

== HttpHeadersFilters

HttpHeadersFilters are applied to requests before sending them downstream, such as in the `NettyRoutingFilter`.

=== Forwarded Headers Filter
The `Forwarded` Headers Filter creates a `Forwarded` header to send to the downstream service. It adds the `Host` header, scheme and port of the current request to any existing `Forwarded` header.

=== RemoveHopByHop Headers Filter
The `RemoveHopByHop` Headers Filter removes headers from forwarded requests. The default list of headers that is removed comes from the https://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-14#section-7.1.3[IETF].

.The default removed headers are:
*  Connection
*  Keep-Alive
*  Proxy-Authenticate
*  Proxy-Authorization
*  TE
*  Trailer
*  Transfer-Encoding
*  Upgrade

To change this, set the `spring.cloud.gateway.filter.remove-hop-by-hop.headers` property to the list of header names to remove.

=== XForwarded Headers Filter
The `XForwarded` Headers Filter creates various a `X-Forwarded-*` headers to send to the downstream service. It users the `Host` header, scheme, port and path of the current request to create the various headers.

Creating of individual headers can be controlled by the following boolean properties (defaults to true):

- `spring.cloud.gateway.x-forwarded.for-enabled`
- `spring.cloud.gateway.x-forwarded.host-enabled`
- `spring.cloud.gateway.x-forwarded.port-enabled`
- `spring.cloud.gateway.x-forwarded.proto-enabled`
- `spring.cloud.gateway.x-forwarded.prefix-enabled`

Appending multiple headers can be controlled by the following boolean properties (defaults to true):

- `spring.cloud.gateway.x-forwarded.for-append`
- `spring.cloud.gateway.x-forwarded.host-append`
- `spring.cloud.gateway.x-forwarded.port-append`
- `spring.cloud.gateway.x-forwarded.proto-append`
- `spring.cloud.gateway.x-forwarded.prefix-append`

== TLS and SSL

The gateway can listen for requests on HTTPS by following the usual Spring server configuration.
The following example shows how to do so:

.application.yml
====
[source,yaml]
----
server:
  ssl:
    enabled: true
    key-alias: scg
    key-store-password: scg1234
    key-store: classpath:scg-keystore.p12
    key-store-type: PKCS12
----
====

You can route gateway routes to both HTTP and HTTPS backends.
If you are routing to an HTTPS backend, you can configure the gateway to trust all downstream certificates with the following configuration:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      httpclient:
        ssl:
          useInsecureTrustManager: true
----
====

Using an insecure trust manager is not suitable for production.
For a production deployment, you can configure the gateway with a set of known certificates that it can trust with the following configuration:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      httpclient:
        ssl:
          trustedX509Certificates:
          - cert1.pem
          - cert2.pem
----
====

If the Spring Cloud Gateway is not provisioned with trusted certificates, the default trust store is used (which you can override by setting the `javax.net.ssl.trustStore` system property).

=== TLS Handshake

The gateway maintains a client pool that it uses to route to backends.
When communicating over HTTPS, the client initiates a TLS handshake.
A number of timeouts are associated with this handshake.
You can configure these timeouts can be configured (defaults shown) as follows:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      httpclient:
        ssl:
          handshake-timeout-millis: 10000
          close-notify-flush-timeout-millis: 3000
          close-notify-read-timeout-millis: 0
----
====

== Configuration

Configuration for Spring Cloud Gateway is driven by a collection of `RouteDefinitionLocator` instances.
The following listing shows the definition of the `RouteDefinitionLocator` interface:

.RouteDefinitionLocator.java
====
[source,java]
----
public interface RouteDefinitionLocator {
	Flux<RouteDefinition> getRouteDefinitions();
}
----
====

By default, a `PropertiesRouteDefinitionLocator` loads properties by using Spring Boot's `@ConfigurationProperties` mechanism.

The earlier configuration examples all use a shortcut notation that uses positional arguments rather than named ones.
The following two examples are equivalent:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: setstatus_route
        uri: https://example.org
        filters:
        - name: SetStatus
          args:
            status: 401
      - id: setstatusshortcut_route
        uri: https://example.org
        filters:
        - SetStatus=401
----
====

For some usages of the gateway, properties are adequate, but some production use cases benefit from loading configuration from an external source, such as a database. Future milestone versions will have `RouteDefinitionLocator` implementations based off of Spring Data Repositories, such as Redis, MongoDB, and Cassandra.

=== RouteDefinition Metrics

To enable `RouteDefinition` metrics, add spring-boot-starter-actuator as a project dependency. Then, by default, the metrics will be available as long as the property `spring.cloud.gateway.metrics.enabled` is set to `true`. A gauge metric named `spring.cloud.gateway.routes.count` will be added, whose value is the number of `RouteDefinitions`. This metric will be available from `/actuator/metrics/spring.cloud.gateway.routes.count`.

== Route Metadata Configuration

You can configure additional parameters for each route by using metadata, as follows:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: route_with_metadata
        uri: https://example.org
        metadata:
          optionName: "OptionValue"
          compositeObject:
            name: "value"
          iAmNumber: 1
----
====

You could acquire all metadata properties from an exchange, as follows:

====
[source]
----
Route route = exchange.getAttribute(GATEWAY_ROUTE_ATTR);
// get all metadata properties
route.getMetadata();
// get a single metadata property
route.getMetadata(someKey);
----
====

== Http timeouts configuration

Http timeouts (response and connect) can be configured for all routes and overridden for each specific route.

=== Global timeouts
To configure Global http timeouts: +
`connect-timeout` must be specified in milliseconds. +
`response-timeout` must be specified as a java.time.Duration

.global http timeouts example
[source,yaml]
----
spring:
  cloud:
    gateway:
      httpclient:
        connect-timeout: 1000
        response-timeout: 5s
----

=== Per-route timeouts
To configure per-route timeouts: +
`connect-timeout` must be specified in milliseconds. +
`response-timeout` must be specified in milliseconds.

.per-route http timeouts configuration via configuration
[source,yaml]
----
      - id: per_route_timeouts
        uri: https://example.org
        predicates:
          - name: Path
            args:
              pattern: /delay/{timeout}
        metadata:
          response-timeout: 200
          connect-timeout: 200
----

.per-route timeouts configuration using Java DSL
[source,java]
----
import static org.springframework.cloud.gateway.support.RouteMetadataUtils.CONNECT_TIMEOUT_ATTR;
import static org.springframework.cloud.gateway.support.RouteMetadataUtils.RESPONSE_TIMEOUT_ATTR;

      @Bean
      public RouteLocator customRouteLocator(RouteLocatorBuilder routeBuilder){
         return routeBuilder.routes()
               .route("test1", r -> {
                  return r.host("*.somehost.org").and().path("/somepath")
                        .filters(f -> f.addRequestHeader("header1", "header-value-1"))
                        .uri("http://someuri")
                        .metadata(RESPONSE_TIMEOUT_ATTR, 200)
                        .metadata(CONNECT_TIMEOUT_ATTR, 200);
               })
               .build();
      }
----

A per-route `response-timeout` with a negative value will disable the global `response-timeout` value.

----
      - id: per_route_timeouts
        uri: https://example.org
        predicates:
          - name: Path
            args:
              pattern: /delay/{timeout}
        metadata:
          response-timeout: -1
----

=== Fluent Java Routes API

To allow for simple configuration in Java, the `RouteLocatorBuilder` bean includes a fluent API.
The following listing shows how it works:

.GatewaySampleApplication.java
====
[source,java]
----
// static imports from GatewayFilters and RoutePredicates
@Bean
public RouteLocator customRouteLocator(RouteLocatorBuilder builder, ThrottleGatewayFilterFactory throttle) {
    return builder.routes()
            .route(r -> r.host("**.abc.org").and().path("/image/png")
                .filters(f ->
                        f.addResponseHeader("X-TestHeader", "foobar"))
                .uri("http://httpbin.org:80")
            )
            .route(r -> r.path("/image/webp")
                .filters(f ->
                        f.addResponseHeader("X-AnotherHeader", "baz"))
                .uri("http://httpbin.org:80")
                .metadata("key", "value")
            )
            .route(r -> r.order(-1)
                .host("**.throttle.org").and().path("/get")
                .filters(f -> f.filter(throttle.apply(1,
                        1,
                        10,
                        TimeUnit.SECONDS)))
                .uri("http://httpbin.org:80")
                .metadata("key", "value")
            )
            .build();
}
----
====

This style also allows for more custom predicate assertions.
The predicates defined by `RouteDefinitionLocator` beans are combined using logical `and`.
By using the fluent Java API, you can use the `and()`, `or()`, and `negate()` operators on the `Predicate` class.

=== The `DiscoveryClient` Route Definition Locator

You can configure the gateway to create routes based on services registered with a `DiscoveryClient` compatible service registry.

To enable this, set `spring.cloud.gateway.discovery.locator.enabled=true` and make sure a `DiscoveryClient` implementation (such as Netflix Eureka, Consul, or Zookeeper) is on the classpath and enabled.

==== Configuring Predicates and Filters For `DiscoveryClient` Routes

By default, the gateway defines a single predicate and filter for routes created with a `DiscoveryClient`.

The default predicate is a path predicate defined with the pattern `/serviceId/**`, where `serviceId` is
the ID of the service from the `DiscoveryClient`.

The default filter is a rewrite path filter with the regex `/serviceId/?(?<remaining>.*)` and the replacement `/${remaining}`.
This strips the service ID from the path before the request is sent downstream.

If you want to customize the predicates or filters used by the `DiscoveryClient` routes, set `spring.cloud.gateway.discovery.locator.predicates[x]` and `spring.cloud.gateway.discovery.locator.filters[y]`.
When doing so, you need to make sure to include the default predicate and filter shown earlier, if you want to retain that functionality.
The following example shows what this looks like:

.application.properties
====
[source,properties]
----
spring.cloud.gateway.discovery.locator.predicates[0].name: Path
spring.cloud.gateway.discovery.locator.predicates[0].args[pattern]: "'/'+serviceId+'/**'"
spring.cloud.gateway.discovery.locator.predicates[1].name: Host
spring.cloud.gateway.discovery.locator.predicates[1].args[pattern]: "'**.foo.com'"
spring.cloud.gateway.discovery.locator.filters[0].name: CircuitBreaker
spring.cloud.gateway.discovery.locator.filters[0].args[name]: serviceId
spring.cloud.gateway.discovery.locator.filters[1].name: RewritePath
spring.cloud.gateway.discovery.locator.filters[1].args[regexp]: "'/' + serviceId + '/?(?<remaining>.*)'"
spring.cloud.gateway.discovery.locator.filters[1].args[replacement]: "'/${remaining}'"
----
====

== Reactor Netty Access Logs

To enable Reactor Netty access logs, set `-Dreactor.netty.http.server.accessLogEnabled=true`.

IMPORTANT: It must be a Java System Property, not a Spring Boot property.

You can configure the logging system to have a separate access log file. The following example creates a Logback configuration:

.logback.xml
====
[source,xml]
----
    <appender name="accessLog" class="ch.qos.logback.core.FileAppender">
        <file>access_log.log</file>
        <encoder>
            <pattern>%msg%n</pattern>
        </encoder>
    </appender>
    <appender name="async" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="accessLog" />
    </appender>

    <logger name="reactor.netty.http.server.AccessLog" level="INFO" additivity="false">
        <appender-ref ref="async"/>
    </logger>
----
====

== CORS Configuration
:cors-configuration-docs-uri: https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/web/cors/CorsConfiguration.html

You can configure the gateway to control CORS behavior globally or per route.
Both offer the same possibilities.

=== Global CORS Configuration

The "`global`" CORS configuration is a map of URL patterns to {cors-configuration-docs-uri}[Spring Framework `CorsConfiguration`].
The following example configures CORS:

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      globalcors:
        cors-configurations:
          '[/**]':
            allowedOrigins: "https://docs.spring.io"
            allowedMethods:
            - GET
----
====

In the preceding example, CORS requests are allowed from requests that originate from `docs.spring.io` for all GET requested paths.

To provide the same CORS configuration to requests that are not handled by some gateway route predicate, set the `spring.cloud.gateway.globalcors.add-to-simple-url-handler-mapping` property  to `true`.
This is useful when you try to support CORS preflight requests and your route predicate does not evaluate to `true` because the HTTP method is `options`.

=== Route CORS Configuration

The "`route`" configuration allows applying CORS directly to a route as metadata with key `cors`.
Like in the case of global configuration, the properties belong to {cors-configuration-docs-uri}[Spring Framework `CorsConfiguration`].

NOTE: If no `Path` predicate is present in the route '/**' will be applied.

.application.yml
====
[source,yaml]
----
spring:
  cloud:
    gateway:
      routes:
      - id: cors_route
        uri: https://example.org
        predicates:
        - Path=/service/**
        metadata:
          cors
            allowedOrigins: '*'
            allowedMethods:
              - GET
              - POST
            allowedHeaders: '*'
            maxAge: 30
----
====

== Actuator API

The `/gateway` actuator endpoint lets you monitor and interact with a Spring Cloud Gateway application.
To be remotely accessible, the endpoint has to be https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#production-ready-endpoints-enabling-endpoints[enabled] and https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#production-ready-endpoints-exposing-endpoints[exposed over HTTP or JMX] in the application properties.
The following listing shows how to do so:

.application.properties
====
[source,properties]
----
management.endpoint.gateway.enabled=true # default value
management.endpoints.web.exposure.include=gateway
----
====

=== Verbose Actuator Format

A new, more verbose format has been added to Spring Cloud Gateway.
It adds more detail to each route, letting you view the predicates and filters associated with each route along with any configuration that is available.
The following example configures `/actuator/gateway/routes`:

====
[source,json]
----
[
  {
    "predicate": "(Hosts: [**.addrequestheader.org] && Paths: [/headers], match trailing slash: true)",
    "route_id": "add_request_header_test",
    "filters": [
      "[[AddResponseHeader X-Response-Default-Foo = 'Default-Bar'], order = 1]",
      "[[AddRequestHeader X-Request-Foo = 'Bar'], order = 1]",
      "[[PrefixPath prefix = '/httpbin'], order = 2]"
    ],
    "uri": "lb://testservice",
    "order": 0
  }
]
----
====

This feature is enabled by default. To disable it, set the following property:

.application.properties
====
[source,properties]
----
spring.cloud.gateway.actuator.verbose.enabled=false
----
====

This will default to `true` in a future release.

=== Retrieving Route Filters

This section details how to retrieve route filters, including:

* <<gateway-global-filters>>
* <<gateway-route-filters>>

[[gateway-global-filters]]
==== Global Filters

To retrieve the <<global-filters,global filters>> applied to all routes, make a `GET` request to `/actuator/gateway/globalfilters`. The resulting response is similar to the following:

====
----
{
  "org.springframework.cloud.gateway.filter.ReactiveLoadBalancerClientFilter@77856cc5": 10100,
  "org.springframework.cloud.gateway.filter.RouteToRequestUrlFilter@4f6fd101": 10000,
  "org.springframework.cloud.gateway.filter.NettyWriteResponseFilter@32d22650": -1,
  "org.springframework.cloud.gateway.filter.ForwardRoutingFilter@106459d9": 2147483647,
  "org.springframework.cloud.gateway.filter.NettyRoutingFilter@1fbd5e0": 2147483647,
  "org.springframework.cloud.gateway.filter.ForwardPathFilter@33a71d23": 0,
  "org.springframework.cloud.gateway.filter.AdaptCachedBodyGlobalFilter@135064ea": 2147483637,
  "org.springframework.cloud.gateway.filter.WebsocketRoutingFilter@23c05889": 2147483646
}
----
====

The response contains the details of the global filters that are in place.
For each global filter, there is a string representation of the filter object (for example, `org.springframework.cloud.gateway.filter.ReactiveLoadBalancerClientFilter@77856cc5`) and the corresponding <<gateway-combined-global-filter-and-gatewayfilter-ordering,order>> in the filter chain.}

[[gateway-route-filters]]
==== Route Filters
To retrieve the <<gatewayfilter-factories,`GatewayFilter` factories>> applied to routes, make a `GET` request to `/actuator/gateway/routefilters`.
The resulting response is similar to the following:

====
----
{
  "[AddRequestHeaderGatewayFilterFactory@570ed9c configClass = AbstractNameValueGatewayFilterFactory.NameValueConfig]": null,
  "[SecureHeadersGatewayFilterFactory@fceab5d configClass = Object]": null,
  "[SaveSessionGatewayFilterFactory@4449b273 configClass = Object]": null
}
----
====

The response contains the details of the `GatewayFilter` factories applied to any particular route.
For each factory there is a string representation of the corresponding object (for example, `[SecureHeadersGatewayFilterFactory@fceab5d configClass = Object]`).
Note that the `null` value is due to an incomplete implementation of the endpoint controller, because it tries to set the order of the object in the filter chain, which does not apply to a `GatewayFilter` factory object.

=== Refreshing the Route Cache

To clear the routes cache, make a `POST` request to `/actuator/gateway/refresh`.
The request returns a 200 without a response body.

=== Retrieving the Routes Defined in the Gateway

To retrieve the routes defined in the gateway, make a `GET` request to `/actuator/gateway/routes`.
The resulting response is similar to the following:

====
----
[{
  "route_id": "first_route",
  "route_object": {
    "predicate": "org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory$$Lambda$432/1736826640@1e9d7e7d",
    "filters": [
      "OrderedGatewayFilter{delegate=org.springframework.cloud.gateway.filter.factory.PreserveHostHeaderGatewayFilterFactory$$Lambda$436/674480275@6631ef72, order=0}"
    ]
  },
  "order": 0
},
{
  "route_id": "second_route",
  "route_object": {
    "predicate": "org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory$$Lambda$432/1736826640@cd8d298",
    "filters": []
  },
  "order": 0
}]
----
====

The response contains the details of all the routes defined in the gateway.
The following table describes the structure of each element (each is a route) of the response:

[cols="3,2,4"]
|===
| Path | Type | Description

|`route_id`
| String
| The route ID.

|`route_object.predicate`
| Object
| The route predicate.

|`route_object.filters`
| Array
| The <<gatewayfilter-factories,`GatewayFilter` factories>> applied to the route.

|`order`
| Number
| The route order.

|===

[[gateway-retrieving-information-about-a-particular-route]]
=== Retrieving Information about a Particular Route

To retrieve information about a single route, make a `GET` request to `/actuator/gateway/routes/{id}` (for example, `/actuator/gateway/routes/first_route`).
The resulting response is similar to the following:

====
----
{
  "id": "first_route",
  "predicates": [{
    "name": "Path",
    "args": {"_genkey_0":"/first"}
  }],
  "filters": [],
  "uri": "https://www.uri-destination.org",
  "order": 0
}
----
====

The following table describes the structure of the response:

[cols="3,2,4"]
|===
| Path | Type | Description

|`id`
| String
| The route ID.

|`predicates`
| Array
| The collection of route predicates. Each item defines the name and the arguments of a given predicate.

|`filters`
| Array
| The collection of filters applied to the route.

|`uri`
| String
| The destination URI of the route.

|`order`
| Number
| The route order.

|===

=== Creating and Deleting a Particular Route

To create a route, make a `POST` request to `/gateway/routes/{id_route_to_create}` with a JSON body that specifies the fields of the route (see <<gateway-retrieving-information-about-a-particular-route>>).

To delete a route, make a `DELETE` request to `/gateway/routes/{id_route_to_delete}`.

=== Recap: The List of All endpoints

The folloiwng table below summarizes the Spring Cloud Gateway actuator endpoints (note that each endpoint has `/actuator/gateway` as the base-path):

[cols="2,2,5"]
|===
| ID | HTTP Method | Description

|`globalfilters`
|GET
| Displays the list of global filters applied to the routes.

|`routefilters`
|GET
| Displays the list of `GatewayFilter` factories applied to a particular route.

|`refresh`
|POST
| Clears the routes cache.

|`routes`
|GET
| Displays the list of routes defined in the gateway.

|`routes/{id}`
|GET
| Displays information about a particular route.

|`routes/{id}`
|POST
| Adds a new route to the gateway.

|`routes/{id}`
|DELETE
| Removes an existing route from the gateway.

|===

=== Sharing Routes between multiple Gateway instances
Spring Cloud Gateway offers two `RouteDefinitionRepository` implementations. The first one is the
`InMemoryRouteDefinitionRepository` which only lives within the memory of one Gateway instance.
This type of Repository is not suited to populate Routes across multiple Gateway instances.

In order to share Routes across a cluster of Spring Cloud Gateway instances, `RedisRouteDefinitionRepository` can be used.
To enable this kind of repository, the following property has to set to true: `spring.cloud.gateway.redis-route-definition-repository.enabled`
Likewise to the RedisRateLimiter Filter Factory it requires the use of the spring-boot-starter-data-redis-reactive Spring Boot starter.

[[troubleshooting]]
== Troubleshooting

This section covers common problems that may arise when you use Spring Cloud Gateway.

=== Log Levels

The following loggers may contain valuable troubleshooting information at the `DEBUG` and `TRACE` levels:

- `org.springframework.cloud.gateway`
- `org.springframework.http.server.reactive`
- `org.springframework.web.reactive`
- `org.springframework.boot.autoconfigure.web`
- `reactor.netty`
- `redisratelimiter`

=== Wiretap

The Reactor Netty `HttpClient` and `HttpServer` can have wiretap enabled.
When combined with setting the `reactor.netty` log level to `DEBUG` or `TRACE`, it enables the logging of information, such as headers and bodies sent and received across the wire.
To enable wiretap, set `spring.cloud.gateway.httpserver.wiretap=true` or `spring.cloud.gateway.httpclient.wiretap=true` for the `HttpServer` and `HttpClient`, respectively.

== Developer Guide

These are basic guides to writing some custom components of the gateway.

=== Writing Custom Route Predicate Factories


In order to write a Route Predicate you will need to implement `RoutePredicateFactory` as a bean. There is an abstract class called `AbstractRoutePredicateFactory` which you can extend.

.MyRoutePredicateFactory.java
[source,java]
----
@Component
public class MyRoutePredicateFactory extends AbstractRoutePredicateFactory<MyRoutePredicateFactory.Config> {

    public MyRoutePredicateFactory() {
        super(Config.class);
    }

    @Override
    public Predicate<ServerWebExchange> apply(Config config) {
        // grab configuration from Config object
        return exchange -> {
            //grab the request
            ServerHttpRequest request = exchange.getRequest();
            //take information from the request to see if it
            //matches configuration.
            return matches(config, request);
        };
    }

    public static class Config {
        //Put the configuration properties for your filter here
    }

}
----
=== Writing Custom GatewayFilter Factories

To write a `GatewayFilter`, you must implement `GatewayFilterFactory` as a bean.
You can extend an abstract class called `AbstractGatewayFilterFactory`.
The following examples show how to do so:

.PreGatewayFilterFactory.java
====
[source,java]
----
@Component
public class PreGatewayFilterFactory extends AbstractGatewayFilterFactory<PreGatewayFilterFactory.Config> {

	public PreGatewayFilterFactory() {
		super(Config.class);
	}

	@Override
	public GatewayFilter apply(Config config) {
		// grab configuration from Config object
		return (exchange, chain) -> {
			//If you want to build a "pre" filter you need to manipulate the
			//request before calling chain.filter
			ServerHttpRequest.Builder builder = exchange.getRequest().mutate();
			//use builder to manipulate the request
			return chain.filter(exchange.mutate().request(builder.build()).build());
		};
	}

	public static class Config {
		//Put the configuration properties for your filter here
	}

}
----

.PostGatewayFilterFactory.java
[source,java]
----
@Component
public class PostGatewayFilterFactory extends AbstractGatewayFilterFactory<PostGatewayFilterFactory.Config> {

	public PostGatewayFilterFactory() {
		super(Config.class);
	}

	@Override
	public GatewayFilter apply(Config config) {
		// grab configuration from Config object
		return (exchange, chain) -> {
			return chain.filter(exchange).then(Mono.fromRunnable(() -> {
				ServerHttpResponse response = exchange.getResponse();
				//Manipulate the response in some way
			}));
		};
	}

	public static class Config {
		//Put the configuration properties for your filter here
	}

}
----
====

==== Naming Custom Filters And References In Configuration

Custom filters class names should end in `GatewayFilterFactory`.

For example, to reference a filter named `Something` in configuration files, the filter
must be in a class named `SomethingGatewayFilterFactory`.

WARNING: It is possible to create a gateway filter named without the
`GatewayFilterFactory` suffix, such as `class AnotherThing`. This filter could be
referenced as `AnotherThing` in configuration files. This is **not** a supported naming
convention and this syntax may be removed in future releases. Please update the filter
name to be compliant.

=== Writing Custom Global Filters

To write a custom global filter, you must implement `GlobalFilter` interface as a bean.
This applies the filter to all requests.

The following examples show how to set up global pre and post filters, respectively:

====
[source,java]
----
@Bean
public GlobalFilter customGlobalFilter() {
    return (exchange, chain) -> exchange.getPrincipal()
        .map(Principal::getName)
        .defaultIfEmpty("Default User")
        .map(userName -> {
          //adds header to proxied request
          exchange.getRequest().mutate().header("CUSTOM-REQUEST-HEADER", userName).build();
          return exchange;
        })
        .flatMap(chain::filter);
}

@Bean
public GlobalFilter customGlobalPostFilter() {
    return (exchange, chain) -> chain.filter(exchange)
        .then(Mono.just(exchange))
        .map(serverWebExchange -> {
          //adds header to response
          serverWebExchange.getResponse().getHeaders().set("CUSTOM-RESPONSE-HEADER",
              HttpStatus.OK.equals(serverWebExchange.getResponse().getStatusCode()) ? "It worked": "It did not work");
          return serverWebExchange;
        })
        .then();
}
----
====

== Building a Simple Gateway by Using Spring MVC or Webflux

WARNING: The following describes an alternative style gateway. None of the prior documentation applies to what follows.

Spring Cloud Gateway provides a utility object called `ProxyExchange`.
You can use it inside a regular Spring web handler as a method parameter.
It supports basic downstream HTTP exchanges through methods that mirror the HTTP verbs.
With MVC, it also supports forwarding to a local handler through the `forward()` method.
To use the `ProxyExchange`, include the right module in your classpath (either `spring-cloud-gateway-mvc` or `spring-cloud-gateway-webflux`).

The following MVC example proxies a request to `/test` downstream to a remote server:

====
[source,java]
----
@RestController
@SpringBootApplication
public class GatewaySampleApplication {

	@Value("${remote.home}")
	private URI home;

	@GetMapping("/test")
	public ResponseEntity<?> proxy(ProxyExchange<byte[]> proxy) throws Exception {
		return proxy.uri(home.toString() + "/image/png").get();
	}

}
----
====

The following example does the same thing with Webflux:

====
[source,java]
----
@RestController
@SpringBootApplication
public class GatewaySampleApplication {

	@Value("${remote.home}")
	private URI home;

	@GetMapping("/test")
	public Mono<ResponseEntity<?>> proxy(ProxyExchange<byte[]> proxy) throws Exception {
		return proxy.uri(home.toString() + "/image/png").get();
	}

}
----
====

Convenience methods on the `ProxyExchange` enable the handler method to discover and enhance the URI path of the incoming request.
For example, you might want to extract the trailing elements of a path to pass them downstream:

====
[source,java]
----
@GetMapping("/proxy/path/**")
public ResponseEntity<?> proxyPath(ProxyExchange<byte[]> proxy) throws Exception {
  String path = proxy.path("/proxy/path/");
  return proxy.uri(home.toString() + "/foos/" + path).get();
}
----
====

All the features of Spring MVC and Webflux are available to gateway handler methods.
As a result, you can inject request headers and query parameters, for instance, and you can constrain the incoming requests with declarations in the mapping annotation.
See the documentation for `@RequestMapping` in Spring MVC for more details of those features.

You can add headers to the downstream response by using the `header()` methods on `ProxyExchange`.

You can also manipulate response headers (and anything else you like in the response) by adding a mapper to the `get()` method (and other methods).
The mapper is a `Function` that takes the incoming `ResponseEntity` and converts it to an outgoing one.

First-class support is provided for "`sensitive`" headers (by default, `cookie` and `authorization`), which are not passed downstream, and for "`proxy`" (`x-forwarded-*`) headers.

== AOT and Native Image Support

Since `4.0.0`, Spring Cloud Gateway supports Spring AOT transformations and native images.

TIP: If you're using load-balanced routes, you need to explicitly define your `LoadBalancerClient` service IDs. You can do so by using the `value` or `name` attributes of the `@LoadBalancerClient` annotation or as values of the `spring.cloud.loadbalancer.eager-load.clients` property.

== Configuration properties

To see the list of all Spring Cloud Gateway related configuration properties, see link:appendix.html[the appendix].
